{
	"title": "Send and Sync - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/send-and-sync.html",
	"markdown": "# Send and Sync - The Rustonomicon\n\nNot everything obeys inherited mutability, though. Some types allow you to have multiple aliases of a location in memory while mutating it. Unless these types use synchronization to manage this access, they are absolutely not thread-safe. Rust captures this through the `Send` and `Sync` traits.\n\n-   A type is Send if it is safe to send it to another thread.\n-   A type is Sync if it is safe to share between threads (T is Sync if and only if `&T` is Send).\n\nSend and Sync are fundamental to Rust's concurrency story. As such, a substantial amount of special tooling exists to make them work right. First and foremost, they're [unsafe traits](safe-unsafe-meaning.html). This means that they are unsafe to implement, and other unsafe code can assume that they are correctly implemented. Since they're _marker traits_ (they have no associated items like methods), correctly implemented simply means that they have the intrinsic properties an implementor should have. Incorrectly implementing Send or Sync can cause Undefined Behavior.\n\nSend and Sync are also automatically derived traits. This means that, unlike every other trait, if a type is composed entirely of Send or Sync types, then it is Send or Sync. Almost all primitives are Send and Sync, and as a consequence pretty much all types you'll ever interact with are Send and Sync.\n\nMajor exceptions include:\n\n-   raw pointers are neither Send nor Sync (because they have no safety guards).\n-   `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).\n-   `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).\n\n`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable unsynchronized shared mutable state. However raw pointers are, strictly speaking, marked as thread-unsafe as more of a _lint_. Doing anything useful with a raw pointer requires dereferencing it, which is already unsafe. In that sense, one could argue that it would be \"fine\" for them to be marked as thread safe.\n\nHowever it's important that they aren't thread-safe to prevent types that contain them from being automatically marked as thread-safe. These types have non-trivial untracked ownership, and it's unlikely that their author was necessarily thinking hard about thread safety. In the case of `Rc`, we have a nice example of a type that contains a `*mut` that is definitely not thread-safe.\n\nTypes that aren't automatically derived can simply implement them if desired:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct MyBox(*mut u8);\n\nunsafe impl Send for MyBox {}\nunsafe impl Sync for MyBox {}\n}\n```\n\nIn the _incredibly rare_ case that a type is inappropriately automatically derived to be Send or Sync, then one can also unimplement Send and Sync:\n\n```rust\n#![allow(unused)]\n#![feature(negative_impls)]\n\nfn main() {\n// I have some magic semantics for some synchronization primitive!\nstruct SpecialThreadToken(u8);\n\nimpl !Send for SpecialThreadToken {}\nimpl !Sync for SpecialThreadToken {}\n}\n```\n\nNote that _in and of itself_ it is impossible to incorrectly derive Send and Sync. Only types that are ascribed special meaning by other unsafe code can possibly cause trouble by being incorrectly Send or Sync.\n\nMost uses of raw pointers should be encapsulated behind a sufficient abstraction that Send and Sync can be derived. For instance all of Rust's standard collections are Send and Sync (when they contain Send and Sync types) in spite of their pervasive use of raw pointers to manage allocations and complex ownership. Similarly, most iterators into these collections are Send and Sync because they largely behave like an `&` or `&mut` into the collection.\n\n## [Example](#example)\n\n[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is implemented as its own special intrinsic type by the compiler for [various reasons](https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/), but we can implement something with similar-ish behavior ourselves to see an example of when it is sound to implement Send and Sync. Let's call it a `Carton`.\n\nWe start by writing code to take a value allocated on the stack and transfer it to the heap.\n\n```rust\n#![allow(unused)]\nfn main() {\npub mod libc {\n   pub use ::std::os::raw::{c_int, c_void};\n   #[allow(non_camel_case_types)]\n   pub type size_t = usize;\n   extern \"C\" { pub fn posix_memalign(memptr: *mut *mut c_void, align: size_t, size: size_t) -> c_int; }\n}\nuse std::{\n    mem::{align_of, size_of},\n    ptr,\n    cmp::max,\n};\n\nstruct Carton<T>(ptr::NonNull<T>);\n\nimpl<T> Carton<T> {\n    pub fn new(value: T) -> Self {\n        // Allocate enough memory on the heap to store one T.\n        assert_ne!(size_of::<T>(), 0, \"Zero-sized types are out of the scope of this example\");\n        let mut memptr: *mut T = ptr::null_mut();\n        unsafe {\n            let ret = libc::posix_memalign(\n                (&mut memptr as *mut *mut T).cast(),\n                max(align_of::<T>(), size_of::<usize>()),\n                size_of::<T>()\n            );\n            assert_eq!(ret, 0, \"Failed to allocate or invalid alignment\");\n        };\n\n        // NonNull is just a wrapper that enforces that the pointer isn't null.\n        let ptr = {\n            // Safety: memptr is dereferenceable because we created it from a\n            // reference and have exclusive access.\n            ptr::NonNull::new(memptr)\n                .expect(\"Guaranteed non-null if posix_memalign returns 0\")\n        };\n\n        // Move value from the stack to the location we allocated on the heap.\n        unsafe {\n            // Safety: If non-null, posix_memalign gives us a ptr that is valid\n            // for writes and properly aligned.\n            ptr.as_ptr().write(value);\n        }\n\n        Self(ptr)\n    }\n}\n}\n```\n\nThis isn't very useful, because once our users give us a value they have no way to access it. [`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) implements [`Deref`](https://doc.rust-lang.org/core/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/core/ops/trait.DerefMut.html) so that you can access the inner value. Let's do that.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::ops::{Deref, DerefMut};\n\nstruct Carton<T>(std::ptr::NonNull<T>);\n\nimpl<T> Deref for Carton<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        unsafe {\n            // Safety: The pointer is aligned, initialized, and dereferenceable\n            //   by the logic in [`Self::new`]. We require readers to borrow the\n            //   Carton, and the lifetime of the return value is elided to the\n            //   lifetime of the input. This means the borrow checker will\n            //   enforce that no one can mutate the contents of the Carton until\n            //   the reference returned is dropped.\n            self.0.as_ref()\n        }\n    }\n}\n\nimpl<T> DerefMut for Carton<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        unsafe {\n            // Safety: The pointer is aligned, initialized, and dereferenceable\n            //   by the logic in [`Self::new`]. We require writers to mutably\n            //   borrow the Carton, and the lifetime of the return value is\n            //   elided to the lifetime of the input. This means the borrow\n            //   checker will enforce that no one else can access the contents\n            //   of the Carton until the mutable reference returned is dropped.\n            self.0.as_mut()\n        }\n    }\n}\n}\n```\n\nFinally, let's think about whether our `Carton` is Send and Sync. Something can safely be Send unless it shares mutable state with something else without enforcing exclusive access to it. Each `Carton` has a unique pointer, so we're good.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Carton<T>(std::ptr::NonNull<T>);\n// Safety: No one besides us has the raw pointer, so we can safely transfer the\n// Carton to another thread if T can be safely transferred.\nunsafe impl<T> Send for Carton<T> where T: Send {}\n}\n```\n\nWhat about Sync? For `Carton` to be Sync we have to enforce that you can't write to something stored in a `&Carton` while that same something could be read or written to from another `&Carton`. Since you need an `&mut Carton` to write to the pointer, and the borrow checker enforces that mutable references must be exclusive, there are no soundness issues making `Carton` sync either.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Carton<T>(std::ptr::NonNull<T>);\n// Safety: Since there exists a public way to go from a `&Carton<T>` to a `&T`\n// in an unsynchronized fashion (such as `Deref`), then `Carton<T>` can't be\n// `Sync` if `T` isn't.\n// Conversely, `Carton` itself does not use any interior mutability whatsoever:\n// all the mutations are performed through an exclusive reference (`&mut`). This\n// means it suffices that `T` be `Sync` for `Carton<T>` to be `Sync`:\nunsafe impl<T> Sync for Carton<T> where T: Sync  {}\n}\n```\n\nWhen we assert our type is Send and Sync we usually need to enforce that every contained type is Send and Sync. When writing custom types that behave like standard library types we can assert that we have the same requirements. For example, the following code asserts that a Carton is Send if the same sort of Box would be Send, which in this case is the same as saying T is Send.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Carton<T>(std::ptr::NonNull<T>);\nunsafe impl<T> Send for Carton<T> where Box<T>: Send {}\n}\n```\n\nRight now `Carton<T>` has a memory leak, as it never frees the memory it allocates. Once we fix that we have a new requirement we have to ensure we meet to be Send: we need to know `free` can be called on a pointer that was yielded by an allocation done on another thread. We can check this is true in the docs for [`libc::free`](https://linux.die.net/man/3/free).\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Carton<T>(std::ptr::NonNull<T>);\nmod libc {\n    pub use ::std::os::raw::c_void;\n    extern \"C\" { pub fn free(p: *mut c_void); }\n}\nimpl<T> Drop for Carton<T> {\n    fn drop(&mut self) {\n        unsafe {\n            libc::free(self.0.as_ptr().cast());\n        }\n    }\n}\n}\n```\n\nA nice example where this does not happen is with a MutexGuard: notice how [it is not Send](https://doc.rust-lang.org/std/sync/struct.MutexGuard.html#impl-Send). The implementation of MutexGuard [uses libraries](https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326) that require you to ensure you don't try to free a lock that you acquired in a different thread. If you were able to Send a MutexGuard to another thread the destructor would run in the thread you sent it to, violating the requirement. MutexGuard can still be Sync because all you can send to another thread is an `&MutexGuard` and dropping a reference does nothing.\n\nTODO: better explain what can or can't be Send or Sync. Sufficient to appeal only to data races?",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Send and Sync - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"send-and-sync\"><a class=\"header\" href=\"#send-and-sync\">Send and Sync</a></h1>\n<p>Not everything obeys inherited mutability, though. Some types allow you to\nhave multiple aliases of a location in memory while mutating it. Unless these types use\nsynchronization to manage this access, they are absolutely not thread-safe. Rust\ncaptures this through the <code class=\"hljs\">Send</code> and <code class=\"hljs\">Sync</code> traits.</p>\n<ul>\n<li>A type is Send if it is safe to send it to another thread.</li>\n<li>A type is Sync if it is safe to share between threads (T is Sync if and only if <code class=\"hljs\">&amp;T</code> is Send).</li>\n</ul>\n<p>Send and Sync are fundamental to Rust's concurrency story. As such, a\nsubstantial amount of special tooling exists to make them work right. First and\nforemost, they're <a href=\"safe-unsafe-meaning.html\">unsafe traits</a>. This means that they are unsafe to\nimplement, and other unsafe code can assume that they are correctly\nimplemented. Since they're <em>marker traits</em> (they have no associated items like\nmethods), correctly implemented simply means that they have the intrinsic\nproperties an implementor should have. Incorrectly implementing Send or Sync can\ncause Undefined Behavior.</p>\n<p>Send and Sync are also automatically derived traits. This means that, unlike\nevery other trait, if a type is composed entirely of Send or Sync types, then it\nis Send or Sync. Almost all primitives are Send and Sync, and as a consequence\npretty much all types you'll ever interact with are Send and Sync.</p>\n<p>Major exceptions include:</p>\n<ul>\n<li>raw pointers are neither Send nor Sync (because they have no safety guards).</li>\n<li><code class=\"hljs\">UnsafeCell</code> isn't Sync (and therefore <code class=\"hljs\">Cell</code> and <code class=\"hljs\">RefCell</code> aren't).</li>\n<li><code class=\"hljs\">Rc</code> isn't Send or Sync (because the refcount is shared and unsynchronized).</li>\n</ul>\n<p><code class=\"hljs\">Rc</code> and <code class=\"hljs\">UnsafeCell</code> are very fundamentally not thread-safe: they enable\nunsynchronized shared mutable state. However raw pointers are, strictly\nspeaking, marked as thread-unsafe as more of a <em>lint</em>. Doing anything useful\nwith a raw pointer requires dereferencing it, which is already unsafe. In that\nsense, one could argue that it would be \"fine\" for them to be marked as thread\nsafe.</p>\n<p>However it's important that they aren't thread-safe to prevent types that\ncontain them from being automatically marked as thread-safe. These types have\nnon-trivial untracked ownership, and it's unlikely that their author was\nnecessarily thinking hard about thread safety. In the case of <code class=\"hljs\">Rc</code>, we have a nice\nexample of a type that contains a <code class=\"hljs\">*mut</code> that is definitely not thread-safe.</p>\n<p>Types that aren't automatically derived can simply implement them if desired:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBox</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>);\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> MyBox {}\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Sync</span> <span class=\"hljs-keyword\">for</span> MyBox {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In the <em>incredibly rare</em> case that a type is inappropriately automatically\nderived to be Send or Sync, then one can also unimplement Send and Sync:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"hljs-meta\">#![feature(negative_impls)]</span>\n\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// I have some magic semantics for some synchronization primitive!</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecialThreadToken</span></span>(<span class=\"hljs-built_in\">u8</span>);\n\n<span class=\"hljs-keyword\">impl</span> !<span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> SpecialThreadToken {}\n<span class=\"hljs-keyword\">impl</span> !<span class=\"hljs-built_in\">Sync</span> <span class=\"hljs-keyword\">for</span> SpecialThreadToken {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Note that <em>in and of itself</em> it is impossible to incorrectly derive Send and\nSync. Only types that are ascribed special meaning by other unsafe code can\npossibly cause trouble by being incorrectly Send or Sync.</p>\n<p>Most uses of raw pointers should be encapsulated behind a sufficient abstraction\nthat Send and Sync can be derived. For instance all of Rust's standard\ncollections are Send and Sync (when they contain Send and Sync types) in spite\nof their pervasive use of raw pointers to manage allocations and complex ownership.\nSimilarly, most iterators into these collections are Send and Sync because they\nlargely behave like an <code class=\"hljs\">&amp;</code> or <code class=\"hljs\">&amp;mut</code> into the collection.</p>\n<h2 id=\"example\"><a class=\"header\" href=\"#example\">Example</a></h2>\n<p><a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html\"><code class=\"hljs\">Box</code></a> is implemented as its own special intrinsic type by the\ncompiler for <a href=\"https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/\">various reasons</a>, but we can implement something\nwith similar-ish behavior ourselves to see an example of when it is sound to\nimplement Send and Sync. Let's call it a <code class=\"hljs\">Carton</code>.</p>\n<p>We start by writing code to take a value allocated on the stack and transfer it\nto the heap.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> libc {\n</span><span class=\"boring\">   <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> ::std::os::raw::{c_int, c_void};\n</span><span class=\"boring\">   <span class=\"hljs-meta\">#[allow(non_camel_case_types)]</span>\n</span><span class=\"boring\">   <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">size_t</span></span> = <span class=\"hljs-built_in\">usize</span>;\n</span><span class=\"boring\">   <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> { <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">posix_memalign</span></span>(memptr: *<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">mut</span> c_void, align: size_t, size: size_t) -&gt; c_int; }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-keyword\">use</span> std::{\n    mem::{align_of, size_of},\n    ptr,\n    cmp::max,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Carton</span></span>&lt;T&gt;(ptr::NonNull&lt;T&gt;);\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Carton&lt;T&gt; {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: T) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-comment\">// Allocate enough memory on the heap to store one T.</span>\n        <span class=\"hljs-built_in\">assert_ne!</span>(size_of::&lt;T&gt;(), <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"Zero-sized types are out of the scope of this example\"</span>);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> memptr: *<span class=\"hljs-keyword\">mut</span> T = ptr::null_mut();\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-keyword\">let</span> ret = libc::posix_memalign(\n                (&amp;<span class=\"hljs-keyword\">mut</span> memptr <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">mut</span> T).cast(),\n                max(align_of::&lt;T&gt;(), size_of::&lt;<span class=\"hljs-built_in\">usize</span>&gt;()),\n                size_of::&lt;T&gt;()\n            );\n            <span class=\"hljs-built_in\">assert_eq!</span>(ret, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"Failed to allocate or invalid alignment\"</span>);\n        };\n\n        <span class=\"hljs-comment\">// NonNull is just a wrapper that enforces that the pointer isn't null.</span>\n        <span class=\"hljs-keyword\">let</span> ptr = {\n            <span class=\"hljs-comment\">// Safety: memptr is dereferenceable because we created it from a</span>\n            <span class=\"hljs-comment\">// reference and have exclusive access.</span>\n            ptr::NonNull::new(memptr)\n                .expect(<span class=\"hljs-string\">\"Guaranteed non-null if posix_memalign returns 0\"</span>)\n        };\n\n        <span class=\"hljs-comment\">// Move value from the stack to the location we allocated on the heap.</span>\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Safety: If non-null, posix_memalign gives us a ptr that is valid</span>\n            <span class=\"hljs-comment\">// for writes and properly aligned.</span>\n            ptr.as_ptr().write(value);\n        }\n\n        <span class=\"hljs-keyword\">Self</span>(ptr)\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This isn't very useful, because once our users give us a value they have no way\nto access it. <a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html\"><code class=\"hljs\">Box</code></a> implements <a href=\"https://doc.rust-lang.org/core/ops/trait.Deref.html\"><code class=\"hljs\">Deref</code></a> and\n<a href=\"https://doc.rust-lang.org/core/ops/trait.DerefMut.html\"><code class=\"hljs\">DerefMut</code></a> so that you can access the inner value. Let's do\nthat.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::ops::{Deref, DerefMut};\n\n<span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Carton</span></span>&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span>&lt;T&gt; Deref <span class=\"hljs-keyword\">for</span> Carton&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = T;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;Self::Target {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Safety: The pointer is aligned, initialized, and dereferenceable</span>\n            <span class=\"hljs-comment\">//   by the logic in [`Self::new`]. We require readers to borrow the</span>\n            <span class=\"hljs-comment\">//   Carton, and the lifetime of the return value is elided to the</span>\n            <span class=\"hljs-comment\">//   lifetime of the input. This means the borrow checker will</span>\n            <span class=\"hljs-comment\">//   enforce that no one can mutate the contents of the Carton until</span>\n            <span class=\"hljs-comment\">//   the reference returned is dropped.</span>\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>.as_ref()\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; DerefMut <span class=\"hljs-keyword\">for</span> Carton&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref_mut</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; &amp;<span class=\"hljs-keyword\">mut</span> Self::Target {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Safety: The pointer is aligned, initialized, and dereferenceable</span>\n            <span class=\"hljs-comment\">//   by the logic in [`Self::new`]. We require writers to mutably</span>\n            <span class=\"hljs-comment\">//   borrow the Carton, and the lifetime of the return value is</span>\n            <span class=\"hljs-comment\">//   elided to the lifetime of the input. This means the borrow</span>\n            <span class=\"hljs-comment\">//   checker will enforce that no one else can access the contents</span>\n            <span class=\"hljs-comment\">//   of the Carton until the mutable reference returned is dropped.</span>\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>.as_mut()\n        }\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Finally, let's think about whether our <code class=\"hljs\">Carton</code> is Send and Sync. Something can\nsafely be Send unless it shares mutable state with something else without\nenforcing exclusive access to it. Each <code class=\"hljs\">Carton</code> has a unique pointer, so\nwe're good.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Carton</span></span>&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);\n</span><span class=\"hljs-comment\">// Safety: No one besides us has the raw pointer, so we can safely transfer the</span>\n<span class=\"hljs-comment\">// Carton to another thread if T can be safely transferred.</span>\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> Carton&lt;T&gt; <span class=\"hljs-keyword\">where</span> T: <span class=\"hljs-built_in\">Send</span> {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>What about Sync? For <code class=\"hljs\">Carton</code> to be Sync we have to enforce that you can't\nwrite to something stored in a <code class=\"hljs\">&amp;Carton</code> while that same something could be read\nor written to from another <code class=\"hljs\">&amp;Carton</code>. Since you need an <code class=\"hljs\">&amp;mut Carton</code> to\nwrite to the pointer, and the borrow checker enforces that mutable\nreferences must be exclusive, there are no soundness issues making <code class=\"hljs\">Carton</code>\nsync either.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Carton</span></span>&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);\n</span><span class=\"hljs-comment\">// Safety: Since there exists a public way to go from a `&amp;Carton&lt;T&gt;` to a `&amp;T`</span>\n<span class=\"hljs-comment\">// in an unsynchronized fashion (such as `Deref`), then `Carton&lt;T&gt;` can't be</span>\n<span class=\"hljs-comment\">// `Sync` if `T` isn't.</span>\n<span class=\"hljs-comment\">// Conversely, `Carton` itself does not use any interior mutability whatsoever:</span>\n<span class=\"hljs-comment\">// all the mutations are performed through an exclusive reference (`&amp;mut`). This</span>\n<span class=\"hljs-comment\">// means it suffices that `T` be `Sync` for `Carton&lt;T&gt;` to be `Sync`:</span>\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Sync</span> <span class=\"hljs-keyword\">for</span> Carton&lt;T&gt; <span class=\"hljs-keyword\">where</span> T: <span class=\"hljs-built_in\">Sync</span>  {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>When we assert our type is Send and Sync we usually need to enforce that every\ncontained type is Send and Sync. When writing custom types that behave like\nstandard library types we can assert that we have the same requirements.\nFor example, the following code asserts that a Carton is Send if the same\nsort of Box would be Send, which in this case is the same as saying T is Send.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Carton</span></span>&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);\n</span><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> Carton&lt;T&gt; <span class=\"hljs-keyword\">where</span> <span class=\"hljs-built_in\">Box</span>&lt;T&gt;: <span class=\"hljs-built_in\">Send</span> {}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Right now <code class=\"hljs\">Carton&lt;T&gt;</code> has a memory leak, as it never frees the memory it allocates.\nOnce we fix that we have a new requirement we have to ensure we meet to be Send:\nwe need to know <code class=\"hljs\">free</code> can be called on a pointer that was yielded by an\nallocation done on another thread. We can check this is true in the docs for\n<a href=\"https://linux.die.net/man/3/free\"><code class=\"hljs\">libc::free</code></a>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Carton</span></span>&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> libc {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> ::std::os::raw::c_void;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> { <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">free</span></span>(p: *<span class=\"hljs-keyword\">mut</span> c_void); }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Carton&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            libc::free(<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>.as_ptr().cast());\n        }\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>A nice example where this does not happen is with a MutexGuard: notice how\n<a href=\"https://doc.rust-lang.org/std/sync/struct.MutexGuard.html#impl-Send\">it is not Send</a>. The implementation of MutexGuard\n<a href=\"https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326\">uses libraries</a> that require you to ensure you\ndon't try to free a lock that you acquired in a different thread. If you were\nable to Send a MutexGuard to another thread the destructor would run in the\nthread you sent it to, violating the requirement. MutexGuard can still be Sync\nbecause all you can send to another thread is an <code class=\"hljs\">&amp;MutexGuard</code> and dropping a\nreference does nothing.</p>\n<p>TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\nonly to data races?</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"races.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"atomics.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"races.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"atomics.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:09.416Z"
}