{
	"title": "Using Trait Objects That Allow for Values of Different Types - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch17-02-trait-objects.html",
	"markdown": "# Using Trait Objects That Allow for Values of Different Types\n\nIn Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-9 where we defined a `SpreadsheetCell` enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.\n\nHowever, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we’ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a `draw` method on each one to draw it to the screen—a common technique for GUI tools. We’ll create a library crate called `gui` that contains the structure of a GUI library. This crate might include some types for people to use, such as `Button` or `TextField`. In addition, `gui` users will want to create their own types that can be drawn: for instance, one programmer might add an `Image` and another might add a `SelectBox`.\n\nWe won’t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can’t know and define all the types other programmers might want to create. But we do know that `gui` needs to keep track of many values of different types, and it needs to call a `draw` method on each of these differently typed values. It doesn’t need to know exactly what will happen when we call the `draw` method, just that the value will have that method available for us to call.\n\nTo do this in a language with inheritance, we might define a class named `Component` that has a method named `draw` on it. The other classes, such as `Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus inherit the `draw` method. They could each override the `draw` method to define their custom behavior, but the framework could treat all of the types as if they were `Component` instances and call `draw` on them. But because Rust doesn’t have inheritance, we need another way to structure the `gui` library to allow users to extend it with new types.\n\n### [Defining a Trait for Common Behavior](#defining-a-trait-for-common-behavior)\n\nTo implement the behavior we want `gui` to have, we’ll define a trait named `Draw` that will have one method named `draw`. Then we can define a vector that takes a _trait object_. A trait object points to both an instance of a type implementing our specified trait and a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a `&` reference or a `Box<T>` smart pointer, then the `dyn` keyword, and then specifying the relevant trait. (We’ll talk about the reason trait objects must use a pointer in Chapter 19 in the section [“Dynamically Sized Types and the `Sized` Trait.”](about:blank/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait)) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust’s type system will ensure at compile time that any value used in that context will implement the trait object’s trait. Consequently, we don’t need to know all the possible types at compile time.\n\nWe’ve mentioned that, in Rust, we refrain from calling structs and enums “objects” to distinguish them from other languages’ objects. In a struct or enum, the data in the struct fields and the behavior in `impl` blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects _are_ more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can’t add data to a trait object. Trait objects aren’t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.\n\nListing 17-3 shows how to define a trait named `Draw` with one method named `draw`:\n\nFilename: src/lib.rs\n\n```rust\npub trait Draw {\n    fn draw(&self);\n}\n```\n\nListing 17-3: Definition of the `Draw` trait\n\nThis syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named `Screen` that holds a vector named `components`. This vector is of type `Box<dyn Draw>`, which is a trait object; it’s a stand-in for any type inside a `Box` that implements the `Draw` trait.\n\nFilename: src/lib.rs\n\n```rust\npub trait Draw {\n    fn draw(&self);\n}\n\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n```\n\nListing 17-4: Definition of the `Screen` struct with a `components` field holding a vector of trait objects that implement the `Draw` trait\n\nOn the `Screen` struct, we’ll define a method named `run` that will call the `draw` method on each of its `components`, as shown in Listing 17-5:\n\nFilename: src/lib.rs\n\n```rust\npub trait Draw {\n    fn draw(&self);\n}\n\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n```\n\nListing 17-5: A `run` method on `Screen` that calls the `draw` method on each component\n\nThis works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the `Screen` struct using a generic type and a trait bound as in Listing 17-6:\n\nFilename: src/lib.rs\n\n```rust\npub trait Draw {\n    fn draw(&self);\n}\n\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n```\n\nListing 17-6: An alternate implementation of the `Screen` struct and its `run` method using generics and trait bounds\n\nThis restricts us to a `Screen` instance that has a list of components all of type `Button` or all of type `TextField`. If you’ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.\n\nOn the other hand, with the method using trait objects, one `Screen` instance can hold a `Vec<T>` that contains a `Box<Button>` as well as a `Box<TextField>`. Let’s look at how this works, and then we’ll talk about the runtime performance implications.\n\n### [Implementing the Trait](#implementing-the-trait)\n\nNow we’ll add some types that implement the `Draw` trait. We’ll provide the `Button` type. Again, actually implementing a GUI library is beyond the scope of this book, so the `draw` method won’t have any useful implementation in its body. To imagine what the implementation might look like, a `Button` struct might have fields for `width`, `height`, and `label`, as shown in Listing 17-7:\n\nFilename: src/lib.rs\n\n```rust\npub trait Draw {\n    fn draw(&self);\n}\n\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {\n    pub width: u32,\n    pub height: u32,\n    pub label: String,\n}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        // code to actually draw a button\n    }\n}\n```\n\nListing 17-7: A `Button` struct that implements the `Draw` trait\n\nThe `width`, `height`, and `label` fields on `Button` will differ from the fields on other components; for example, a `TextField` type might have those same fields plus a `placeholder` field. Each of the types we want to draw on the screen will implement the `Draw` trait but will use different code in the `draw` method to define how to draw that particular type, as `Button` has here (without the actual GUI code, as mentioned). The `Button` type, for instance, might have an additional `impl` block containing methods related to what happens when a user clicks the button. These kinds of methods won’t apply to types like `TextField`.\n\nIf someone using our library decides to implement a `SelectBox` struct that has `width`, `height`, and `options` fields, they implement the `Draw` trait on the `SelectBox` type as well, as shown in Listing 17-8:\n\nFilename: src/main.rs\n\n```rust\nuse gui::Draw;\n\nstruct SelectBox {\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\n\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        // code to actually draw a select box\n    }\n}\n\nfn main() {}\n```\n\nListing 17-8: Another crate using `gui` and implementing the `Draw` trait on a `SelectBox` struct\n\nOur library’s user can now write their `main` function to create a `Screen` instance. To the `Screen` instance, they can add a `SelectBox` and a `Button` by putting each in a `Box<T>` to become a trait object. They can then call the `run` method on the `Screen` instance, which will call `draw` on each of the components. Listing 17-9 shows this implementation:\n\nFilename: src/main.rs\n\n```rust\nuse gui::Draw;\n\nstruct SelectBox {\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\n\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        // code to actually draw a select box\n    }\n}\n\nuse gui::{Button, Screen};\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(SelectBox {\n                width: 75,\n                height: 10,\n                options: vec![\n                    String::from(\"Yes\"),\n                    String::from(\"Maybe\"),\n                    String::from(\"No\"),\n                ],\n            }),\n            Box::new(Button {\n                width: 50,\n                height: 10,\n                label: String::from(\"OK\"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n```\n\nListing 17-9: Using trait objects to store values of different types that implement the same trait\n\nWhen we wrote the library, we didn’t know that someone might add the `SelectBox` type, but our `Screen` implementation was able to operate on the new type and draw it because `SelectBox` implements the `Draw` trait, which means it implements the `draw` method.\n\nThis concept—of being concerned only with the messages a value responds to rather than the value’s concrete type—is similar to the concept of _duck typing_ in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of `run` on `Screen` in Listing 17-5, `run` doesn’t need to know what the concrete type of each component is. It doesn’t check whether a component is an instance of a `Button` or a `SelectBox`, it just calls the `draw` method on the component. By specifying `Box<dyn Draw>` as the type of the values in the `components` vector, we’ve defined `Screen` to need values that we can call the `draw` method on.\n\nThe advantage of using trait objects and Rust’s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn’t implement a method but we call it anyway. Rust won’t compile our code if the values don’t implement the traits that the trait objects need.\n\nFor example, Listing 17-10 shows what happens if we try to create a `Screen` with a `String` as a component:\n\nFilename: src/main.rs\n\n```rust\nuse gui::Screen;\n\nfn main() {\n    let screen = Screen {\n        components: vec![Box::new(String::from(\"Hi\"))],\n    };\n\n    screen.run();\n}\n```\n\nListing 17-10: Attempting to use a type that doesn’t implement the trait object’s trait\n\nWe’ll get this error because `String` doesn’t implement the `Draw` trait:\n\n```console\n$ cargo run\n   Compiling gui v0.1.0 (file:///projects/gui)\nerror[E0277]: the trait bound `String: Draw` is not satisfied\n --> src/main.rs:5:26\n  |\n5 |         components: vec![Box::new(String::from(\"Hi\"))],\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`\n  |\n  = help: the trait `Draw` is implemented for `Button`\n  = note: required for the cast from `Box<String>` to `Box<dyn Draw>`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `gui` (bin \"gui\") due to 1 previous error\n\n```\n\nThis error lets us know that either we’re passing something to `Screen` we didn’t mean to pass and so should pass a different type or we should implement `Draw` on `String` so that `Screen` is able to call `draw` on it.\n\n### [Trait Objects Perform Dynamic Dispatch](#trait-objects-perform-dynamic-dispatch)\n\nRecall in the [“Performance of Code Using Generics”](about:blank/ch10-01-syntax.html#performance-of-code-using-generics) section in Chapter 10 our discussion on the monomorphization process performed by the compiler when we use trait bounds on generics: the compiler generates nongeneric implementations of functions and methods for each concrete type that we use in place of a generic type parameter. The code that results from monomorphization is doing _static dispatch_, which is when the compiler knows what method you’re calling at compile time. This is opposed to _dynamic dispatch_, which is when the compiler can’t tell at compile time which method you’re calling. In dynamic dispatch cases, the compiler emits code that at runtime will figure out which method to call.\n\nWhen we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t know all the types that might be used with the code that’s using trait objects, so it doesn’t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. This lookup incurs a runtime cost that doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method’s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off to consider.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Using Trait Objects That Allow for Values of Different Types - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"using-trait-objects-that-allow-for-values-of-different-types\"><a class=\"header\" href=\"#using-trait-objects-that-allow-for-values-of-different-types\">Using Trait Objects That Allow for Values of Different Types</a></h2>\n<p>In Chapter 8, we mentioned that one limitation of vectors is that they can\nstore elements of only one type. We created a workaround in Listing 8-9 where\nwe defined a <code class=\"hljs\">SpreadsheetCell</code> enum that had variants to hold integers, floats,\nand text. This meant we could store different types of data in each cell and\nstill have a vector that represented a row of cells. This is a perfectly good\nsolution when our interchangeable items are a fixed set of types that we know\nwhen our code is compiled.</p>\n<p>However, sometimes we want our library user to be able to extend the set of\ntypes that are valid in a particular situation. To show how we might achieve\nthis, we’ll create an example graphical user interface (GUI) tool that iterates\nthrough a list of items, calling a <code class=\"hljs\">draw</code> method on each one to draw it to the\nscreen—a common technique for GUI tools. We’ll create a library crate called\n<code class=\"hljs\">gui</code> that contains the structure of a GUI library. This crate might include\nsome types for people to use, such as <code class=\"hljs\">Button</code> or <code class=\"hljs\">TextField</code>. In addition,\n<code class=\"hljs\">gui</code> users will want to create their own types that can be drawn: for\ninstance, one programmer might add an <code class=\"hljs\">Image</code> and another might add a\n<code class=\"hljs\">SelectBox</code>.</p>\n<p>We won’t implement a fully fledged GUI library for this example but will show\nhow the pieces would fit together. At the time of writing the library, we can’t\nknow and define all the types other programmers might want to create. But we do\nknow that <code class=\"hljs\">gui</code> needs to keep track of many values of different types, and it\nneeds to call a <code class=\"hljs\">draw</code> method on each of these differently typed values. It\ndoesn’t need to know exactly what will happen when we call the <code class=\"hljs\">draw</code> method,\njust that the value will have that method available for us to call.</p>\n<p>To do this in a language with inheritance, we might define a class named\n<code class=\"hljs\">Component</code> that has a method named <code class=\"hljs\">draw</code> on it. The other classes, such as\n<code class=\"hljs\">Button</code>, <code class=\"hljs\">Image</code>, and <code class=\"hljs\">SelectBox</code>, would inherit from <code class=\"hljs\">Component</code> and thus\ninherit the <code class=\"hljs\">draw</code> method. They could each override the <code class=\"hljs\">draw</code> method to define\ntheir custom behavior, but the framework could treat all of the types as if\nthey were <code class=\"hljs\">Component</code> instances and call <code class=\"hljs\">draw</code> on them. But because Rust\ndoesn’t have inheritance, we need another way to structure the <code class=\"hljs\">gui</code> library to\nallow users to extend it with new types.</p>\n<h3 id=\"defining-a-trait-for-common-behavior\"><a class=\"header\" href=\"#defining-a-trait-for-common-behavior\">Defining a Trait for Common Behavior</a></h3>\n<p>To implement the behavior we want <code class=\"hljs\">gui</code> to have, we’ll define a trait named\n<code class=\"hljs\">Draw</code> that will have one method named <code class=\"hljs\">draw</code>. Then we can define a vector that\ntakes a <em>trait object</em>. A trait object points to both an instance of a type\nimplementing our specified trait and a table used to look up trait methods on\nthat type at runtime. We create a trait object by specifying some sort of\npointer, such as a <code class=\"hljs\">&amp;</code> reference or a <code class=\"hljs\">Box&lt;T&gt;</code> smart pointer, then the <code class=\"hljs\">dyn</code>\nkeyword, and then specifying the relevant trait. (We’ll talk about the reason\ntrait objects must use a pointer in Chapter 19 in the section <a href=\"ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\">“Dynamically\nSized Types and the <code class=\"hljs\">Sized</code> Trait.”</a><!-- ignore -->) We can\nuse trait objects in place of a generic or concrete type. Wherever we use a\ntrait object, Rust’s type system will ensure at compile time that any value\nused in that context will implement the trait object’s trait. Consequently, we\ndon’t need to know all the possible types at compile time.</p>\n<p>We’ve mentioned that, in Rust, we refrain from calling structs and enums\n“objects” to distinguish them from other languages’ objects. In a struct or\nenum, the data in the struct fields and the behavior in <code class=\"hljs\">impl</code> blocks are\nseparated, whereas in other languages, the data and behavior combined into one\nconcept is often labeled an object. However, trait objects <em>are</em> more like\nobjects in other languages in the sense that they combine data and behavior.\nBut trait objects differ from traditional objects in that we can’t add data to\na trait object. Trait objects aren’t as generally useful as objects in other\nlanguages: their specific purpose is to allow abstraction across common\nbehavior.</p>\n<p>Listing 17-3 shows how to define a trait named <code class=\"hljs\">Draw</code> with one method named\n<code class=\"hljs\">draw</code>:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Draw</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n}</code></pre>\n<p><span class=\"caption\">Listing 17-3: Definition of the <code class=\"hljs\">Draw</code> trait</span></p>\n<p>This syntax should look familiar from our discussions on how to define traits\nin Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named\n<code class=\"hljs\">Screen</code> that holds a vector named <code class=\"hljs\">components</code>. This vector is of type\n<code class=\"hljs\">Box&lt;dyn Draw&gt;</code>, which is a trait object; it’s a stand-in for any type inside\na <code class=\"hljs\">Box</code> that implements the <code class=\"hljs\">Draw</code> trait.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Draw</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Screen</span></span> {\n    <span class=\"hljs-keyword\">pub</span> components: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Draw&gt;&gt;,\n}</code></pre>\n<p><span class=\"caption\">Listing 17-4: Definition of the <code class=\"hljs\">Screen</code> struct with a\n<code class=\"hljs\">components</code> field holding a vector of trait objects that implement the <code class=\"hljs\">Draw</code>\ntrait</span></p>\n<p>On the <code class=\"hljs\">Screen</code> struct, we’ll define a method named <code class=\"hljs\">run</code> that will call the\n<code class=\"hljs\">draw</code> method on each of its <code class=\"hljs\">components</code>, as shown in Listing 17-5:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Draw</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Screen</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> components: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Draw&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Screen {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">for</span> component <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.components.iter() {\n            component.draw();\n        }\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 17-5: A <code class=\"hljs\">run</code> method on <code class=\"hljs\">Screen</code> that calls the\n<code class=\"hljs\">draw</code> method on each component</span></p>\n<p>This works differently from defining a struct that uses a generic type\nparameter with trait bounds. A generic type parameter can only be substituted\nwith one concrete type at a time, whereas trait objects allow for multiple\nconcrete types to fill in for the trait object at runtime. For example, we\ncould have defined the <code class=\"hljs\">Screen</code> struct using a generic type and a trait bound\nas in Listing 17-6:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Draw</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Screen</span></span>&lt;T: Draw&gt; {\n    <span class=\"hljs-keyword\">pub</span> components: <span class=\"hljs-built_in\">Vec</span>&lt;T&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Screen&lt;T&gt;\n<span class=\"hljs-keyword\">where</span>\n    T: Draw,\n{\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">for</span> component <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.components.iter() {\n            component.draw();\n        }\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 17-6: An alternate implementation of the <code class=\"hljs\">Screen</code>\nstruct and its <code class=\"hljs\">run</code> method using generics and trait bounds</span></p>\n<p>This restricts us to a <code class=\"hljs\">Screen</code> instance that has a list of components all of\ntype <code class=\"hljs\">Button</code> or all of type <code class=\"hljs\">TextField</code>. If you’ll only ever have homogeneous\ncollections, using generics and trait bounds is preferable because the\ndefinitions will be monomorphized at compile time to use the concrete types.</p>\n<p>On the other hand, with the method using trait objects, one <code class=\"hljs\">Screen</code> instance\ncan hold a <code class=\"hljs\">Vec&lt;T&gt;</code> that contains a <code class=\"hljs\">Box&lt;Button&gt;</code> as well as a\n<code class=\"hljs\">Box&lt;TextField&gt;</code>. Let’s look at how this works, and then we’ll talk about the\nruntime performance implications.</p>\n<h3 id=\"implementing-the-trait\"><a class=\"header\" href=\"#implementing-the-trait\">Implementing the Trait</a></h3>\n<p>Now we’ll add some types that implement the <code class=\"hljs\">Draw</code> trait. We’ll provide the\n<code class=\"hljs\">Button</code> type. Again, actually implementing a GUI library is beyond the scope\nof this book, so the <code class=\"hljs\">draw</code> method won’t have any useful implementation in its\nbody. To imagine what the implementation might look like, a <code class=\"hljs\">Button</code> struct\nmight have fields for <code class=\"hljs\">width</code>, <code class=\"hljs\">height</code>, and <code class=\"hljs\">label</code>, as shown in Listing 17-7:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Draw</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Screen</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> components: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Draw&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Screen {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> component <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.components.iter() {\n</span><span class=\"boring\">            component.draw();\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Button</span></span> {\n    <span class=\"hljs-keyword\">pub</span> width: <span class=\"hljs-built_in\">u32</span>,\n    <span class=\"hljs-keyword\">pub</span> height: <span class=\"hljs-built_in\">u32</span>,\n    <span class=\"hljs-keyword\">pub</span> label: <span class=\"hljs-built_in\">String</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Draw <span class=\"hljs-keyword\">for</span> Button {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// code to actually draw a button</span>\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 17-7: A <code class=\"hljs\">Button</code> struct that implements the\n<code class=\"hljs\">Draw</code> trait</span></p>\n<p>The <code class=\"hljs\">width</code>, <code class=\"hljs\">height</code>, and <code class=\"hljs\">label</code> fields on <code class=\"hljs\">Button</code> will differ from the\nfields on other components; for example, a <code class=\"hljs\">TextField</code> type might have those\nsame fields plus a <code class=\"hljs\">placeholder</code> field. Each of the types we want to draw on\nthe screen will implement the <code class=\"hljs\">Draw</code> trait but will use different code in the\n<code class=\"hljs\">draw</code> method to define how to draw that particular type, as <code class=\"hljs\">Button</code> has here\n(without the actual GUI code, as mentioned). The <code class=\"hljs\">Button</code> type, for instance,\nmight have an additional <code class=\"hljs\">impl</code> block containing methods related to what\nhappens when a user clicks the button. These kinds of methods won’t apply to\ntypes like <code class=\"hljs\">TextField</code>.</p>\n<p>If someone using our library decides to implement a <code class=\"hljs\">SelectBox</code> struct that has\n<code class=\"hljs\">width</code>, <code class=\"hljs\">height</code>, and <code class=\"hljs\">options</code> fields, they implement the <code class=\"hljs\">Draw</code> trait on the\n<code class=\"hljs\">SelectBox</code> type as well, as shown in Listing 17-8:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-keyword\">use</span> gui::Draw;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SelectBox</span></span> {\n    width: <span class=\"hljs-built_in\">u32</span>,\n    height: <span class=\"hljs-built_in\">u32</span>,\n    options: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> Draw <span class=\"hljs-keyword\">for</span> SelectBox {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// code to actually draw a select box</span>\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre>\n<p><span class=\"caption\">Listing 17-8: Another crate using <code class=\"hljs\">gui</code> and implementing\nthe <code class=\"hljs\">Draw</code> trait on a <code class=\"hljs\">SelectBox</code> struct</span></p>\n<p>Our library’s user can now write their <code class=\"hljs\">main</code> function to create a <code class=\"hljs\">Screen</code>\ninstance. To the <code class=\"hljs\">Screen</code> instance, they can add a <code class=\"hljs\">SelectBox</code> and a <code class=\"hljs\">Button</code>\nby putting each in a <code class=\"hljs\">Box&lt;T&gt;</code> to become a trait object. They can then call the\n<code class=\"hljs\">run</code> method on the <code class=\"hljs\">Screen</code> instance, which will call <code class=\"hljs\">draw</code> on each of the\ncomponents. Listing 17-9 shows this implementation:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> gui::Draw;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SelectBox</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    options: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">String</span>&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Draw <span class=\"hljs-keyword\">for</span> SelectBox {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">draw</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-comment\">// code to actually draw a select box</span>\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">use</span> gui::{Button, Screen};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> screen = Screen {\n        components: <span class=\"hljs-built_in\">vec!</span>[\n            <span class=\"hljs-built_in\">Box</span>::new(SelectBox {\n                width: <span class=\"hljs-number\">75</span>,\n                height: <span class=\"hljs-number\">10</span>,\n                options: <span class=\"hljs-built_in\">vec!</span>[\n                    <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Yes\"</span>),\n                    <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Maybe\"</span>),\n                    <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"No\"</span>),\n                ],\n            }),\n            <span class=\"hljs-built_in\">Box</span>::new(Button {\n                width: <span class=\"hljs-number\">50</span>,\n                height: <span class=\"hljs-number\">10</span>,\n                label: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"OK\"</span>),\n            }),\n        ],\n    };\n\n    screen.run();\n}</code></pre>\n<p><span class=\"caption\">Listing 17-9: Using trait objects to store values of\ndifferent types that implement the same trait</span></p>\n<p>When we wrote the library, we didn’t know that someone might add the\n<code class=\"hljs\">SelectBox</code> type, but our <code class=\"hljs\">Screen</code> implementation was able to operate on the\nnew type and draw it because <code class=\"hljs\">SelectBox</code> implements the <code class=\"hljs\">Draw</code> trait, which\nmeans it implements the <code class=\"hljs\">draw</code> method.</p>\n<p>This concept—of being concerned only with the messages a value responds to\nrather than the value’s concrete type—is similar to the concept of <em>duck\ntyping</em> in dynamically typed languages: if it walks like a duck and quacks\nlike a duck, then it must be a duck! In the implementation of <code class=\"hljs\">run</code> on <code class=\"hljs\">Screen</code>\nin Listing 17-5, <code class=\"hljs\">run</code> doesn’t need to know what the concrete type of each\ncomponent is. It doesn’t check whether a component is an instance of a <code class=\"hljs\">Button</code>\nor a <code class=\"hljs\">SelectBox</code>, it just calls the <code class=\"hljs\">draw</code> method on the component. By\nspecifying <code class=\"hljs\">Box&lt;dyn Draw&gt;</code> as the type of the values in the <code class=\"hljs\">components</code>\nvector, we’ve defined <code class=\"hljs\">Screen</code> to need values that we can call the <code class=\"hljs\">draw</code>\nmethod on.</p>\n<p>The advantage of using trait objects and Rust’s type system to write code\nsimilar to code using duck typing is that we never have to check whether a\nvalue implements a particular method at runtime or worry about getting errors\nif a value doesn’t implement a method but we call it anyway. Rust won’t compile\nour code if the values don’t implement the traits that the trait objects need.</p>\n<p>For example, Listing 17-10 shows what happens if we try to create a <code class=\"hljs\">Screen</code>\nwith a <code class=\"hljs\">String</code> as a component:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-keyword\">use</span> gui::Screen;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> screen = Screen {\n        components: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hi\"</span>))],\n    };\n\n    screen.run();\n}</code></pre>\n<p><span class=\"caption\">Listing 17-10: Attempting to use a type that doesn’t\nimplement the trait object’s trait</span></p>\n<p>We’ll get this error because <code class=\"hljs\">String</code> doesn’t implement the <code class=\"hljs\">Draw</code> trait:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling gui v0.1.0 (file:///projects/gui)\nerror[E0277]: the trait bound `String: Draw` is not satisfied\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:5:26</span>\n  |\n5 |         components: vec![Box::new(String::from(\"Hi\"))],\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`\n  |\n  = help: the trait `Draw` is implemented for `Button`\n  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `gui` (bin \"gui\") due to 1 previous error\n</code></pre>\n<p>This error lets us know that either we’re passing something to <code class=\"hljs\">Screen</code> we\ndidn’t mean to pass and so should pass a different type or we should implement\n<code class=\"hljs\">Draw</code> on <code class=\"hljs\">String</code> so that <code class=\"hljs\">Screen</code> is able to call <code class=\"hljs\">draw</code> on it.</p>\n<h3 id=\"trait-objects-perform-dynamic-dispatch\"><a class=\"header\" href=\"#trait-objects-perform-dynamic-dispatch\">Trait Objects Perform Dynamic Dispatch</a></h3>\n<p>Recall in the <a href=\"ch10-01-syntax.html#performance-of-code-using-generics\">“Performance of Code Using\nGenerics”</a><!-- ignore --> section in\nChapter 10 our discussion on the monomorphization process performed by the\ncompiler when we use trait bounds on generics: the compiler generates\nnongeneric implementations of functions and methods for each concrete type that\nwe use in place of a generic type parameter. The code that results from\nmonomorphization is doing <em>static dispatch</em>, which is when the compiler knows\nwhat method you’re calling at compile time. This is opposed to <em>dynamic\ndispatch</em>, which is when the compiler can’t tell at compile time which method\nyou’re calling. In dynamic dispatch cases, the compiler emits code that at\nruntime will figure out which method to call.</p>\n<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t\nknow all the types that might be used with the code that’s using trait objects,\nso it doesn’t know which method implemented on which type to call. Instead, at\nruntime, Rust uses the pointers inside the trait object to know which method to\ncall. This lookup incurs a runtime cost that doesn’t occur with static\ndispatch. Dynamic dispatch also prevents the compiler from choosing to inline a\nmethod’s code, which in turn prevents some optimizations. However, we did get\nextra flexibility in the code that we wrote in Listing 17-5 and were able to\nsupport in Listing 17-9, so it’s a trade-off to consider.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch17-01-what-is-oo.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch17-03-oo-design-patterns.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch17-01-what-is-oo.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch17-03-oo-design-patterns.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:31.588Z"
}