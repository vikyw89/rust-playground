{
	"title": "Macros By Example - The Rust Reference",
	"url": "https://doc.rust-lang.org/reference/macros-by-example.html#hygiene",
	"markdown": "# Macros By Example - The Rust Reference\n\n> **Syntax**  \n> _MacroRulesDefinition_ :  \n>    `macro_rules` `!` [IDENTIFIER](identifiers.html) _MacroRulesDef_\n> \n> _MacroRulesDef_ :  \n>       `(` _MacroRules_ `)` `;`  \n>    | `[` _MacroRules_ `]` `;`  \n>    | `{` _MacroRules_ `}`\n> \n> _MacroRules_ :  \n>    _MacroRule_ ( `;` _MacroRule_ )\\* `;`?\n> \n> _MacroRule_ :  \n>    _MacroMatcher_ `=>` _MacroTranscriber_\n> \n> _MacroMatcher_ :  \n>       `(` _MacroMatch_\\* `)`  \n>    | `[` _MacroMatch_\\* `]`  \n>    | `{` _MacroMatch_\\* `}`\n> \n> _MacroMatch_ :  \n>       [_Token_](tokens.html)_except `$` and [delimiters](about:blank/tokens.html#delimiters)_  \n>    | _MacroMatcher_  \n>    | `$` ( [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html) _except `crate`_ | [RAW\\_IDENTIFIER](identifiers.html) | `_` ) `:` _MacroFragSpec_  \n>    | `$` `(` _MacroMatch_+ `)` _MacroRepSep_? _MacroRepOp_\n> \n> _MacroFragSpec_ :  \n>       `block` | `expr` | `ident` | `item` | `lifetime` | `literal`  \n>    | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`\n> \n> _MacroRepSep_ :  \n>    [_Token_](tokens.html)_except [delimiters](about:blank/tokens.html#delimiters) and MacroRepOp_\n> \n> _MacroRepOp_ :  \n>    `*` | `+` | `?`\n> \n> _MacroTranscriber_ :  \n>    [_DelimTokenTree_](macros.html)\n\n`macro_rules` allows users to define syntax extension in a declarative way. We call such extensions \"macros by example\" or simply \"macros\".\n\nEach macro by example has a name, and one or more _rules_. Each rule has two parts: a _matcher_, describing the syntax that it matches, and a _transcriber_, describing the syntax that will replace a successfully matched invocation. Both the matcher and the transcriber must be surrounded by delimiters. Macros can expand to expressions, statements, items (including traits, impls, and foreign items), types, or patterns.\n\n## [Transcribing](#transcribing)\n\nWhen a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a `)`, even though that would allow it to parse the invocation unambiguously:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! ambiguity {\n    ($($i:ident)* $j:ident) => { };\n}\n\nambiguity!(error); // Error: local ambiguity\n}\n```\n\nIn both the matcher and the transcriber, the `$` token is used to invoke special behaviours from the macro engine (described below in [Metavariables](#metavariables) and [Repetitions](#repetitions)). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher `(())` will match `{()}` but not `{{}}`. The character `$` cannot be matched or transcribed literally.\n\n### [Forwarding a matched fragment](#forwarding-a-matched-fragment)\n\nWhen forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The `ident`, `lifetime`, and `tt` fragment types are an exception, and _can_ be matched by literal tokens. The following illustrates this restriction:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! foo {\n    ($l:expr) => { bar!($l); }\n// ERROR:               ^^ no rules expected this token in macro call\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);\n}\n```\n\nThe following illustrates how tokens can be directly matched after matching a `tt` fragment:\n\n```rust\n#![allow(unused)]\nfn main() {\n// compiles OK\nmacro_rules! foo {\n    ($l:tt) => { bar!($l); }\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);\n}\n```\n\nIn the matcher, `$` _name_ `:` _fragment-specifier_ matches a Rust syntax fragment of the kind specified and binds it to the metavariable `$`_name_. Valid fragment specifiers are:\n\n-   `item`: an [_Item_](items.html)\n-   `block`: a [_BlockExpression_](expressions/block-expr.html)\n-   `stmt`: a [_Statement_](statements.html) without the trailing semicolon (except for item statements that require semicolons)\n-   `pat_param`: a [_PatternNoTopAlt_](patterns.html)\n-   `pat`: at least any [_PatternNoTopAlt_](patterns.html), and possibly more depending on edition\n-   `expr`: an [_Expression_](expressions.html)\n-   `ty`: a [_Type_](about:blank/types.html#type-expressions)\n-   `ident`: an [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html) or [RAW\\_IDENTIFIER](identifiers.html)\n-   `path`: a [_TypePath_](about:blank/paths.html#paths-in-types) style path\n-   `tt`: a [_TokenTree_](about:blank/macros.html#macro-invocation) (a single [token](tokens.html) or tokens in matching delimiters `()`, `[]`, or `{}`)\n-   `meta`: an [_Attr_](attributes.html), the contents of an attribute\n-   `lifetime`: a [LIFETIME\\_TOKEN](about:blank/tokens.html#lifetimes-and-loop-labels)\n-   `vis`: a possibly empty [_Visibility_](visibility-and-privacy.html) qualifier\n-   `literal`: matches `-`?[_LiteralExpression_](expressions/literal-expr.html)\n\nIn the transcriber, metavariables are referred to simply by `$`_name_, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable `$crate` can be used to refer to the current crate; see [Hygiene](#hygiene) below. Metavariables can be transcribed more than once or not at all.\n\nFor reasons of backwards compatibility, though `_` [is also an expression](expressions/underscore-expr.html), a standalone underscore is not matched by the `expr` fragment specifier. However, `_` is matched by the `expr` fragment specifier when it appears as a subexpression. For the same reason, a standalone [const block](about:blank/expressions/block-expr.html#const-blocks) is not matched but it is matched when appearing as a subexpression.\n\n> **Edition Differences**: Starting with the 2021 edition, `pat` fragment-specifiers match top-level or-patterns (that is, they accept [_Pattern_](patterns.html)).\n> \n> Before the 2021 edition, they match exactly the same fragments as `pat_param` (that is, they accept [_PatternNoTopAlt_](patterns.html)).\n> \n> The relevant edition is the one in effect for the `macro_rules!` definition.\n\n## [Repetitions](#repetitions)\n\nIn both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside `$(`…`)`, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but `;` and `,` are the most common. For instance, `$( $i:ident ),*` represents any number of identifiers separated by commas. Nested repetitions are permitted.\n\nThe repetition operators are:\n\n-   `*` — indicates any number of repetitions.\n-   `+` — indicates any number but at least one.\n-   `?` — indicates an optional fragment with zero or one occurrence.\n\nSince `?` represents at most one occurrence, it cannot be used with a separator.\n\nThe repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the `$( $i:ident ),*` example above matches `$i` to all of the identifiers in the list.\n\nDuring transcription, additional restrictions apply to repetitions so that the compiler knows how to expand them properly:\n\n1.  A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher `$( $i:ident ),*`, the transcribers `=> { $i }`, `=> { $( $( $i)* )* }`, and `=> { $( $i )+ }` are all illegal, but `=> { $( $i );* }` is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.\n2.  Each repetition in the transcriber must contain at least one metavariable to decide how many times to expand it. If multiple metavariables appear in the same repetition, they must be bound to the same number of fragments. For instance, `( $( $i:ident ),* ; $( $j:ident ),* ) => (( $( ($i,$j) ),* ))` must bind the same number of `$i` fragments as `$j` fragments. This means that invoking the macro with `(a, b, c; d, e, f)` is legal and expands to `((a,d), (b,e), (c,f))`, but `(a, b, c; d, e)` is illegal because it does not have the same number. This requirement applies to every layer of nested repetitions.\n\n## [Scoping, Exporting, and Importing](#scoping-exporting-and-importing)\n\nFor historical reasons, the scoping of macros by example does not work entirely like items. Macros have two forms of scope: textual scope, and path-based scope. Textual scope is based on the order that things appear in source files, or even across multiple files, and is the default scoping. It is explained further below. Path-based scope works exactly the same way that item scoping does. The scoping, exporting, and importing of macros is controlled largely by attributes.\n\nWhen a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.\n\n```rust\nuse lazy_static::lazy_static; // Path-based import.\n\nmacro_rules! lazy_static { // Textual definition.\n    (lazy) => {};\n}\n\nlazy_static!{lazy} // Textual lookup finds our macro first.\nself::lazy_static!{} // Path-based lookup ignores our macro, finds imported one.\n```\n\n### [Textual Scope](#textual-scope)\n\nTextual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with `let` except it also applies at the module level. When `macro_rules!` is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:\n\n```rust\n//// src/lib.rs\nmod has_macro {\n    // m!{} // Error: m is not in scope.\n\n    macro_rules! m {\n        () => {};\n    }\n    m!{} // OK: appears after declaration of m.\n\n    mod uses_macro;\n}\n\n// m!{} // Error: m is not in scope.\n\n//// src/has_macro/uses_macro.rs\n\nm!{} // OK: appears after declaration of m in src/lib.rs\n```\n\nIt is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! m {\n    (1) => {};\n}\n\nm!(1);\n\nmod inner {\n    m!(1);\n\n    macro_rules! m {\n        (2) => {};\n    }\n    // m!(1); // Error: no rule matches '1'\n    m!(2);\n\n    macro_rules! m {\n        (3) => {};\n    }\n    m!(3);\n}\n\nm!(1);\n}\n```\n\nMacros can be declared and used locally inside functions as well, and work similarly:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn foo() {\n    // m!(); // Error: m is not in scope.\n    macro_rules! m {\n        () => {};\n    }\n    m!();\n}\n\n\n// m!(); // Error: m is not in scope.\n}\n```\n\n### [The `macro_use` attribute](#the-macro_use-attribute)\n\nThe _`macro_use` attribute_ has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[macro_use]\nmod inner {\n    macro_rules! m {\n        () => {};\n    }\n}\n\nm!();\n}\n```\n\nSecond, it can be used to import macros from another crate, by attaching it to an `extern crate` declaration appearing in the crate's root module. Macros imported this way are imported into the [`macro_use` prelude](about:blank/names/preludes.html#macro_use-prelude), not textually, which means that they can be shadowed by any other name. While macros imported by `#[macro_use]` can be used before the import statement, in case of a conflict, the last macro imported wins. Optionally, a list of macros to import can be specified using the [_MetaListIdents_](about:blank/attributes.html#meta-item-attribute-syntax) syntax; this is not supported when `#[macro_use]` is applied to a module.\n\n```rust\n#[macro_use(lazy_static)] // Or #[macro_use] to import all macros.\nextern crate lazy_static;\n\nlazy_static!{}\n// self::lazy_static!{} // Error: lazy_static is not defined in `self`\n```\n\nMacros to be imported with `#[macro_use]` must be exported with `#[macro_export]`, which is described below.\n\n### [Path-Based Scope](#path-based-scope)\n\nBy default, a macro has no path-based scope. However, if it has the `#[macro_export]` attribute, then it is declared in the crate root scope and can be referred to normally as such:\n\n```rust\n#![allow(unused)]\nfn main() {\nself::m!();\nm!(); // OK: Path-based lookup finds m in the current module.\n\nmod inner {\n    super::m!();\n    crate::m!();\n}\n\nmod mac {\n    #[macro_export]\n    macro_rules! m {\n        () => {};\n    }\n}\n}\n```\n\nMacros labeled with `#[macro_export]` are always `pub` and can be referred to by other crates, either by path or by `#[macro_use]` as described above.\n\n## [Hygiene](#hygiene)\n\nBy default, all identifiers referred to in a macro are expanded as-is, and are looked up at the macro's invocation site. This can lead to issues if a macro refers to an item or macro which isn't in scope at the invocation site. To alleviate this, the `$crate` metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro.\n\n```rust\n//// Definitions in the `helper_macro` crate.\n#[macro_export]\nmacro_rules! helped {\n    // () => { helper!() } // This might lead to an error due to 'helper' not being in scope.\n    () => { $crate::helper!() }\n}\n\n#[macro_export]\nmacro_rules! helper {\n    () => { () }\n}\n\n//// Usage in another crate.\n// Note that `helper_macro::helper` is not imported!\nuse helper_macro::helped;\n\nfn unit() {\n    helped!();\n}\n```\n\nNote that, because `$crate` refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:\n\n```rust\n#![allow(unused)]\nfn main() {\npub mod inner {\n    #[macro_export]\n    macro_rules! call_foo {\n        () => { $crate::inner::foo() };\n    }\n\n    pub fn foo() {}\n}\n}\n```\n\nAdditionally, even though `$crate` allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke `call_foo!()` from outside its crate will fail because `foo()` is not public.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[macro_export]\nmacro_rules! call_foo {\n    () => { $crate::foo() };\n}\n\nfn foo() {}\n}\n```\n\n> **Version & Edition Differences**: Prior to Rust 1.30, `$crate` and `local_inner_macros` (below) were unsupported. They were added alongside path-based imports of macros (described above), to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use `$crate` or `local_inner_macros` to work well with path-based imports.\n\nWhen a macro is exported, the `#[macro_export]` attribute can have the `local_inner_macros` keyword added to automatically prefix all contained macro invocations with `$crate::`. This is intended primarily as a tool to migrate code written before `$crate` was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[macro_export(local_inner_macros)]\nmacro_rules! helped {\n    () => { helper!() } // Automatically converted to $crate::helper!().\n}\n\n#[macro_export]\nmacro_rules! helper {\n    () => { () }\n}\n}\n```\n\n## [Follow-set Ambiguity Restrictions](#follow-set-ambiguity-restrictions)\n\nThe parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.\n\nAs an example, a macro matcher like `$i:expr [ , ]` could in theory be accepted in Rust today, since `[,]` cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because `[` can start trailing expressions, `[` is not a character which can safely be ruled out as coming after an expression. If `[,]` were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like `$i:expr,` or `$i:expr;` would be legal, however, because `,` and `;` are legal expression separators. The specific rules are:\n\n-   `expr` and `stmt` may only be followed by one of: `=>`, `,`, or `;`.\n-   `pat_param` may only be followed by one of: `=>`, `,`, `=`, `|`, `if`, or `in`.\n-   `pat` may only be followed by one of: `=>`, `,`, `=`, `if`, or `in`.\n-   `path` and `ty` may only be followed by one of: `=>`, `,`, `=`, `|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, `where`, or a macro variable of `block` fragment specifier.\n-   `vis` may only be followed by one of: `,`, an identifier other than a non-raw `priv`, any token that can begin a type, or a metavariable with a `ident`, `ty`, or `path` fragment specifier.\n-   All other fragment specifiers have no restrictions.\n\n> **Edition Differences**: Before the 2021 edition, `pat` may also be followed by `|`.\n\nWhen repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:\n\n-   If the repetition includes a separator, that separator must be able to follow the contents of the repetition.\n-   If the repetition can repeat multiple times (`*` or `+`), then the contents must be able to follow themselves.\n-   The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.\n-   If the repetition can match zero times (`*` or `?`), then whatever comes after must be able to follow whatever comes before.\n\nFor more detail, see the [formal specification](macro-ambiguity.html).",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Macros By Example - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar bordered\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/macros-by-example.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"macros-by-example\"><a class=\"header\" href=\"#macros-by-example\">Macros By Example</a></h1>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>MacroRulesDefinition</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">macro_rules</code> <code class=\"hljs\">!</code> <a href=\"identifiers.html\">IDENTIFIER</a> <em>MacroRulesDef</em></p>\n<p><em>MacroRulesDef</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">(</code> <em>MacroRules</em> <code class=\"hljs\">)</code> <code class=\"hljs\">;</code><br>\n&nbsp;&nbsp; | <code class=\"hljs\">[</code> <em>MacroRules</em> <code class=\"hljs\">]</code> <code class=\"hljs\">;</code><br>\n&nbsp;&nbsp; | <code class=\"hljs\">{</code> <em>MacroRules</em> <code class=\"hljs\">}</code></p>\n<p><em>MacroRules</em> :<br>\n&nbsp;&nbsp; <em>MacroRule</em> ( <code class=\"hljs\">;</code> <em>MacroRule</em> )<sup>*</sup> <code class=\"hljs\">;</code><sup>?</sup></p>\n<p><em>MacroRule</em> :<br>\n&nbsp;&nbsp; <em>MacroMatcher</em> <code class=\"hljs\">=&gt;</code> <em>MacroTranscriber</em></p>\n<p><em>MacroMatcher</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">(</code> <em>MacroMatch</em><sup>*</sup> <code class=\"hljs\">)</code><br>\n&nbsp;&nbsp; | <code class=\"hljs\">[</code> <em>MacroMatch</em><sup>*</sup> <code class=\"hljs\">]</code><br>\n&nbsp;&nbsp; | <code class=\"hljs\">{</code> <em>MacroMatch</em><sup>*</sup> <code class=\"hljs\">}</code></p>\n<p><em>MacroMatch</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"tokens.html\"><em>Token</em></a><sub><em>except <code class=\"hljs\">$</code> and <a href=\"tokens.html#delimiters\">delimiters</a></em></sub><br>\n&nbsp;&nbsp; | <em>MacroMatcher</em><br>\n&nbsp;&nbsp; | <code class=\"hljs\">$</code> ( <a href=\"identifiers.html\">IDENTIFIER_OR_KEYWORD</a> <sub><em>except <code class=\"hljs\">crate</code></em></sub> | <a href=\"identifiers.html\">RAW_IDENTIFIER</a> | <code class=\"hljs\">_</code> ) <code class=\"hljs\">:</code> <em>MacroFragSpec</em><br>\n&nbsp;&nbsp; | <code class=\"hljs\">$</code> <code class=\"hljs\">(</code> <em>MacroMatch</em><sup>+</sup> <code class=\"hljs\">)</code> <em>MacroRepSep</em><sup>?</sup> <em>MacroRepOp</em></p>\n<p><em>MacroFragSpec</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">block</code> | <code class=\"hljs\">expr</code> | <code class=\"hljs\">ident</code> | <code class=\"hljs\">item</code> | <code class=\"hljs\">lifetime</code> | <code class=\"hljs\">literal</code><br>\n&nbsp;&nbsp; | <code class=\"hljs\">meta</code> | <code class=\"hljs\">pat</code> | <code class=\"hljs\">pat_param</code> | <code class=\"hljs\">path</code> | <code class=\"hljs\">stmt</code> | <code class=\"hljs\">tt</code> | <code class=\"hljs\">ty</code> | <code class=\"hljs\">vis</code></p>\n<p><em>MacroRepSep</em> :<br>\n&nbsp;&nbsp; <a href=\"tokens.html\"><em>Token</em></a><sub><em>except <a href=\"tokens.html#delimiters\">delimiters</a> and MacroRepOp</em></sub></p>\n<p><em>MacroRepOp</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">*</code> | <code class=\"hljs\">+</code> | <code class=\"hljs\">?</code></p>\n<p><em>MacroTranscriber</em> :<br>\n&nbsp;&nbsp; <a href=\"macros.html\"><em>DelimTokenTree</em></a></p>\n</blockquote>\n<p><code class=\"hljs\">macro_rules</code> allows users to define syntax extension in a declarative way.  We\ncall such extensions \"macros by example\" or simply \"macros\".</p>\n<p>Each macro by example has a name, and one or more <em>rules</em>. Each rule has two\nparts: a <em>matcher</em>, describing the syntax that it matches, and a <em>transcriber</em>,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.</p>\n<h2 id=\"transcribing\"><a class=\"header\" href=\"#transcribing\">Transcribing</a></h2>\n<p>When a macro is invoked, the macro expander looks up macro invocations by name,\nand tries each macro rule in turn. It transcribes the first successful match; if\nthis results in an error, then future matches are not tried. When matching, no\nlookahead is performed; if the compiler cannot unambiguously determine how to\nparse the macro invocation one token at a time, then it is an error. In the\nfollowing example, the compiler does not look ahead past the identifier to see\nif the following token is a <code class=\"hljs\">)</code>, even though that would allow it to parse the\ninvocation unambiguously:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">macro_rules!</span> ambiguity {\n    ($($i:ident)* $j:ident) =&gt; { };\n}\n\nambiguity!(error); <span class=\"hljs-comment\">// Error: local ambiguity</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In both the matcher and the transcriber, the <code class=\"hljs\">$</code> token is used to invoke special\nbehaviours from the macro engine (described below in <a href=\"#metavariables\">Metavariables</a> and\n<a href=\"#repetitions\">Repetitions</a>). Tokens that aren't part of such an invocation are matched and\ntranscribed literally, with one exception. The exception is that the outer\ndelimiters for the matcher will match any pair of delimiters. Thus, for\ninstance, the matcher <code class=\"hljs\">(())</code> will match <code class=\"hljs\">{()}</code> but not <code class=\"hljs\">{{}}</code>. The character\n<code class=\"hljs\">$</code> cannot be matched or transcribed literally.</p>\n<h3 id=\"forwarding-a-matched-fragment\"><a class=\"header\" href=\"#forwarding-a-matched-fragment\">Forwarding a matched fragment</a></h3>\n<p>When forwarding a matched fragment to another macro-by-example, matchers in\nthe second macro will see an opaque AST of the fragment type. The second macro\ncan't use literal tokens to match the fragments in the matcher, only a\nfragment specifier of the same type. The <code class=\"hljs\">ident</code>, <code class=\"hljs\">lifetime</code>, and <code class=\"hljs\">tt</code>\nfragment types are an exception, and <em>can</em> be matched by literal tokens. The\nfollowing illustrates this restriction:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">macro_rules!</span> foo {\n    ($l:expr) =&gt; { bar!($l); }\n<span class=\"hljs-comment\">// ERROR:               ^^ no rules expected this token in macro call</span>\n}\n\n<span class=\"hljs-built_in\">macro_rules!</span> bar {\n    (<span class=\"hljs-number\">3</span>) =&gt; {}\n}\n\nfoo!(<span class=\"hljs-number\">3</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The following illustrates how tokens can be directly matched after matching a\n<code class=\"hljs\">tt</code> fragment:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// compiles OK</span>\n<span class=\"hljs-built_in\">macro_rules!</span> foo {\n    ($l:tt) =&gt; { bar!($l); }\n}\n\n<span class=\"hljs-built_in\">macro_rules!</span> bar {\n    (<span class=\"hljs-number\">3</span>) =&gt; {}\n}\n\nfoo!(<span class=\"hljs-number\">3</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"metavariables\"><a class=\"header\" href=\"#metavariables\">Metavariables</a></h2>\n<p>In the matcher, <code class=\"hljs\">$</code> <em>name</em> <code class=\"hljs\">:</code> <em>fragment-specifier</em> matches a Rust syntax\nfragment of the kind specified and binds it to the metavariable <code class=\"hljs\">$</code><em>name</em>. Valid\nfragment specifiers are:</p>\n<ul>\n<li><code class=\"hljs\">item</code>: an <a href=\"items.html\"><em>Item</em></a></li>\n<li><code class=\"hljs\">block</code>: a <a href=\"expressions/block-expr.html\"><em>BlockExpression</em></a></li>\n<li><code class=\"hljs\">stmt</code>: a <a href=\"statements.html\"><em>Statement</em></a> without the trailing semicolon (except for item\nstatements that require semicolons)</li>\n<li><code class=\"hljs\">pat_param</code>: a <a href=\"patterns.html\"><em>PatternNoTopAlt</em></a></li>\n<li><code class=\"hljs\">pat</code>: at least any <a href=\"patterns.html\"><em>PatternNoTopAlt</em></a>, and possibly more depending on edition</li>\n<li><code class=\"hljs\">expr</code>: an <a href=\"expressions.html\"><em>Expression</em></a></li>\n<li><code class=\"hljs\">ty</code>: a <a href=\"types.html#type-expressions\"><em>Type</em></a></li>\n<li><code class=\"hljs\">ident</code>: an <a href=\"identifiers.html\">IDENTIFIER_OR_KEYWORD</a> or <a href=\"identifiers.html\">RAW_IDENTIFIER</a></li>\n<li><code class=\"hljs\">path</code>: a <a href=\"paths.html#paths-in-types\"><em>TypePath</em></a> style path</li>\n<li><code class=\"hljs\">tt</code>: a <a href=\"macros.html#macro-invocation\"><em>TokenTree</em></a>&nbsp;(a single <a href=\"tokens.html\">token</a> or tokens in matching delimiters <code class=\"hljs\">()</code>, <code class=\"hljs\">[]</code>, or <code class=\"hljs\">{}</code>)</li>\n<li><code class=\"hljs\">meta</code>: an <a href=\"attributes.html\"><em>Attr</em></a>, the contents of an attribute</li>\n<li><code class=\"hljs\">lifetime</code>: a <a href=\"tokens.html#lifetimes-and-loop-labels\">LIFETIME_TOKEN</a></li>\n<li><code class=\"hljs\">vis</code>: a possibly empty <a href=\"visibility-and-privacy.html\"><em>Visibility</em></a> qualifier</li>\n<li><code class=\"hljs\">literal</code>: matches <code class=\"hljs\">-</code><sup>?</sup><a href=\"expressions/literal-expr.html\"><em>LiteralExpression</em></a></li>\n</ul>\n<p>In the transcriber, metavariables are referred to simply by <code class=\"hljs\">$</code><em>name</em>, since\nthe fragment kind is specified in the matcher. Metavariables are replaced with\nthe syntax element that matched them. The keyword metavariable <code class=\"hljs\">$crate</code> can be\nused to refer to the current crate; see <a href=\"#hygiene\">Hygiene</a> below. Metavariables can be\ntranscribed more than once or not at all.</p>\n<p>For reasons of backwards compatibility, though <code class=\"hljs\">_</code> <a href=\"expressions/underscore-expr.html\">is also an\nexpression</a>, a standalone underscore is not matched by\nthe <code class=\"hljs\">expr</code> fragment specifier. However, <code class=\"hljs\">_</code> is matched by the <code class=\"hljs\">expr</code> fragment\nspecifier when it appears as a subexpression.\nFor the same reason, a standalone <a href=\"expressions/block-expr.html#const-blocks\">const block</a> is not matched but it is matched when appearing as a subexpression.</p>\n<blockquote>\n<p><strong>Edition Differences</strong>: Starting with the 2021 edition, <code class=\"hljs\">pat</code> fragment-specifiers match top-level or-patterns (that is, they accept <a href=\"patterns.html\"><em>Pattern</em></a>).</p>\n<p>Before the 2021 edition, they match exactly the same fragments as <code class=\"hljs\">pat_param</code> (that is, they accept <a href=\"patterns.html\"><em>PatternNoTopAlt</em></a>).</p>\n<p>The relevant edition is the one in effect for the <code class=\"hljs\">macro_rules!</code> definition.</p>\n</blockquote>\n<h2 id=\"repetitions\"><a class=\"header\" href=\"#repetitions\">Repetitions</a></h2>\n<p>In both the matcher and transcriber, repetitions are indicated by placing the\ntokens to be repeated inside <code class=\"hljs\">$(</code>…<code class=\"hljs\">)</code>, followed by a repetition operator,\noptionally with a separator token between. The separator token can be any token\nother than a delimiter or one of the repetition operators, but <code class=\"hljs\">;</code> and <code class=\"hljs\">,</code> are\nthe most common. For instance, <code class=\"hljs\">$( $i:ident ),*</code> represents any number of\nidentifiers separated by commas. Nested repetitions are permitted.</p>\n<p>The repetition operators are:</p>\n<ul>\n<li><code class=\"hljs\">*</code> — indicates any number of repetitions.</li>\n<li><code class=\"hljs\">+</code> — indicates any number but at least one.</li>\n<li><code class=\"hljs\">?</code> — indicates an optional fragment with zero or one occurrence.</li>\n</ul>\n<p>Since <code class=\"hljs\">?</code> represents at most one occurrence, it cannot be used with a\nseparator.</p>\n<p>The repeated fragment both matches and transcribes to the specified number of\nthe fragment, separated by the separator token. Metavariables are matched to\nevery repetition of their corresponding fragment. For instance, the <code class=\"hljs\">$( $i:ident ),*</code> example above matches <code class=\"hljs\">$i</code> to all of the identifiers in the list.</p>\n<p>During transcription, additional restrictions apply to repetitions so that the\ncompiler knows how to expand them properly:</p>\n<ol>\n<li>A metavariable must appear in exactly the same number, kind, and nesting\norder of repetitions in the transcriber as it did in the matcher. So for the\nmatcher <code class=\"hljs\">$( $i:ident ),*</code>, the transcribers <code class=\"hljs\">=&gt; { $i }</code>,\n<code class=\"hljs\">=&gt; { $( $( $i)* )* }</code>, and <code class=\"hljs\">=&gt; { $( $i )+ }</code> are all illegal, but\n<code class=\"hljs\">=&gt; { $( $i );* }</code> is correct and replaces a comma-separated list of\nidentifiers with a semicolon-separated list.</li>\n<li>Each repetition in the transcriber must contain at least one metavariable to\ndecide how many times to expand it. If multiple metavariables appear in the\nsame repetition, they must be bound to the same number of fragments. For\ninstance, <code class=\"hljs\">( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code> must\nbind the same number of <code class=\"hljs\">$i</code> fragments as <code class=\"hljs\">$j</code> fragments. This means that\ninvoking the macro with <code class=\"hljs\">(a, b, c; d, e, f)</code> is legal and expands to\n<code class=\"hljs\">((a,d), (b,e), (c,f))</code>, but <code class=\"hljs\">(a, b, c; d, e)</code> is illegal because it does\nnot have the same number. This requirement applies to every layer of nested\nrepetitions.</li>\n</ol>\n<h2 id=\"scoping-exporting-and-importing\"><a class=\"header\" href=\"#scoping-exporting-and-importing\">Scoping, Exporting, and Importing</a></h2>\n<p>For historical reasons, the scoping of macros by example does not work entirely\nlike items. Macros have two forms of scope: textual scope, and path-based scope.\nTextual scope is based on the order that things appear in source files, or even\nacross multiple files, and is the default scoping. It is explained further below.\nPath-based scope works exactly the same way that item scoping does. The scoping,\nexporting, and importing of macros is controlled largely by attributes.</p>\n<p>When a macro is invoked by an unqualified identifier (not part of a multi-part\npath), it is first looked up in textual scoping. If this does not yield any\nresults, then it is looked up in path-based scoping. If the macro's name is\nqualified with a path, then it is only looked up in path-based scoping.</p>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> lazy_static::lazy_static; <span class=\"hljs-comment\">// Path-based import.</span>\n\n<span class=\"hljs-built_in\">macro_rules!</span> lazy_static { <span class=\"hljs-comment\">// Textual definition.</span>\n    (lazy) =&gt; {};\n}\n\nlazy_static!{lazy} <span class=\"hljs-comment\">// Textual lookup finds our macro first.</span>\nself::lazy_static!{} <span class=\"hljs-comment\">// Path-based lookup ignores our macro, finds imported one.</span></code></pre>\n<h3 id=\"textual-scope\"><a class=\"header\" href=\"#textual-scope\">Textual Scope</a></h3>\n<p>Textual scope is based largely on the order that things appear in source files,\nand works similarly to the scope of local variables declared with <code class=\"hljs\">let</code> except\nit also applies at the module level. When <code class=\"hljs\">macro_rules!</code> is used to define a\nmacro, the macro enters the scope after the definition (note that it can still\nbe used recursively, since names are looked up from the invocation site), up\nuntil its surrounding scope, typically a module, is closed. This can enter child\nmodules and even span across multiple files:</p>\n<!-- ignore: requires external modules -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">//// src/lib.rs</span>\n<span class=\"hljs-keyword\">mod</span> has_macro {\n    <span class=\"hljs-comment\">// m!{} // Error: m is not in scope.</span>\n\n    <span class=\"hljs-built_in\">macro_rules!</span> m {\n        () =&gt; {};\n    }\n    m!{} <span class=\"hljs-comment\">// OK: appears after declaration of m.</span>\n\n    <span class=\"hljs-keyword\">mod</span> uses_macro;\n}\n\n<span class=\"hljs-comment\">// m!{} // Error: m is not in scope.</span>\n\n<span class=\"hljs-comment\">//// src/has_macro/uses_macro.rs</span>\n\nm!{} <span class=\"hljs-comment\">// OK: appears after declaration of m in src/lib.rs</span></code></pre>\n<p>It is not an error to define a macro multiple times; the most recent declaration\nwill shadow the previous one unless it has gone out of scope.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">macro_rules!</span> m {\n    (<span class=\"hljs-number\">1</span>) =&gt; {};\n}\n\nm!(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">mod</span> inner {\n    m!(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-built_in\">macro_rules!</span> m {\n        (<span class=\"hljs-number\">2</span>) =&gt; {};\n    }\n    <span class=\"hljs-comment\">// m!(1); // Error: no rule matches '1'</span>\n    m!(<span class=\"hljs-number\">2</span>);\n\n    <span class=\"hljs-built_in\">macro_rules!</span> m {\n        (<span class=\"hljs-number\">3</span>) =&gt; {};\n    }\n    m!(<span class=\"hljs-number\">3</span>);\n}\n\nm!(<span class=\"hljs-number\">1</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Macros can be declared and used locally inside functions as well, and work\nsimilarly:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    <span class=\"hljs-comment\">// m!(); // Error: m is not in scope.</span>\n    <span class=\"hljs-built_in\">macro_rules!</span> m {\n        () =&gt; {};\n    }\n    m!();\n}\n\n\n<span class=\"hljs-comment\">// m!(); // Error: m is not in scope.</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"the-macro_use-attribute\"><a class=\"header\" href=\"#the-macro_use-attribute\">The <code>macro_use</code> attribute</a></h3>\n<p>The <em><code class=\"hljs\">macro_use</code> attribute</em> has two purposes. First, it can be used to make a\nmodule's macro scope not end when the module is closed, by applying it to a\nmodule:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[macro_use]</span>\n<span class=\"hljs-keyword\">mod</span> inner {\n    <span class=\"hljs-built_in\">macro_rules!</span> m {\n        () =&gt; {};\n    }\n}\n\nm!();\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Second, it can be used to import macros from another crate, by attaching it to\nan <code class=\"hljs\">extern crate</code> declaration appearing in the crate's root module. Macros\nimported this way are imported into the <a href=\"names/preludes.html#macro_use-prelude\"><code class=\"hljs\">macro_use</code> prelude</a>, not textually,\nwhich means that they can be shadowed by any other name. While macros imported\nby <code class=\"hljs\">#[macro_use]</code> can be used before the import statement, in case of a\nconflict, the last macro imported wins. Optionally, a list of macros to import\ncan be specified using the <a href=\"attributes.html#meta-item-attribute-syntax\"><em>MetaListIdents</em></a> syntax; this is not supported\nwhen <code class=\"hljs\">#[macro_use]</code> is applied to a module.</p>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[macro_use(lazy_static)]</span> <span class=\"hljs-comment\">// Or #[macro_use] to import all macros.</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> lazy_static;\n\nlazy_static!{}\n<span class=\"hljs-comment\">// self::lazy_static!{} // Error: lazy_static is not defined in `self`</span></code></pre>\n<p>Macros to be imported with <code class=\"hljs\">#[macro_use]</code> must be exported with\n<code class=\"hljs\">#[macro_export]</code>, which is described below.</p>\n<h3 id=\"path-based-scope\"><a class=\"header\" href=\"#path-based-scope\">Path-Based Scope</a></h3>\n<p>By default, a macro has no path-based scope. However, if it has the\n<code class=\"hljs\">#[macro_export]</code> attribute, then it is declared in the crate root scope and can\nbe referred to normally as such:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>self::m!();\nm!(); <span class=\"hljs-comment\">// OK: Path-based lookup finds m in the current module.</span>\n\n<span class=\"hljs-keyword\">mod</span> inner {\n    super::m!();\n    crate::m!();\n}\n\n<span class=\"hljs-keyword\">mod</span> mac {\n    <span class=\"hljs-meta\">#[macro_export]</span>\n    <span class=\"hljs-built_in\">macro_rules!</span> m {\n        () =&gt; {};\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Macros labeled with <code class=\"hljs\">#[macro_export]</code> are always <code class=\"hljs\">pub</code> and can be referred to\nby other crates, either by path or by <code class=\"hljs\">#[macro_use]</code> as described above.</p>\n<h2 id=\"hygiene\"><a class=\"header\" href=\"#hygiene\">Hygiene</a></h2>\n<p>By default, all identifiers referred to in a macro are expanded as-is, and are\nlooked up at the macro's invocation site. This can lead to issues if a macro\nrefers to an item or macro which isn't in scope at the invocation site. To\nalleviate this, the <code class=\"hljs\">$crate</code> metavariable can be used at the start of a path to\nforce lookup to occur inside the crate defining the macro.</p>\n<!-- ignore: requires external crates -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">//// Definitions in the `helper_macro` crate.</span>\n<span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> helped {\n    <span class=\"hljs-comment\">// () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.</span>\n    () =&gt; { $crate::helper!() }\n}\n\n<span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> helper {\n    () =&gt; { () }\n}\n\n<span class=\"hljs-comment\">//// Usage in another crate.</span>\n<span class=\"hljs-comment\">// Note that `helper_macro::helper` is not imported!</span>\n<span class=\"hljs-keyword\">use</span> helper_macro::helped;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">unit</span></span>() {\n    helped!();\n}</code></pre>\n<p>Note that, because <code class=\"hljs\">$crate</code> refers to the current crate, it must be used with a\nfully qualified module path when referring to non-macro items:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> inner {\n    <span class=\"hljs-meta\">#[macro_export]</span>\n    <span class=\"hljs-built_in\">macro_rules!</span> call_foo {\n        () =&gt; { $crate::inner::foo() };\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Additionally, even though <code class=\"hljs\">$crate</code> allows a macro to refer to items within its\nown crate when expanding, its use has no effect on visibility. An item or macro\nreferred to must still be visible from the invocation site. In the following\nexample, any attempt to invoke <code class=\"hljs\">call_foo!()</code> from outside its crate will fail\nbecause <code class=\"hljs\">foo()</code> is not public.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> call_foo {\n    () =&gt; { $crate::foo() };\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n<span class=\"boring\">}</span></code></pre></pre>\n<blockquote>\n<p><strong>Version &amp; Edition Differences</strong>: Prior to Rust 1.30, <code class=\"hljs\">$crate</code> and\n<code class=\"hljs\">local_inner_macros</code> (below) were unsupported. They were added alongside\npath-based imports of macros (described above), to ensure that helper macros\ndid not need to be manually imported by users of a macro-exporting crate.\nCrates written for earlier versions of Rust that use helper macros need to be\nmodified to use <code class=\"hljs\">$crate</code> or <code class=\"hljs\">local_inner_macros</code> to work well with path-based\nimports.</p>\n</blockquote>\n<p>When a macro is exported, the <code class=\"hljs\">#[macro_export]</code> attribute can have the\n<code class=\"hljs\">local_inner_macros</code> keyword added to automatically prefix all contained macro\ninvocations with <code class=\"hljs\">$crate::</code>. This is intended primarily as a tool to migrate\ncode written before <code class=\"hljs\">$crate</code> was added to the language to work with Rust 2018's\npath-based imports of macros. Its use is discouraged in new code.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[macro_export(local_inner_macros)]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> helped {\n    () =&gt; { helper!() } <span class=\"hljs-comment\">// Automatically converted to $crate::helper!().</span>\n}\n\n<span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> helper {\n    () =&gt; { () }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"follow-set-ambiguity-restrictions\"><a class=\"header\" href=\"#follow-set-ambiguity-restrictions\">Follow-set Ambiguity Restrictions</a></h2>\n<p>The parser used by the macro system is reasonably powerful, but it is limited in\norder to prevent ambiguity in current or future versions of the language. In\nparticular, in addition to the rule about ambiguous expansions, a nonterminal\nmatched by a metavariable must be followed by a token which has been decided can\nbe safely used after that kind of match.</p>\n<p>As an example, a macro matcher like <code class=\"hljs\">$i:expr [ , ]</code> could in theory be accepted\nin Rust today, since <code class=\"hljs\">[,]</code> cannot be part of a legal expression and therefore\nthe parse would always be unambiguous. However, because <code class=\"hljs\">[</code> can start trailing\nexpressions, <code class=\"hljs\">[</code> is not a character which can safely be ruled out as coming\nafter an expression. If <code class=\"hljs\">[,]</code> were accepted in a later version of Rust, this\nmatcher would become ambiguous or would misparse, breaking working code.\nMatchers like <code class=\"hljs\">$i:expr,</code> or <code class=\"hljs\">$i:expr;</code> would be legal, however, because <code class=\"hljs\">,</code> and\n<code class=\"hljs\">;</code> are legal expression separators. The specific rules are:</p>\n<ul>\n<li><code class=\"hljs\">expr</code> and <code class=\"hljs\">stmt</code> may only be followed by one of: <code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">,</code>, or <code class=\"hljs\">;</code>.</li>\n<li><code class=\"hljs\">pat_param</code> may only be followed by one of: <code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">,</code>, <code class=\"hljs\">=</code>, <code class=\"hljs\">|</code>, <code class=\"hljs\">if</code>, or <code class=\"hljs\">in</code>.</li>\n<li><code class=\"hljs\">pat</code> may only be followed by one of: <code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">,</code>, <code class=\"hljs\">=</code>, <code class=\"hljs\">if</code>, or <code class=\"hljs\">in</code>.</li>\n<li><code class=\"hljs\">path</code> and <code class=\"hljs\">ty</code> may only be followed by one of: <code class=\"hljs\">=&gt;</code>, <code class=\"hljs\">,</code>, <code class=\"hljs\">=</code>, <code class=\"hljs\">|</code>, <code class=\"hljs\">;</code>,\n<code class=\"hljs\">:</code>, <code class=\"hljs\">&gt;</code>, <code class=\"hljs\">&gt;&gt;</code>, <code class=\"hljs\">[</code>, <code class=\"hljs\">{</code>, <code class=\"hljs\">as</code>, <code class=\"hljs\">where</code>, or a macro variable of <code class=\"hljs\">block</code>\nfragment specifier.</li>\n<li><code class=\"hljs\">vis</code> may only be followed by one of: <code class=\"hljs\">,</code>, an identifier other than a\nnon-raw <code class=\"hljs\">priv</code>, any token that can begin a type, or a metavariable with a\n<code class=\"hljs\">ident</code>, <code class=\"hljs\">ty</code>, or <code class=\"hljs\">path</code> fragment specifier.</li>\n<li>All other fragment specifiers have no restrictions.</li>\n</ul>\n<blockquote>\n<p><strong>Edition Differences</strong>: Before the 2021 edition, <code class=\"hljs\">pat</code> may also be followed by <code class=\"hljs\">|</code>.</p>\n</blockquote>\n<p>When repetitions are involved, then the rules apply to every possible number of\nexpansions, taking separators into account. This means:</p>\n<ul>\n<li>If the repetition includes a separator, that separator must be able to\nfollow the contents of the repetition.</li>\n<li>If the repetition can repeat multiple times (<code class=\"hljs\">*</code> or <code class=\"hljs\">+</code>), then the contents\nmust be able to follow themselves.</li>\n<li>The contents of the repetition must be able to follow whatever comes\nbefore, and whatever comes after must be able to follow the contents of the\nrepetition.</li>\n<li>If the repetition can match zero times (<code class=\"hljs\">*</code> or <code class=\"hljs\">?</code>), then whatever comes\nafter must be able to follow whatever comes before.</li>\n</ul>\n<p>For more detail, see the <a href=\"macro-ambiguity.html\">formal specification</a>.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"macros.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"procedural-macros.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"macros.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"procedural-macros.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:25:51.471Z"
}