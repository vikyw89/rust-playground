{
	"title": "scope in std::thread - Rust",
	"url": "https://doc.rust-lang.org/stable/std/thread/fn.scope.html",
	"markdown": "# scope in std::thread - Rust\n\n## Function [std](../index.html)::[thread](index.html)::[scope](#)\n\n1.63.0 · [source](about:blank/src/std/thread/scoped.rs.html#135-167) ·\n\n```\npub fn scope<'env, F, T>(f: F) -> Twhere\n    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n```\n\nExpand description\n\nCreate a scope for spawning scoped threads.\n\nThe function passed to `scope` will be provided a [`Scope`](struct.Scope.html \"struct std::thread::Scope\") object, through which scoped threads can be [spawned](about:blank/struct.Scope.html#method.spawn \"method std::thread::Scope::spawn\").\n\nUnlike non-scoped threads, scoped threads can borrow non-`'static` data, as the scope guarantees all threads will be joined at the end of the scope.\n\nAll threads spawned within the scope that haven’t been manually joined will be automatically joined before this function returns.\n\n## [§](#panics)Panics\n\nIf any of the automatically joined threads panicked, this function will panic.\n\nIf you want to handle panics from spawned threads, [`join`](about:blank/struct.ScopedJoinHandle.html#method.join \"method std::thread::ScopedJoinHandle::join\") them before the end of the scope.\n\n## [§](#example)Example\n\n```\nuse std::thread;\n\nlet mut a = vec![1, 2, 3];\nlet mut x = 0;\n\nthread::scope(|s| {\n    s.spawn(|| {\n        println!(\"hello from the first scoped thread\");\n        // We can borrow `a` here.\n        dbg!(&a);\n    });\n    s.spawn(|| {\n        println!(\"hello from the second scoped thread\");\n        // We can even mutably borrow `x` here,\n        // because no other threads are using it.\n        x += a[0] + a[2];\n    });\n    println!(\"hello from the main thread\");\n});\n\n// After the scope, we can modify and access our variables again:\na.push(4);\nassert_eq!(x, a.len());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++let+mut+a+=+vec!%5B1,+2,+3%5D;%0A++++let+mut+x+=+0;%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++s.spawn(%7C%7C+%7B%0A++++++++++++println!(%22hello+from+the+first+scoped+thread%22);%0A++++++++++++//+We+can+borrow+%60a%60+here.%0A++++++++++++dbg!(%26a);%0A++++++++%7D);%0A++++++++s.spawn(%7C%7C+%7B%0A++++++++++++println!(%22hello+from+the+second+scoped+thread%22);%0A++++++++++++//+We+can+even+mutably+borrow+%60x%60+here,%0A++++++++++++//+because+no+other+threads+are+using+it.%0A++++++++++++x+%2B=+a%5B0%5D+%2B+a%5B2%5D;%0A++++++++%7D);%0A++++++++println!(%22hello+from+the+main+thread%22);%0A++++%7D);%0A++++%0A++++//+After+the+scope,+we+can+modify+and+access+our+variables+again:%0A++++a.push(4);%0A++++assert_eq!(x,+a.len());%0A%7D&edition=2021)\n\n## [§](#lifetimes)Lifetimes\n\nScoped threads involve two lifetimes: `'scope` and `'env`.\n\nThe `'scope` lifetime represents the lifetime of the scope itself. That is: the time during which new scoped threads may be spawned, and also the time during which they might still be running. Once this lifetime ends, all scoped threads are joined. This lifetime starts within the `scope` function, before `f` (the argument to `scope`) starts. It ends after `f` returns and all scoped threads have been joined, but before `scope` returns.\n\nThe `'env` lifetime represents the lifetime of whatever is borrowed by the scoped threads. This lifetime must outlast the call to `scope`, and thus cannot be smaller than `'scope`. It can be as small as the call to `scope`, meaning that anything that outlives this call, such as local variables defined right before the scope, can be borrowed by the scoped threads.\n\nThe `'env: 'scope` bound is part of the definition of the `Scope` type.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Create a scope for spawning scoped threads.\"><title>scope in std::thread - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::thread</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AccessError.html\">AccessError</a></li><li><a href=\"struct.Builder.html\">Builder</a></li><li><a href=\"struct.JoinHandle.html\">JoinHandle</a></li><li><a href=\"struct.LocalKey.html\">LocalKey</a></li><li><a href=\"struct.Scope.html\">Scope</a></li><li><a href=\"struct.ScopedJoinHandle.html\">ScopedJoinHandle</a></li><li><a href=\"struct.Thread.html\">Thread</a></li><li><a href=\"struct.ThreadId.html\">ThreadId</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.available_parallelism.html\">available_parallelism</a></li><li><a href=\"fn.current.html\">current</a></li><li><a href=\"fn.panicking.html\">panicking</a></li><li><a href=\"fn.park.html\">park</a></li><li><a href=\"fn.park_timeout.html\">park_timeout</a></li><li><a href=\"fn.park_timeout_ms.html\">park_timeout_ms</a></li><li><a href=\"fn.scope.html\">scope</a></li><li><a href=\"fn.sleep.html\">sleep</a></li><li><a href=\"fn.sleep_ms.html\">sleep_ms</a></li><li><a href=\"fn.sleep_until.html\">sleep_until</a></li><li><a href=\"fn.spawn.html\">spawn</a></li><li><a href=\"fn.yield_now.html\">yield_now</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.Result.html\">Result</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">thread</a>::<wbr><a class=\"fn\" href=\"#\">scope</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> · <a class=\"src\" href=\"../../src/std/thread/scoped.rs.html#135-167\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub fn scope&lt;'env, F, T&gt;(f: F) -&gt; T<div class=\"where\">where\n    F: for&lt;'scope&gt; <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(&amp;'scope <a class=\"struct\" href=\"struct.Scope.html\" title=\"struct std::thread::Scope\">Scope</a>&lt;'scope, 'env&gt;) -&gt; T,</div></code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Create a scope for spawning scoped threads.</p>\n<p>The function passed to <code>scope</code> will be provided a <a href=\"struct.Scope.html\" title=\"struct std::thread::Scope\"><code>Scope</code></a> object,\nthrough which scoped threads can be <a href=\"struct.Scope.html#method.spawn\" title=\"method std::thread::Scope::spawn\">spawned</a>.</p>\n<p>Unlike non-scoped threads, scoped threads can borrow non-<code>'static</code> data,\nas the scope guarantees all threads will be joined at the end of the scope.</p>\n<p>All threads spawned within the scope that haven’t been manually joined\nwill be automatically joined before this function returns.</p>\n<h2 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h2>\n<p>If any of the automatically joined threads panicked, this function will panic.</p>\n<p>If you want to handle panics from spawned threads,\n<a href=\"struct.ScopedJoinHandle.html#method.join\" title=\"method std::thread::ScopedJoinHandle::join\"><code>join</code></a> them before the end of the scope.</p>\n<h2 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = <span class=\"number\">0</span>;\n\nthread::scope(|s| {\n    s.spawn(|| {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"hello from the first scoped thread\"</span>);\n        <span class=\"comment\">// We can borrow `a` here.\n        </span><span class=\"macro\">dbg!</span>(<span class=\"kw-2\">&amp;</span>a);\n    });\n    s.spawn(|| {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"hello from the second scoped thread\"</span>);\n        <span class=\"comment\">// We can even mutably borrow `x` here,\n        // because no other threads are using it.\n        </span>x += a[<span class=\"number\">0</span>] + a[<span class=\"number\">2</span>];\n    });\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"hello from the main thread\"</span>);\n});\n\n<span class=\"comment\">// After the scope, we can modify and access our variables again:\n</span>a.push(<span class=\"number\">4</span>);\n<span class=\"macro\">assert_eq!</span>(x, a.len());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++let+mut+a+=+vec!%5B1,+2,+3%5D;%0A++++let+mut+x+=+0;%0A++++%0A++++thread::scope(%7Cs%7C+%7B%0A++++++++s.spawn(%7C%7C+%7B%0A++++++++++++println!(%22hello+from+the+first+scoped+thread%22);%0A++++++++++++//+We+can+borrow+%60a%60+here.%0A++++++++++++dbg!(%26a);%0A++++++++%7D);%0A++++++++s.spawn(%7C%7C+%7B%0A++++++++++++println!(%22hello+from+the+second+scoped+thread%22);%0A++++++++++++//+We+can+even+mutably+borrow+%60x%60+here,%0A++++++++++++//+because+no+other+threads+are+using+it.%0A++++++++++++x+%2B=+a%5B0%5D+%2B+a%5B2%5D;%0A++++++++%7D);%0A++++++++println!(%22hello+from+the+main+thread%22);%0A++++%7D);%0A++++%0A++++//+After+the+scope,+we+can+modify+and+access+our+variables+again:%0A++++a.push(4);%0A++++assert_eq!(x,+a.len());%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"lifetimes\"><a class=\"doc-anchor\" href=\"#lifetimes\">§</a>Lifetimes</h2>\n<p>Scoped threads involve two lifetimes: <code>'scope</code> and <code>'env</code>.</p>\n<p>The <code>'scope</code> lifetime represents the lifetime of the scope itself.\nThat is: the time during which new scoped threads may be spawned,\nand also the time during which they might still be running.\nOnce this lifetime ends, all scoped threads are joined.\nThis lifetime starts within the <code>scope</code> function, before <code>f</code> (the argument to <code>scope</code>) starts.\nIt ends after <code>f</code> returns and all scoped threads have been joined, but before <code>scope</code> returns.</p>\n<p>The <code>'env</code> lifetime represents the lifetime of whatever is borrowed by the scoped threads.\nThis lifetime must outlast the call to <code>scope</code>, and thus cannot be smaller than <code>'scope</code>.\nIt can be as small as the call to <code>scope</code>, meaning that anything that outlives this call,\nsuch as local variables defined right before the scope, can be borrowed by the scoped threads.</p>\n<p>The <code>'env: 'scope</code> bound is part of the definition of the <code>Scope</code> type.</p>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:20:24.870Z"
}