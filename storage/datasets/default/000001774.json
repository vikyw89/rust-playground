{
	"title": "Path and module system changes - The Rust Edition Guide",
	"url": "https://doc.rust-lang.org/stable/edition-guide/rust-2018/path-changes.html",
	"markdown": "# Path and module system changes\n\n![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)\n\n## [Summary](#summary)\n\n-   Paths in `use` declarations now work the same as other paths.\n-   Paths starting with `::` must now be followed with an external crate.\n-   Paths in `pub(in path)` visibility modifiers must now start with `crate`, `self`, or `super`.\n\n## [Motivation](#motivation)\n\nThe module system is often one of the hardest things for people new to Rust. Everyone has their own things that take time to master, of course, but there's a root cause for why it's so confusing to many: while there are simple and consistent rules defining the module system, their consequences can feel inconsistent, counterintuitive and mysterious.\n\nAs such, the 2018 edition of Rust introduces a few new module system features, but they end up _simplifying_ the module system, to make it more clear as to what is going on.\n\nHere's a brief summary:\n\n-   `extern crate` is no longer needed in 99% of circumstances.\n-   The `crate` keyword refers to the current crate.\n-   Paths may start with a crate name, even within submodules.\n-   Paths starting with `::` must reference an external crate.\n-   A `foo.rs` and `foo/` subdirectory may coexist; `mod.rs` is no longer needed when placing submodules in a subdirectory.\n-   Paths in `use` declarations work the same as other paths.\n\nThese may seem like arbitrary new rules when put this way, but the mental model is now significantly simplified overall. Read on for more details!\n\n## [More details](#more-details)\n\nLet's talk about each new feature in turn.\n\n### [No more `extern crate`](#no-more-extern-crate)\n\nThis one is quite straightforward: you no longer need to write `extern crate` to import a crate into your project. Before:\n\n```rust\n// Rust 2015\n\nextern crate futures;\n\nmod submodule {\n    use futures::Future;\n}\n```\n\nAfter:\n\n```rust\n// Rust 2018\n\nmod submodule {\n    use futures::Future;\n}\n```\n\nNow, to add a new crate to your project, you can add it to your `Cargo.toml`, and then there is no step two. If you're not using Cargo, you already had to pass `--extern` flags to give `rustc` the location of external crates, so you'd just keep doing what you were doing there as well.\n\n> One small note here: `cargo fix` will not currently automate this change. We may have it do this for you in the future.\n\n#### [An exception](#an-exception)\n\nThere's one exception to this rule, and that's the \"sysroot\" crates. These are the crates distributed with Rust itself.\n\nUsually these are only needed in very specialized situations. Starting in 1.41, `rustc` accepts the `--extern=CRATE_NAME` flag which automatically adds the given crate name in a way similar to `extern crate`. Build tools may use this to inject sysroot crates into the crate's prelude. Cargo does not have a general way to express this, though it uses it for `proc_macro` crates.\n\nSome examples of needing to explicitly import sysroot crates are:\n\n-   [`std`](../../std/index.html): Usually this is not necessary, because `std` is automatically imported unless the crate is marked with [`#![no_std]`](about:blank/reference/names/preludes.html#the-no_std-attribute).\n-   [`core`](../../core/index.html): Usually this is not necessary, because `core` is automatically imported, unless the crate is marked with [`#![no_core]`](https://github.com/rust-lang/rust/issues/29639). For example, some of the internal crates used by the standard library itself need this.\n-   [`proc_macro`](../../proc_macro/index.html): This is automatically imported by Cargo if it is a proc-macro crate starting in 1.42. `extern crate proc_macro;` would be needed if you want to support older releases, or if using another build tool that does not pass the appropriate `--extern` flags to `rustc`.\n-   [`alloc`](../../alloc/index.html): Items in the `alloc` crate are usually accessed via re-exports in the `std` crate. If you are working with a `no_std` crate that supports allocation, then you may need to explicitly import `alloc`.\n-   [`test`](../../test/index.html): This is only available on the [nightly channel](../../book/appendix-07-nightly-rust.html), and is usually only used for the unstable benchmark support.\n\n#### [Macros](#macros)\n\nOne other use for `extern crate` was to import macros; that's no longer needed. Macros may be imported with `use` like any other item. For example, the following use of `extern crate`:\n\n```rust\n#[macro_use]\nextern crate bar;\n\nfn main() {\n    baz!();\n}\n```\n\nCan be changed to something like the following:\n\n```rust\nuse bar::baz;\n\nfn main() {\n    baz!();\n}\n```\n\n#### [Renaming crates](#renaming-crates)\n\nIf you've been using `as` to rename your crate like this:\n\n```rust\nextern crate futures as f;\n\nuse f::Future;\n```\n\nthen removing the `extern crate` line on its own won't work. You'll need to do this:\n\n```rust\nuse futures as f;\n\nuse self::f::Future;\n```\n\nThis change will need to happen in any module that uses `f`.\n\n### [The `crate` keyword refers to the current crate](#the-crate-keyword-refers-to-the-current-crate)\n\nIn `use` declarations and in other code, you can refer to the root of the current crate with the `crate::` prefix. For instance, `crate::foo::bar` will always refer to the name `bar` inside the module `foo`, from anywhere else in the same crate.\n\nThe prefix `::` previously referred to either the crate root or an external crate; it now unambiguously refers to an external crate. For instance, `::foo::bar` always refers to the name `bar` inside the external crate `foo`.\n\n### [Extern crate paths](#extern-crate-paths)\n\nPreviously, using an external crate in a module without a `use` import required a leading `::` on the path.\n\n```rust\n// Rust 2015\n\nextern crate chrono;\n\nfn foo() {\n    // this works in the crate root\n    let x = chrono::Utc::now();\n}\n\nmod submodule {\n    fn function() {\n        // but in a submodule it requires a leading :: if not imported with `use`\n        let x = ::chrono::Utc::now();\n    }\n}\n```\n\nNow, extern crate names are in scope in the entire crate, including submodules.\n\n```rust\n// Rust 2018\n\nfn foo() {\n    // this works in the crate root\n    let x = chrono::Utc::now();\n}\n\nmod submodule {\n    fn function() {\n        // crates may be referenced directly, even in submodules\n        let x = chrono::Utc::now();\n    }\n}\n```\n\nIf you have a local module or item with the same name as an external crate, a path begining with that name will be taken to refer to the local module or item. To explicitly refer to the external crate, use the `::name` form.\n\n### [No more `mod.rs`](#no-more-modrs)\n\nIn Rust 2015, if you have a submodule:\n\n```rust\n// This `mod` declaration looks for the `foo` module in\n// `foo.rs` or `foo/mod.rs`.\nmod foo;\n```\n\nIt can live in `foo.rs` or `foo/mod.rs`. If it has submodules of its own, it _must_ be `foo/mod.rs`. So a `bar` submodule of `foo` would live at `foo/bar.rs`.\n\nIn Rust 2018 the restriction that a module with submodules must be named `mod.rs` is lifted. `foo.rs` can just be `foo.rs`, and the submodule is still `foo/bar.rs`. This eliminates the special name, and if you have a bunch of files open in your editor, you can clearly see their names, instead of having a bunch of tabs named `mod.rs`.\n\n| Rust 2015 | Rust 2018 |\n| --- | --- |\n| \n```\n.\nâ”œâ”€â”€ lib.rs\nâ””â”€â”€ foo/\n Â Â  â”œâ”€â”€ mod.rs\n Â Â  â””â”€â”€ bar.rs\n```\n\n | \n```\n.\nâ”œâ”€â”€ lib.rs\nâ”œâ”€â”€ foo.rs\nâ””â”€â”€ foo/\n Â Â  â””â”€â”€ bar.rs\n\n```\n\n |\n\n### [`use` paths](#use-paths)\n\n![Minimum Rust version: 1.32](https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg)\n\nRust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust 2015, paths work differently in `use` declarations than they do elsewhere. In particular, paths in `use` declarations would always start from the crate root, while paths in other code implicitly started from the current scope. Those differences didn't have any effect in the top-level module, which meant that everything would seem straightforward until working on a project large enough to have submodules.\n\nIn Rust 2018, paths in `use` declarations and in other code work the same way, both in the top-level module and in any submodule. You can use a relative path from the current scope, a path starting from an external crate name, or a path starting with `::`, `crate`, `super`, or `self`.\n\nCode that looked like this:\n\n```rust\n// Rust 2015\n\nextern crate futures;\n\nuse futures::Future;\n\nmod foo {\n    pub struct Bar;\n}\n\nuse foo::Bar;\n\nfn my_poll() -> futures::Poll { ... }\n\nenum SomeEnum {\n    V1(usize),\n    V2(String),\n}\n\nfn func() {\n    let five = std::sync::Arc::new(5);\n    use SomeEnum::*;\n    match ... {\n        V1(i) => { ... }\n        V2(s) => { ... }\n    }\n}\n```\n\nwill look exactly the same in Rust 2018, except that you can delete the `extern crate` line:\n\n```rust\n// Rust 2018\n\nuse futures::Future;\n\nmod foo {\n    pub struct Bar;\n}\n\nuse foo::Bar;\n\nfn my_poll() -> futures::Poll { ... }\n\nenum SomeEnum {\n    V1(usize),\n    V2(String),\n}\n\nfn func() {\n    let five = std::sync::Arc::new(5);\n    use SomeEnum::*;\n    match ... {\n        V1(i) => { ... }\n        V2(s) => { ... }\n    }\n}\n```\n\nThe same code will also work completely unmodified in a submodule:\n\n```rust\n// Rust 2018\n\nmod submodule {\n    use futures::Future;\n\n    mod foo {\n        pub struct Bar;\n    }\n\n    use foo::Bar;\n\n    fn my_poll() -> futures::Poll { ... }\n\n    enum SomeEnum {\n        V1(usize),\n        V2(String),\n    }\n\n    fn func() {\n        let five = std::sync::Arc::new(5);\n        use SomeEnum::*;\n        match ... {\n            V1(i) => { ... }\n            V2(s) => { ... }\n        }\n    }\n}\n```\n\nThis makes it easy to move code around in a project, and avoids introducing additional complexity to multi-module projects.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Path and module system changes - The Rust Edition Guide</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> What are editions?</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../editions/creating-a-new-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Creating a new project</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/transitioning-an-existing-project-to-a-new-edition.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Transitioning an existing project to a new edition</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/advanced-migrations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Advanced migrations</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2015/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Rust 2015</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Rust 2018</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2018/path-changes.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Path and module system changes</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/trait-fn-parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Anonymous trait function parameters deprecated</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/new-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> New keywords</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/tyvar-behind-raw-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Cargo changes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Rust 2021</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2021/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/default-cargo-resolver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Default Cargo feature resolver</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/IntoIterator-for-arrays.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> IntoIterator for arrays</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/disjoint-capture-in-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Disjoint capture in closures</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/panic-macro-consistency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Panic macro consistency</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/reserving-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.6.</strong> Reserving syntax</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/warnings-promoted-to-error.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.7.</strong> Warnings promoted to errors</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/or-patterns-macro-rules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.8.</strong> Or patterns in macro-rules</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/c-string-literals.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.9.</strong> C-string literals</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Rust 2024 ðŸš§</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2024/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/unsafe-op-in-unsafe-fn.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> unsafe_op_in_unsafe_fn warning</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/rpit-lifetime-capture.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> RPIT lifetime capture</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/static-mut-reference.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.4.</strong> Disallow references to static mut</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/public-private-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.5.</strong> Public/private dependencies</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-remove-implicit-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.6.</strong> Cargo: Remove implicit features</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-table-key-names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.7.</strong> Cargo: Table and key name consistency</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-inherited-default-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.8.</strong> Cargo: Reject unused inherited default-features</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/rustfmt-overflow-delimited-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.9.</strong> Rustfmt: Combine all delimited exprs as last argument</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/gen-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.10.</strong> gen keyword</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Edition Guide</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide/edit/master/src/rust-2018/path-changes.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"path-and-module-system-changes\"><a class=\"header\" href=\"#path-and-module-system-changes\">Path and module system changes</a></h1>\n<p><img src=\"https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg\" alt=\"Minimum Rust version: 1.31\"></p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<ul>\n<li>Paths in <code class=\"hljs\">use</code> declarations now work the same as other paths.</li>\n<li>Paths starting with <code class=\"hljs\">::</code> must now be followed with an external crate.</li>\n<li>Paths in <code class=\"hljs\">pub(in path)</code> visibility modifiers must now start with <code class=\"hljs\">crate</code>, <code class=\"hljs\">self</code>, or <code class=\"hljs\">super</code>.</li>\n</ul>\n<h2 id=\"motivation\"><a class=\"header\" href=\"#motivation\">Motivation</a></h2>\n<p>The module system is often one of the hardest things for people new to Rust. Everyone\nhas their own things that take time to master, of course, but there's a root\ncause for why it's so confusing to many: while there are simple and\nconsistent rules defining the module system, their consequences can feel\ninconsistent, counterintuitive and mysterious.</p>\n<p>As such, the 2018 edition of Rust introduces a few new module system\nfeatures, but they end up <em>simplifying</em> the module system, to make it more\nclear as to what is going on.</p>\n<p>Here's a brief summary:</p>\n<ul>\n<li><code class=\"hljs\">extern crate</code> is no longer needed in 99% of circumstances.</li>\n<li>The <code class=\"hljs\">crate</code> keyword refers to the current crate.</li>\n<li>Paths may start with a crate name, even within submodules.</li>\n<li>Paths starting with <code class=\"hljs\">::</code> must reference an external crate.</li>\n<li>A <code class=\"hljs\">foo.rs</code> and <code class=\"hljs\">foo/</code> subdirectory may coexist; <code class=\"hljs\">mod.rs</code> is no longer needed\nwhen placing submodules in a subdirectory.</li>\n<li>Paths in <code class=\"hljs\">use</code> declarations work the same as other paths.</li>\n</ul>\n<p>These may seem like arbitrary new rules when put this way, but the mental\nmodel is now significantly simplified overall. Read on for more details!</p>\n<h2 id=\"more-details\"><a class=\"header\" href=\"#more-details\">More details</a></h2>\n<p>Let's talk about each new feature in turn.</p>\n<h3 id=\"no-more-extern-crate\"><a class=\"header\" href=\"#no-more-extern-crate\">No more <code>extern crate</code></a></h3>\n<p>This one is quite straightforward: you no longer need to write <code class=\"hljs\">extern crate</code> to\nimport a crate into your project. Before:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2015</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> futures;\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-keyword\">use</span> futures::Future;\n}</code></pre>\n<p>After:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-keyword\">use</span> futures::Future;\n}</code></pre>\n<p>Now, to add a new crate to your project, you can add it to your <code class=\"hljs\">Cargo.toml</code>,\nand then there is no step two. If you're not using Cargo, you already had to pass\n<code class=\"hljs\">--extern</code> flags to give <code class=\"hljs\">rustc</code> the location of external crates, so you'd just\nkeep doing what you were doing there as well.</p>\n<blockquote>\n<p>One small note here: <code class=\"hljs\">cargo fix</code> will not currently automate this change. We may\nhave it do this for you in the future.</p>\n</blockquote>\n<h4 id=\"an-exception\"><a class=\"header\" href=\"#an-exception\">An exception</a></h4>\n<p>There's one exception to this rule, and that's the \"sysroot\" crates. These are the\ncrates distributed with Rust itself.</p>\n<p>Usually these are only needed in very specialized situations. Starting in\n1.41, <code class=\"hljs\">rustc</code> accepts the <code class=\"hljs\">--extern=CRATE_NAME</code> flag which automatically adds\nthe given crate name in a way similar to <code class=\"hljs\">extern crate</code>. Build tools may use\nthis to inject sysroot crates into the crate's prelude. Cargo does not have a\ngeneral way to express this, though it uses it for <code class=\"hljs\">proc_macro</code> crates.</p>\n<p>Some examples of needing to explicitly import sysroot crates are:</p>\n<ul>\n<li><a href=\"../../std/index.html\"><code class=\"hljs\">std</code></a>: Usually this is not necessary, because <code class=\"hljs\">std</code> is automatically\nimported unless the crate is marked with <a href=\"../../reference/names/preludes.html#the-no_std-attribute\"><code class=\"hljs\">#![no_std]</code></a>.</li>\n<li><a href=\"../../core/index.html\"><code class=\"hljs\">core</code></a>: Usually this is not necessary, because <code class=\"hljs\">core</code> is automatically\nimported, unless the crate is marked with <a href=\"https://github.com/rust-lang/rust/issues/29639\"><code class=\"hljs\">#![no_core]</code></a>. For\nexample, some of the internal crates used by the standard library itself\nneed this.</li>\n<li><a href=\"../../proc_macro/index.html\"><code class=\"hljs\">proc_macro</code></a>: This is automatically imported by Cargo if it is a\nproc-macro crate starting in 1.42. <code class=\"hljs\">extern crate proc_macro;</code> would be\nneeded if you want to support older releases, or if using another build tool\nthat does not pass the appropriate <code class=\"hljs\">--extern</code> flags to <code class=\"hljs\">rustc</code>.</li>\n<li><a href=\"../../alloc/index.html\"><code class=\"hljs\">alloc</code></a>: Items in the <code class=\"hljs\">alloc</code> crate are usually accessed via re-exports in\nthe <code class=\"hljs\">std</code> crate. If you are working with a <code class=\"hljs\">no_std</code> crate that supports\nallocation, then you may need to explicitly import <code class=\"hljs\">alloc</code>.</li>\n<li><a href=\"../../test/index.html\"><code class=\"hljs\">test</code></a>: This is only available on the <a href=\"../../book/appendix-07-nightly-rust.html\">nightly channel</a>, and is usually\nonly used for the unstable benchmark support.</li>\n</ul>\n<h4 id=\"macros\"><a class=\"header\" href=\"#macros\">Macros</a></h4>\n<p>One other use for <code class=\"hljs\">extern crate</code> was to import macros; that's no longer needed.\nMacros may be imported with <code class=\"hljs\">use</code> like any other item. For example, the\nfollowing use of <code class=\"hljs\">extern crate</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[macro_use]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> bar;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    baz!();\n}</code></pre>\n<p>Can be changed to something like the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> bar::baz;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    baz!();\n}</code></pre>\n<h4 id=\"renaming-crates\"><a class=\"header\" href=\"#renaming-crates\">Renaming crates</a></h4>\n<p>If you've been using <code class=\"hljs\">as</code> to rename your crate like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> futures <span class=\"hljs-keyword\">as</span> f;\n\n<span class=\"hljs-keyword\">use</span> f::Future;</code></pre>\n<p>then removing the <code class=\"hljs\">extern crate</code> line on its own won't work. You'll need to do this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> futures <span class=\"hljs-keyword\">as</span> f;\n\n<span class=\"hljs-keyword\">use</span> self::f::Future;</code></pre>\n<p>This change will need to happen in any module that uses <code class=\"hljs\">f</code>.</p>\n<h3 id=\"the-crate-keyword-refers-to-the-current-crate\"><a class=\"header\" href=\"#the-crate-keyword-refers-to-the-current-crate\">The <code>crate</code> keyword refers to the current crate</a></h3>\n<p>In <code class=\"hljs\">use</code> declarations and in other code, you can refer to the root of the\ncurrent crate with the <code class=\"hljs\">crate::</code> prefix. For instance, <code class=\"hljs\">crate::foo::bar</code> will\nalways refer to the name <code class=\"hljs\">bar</code> inside the module <code class=\"hljs\">foo</code>, from anywhere else in\nthe same crate.</p>\n<p>The prefix <code class=\"hljs\">::</code> previously referred to either the crate root or an external\ncrate; it now unambiguously refers to an external crate. For instance,\n<code class=\"hljs\">::foo::bar</code> always refers to the name <code class=\"hljs\">bar</code> inside the external crate <code class=\"hljs\">foo</code>.</p>\n<h3 id=\"extern-crate-paths\"><a class=\"header\" href=\"#extern-crate-paths\">Extern crate paths</a></h3>\n<p>Previously, using an external crate in a module without a <code class=\"hljs\">use</code> import\nrequired a leading <code class=\"hljs\">::</code> on the path.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2015</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> chrono;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    <span class=\"hljs-comment\">// this works in the crate root</span>\n    <span class=\"hljs-keyword\">let</span> x = chrono::Utc::now();\n}\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-comment\">// but in a submodule it requires a leading :: if not imported with `use`</span>\n        <span class=\"hljs-keyword\">let</span> x = ::chrono::Utc::now();\n    }\n}</code></pre>\n<p>Now, extern crate names are in scope in the entire crate, including\nsubmodules.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    <span class=\"hljs-comment\">// this works in the crate root</span>\n    <span class=\"hljs-keyword\">let</span> x = chrono::Utc::now();\n}\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-comment\">// crates may be referenced directly, even in submodules</span>\n        <span class=\"hljs-keyword\">let</span> x = chrono::Utc::now();\n    }\n}</code></pre>\n<p>If you have a local module or item with the same name as an external crate, a\npath begining with that name will be taken to refer to the local module or\nitem. To explicitly refer to the external crate, use the <code class=\"hljs\">::name</code> form.</p>\n<h3 id=\"no-more-modrs\"><a class=\"header\" href=\"#no-more-modrs\">No more <code>mod.rs</code></a></h3>\n<p>In Rust 2015, if you have a submodule:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// This `mod` declaration looks for the `foo` module in</span>\n<span class=\"hljs-comment\">// `foo.rs` or `foo/mod.rs`.</span>\n<span class=\"hljs-keyword\">mod</span> foo;</code></pre>\n<p>It can live in <code class=\"hljs\">foo.rs</code> or <code class=\"hljs\">foo/mod.rs</code>. If it has submodules of its own, it\n<em>must</em> be <code class=\"hljs\">foo/mod.rs</code>. So a <code class=\"hljs\">bar</code> submodule of <code class=\"hljs\">foo</code> would live at\n<code class=\"hljs\">foo/bar.rs</code>.</p>\n<p>In Rust 2018 the restriction that a module with submodules must be named\n<code class=\"hljs\">mod.rs</code> is lifted. <code class=\"hljs\">foo.rs</code> can just be <code class=\"hljs\">foo.rs</code>,\nand the submodule is still <code class=\"hljs\">foo/bar.rs</code>. This eliminates the special\nname, and if you have a bunch of files open in your editor, you can clearly\nsee their names, instead of having a bunch of tabs named <code class=\"hljs\">mod.rs</code>.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Rust 2015</th>\n      <th>Rust 2018</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n<pre>.\nâ”œâ”€â”€ lib.rs\nâ””â”€â”€ foo/\n &nbsp;&nbsp; â”œâ”€â”€ mod.rs\n &nbsp;&nbsp; â””â”€â”€ bar.rs\n</pre>\n    </td>\n    <td>\n<pre>.\nâ”œâ”€â”€ lib.rs\nâ”œâ”€â”€ foo.rs\nâ””â”€â”€ foo/\n &nbsp;&nbsp; â””â”€â”€ bar.rs\n</pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<h3 id=\"use-paths\"><a class=\"header\" href=\"#use-paths\"><code>use</code> paths</a></h3>\n<p><img src=\"https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg\" alt=\"Minimum Rust version: 1.32\"></p>\n<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust\n2015, paths work differently in <code class=\"hljs\">use</code> declarations than they do elsewhere. In\nparticular, paths in <code class=\"hljs\">use</code> declarations would always start from the crate\nroot, while paths in other code implicitly started from the current scope.\nThose differences didn't have any effect in the top-level module, which meant\nthat everything would seem straightforward until working on a project large\nenough to have submodules.</p>\n<p>In Rust 2018, paths in <code class=\"hljs\">use</code> declarations and in other code work the same way,\nboth in the top-level module and in any submodule. You can use a relative path\nfrom the current scope, a path starting from an external crate name, or a path\nstarting with <code class=\"hljs\">::</code>, <code class=\"hljs\">crate</code>, <code class=\"hljs\">super</code>, or <code class=\"hljs\">self</code>.</p>\n<p>Code that looked like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2015</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> futures;\n\n<span class=\"hljs-keyword\">use</span> futures::Future;\n\n<span class=\"hljs-keyword\">mod</span> foo {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>;\n}\n\n<span class=\"hljs-keyword\">use</span> foo::Bar;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_poll</span></span>() -&gt; futures::Poll { ... }\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">SomeEnum</span></span> {\n    V1(<span class=\"hljs-built_in\">usize</span>),\n    V2(<span class=\"hljs-built_in\">String</span>),\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">func</span></span>() {\n    <span class=\"hljs-keyword\">let</span> five = std::sync::Arc::new(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">use</span> SomeEnum::*;\n    <span class=\"hljs-keyword\">match</span> ... {\n        V1(i) =&gt; { ... }\n        V2(s) =&gt; { ... }\n    }\n}</code></pre>\n<p>will look exactly the same in Rust 2018, except that you can delete the <code class=\"hljs\">extern crate</code> line:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-keyword\">use</span> futures::Future;\n\n<span class=\"hljs-keyword\">mod</span> foo {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>;\n}\n\n<span class=\"hljs-keyword\">use</span> foo::Bar;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_poll</span></span>() -&gt; futures::Poll { ... }\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">SomeEnum</span></span> {\n    V1(<span class=\"hljs-built_in\">usize</span>),\n    V2(<span class=\"hljs-built_in\">String</span>),\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">func</span></span>() {\n    <span class=\"hljs-keyword\">let</span> five = std::sync::Arc::new(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">use</span> SomeEnum::*;\n    <span class=\"hljs-keyword\">match</span> ... {\n        V1(i) =&gt; { ... }\n        V2(s) =&gt; { ... }\n    }\n}</code></pre>\n<p>The same code will also work completely unmodified in a submodule:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-keyword\">use</span> futures::Future;\n\n    <span class=\"hljs-keyword\">mod</span> foo {\n        <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>;\n    }\n\n    <span class=\"hljs-keyword\">use</span> foo::Bar;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_poll</span></span>() -&gt; futures::Poll { ... }\n\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">SomeEnum</span></span> {\n        V1(<span class=\"hljs-built_in\">usize</span>),\n        V2(<span class=\"hljs-built_in\">String</span>),\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">func</span></span>() {\n        <span class=\"hljs-keyword\">let</span> five = std::sync::Arc::new(<span class=\"hljs-number\">5</span>);\n        <span class=\"hljs-keyword\">use</span> SomeEnum::*;\n        <span class=\"hljs-keyword\">match</span> ... {\n            V1(i) =&gt; { ... }\n            V2(s) =&gt; { ... }\n        }\n    }\n}</code></pre>\n<p>This makes it easy to move code around in a project, and avoids introducing\nadditional complexity to multi-module projects.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../rust-2018/index.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../rust-2018/trait-fn-parameters.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../rust-2018/index.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../rust-2018/trait-fn-parameters.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:30.551Z"
}