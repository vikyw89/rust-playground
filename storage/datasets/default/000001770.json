{
	"title": "Advanced migrations - The Rust Edition Guide",
	"url": "https://doc.rust-lang.org/stable/edition-guide/editions/advanced-migrations.html",
	"markdown": "# Advanced migrations - The Rust Edition Guide\n\n## [Advanced migration strategies](#advanced-migration-strategies)\n\n## [How migrations work](#how-migrations-work)\n\n[`cargo fix --edition`](../../cargo/commands/cargo-fix.html) works by running the equivalent of [`cargo check`](../../cargo/commands/cargo-check.html) on your project with special [lints](../../rustc/lints/index.html) enabled which will detect code that may not compile in the next edition. These lints include instructions on how to modify the code to make it compatible on both the current and the next edition. `cargo fix` applies these changes to the source code, and then runs `cargo check` again to verify that the fixes work. If the fixes fail, then it will back out the changes and display a warning.\n\nChanging the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code. If the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing `Cargo.toml` to use the next edition.\n\nThe lints that `cargo fix --edition` apply are part of a [lint group](../../rustc/lints/groups.html). For example, when migrating from 2018 to 2021, Cargo uses the `rust-2021-compatibility` group of lints to fix the code. Check the [Partial migration](#partial-migration-with-broken-code) section below for tips on using individual lints to help with migration.\n\n`cargo fix` may run `cargo check` multiple times. For example, after applying one set of fixes, this may trigger new warnings which require further fixes. Cargo repeats this until no new warnings are generated.\n\n## [Migrating multiple configurations](#migrating-multiple-configurations)\n\n`cargo fix` can only work with a single configuration at a time. If you use [Cargo features](../../cargo/reference/features.html) or [conditional compilation](../../reference/conditional-compilation.html), then you may need to run `cargo fix` multiple times with different flags.\n\nFor example, if you have code that uses `#[cfg]` attributes to include different code for different platforms, you may need to run `cargo fix` with the `--target` option to fix for different targets. This may require moving your code between machines if you don't have cross-compiling available.\n\nSimilarly, if you have conditions on Cargo features, like `#[cfg(feature = \"my-optional-thing\")]`, it is recommended to use the `--all-features` flag to allow `cargo fix` to migrate all the code behind those feature gates. If you want to migrate feature code individually, you can use the `--features` flag to migrate one at a time.\n\n## [Migrating a large project or workspace](#migrating-a-large-project-or-workspace)\n\nYou can migrate a large project incrementally to make the process easier if you run into problems.\n\nIn a [Cargo workspace](../../cargo/reference/workspaces.html), each package defines its own edition, so the process naturally involves migrating one package at a time.\n\nWithin a [Cargo package](about:blank/cargo/reference/manifest.html#the-package-section), you can either migrate the entire package at once, or migrate individual [Cargo targets](../../cargo/reference/cargo-targets.html) one at a time. For example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with `cargo fix --edition` to migrate just that one target. By default, `cargo fix` uses `--all-targets`.\n\nFor even more advanced cases, you can specify the edition for each individual target in `Cargo.toml` like this:\n\n```toml\n[[bin]]\nname = \"my-binary\"\nedition = \"2018\"\n\n```\n\nThis usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.\n\n## [Partial migration with broken code](#partial-migration-with-broken-code)\n\nSometimes the fixes suggested by the compiler may fail to work. When this happens, Cargo will report a warning indicating what happened and what the error was. However, by default it will automatically back out the changes it made. It can be helpful to keep the code in the broken state and manually resolve the issue. Some of the fixes may have been correct, and the broken fix may be _mostly_ correct, but just need minor tweaking.\n\nIn this situation, use the `--broken-code` option with `cargo fix` to tell Cargo not to back out the changes. Then, you can go manually inspect the error and investigate what is needed to fix it.\n\nAnother option to incrementally migrate a project is to apply individual fixes separately, one at a time. You can do this by adding the individual lints as warnings, and then either running `cargo fix` (without the `--edition` flag) or using your editor or IDE to apply its suggestions if it supports \"Quick Fixes\".\n\nFor example, the 2018 edition uses the [`keyword-idents`](about:blank/rustc/lints/listing/allowed-by-default.html#keyword-idents) lint to fix any conflicting keywords. You can add `#![warn(keyword_idents)]` to the top of each crate (like at the top of `src/lib.rs` or `src/main.rs`). Then, running `cargo fix` will apply just the suggestions for that lint.\n\nYou can see the list of lints enabled for each edition in the [lint group](../../rustc/lints/groups.html) page, or run the `rustc -Whelp` command.\n\n## [Migrating macros](#migrating-macros)\n\nSome macros may require manual work to fix them for the next edition. For example, `cargo fix --edition` may not be able to automatically fix a macro that generates syntax that does not work in the next edition.\n\nThis may be a problem for both [proc macros](../../reference/procedural-macros.html) and `macro_rules`\\-style macros. `macro_rules` macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot. Proc macros in general cannot be automatically fixed at all.\n\nFor example, if we migrate a crate containing this (contrived) macro `foo` from 2015 to 2018, `foo` would not be automatically fixed.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[macro_export]\nmacro_rules! foo {\n    () => {\n        let dyn = 1;\n        println!(\"it is {}\", dyn);\n    };\n}\n}\n```\n\nWhen this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below). In 2015, `dyn` is a normal identifier and can be used without restriction.\n\nHowever, in 2018, `dyn` is no longer a valid identifier. When using `cargo fix --edition` to migrate to 2018, Cargo won't display any warnings or errors at all. However, `foo` won't work when called from any crate.\n\nIf you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax. You may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere. If you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.\n\n### [Macro hygiene](#macro-hygiene)\n\nMacros use a system called \"edition hygiene\" where the tokens within a macro are marked with which edition they come from. This allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.\n\nLet's take a closer look at the example above that defines a `macro_rules` macro using `dyn` as an identifier. If that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where `dyn` is a keyword and that would normally be a syntax error. The `let dyn = 1;` tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded. The parser looks at the edition of the tokens to know how to interpret it.\n\nThe problem arises when changing the edition to 2018 in the crate where it is defined. Now, those tokens are tagged with the 2018 edition, and those will fail to parse. However, since we never called the macro from our crate, `cargo fix --edition` never had a chance to inspect the macro and fix it.\n\n## [Documentation tests](#documentation-tests)\n\nAt this time, `cargo fix` is not able to update [documentation tests](../../rustdoc/documentation-tests.html). After updating the edition in `Cargo.toml`, you should run `cargo test` to ensure everything still passes. If your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.\n\nIn rare cases, you can manually set the edition for each test. For example, you can use the [`edition2018` annotation](about:blank/rustdoc/documentation-tests.html#attributes) on the triple backticks to tell `rustdoc` which edition to use.\n\n## [Generated code](#generated-code)\n\nAnother area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see [Code generation](about:blank/cargo/reference/build-script-examples.html#code-generation) for an example). In this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.\n\n## [Migrating non-Cargo projects](#migrating-non-cargo-projects)\n\nIf your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition. You can enable the migration lints as described above by enabling the appropriate [lint group](../../rustc/lints/groups.html). For example, you can use the `#![warn(rust_2021_compatibility)]` attribute or the `-Wrust-2021-compatibility` or `--force-warns=rust-2021-compatibility` [CLI flag](about:blank/rustc/lints/levels.html#via-compiler-flag).\n\nThe next step is to apply those lints to your code. There are several options here:\n\n-   Manually read the warnings and apply the suggestions recommended by the compiler.\n-   Use an editor or IDE that supports automatically applying suggestions. For example, [Visual Studio Code](https://code.visualstudio.com/) with the [Rust Analyzer extension](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer) has the ability to use the \"Quick Fix\" links to automatically apply suggestions. Many other editors and IDEs have similar functionality.\n-   Write a migration tool using the [`rustfix`](https://crates.io/crates/rustfix) library. This is the library that Cargo uses internally to take the [JSON messages](../../rustc/json.html) from the compiler and modify the source code. Check the [`examples` directory](https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples) for examples of how to use the library.\n\n## [Writing idiomatic code in a new edition](#writing-idiomatic-code-in-a-new-edition)\n\nEditions are not only about new features and removing old ones. In any programming language, idioms change over time, and Rust is no exception. While old code will continue to compile, it might be written with different idioms today.\n\nFor example, in Rust 2015, external crates must be listed with `extern crate` like this:\n\n```rust\n// src/lib.rs\nextern crate rand;\n```\n\nIn Rust 2018, it is [no longer necessary](about:blank/rust-2018/path-changes.html#no-more-extern-crate) to include these items.\n\n`cargo fix` has the `--edition-idioms` option to automatically transition some of these idioms to the new syntax.\n\n> **Warning**: The current _\"idiom lints\"_ are known to have some problems. They may make incorrect suggestions which may fail to compile. The current lints are:\n> \n> -   Edition 2018:\n>     -   [`unused-extern-crates`](about:blank/rustc/lints/listing/allowed-by-default.html#unused-extern-crates)\n>     -   [`explicit-outlives-requirements`](about:blank/rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements)\n> -   Edition 2021 does not have any idiom lints.\n> \n> The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs! If you run into problems, you can try the `--broken-code` option [described above](#partial-migration-with-broken-code) to make as much progress as possible, and then resolve the remaining issues manually.\n\nWith that out of the way, we can instruct Cargo to fix our code snippet with:\n\n```console\ncargo fix --edition-idioms\n\n```\n\nAfterwards, the line with `extern crate rand;` in `src/lib.rs` will be removed.\n\nWe're now more idiomatic, and we didn't have to fix our code manually!",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Advanced migrations - The Rust Edition Guide</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> What are editions?</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../editions/creating-a-new-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Creating a new project</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/transitioning-an-existing-project-to-a-new-edition.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Transitioning an existing project to a new edition</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/advanced-migrations.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Advanced migrations</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2015/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Rust 2015</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Rust 2018</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2018/path-changes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Path and module system changes</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/trait-fn-parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Anonymous trait function parameters deprecated</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/new-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> New keywords</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/tyvar-behind-raw-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Cargo changes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Rust 2021</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2021/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/default-cargo-resolver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Default Cargo feature resolver</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/IntoIterator-for-arrays.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> IntoIterator for arrays</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/disjoint-capture-in-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Disjoint capture in closures</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/panic-macro-consistency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Panic macro consistency</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/reserving-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.6.</strong> Reserving syntax</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/warnings-promoted-to-error.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.7.</strong> Warnings promoted to errors</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/or-patterns-macro-rules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.8.</strong> Or patterns in macro-rules</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/c-string-literals.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.9.</strong> C-string literals</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Rust 2024 ðŸš§</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2024/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/unsafe-op-in-unsafe-fn.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> unsafe_op_in_unsafe_fn warning</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/rpit-lifetime-capture.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> RPIT lifetime capture</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/static-mut-reference.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.4.</strong> Disallow references to static mut</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/public-private-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.5.</strong> Public/private dependencies</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-remove-implicit-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.6.</strong> Cargo: Remove implicit features</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-table-key-names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.7.</strong> Cargo: Table and key name consistency</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-inherited-default-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.8.</strong> Cargo: Reject unused inherited default-features</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/rustfmt-overflow-delimited-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.9.</strong> Rustfmt: Combine all delimited exprs as last argument</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/gen-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.10.</strong> gen keyword</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Edition Guide</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide/edit/master/src/editions/advanced-migrations.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"advanced-migration-strategies\"><a class=\"header\" href=\"#advanced-migration-strategies\">Advanced migration strategies</a></h1>\n<h2 id=\"how-migrations-work\"><a class=\"header\" href=\"#how-migrations-work\">How migrations work</a></h2>\n<p><a href=\"../../cargo/commands/cargo-fix.html\"><code class=\"hljs\">cargo fix --edition</code></a> works by running the equivalent of <a href=\"../../cargo/commands/cargo-check.html\"><code class=\"hljs\">cargo check</code></a> on your project with special <a href=\"../../rustc/lints/index.html\">lints</a> enabled which will detect code that may not compile in the next edition.\nThese lints include instructions on how to modify the code to make it compatible on both the current and the next edition.\n<code class=\"hljs\">cargo fix</code> applies these changes to the source code, and then runs <code class=\"hljs\">cargo check</code> again to verify that the fixes work.\nIf the fixes fail, then it will back out the changes and display a warning.</p>\n<p>Changing the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code.\nIf the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing <code class=\"hljs\">Cargo.toml</code> to use the next edition.</p>\n<p>The lints that <code class=\"hljs\">cargo fix --edition</code> apply are part of a <a href=\"../../rustc/lints/groups.html\">lint group</a>.\nFor example, when migrating from 2018 to 2021, Cargo uses the <code class=\"hljs\">rust-2021-compatibility</code> group of lints to fix the code.\nCheck the <a href=\"#partial-migration-with-broken-code\">Partial migration</a> section below for tips on using individual lints to help with migration.</p>\n<p><code class=\"hljs\">cargo fix</code> may run <code class=\"hljs\">cargo check</code> multiple times.\nFor example, after applying one set of fixes, this may trigger new warnings which require further fixes.\nCargo repeats this until no new warnings are generated.</p>\n<h2 id=\"migrating-multiple-configurations\"><a class=\"header\" href=\"#migrating-multiple-configurations\">Migrating multiple configurations</a></h2>\n<p><code class=\"hljs\">cargo fix</code> can only work with a single configuration at a time.\nIf you use <a href=\"../../cargo/reference/features.html\">Cargo features</a> or <a href=\"../../reference/conditional-compilation.html\">conditional compilation</a>, then you may need to run <code class=\"hljs\">cargo fix</code> multiple times with different flags.</p>\n<p>For example, if you have code that uses <code class=\"hljs\">#[cfg]</code> attributes to include different code for different platforms, you may need to run <code class=\"hljs\">cargo fix</code> with the <code class=\"hljs\">--target</code> option to fix for different targets.\nThis may require moving your code between machines if you don't have cross-compiling available.</p>\n<p>Similarly, if you have conditions on Cargo features, like <code class=\"hljs\">#[cfg(feature = \"my-optional-thing\")]</code>, it is recommended to use the <code class=\"hljs\">--all-features</code> flag to allow <code class=\"hljs\">cargo fix</code> to migrate all the code behind those feature gates.\nIf you want to migrate feature code individually, you can use the <code class=\"hljs\">--features</code> flag to migrate one at a time.</p>\n<h2 id=\"migrating-a-large-project-or-workspace\"><a class=\"header\" href=\"#migrating-a-large-project-or-workspace\">Migrating a large project or workspace</a></h2>\n<p>You can migrate a large project incrementally to make the process easier if you run into problems.</p>\n<p>In a <a href=\"../../cargo/reference/workspaces.html\">Cargo workspace</a>, each package defines its own edition, so the process naturally involves migrating one package at a time.</p>\n<p>Within a <a href=\"../../cargo/reference/manifest.html#the-package-section\">Cargo package</a>, you can either migrate the entire package at once, or migrate individual <a href=\"../../cargo/reference/cargo-targets.html\">Cargo targets</a> one at a time.\nFor example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with <code class=\"hljs\">cargo fix --edition</code> to migrate just that one target.\nBy default, <code class=\"hljs\">cargo fix</code> uses <code class=\"hljs\">--all-targets</code>.</p>\n<p>For even more advanced cases, you can specify the edition for each individual target in <code class=\"hljs\">Cargo.toml</code> like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[[bin]]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"my-binary\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2018\"</span>\n</code></pre>\n<p>This usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.</p>\n<h2 id=\"partial-migration-with-broken-code\"><a class=\"header\" href=\"#partial-migration-with-broken-code\">Partial migration with broken code</a></h2>\n<p>Sometimes the fixes suggested by the compiler may fail to work.\nWhen this happens, Cargo will report a warning indicating what happened and what the error was.\nHowever, by default it will automatically back out the changes it made.\nIt can be helpful to keep the code in the broken state and manually resolve the issue.\nSome of the fixes may have been correct, and the broken fix may be <em>mostly</em> correct, but just need minor tweaking.</p>\n<p>In this situation, use the <code class=\"hljs\">--broken-code</code> option with <code class=\"hljs\">cargo fix</code> to tell Cargo not to back out the changes.\nThen, you can go manually inspect the error and investigate what is needed to fix it.</p>\n<p>Another option to incrementally migrate a project is to apply individual fixes separately, one at a time.\nYou can do this by adding the individual lints as warnings, and then either running <code class=\"hljs\">cargo fix</code> (without the <code class=\"hljs\">--edition</code> flag) or using your editor or IDE to apply its suggestions if it supports \"Quick Fixes\".</p>\n<p>For example, the 2018 edition uses the <a href=\"../../rustc/lints/listing/allowed-by-default.html#keyword-idents\"><code class=\"hljs\">keyword-idents</code></a> lint to fix any conflicting keywords.\nYou can add <code class=\"hljs\">#![warn(keyword_idents)]</code> to the top of each crate (like at the top of <code class=\"hljs\">src/lib.rs</code> or <code class=\"hljs\">src/main.rs</code>).\nThen, running <code class=\"hljs\">cargo fix</code> will apply just the suggestions for that lint.</p>\n<p>You can see the list of lints enabled for each edition in the <a href=\"../../rustc/lints/groups.html\">lint group</a> page, or run the <code class=\"hljs\">rustc -Whelp</code> command.</p>\n<h2 id=\"migrating-macros\"><a class=\"header\" href=\"#migrating-macros\">Migrating macros</a></h2>\n<p>Some macros may require manual work to fix them for the next edition.\nFor example, <code class=\"hljs\">cargo fix --edition</code> may not be able to automatically fix a macro that generates syntax that does not work in the next edition.</p>\n<p>This may be a problem for both <a href=\"../../reference/procedural-macros.html\">proc macros</a> and <code class=\"hljs\">macro_rules</code>-style macros.\n<code class=\"hljs\">macro_rules</code> macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot.\nProc macros in general cannot be automatically fixed at all.</p>\n<p>For example, if we migrate a crate containing this (contrived) macro <code class=\"hljs\">foo</code> from 2015 to 2018, <code class=\"hljs\">foo</code> would not be automatically fixed.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> foo {\n    () =&gt; {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">dyn</span> = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"it is {}\"</span>, <span class=\"hljs-keyword\">dyn</span>);\n    };\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>When this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below).\nIn 2015, <code class=\"hljs\">dyn</code> is a normal identifier and can be used without restriction.</p>\n<p>However, in 2018, <code class=\"hljs\">dyn</code> is no longer a valid identifier.\nWhen using <code class=\"hljs\">cargo fix --edition</code> to migrate to 2018, Cargo won't display any warnings or errors at all.\nHowever, <code class=\"hljs\">foo</code> won't work when called from any crate.</p>\n<p>If you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax.\nYou may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere.\nIf you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.</p>\n<h3 id=\"macro-hygiene\"><a class=\"header\" href=\"#macro-hygiene\">Macro hygiene</a></h3>\n<p>Macros use a system called \"edition hygiene\" where the tokens within a macro are marked with which edition they come from.\nThis allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.</p>\n<p>Let's take a closer look at the example above that defines a <code class=\"hljs\">macro_rules</code> macro using <code class=\"hljs\">dyn</code> as an identifier.\nIf that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where <code class=\"hljs\">dyn</code> is a keyword and that would normally be a syntax error.\nThe <code class=\"hljs\">let dyn = 1;</code> tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded.\nThe parser looks at the edition of the tokens to know how to interpret it.</p>\n<p>The problem arises when changing the edition to 2018 in the crate where it is defined.\nNow, those tokens are tagged with the 2018 edition, and those will fail to parse.\nHowever, since we never called the macro from our crate, <code class=\"hljs\">cargo fix --edition</code> never had a chance to inspect the macro and fix it.</p>\n<!-- TODO: hopefully someday, the reference will have chapters on how expansion works, and this can link there for actual details. -->\n<h2 id=\"documentation-tests\"><a class=\"header\" href=\"#documentation-tests\">Documentation tests</a></h2>\n<p>At this time, <code class=\"hljs\">cargo fix</code> is not able to update <a href=\"../../rustdoc/documentation-tests.html\">documentation tests</a>.\nAfter updating the edition in <code class=\"hljs\">Cargo.toml</code>, you should run <code class=\"hljs\">cargo test</code> to ensure everything still passes.\nIf your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.</p>\n<p>In rare cases, you can manually set the edition for each test.\nFor example, you can use the <a href=\"../../rustdoc/documentation-tests.html#attributes\"><code class=\"hljs\">edition2018</code> annotation</a> on the triple backticks to tell <code class=\"hljs\">rustdoc</code> which edition to use.</p>\n<h2 id=\"generated-code\"><a class=\"header\" href=\"#generated-code\">Generated code</a></h2>\n<p>Another area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see <a href=\"../../cargo/reference/build-script-examples.html#code-generation\">Code generation</a> for an example).\nIn this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.</p>\n<h2 id=\"migrating-non-cargo-projects\"><a class=\"header\" href=\"#migrating-non-cargo-projects\">Migrating non-Cargo projects</a></h2>\n<p>If your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition.\nYou can enable the migration lints as described above by enabling the appropriate <a href=\"../../rustc/lints/groups.html\">lint group</a>.\nFor example, you can use the <code class=\"hljs\">#![warn(rust_2021_compatibility)]</code> attribute or the <code class=\"hljs\">-Wrust-2021-compatibility</code> or <code class=\"hljs\">--force-warns=rust-2021-compatibility</code> <a href=\"../../rustc/lints/levels.html#via-compiler-flag\">CLI flag</a>.</p>\n<p>The next step is to apply those lints to your code.\nThere are several options here:</p>\n<ul>\n<li>Manually read the warnings and apply the suggestions recommended by the compiler.</li>\n<li>Use an editor or IDE that supports automatically applying suggestions.\nFor example, <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a> with the <a href=\"https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer\">Rust Analyzer extension</a> has the ability to use the \"Quick Fix\" links to automatically apply suggestions.\nMany other editors and IDEs have similar functionality.</li>\n<li>Write a migration tool using the <a href=\"https://crates.io/crates/rustfix\"><code class=\"hljs\">rustfix</code></a> library.\nThis is the library that Cargo uses internally to take the <a href=\"../../rustc/json.html\">JSON messages</a> from the compiler and modify the source code.\nCheck the <a href=\"https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples\"><code class=\"hljs\">examples</code> directory</a> for examples of how to use the library.</li>\n</ul>\n<h2 id=\"writing-idiomatic-code-in-a-new-edition\"><a class=\"header\" href=\"#writing-idiomatic-code-in-a-new-edition\">Writing idiomatic code in a new edition</a></h2>\n<p>Editions are not only about new features and removing old ones.\nIn any programming language, idioms change over time, and Rust is no exception.\nWhile old code will continue to compile, it might be written with different idioms today.</p>\n<p>For example, in Rust 2015, external crates must be listed with <code class=\"hljs\">extern crate</code> like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// src/lib.rs</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> rand;</code></pre>\n<p>In Rust 2018, it is <a href=\"../rust-2018/path-changes.html#no-more-extern-crate\">no longer necessary</a> to include these items.</p>\n<p><code class=\"hljs\">cargo fix</code> has the <code class=\"hljs\">--edition-idioms</code> option to automatically transition some of these idioms to the new syntax.</p>\n<blockquote>\n<p><strong>Warning</strong>: The current <em>\"idiom lints\"</em> are known to have some problems.\nThey may make incorrect suggestions which may fail to compile.\nThe current lints are:</p>\n<ul>\n<li>Edition 2018:\n<ul>\n<li><a href=\"../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates\"><code class=\"hljs\">unused-extern-crates</code></a></li>\n<li><a href=\"../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements\"><code class=\"hljs\">explicit-outlives-requirements</code></a></li>\n</ul>\n</li>\n<li>Edition 2021 does not have any idiom lints.</li>\n</ul>\n<p>The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs!\nIf you run into problems, you can try the <code class=\"hljs\">--broken-code</code> option <a href=\"#partial-migration-with-broken-code\">described above</a> to make as much progress as possible, and then resolve the remaining issues manually.</p>\n</blockquote>\n<p>With that out of the way, we can instruct Cargo to fix our code snippet with:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\">cargo fix --edition-idioms\n</code></pre>\n<p>Afterwards, the line with <code class=\"hljs\">extern crate rand;</code> in <code class=\"hljs\">src/lib.rs</code> will be removed.</p>\n<p>We're now more idiomatic, and we didn't have to fix our code manually!</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../editions/transitioning-an-existing-project-to-a-new-edition.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../rust-2015/index.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../editions/transitioning-an-existing-project-to-a-new-edition.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../rust-2015/index.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:30.378Z"
}