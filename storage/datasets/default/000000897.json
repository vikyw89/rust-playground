{
	"title": "Exception Safety - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/exception-safety.html",
	"markdown": "# Exception Safety - The Rustonomicon\n\nAlthough programs should use unwinding sparingly, there's a lot of code that _can_ panic. If you unwrap a None, index out of bounds, or divide by 0, your program will panic. On debug builds, every arithmetic operation can panic if it overflows. Unless you are very careful and tightly control what code runs, pretty much everything can unwind, and you need to be ready for it.\n\nBeing ready for unwinding is often referred to as _exception safety_ in the broader programming world. In Rust, there are two levels of exception safety that one may concern themselves with:\n\n-   In unsafe code, we _must_ be exception safe to the point of not violating memory safety. We'll call this _minimal_ exception safety.\n    \n-   In safe code, it is _good_ to be exception safe to the point of your program doing the right thing. We'll call this _maximal_ exception safety.\n    \n\nAs is the case in many places in Rust, Unsafe code must be ready to deal with bad Safe code when it comes to unwinding. Code that transiently creates unsound states must be careful that a panic does not cause that state to be used. Generally this means ensuring that only non-panicking code is run while these states exist, or making a guard that cleans up the state in the case of a panic. This does not necessarily mean that the state a panic witnesses is a fully coherent state. We need only guarantee that it's a _safe_ state.\n\nMost Unsafe code is leaf-like, and therefore fairly easy to make exception-safe. It controls all the code that runs, and most of that code can't panic. However it is not uncommon for Unsafe code to work with arrays of temporarily uninitialized data while repeatedly invoking caller-provided code. Such code needs to be careful and consider exception safety.\n\n## [Vec::push\\_all](#vecpush_all)\n\n`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably efficient without specialization. Here's a simple implementation:\n\n```rust\nimpl<T: Clone> Vec<T> {\n    fn push_all(&mut self, to_push: &[T]) {\n        self.reserve(to_push.len());\n        unsafe {\n            // can't overflow because we just reserved this\n            self.set_len(self.len() + to_push.len());\n\n            for (i, x) in to_push.iter().enumerate() {\n                self.ptr().add(i).write(x.clone());\n            }\n        }\n    }\n}\n```\n\nWe bypass `push` in order to avoid redundant capacity and `len` checks on the Vec that we definitely know has capacity. The logic is totally correct, except there's a subtle problem with our code: it's not exception-safe! `set_len`, `add`, and `write` are all fine; `clone` is the panic bomb we over-looked.\n\nClone is completely out of our control, and is totally free to panic. If it does, our function will exit early with the length of the Vec set too large. If the Vec is looked at or dropped, uninitialized memory will be read!\n\nThe fix in this case is fairly simple. If we want to guarantee that the values we _did_ clone are dropped, we can set the `len` every loop iteration. If we just want to guarantee that uninitialized memory can't be observed, we can set the `len` after the loop.\n\n## [BinaryHeap::sift\\_up](#binaryheapsift_up)\n\nBubbling an element up a heap is a bit more complicated than extending a Vec. The pseudocode is as follows:\n\n```text\nbubble_up(heap, index):\n    while index != 0 && heap[index] < heap[parent(index)]:\n        heap.swap(index, parent(index))\n        index = parent(index)\n\n```\n\nA literal transcription of this code to Rust is totally fine, but has an annoying performance characteristic: the `self` element is swapped over and over again uselessly. We would rather have the following:\n\n```text\nbubble_up(heap, index):\n    let elem = heap[index]\n    while index != 0 && elem < heap[parent(index)]:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem\n\n```\n\nThis code ensures that each element is copied as little as possible (it is in fact necessary that elem be copied twice in general). However it now exposes some exception safety trouble! At all times, there exists two copies of one value. If we panic in this function something will be double-dropped. Unfortunately, we also don't have full control of the code: that comparison is user-defined!\n\nUnlike Vec, the fix isn't as easy here. One option is to break the user-defined code and the unsafe code into two separate phases:\n\n```text\nbubble_up(heap, index):\n    let end_index = index;\n    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:\n        end_index = parent(end_index)\n\n    let elem = heap[index]\n    while index != end_index:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem\n\n```\n\nIf the user-defined code blows up, that's no problem anymore, because we haven't actually touched the state of the heap yet. Once we do start messing with the heap, we're working with only data and functions that we trust, so there's no concern of panics.\n\nPerhaps you're not happy with this design. Surely it's cheating! And we have to do the complex heap traversal _twice_! Alright, let's bite the bullet. Let's intermix untrusted and unsafe code _for reals_.\n\nIf Rust had `try` and `finally` like in Java, we could do the following:\n\n```text\nbubble_up(heap, index):\n    let elem = heap[index]\n    try:\n        while index != 0 && elem < heap[parent(index)]:\n            heap[index] = heap[parent(index)]\n            index = parent(index)\n    finally:\n        heap[index] = elem\n\n```\n\nThe basic idea is simple: if the comparison panics, we just toss the loose element in the logically uninitialized index and bail out. Anyone who observes the heap will see a potentially _inconsistent_ heap, but at least it won't cause any double-drops! If the algorithm terminates normally, then this operation happens to coincide precisely with how we finish up regardless.\n\nSadly, Rust has no such construct, so we're going to need to roll our own! The way to do this is to store the algorithm's state in a separate struct with a destructor for the \"finally\" logic. Whether we panic or not, that destructor will run and clean up after us.\n\n```rust\nstruct Hole<'a, T: 'a> {\n    data: &'a mut [T],\n    /// `elt` is always `Some` from new until drop.\n    elt: Option<T>,\n    pos: usize,\n}\n\nimpl<'a, T> Hole<'a, T> {\n    fn new(data: &'a mut [T], pos: usize) -> Self {\n        unsafe {\n            let elt = ptr::read(&data[pos]);\n            Hole {\n                data,\n                elt: Some(elt),\n                pos,\n            }\n        }\n    }\n\n    fn pos(&self) -> usize { self.pos }\n\n    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n\n    fn get(&self, index: usize) -> &T { &self.data[index] }\n\n    unsafe fn move_to(&mut self, index: usize) {\n        let index_ptr: *const _ = &self.data[index];\n        let hole_ptr = &mut self.data[self.pos];\n        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n        self.pos = index;\n    }\n}\n\nimpl<'a, T> Drop for Hole<'a, T> {\n    fn drop(&mut self) {\n        // fill the hole again\n        unsafe {\n            let pos = self.pos;\n            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n        }\n    }\n}\n\nimpl<T: Ord> BinaryHeap<T> {\n    fn sift_up(&mut self, pos: usize) {\n        unsafe {\n            // Take out the value at `pos` and create a hole.\n            let mut hole = Hole::new(&mut self.data, pos);\n\n            while hole.pos() != 0 {\n                let parent = parent(hole.pos());\n                if hole.removed() <= hole.get(parent) { break }\n                hole.move_to(parent);\n            }\n            // Hole will be unconditionally filled here; panic or not!\n        }\n    }\n}\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Exception Safety - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"exception-safety\"><a class=\"header\" href=\"#exception-safety\">Exception Safety</a></h1>\n<p>Although programs should use unwinding sparingly, there's a lot of code that\n<em>can</em> panic. If you unwrap a None, index out of bounds, or divide by 0, your\nprogram will panic. On debug builds, every arithmetic operation can panic\nif it overflows. Unless you are very careful and tightly control what code runs,\npretty much everything can unwind, and you need to be ready for it.</p>\n<p>Being ready for unwinding is often referred to as <em>exception safety</em>\nin the broader programming world. In Rust, there are two levels of exception\nsafety that one may concern themselves with:</p>\n<ul>\n<li>\n<p>In unsafe code, we <em>must</em> be exception safe to the point of not violating\nmemory safety. We'll call this <em>minimal</em> exception safety.</p>\n</li>\n<li>\n<p>In safe code, it is <em>good</em> to be exception safe to the point of your program\ndoing the right thing. We'll call this <em>maximal</em> exception safety.</p>\n</li>\n</ul>\n<p>As is the case in many places in Rust, Unsafe code must be ready to deal with\nbad Safe code when it comes to unwinding. Code that transiently creates\nunsound states must be careful that a panic does not cause that state to be\nused. Generally this means ensuring that only non-panicking code is run while\nthese states exist, or making a guard that cleans up the state in the case of\na panic. This does not necessarily mean that the state a panic witnesses is a\nfully coherent state. We need only guarantee that it's a <em>safe</em> state.</p>\n<p>Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\nIt controls all the code that runs, and most of that code can't panic. However\nit is not uncommon for Unsafe code to work with arrays of temporarily\nuninitialized data while repeatedly invoking caller-provided code. Such code\nneeds to be careful and consider exception safety.</p>\n<h2 id=\"vecpush_all\"><a class=\"header\" href=\"#vecpush_all\">Vec::push_all</a></h2>\n<p><code class=\"hljs\">Vec::push_all</code> is a temporary hack to get extending a Vec by a slice reliably\nefficient without specialization. Here's a simple implementation:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Clone</span>&gt; <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">push_all</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, to_push: &amp;[T]) {\n        <span class=\"hljs-keyword\">self</span>.reserve(to_push.len());\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// can't overflow because we just reserved this</span>\n            <span class=\"hljs-keyword\">self</span>.set_len(<span class=\"hljs-keyword\">self</span>.len() + to_push.len());\n\n            <span class=\"hljs-keyword\">for</span> (i, x) <span class=\"hljs-keyword\">in</span> to_push.iter().enumerate() {\n                <span class=\"hljs-keyword\">self</span>.ptr().add(i).write(x.clone());\n            }\n        }\n    }\n}</code></pre>\n<p>We bypass <code class=\"hljs\">push</code> in order to avoid redundant capacity and <code class=\"hljs\">len</code> checks on the\nVec that we definitely know has capacity. The logic is totally correct, except\nthere's a subtle problem with our code: it's not exception-safe! <code class=\"hljs\">set_len</code>,\n<code class=\"hljs\">add</code>, and <code class=\"hljs\">write</code> are all fine; <code class=\"hljs\">clone</code> is the panic bomb we over-looked.</p>\n<p>Clone is completely out of our control, and is totally free to panic. If it\ndoes, our function will exit early with the length of the Vec set too large. If\nthe Vec is looked at or dropped, uninitialized memory will be read!</p>\n<p>The fix in this case is fairly simple. If we want to guarantee that the values\nwe <em>did</em> clone are dropped, we can set the <code class=\"hljs\">len</code> every loop iteration. If we\njust want to guarantee that uninitialized memory can't be observed, we can set\nthe <code class=\"hljs\">len</code> after the loop.</p>\n<h2 id=\"binaryheapsift_up\"><a class=\"header\" href=\"#binaryheapsift_up\">BinaryHeap::sift_up</a></h2>\n<p>Bubbling an element up a heap is a bit more complicated than extending a Vec.\nThe pseudocode is as follows:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">bubble_up(heap, index):\n    while index != 0 &amp;&amp; heap[index] &lt; heap[parent(index)]:\n        heap.swap(index, parent(index))\n        index = parent(index)\n</code></pre>\n<p>A literal transcription of this code to Rust is totally fine, but has an annoying\nperformance characteristic: the <code class=\"hljs\">self</code> element is swapped over and over again\nuselessly. We would rather have the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">bubble_up(heap, index):\n    let elem = heap[index]\n    while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem\n</code></pre>\n<p>This code ensures that each element is copied as little as possible (it is in\nfact necessary that elem be copied twice in general). However it now exposes\nsome exception safety trouble! At all times, there exists two copies of one\nvalue. If we panic in this function something will be double-dropped.\nUnfortunately, we also don't have full control of the code: that comparison is\nuser-defined!</p>\n<p>Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\ncode and the unsafe code into two separate phases:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">bubble_up(heap, index):\n    let end_index = index;\n    while end_index != 0 &amp;&amp; heap[end_index] &lt; heap[parent(end_index)]:\n        end_index = parent(end_index)\n\n    let elem = heap[index]\n    while index != end_index:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem\n</code></pre>\n<p>If the user-defined code blows up, that's no problem anymore, because we haven't\nactually touched the state of the heap yet. Once we do start messing with the\nheap, we're working with only data and functions that we trust, so there's no\nconcern of panics.</p>\n<p>Perhaps you're not happy with this design. Surely it's cheating! And we have\nto do the complex heap traversal <em>twice</em>! Alright, let's bite the bullet. Let's\nintermix untrusted and unsafe code <em>for reals</em>.</p>\n<p>If Rust had <code class=\"hljs\">try</code> and <code class=\"hljs\">finally</code> like in Java, we could do the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">bubble_up(heap, index):\n    let elem = heap[index]\n    try:\n &nbsp; &nbsp; &nbsp; &nbsp;while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:\n            heap[index] = heap[parent(index)]\n            index = parent(index)\n    finally:\n        heap[index] = elem\n</code></pre>\n<p>The basic idea is simple: if the comparison panics, we just toss the loose\nelement in the logically uninitialized index and bail out. Anyone who observes\nthe heap will see a potentially <em>inconsistent</em> heap, but at least it won't\ncause any double-drops! If the algorithm terminates normally, then this\noperation happens to coincide precisely with how we finish up regardless.</p>\n<p>Sadly, Rust has no such construct, so we're going to need to roll our own! The\nway to do this is to store the algorithm's state in a separate struct with a\ndestructor for the \"finally\" logic. Whether we panic or not, that destructor\nwill run and clean up after us.</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Hole</span></span>&lt;<span class=\"hljs-symbol\">'a</span>, T: <span class=\"hljs-symbol\">'a</span>&gt; {\n    data: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-keyword\">mut</span> [T],\n    <span class=\"hljs-comment\">/// `elt` is always `Some` from new until drop.</span>\n    elt: <span class=\"hljs-built_in\">Option</span>&lt;T&gt;,\n    pos: <span class=\"hljs-built_in\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; Hole&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(data: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-keyword\">mut</span> [T], pos: <span class=\"hljs-built_in\">usize</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-keyword\">let</span> elt = ptr::read(&amp;data[pos]);\n            Hole {\n                data,\n                elt: <span class=\"hljs-literal\">Some</span>(elt),\n                pos,\n            }\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">pos</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">usize</span> { <span class=\"hljs-keyword\">self</span>.pos }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">removed</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;T { <span class=\"hljs-keyword\">self</span>.elt.as_ref().unwrap() }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, index: <span class=\"hljs-built_in\">usize</span>) -&gt; &amp;T { &amp;<span class=\"hljs-keyword\">self</span>.data[index] }\n\n    <span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">move_to</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, index: <span class=\"hljs-built_in\">usize</span>) {\n        <span class=\"hljs-keyword\">let</span> index_ptr: *<span class=\"hljs-keyword\">const</span> _ = &amp;<span class=\"hljs-keyword\">self</span>.data[index];\n        <span class=\"hljs-keyword\">let</span> hole_ptr = &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.data[<span class=\"hljs-keyword\">self</span>.pos];\n        ptr::copy_nonoverlapping(index_ptr, hole_ptr, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">self</span>.pos = index;\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Hole&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// fill the hole again</span>\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-keyword\">let</span> pos = <span class=\"hljs-keyword\">self</span>.pos;\n            ptr::write(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.data[pos], <span class=\"hljs-keyword\">self</span>.elt.take().unwrap());\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Ord</span>&gt; BinaryHeap&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">sift_up</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, pos: <span class=\"hljs-built_in\">usize</span>) {\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-comment\">// Take out the value at `pos` and create a hole.</span>\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> hole = Hole::new(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.data, pos);\n\n            <span class=\"hljs-keyword\">while</span> hole.pos() != <span class=\"hljs-number\">0</span> {\n                <span class=\"hljs-keyword\">let</span> parent = parent(hole.pos());\n                <span class=\"hljs-keyword\">if</span> hole.removed() &lt;= hole.get(parent) { <span class=\"hljs-keyword\">break</span> }\n                hole.move_to(parent);\n            }\n            <span class=\"hljs-comment\">// Hole will be unconditionally filled here; panic or not!</span>\n        }\n    }\n}</code></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"unwinding.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"poisoning.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"unwinding.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"poisoning.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:08.627Z"
}