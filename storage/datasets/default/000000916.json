{
	"title": "Final Code - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/vec/vec-final.html",
	"markdown": "# Final Code - The Rustonomicon\n\n```rust\nuse std::alloc::{self, Layout};\nuse std::marker::PhantomData;\nuse std::mem;\nuse std::ops::{Deref, DerefMut};\nuse std::ptr::{self, NonNull};\n\nstruct RawVec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n}\n\nunsafe impl<T: Send> Send for RawVec<T> {}\nunsafe impl<T: Sync> Sync for RawVec<T> {}\n\nimpl<T> RawVec<T> {\n    fn new() -> Self {\n        // !0 is usize::MAX. This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n\n        // `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }\n\n    fn grow(&mut self) {\n        // since we set the capacity to usize::MAX when T has size 0,\n        // getting to here necessarily means the Vec is overfull.\n        assert!(mem::size_of::<T>() != 0, \"capacity overflow\");\n\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1).unwrap())\n        } else {\n            // This can't overflow because we ensure self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n\n            // `Layout::array` checks that the number of bytes is <= usize::MAX,\n            // but this is redundant since old_layout.size() <= isize::MAX,\n            // so the `unwrap` should never fail.\n            let new_layout = Layout::array::<T>(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        // Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(\n            new_layout.size() <= isize::MAX as usize,\n            \"Allocation too large\"\n        );\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}\n\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        let elem_size = mem::size_of::<T>();\n\n        if self.cap != 0 && elem_size != 0 {\n            unsafe {\n                alloc::dealloc(\n                    self.ptr.as_ptr() as *mut u8,\n                    Layout::array::<T>(self.cap).unwrap(),\n                );\n            }\n        }\n    }\n}\n\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n\nimpl<T> Vec<T> {\n    fn ptr(&self) -> *mut T {\n        self.buf.ptr.as_ptr()\n    }\n\n    fn cap(&self) -> usize {\n        self.buf.cap\n    }\n\n    pub fn new() -> Self {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n    pub fn push(&mut self, elem: T) {\n        if self.len == self.cap() {\n            self.buf.grow();\n        }\n\n        unsafe {\n            ptr::write(self.ptr().add(self.len), elem);\n        }\n\n        // Can't overflow, we'll OOM first.\n        self.len += 1;\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            self.len -= 1;\n            unsafe { Some(ptr::read(self.ptr().add(self.len))) }\n        }\n    }\n\n    pub fn insert(&mut self, index: usize, elem: T) {\n        assert!(index <= self.len, \"index out of bounds\");\n        if self.len == self.cap() {\n            self.buf.grow();\n        }\n\n        unsafe {\n            ptr::copy(\n                self.ptr().add(index),\n                self.ptr().add(index + 1),\n                self.len - index,\n            );\n            ptr::write(self.ptr().add(index), elem);\n        }\n\n        self.len += 1;\n    }\n\n    pub fn remove(&mut self, index: usize) -> T {\n        assert!(index < self.len, \"index out of bounds\");\n\n        self.len -= 1;\n\n        unsafe {\n            let result = ptr::read(self.ptr().add(index));\n            ptr::copy(\n                self.ptr().add(index + 1),\n                self.ptr().add(index),\n                self.len - index,\n            );\n            result\n        }\n    }\n\n    pub fn drain(&mut self) -> Drain<T> {\n        let iter = unsafe { RawValIter::new(&self) };\n\n        // this is a mem::forget safety thing. If Drain is forgotten, we just\n        // leak the whole Vec's contents. Also we need to do this *eventually*\n        // anyway, so why not do it now?\n        self.len = 0;\n\n        Drain {\n            iter,\n            vec: PhantomData,\n        }\n    }\n}\n\nimpl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        while let Some(_) = self.pop() {}\n        // deallocation is handled by RawVec\n    }\n}\n\nimpl<T> Deref for Vec<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        unsafe { std::slice::from_raw_parts(self.ptr(), self.len) }\n    }\n}\n\nimpl<T> DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe { std::slice::from_raw_parts_mut(self.ptr(), self.len) }\n    }\n}\n\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        let (iter, buf) = unsafe {\n            (RawValIter::new(&self), ptr::read(&self.buf))\n        };\n\n        mem::forget(self);\n\n        IntoIter {\n            iter,\n            _buf: buf,\n        }\n    }\n}\n\nstruct RawValIter<T> {\n    start: *const T,\n    end: *const T,\n}\n\nimpl<T> RawValIter<T> {\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if mem::size_of::<T>() == 0 {\n                ((slice.as_ptr() as usize) + slice.len()) as *const _\n            } else if slice.len() == 0 {\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}\n\nimpl<T> Iterator for RawValIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.start = (self.start as usize + 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    let old_ptr = self.start;\n                    self.start = self.start.offset(1);\n                    Some(ptr::read(old_ptr))\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let elem_size = mem::size_of::<T>();\n        let len = (self.end as usize - self.start as usize)\n                  / if elem_size == 0 { 1 } else { elem_size };\n        (len, Some(len))\n    }\n}\n\nimpl<T> DoubleEndedIterator for RawValIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.end = (self.end as usize - 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    self.end = self.end.offset(-1);\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}\n\npub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    iter: RawValIter<T>,\n}\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}\n\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}\n\npub struct Drain<'a, T: 'a> {\n    vec: PhantomData<&'a mut Vec<T>>,\n    iter: RawValIter<T>,\n}\n\nimpl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}\n\nimpl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        // pre-drain the iter\n        for _ in &mut *self {}\n    }\n}\n\nfn main() {\n    tests::create_push_pop();\n    tests::iter_test();\n    tests::test_drain();\n    tests::test_zst();\n    println!(\"All tests finished OK\");\n}\n\nmod tests {\n    use super::*;\n\n    pub fn create_push_pop() {\n        let mut v = Vec::new();\n        v.push(1);\n        assert_eq!(1, v.len());\n        assert_eq!(1, v[0]);\n        for i in v.iter_mut() {\n            *i += 1;\n        }\n        v.insert(0, 5);\n        let x = v.pop();\n        assert_eq!(Some(2), x);\n        assert_eq!(1, v.len());\n        v.push(10);\n        let x = v.remove(0);\n        assert_eq!(5, x);\n        assert_eq!(1, v.len());\n    }\n\n    pub fn iter_test() {\n        let mut v = Vec::new();\n        for i in 0..10 {\n            v.push(Box::new(i))\n        }\n        let mut iter = v.into_iter();\n        let first = iter.next().unwrap();\n        let last = iter.next_back().unwrap();\n        drop(iter);\n        assert_eq!(0, *first);\n        assert_eq!(9, *last);\n    }\n\n    pub fn test_drain() {\n        let mut v = Vec::new();\n        for i in 0..10 {\n            v.push(Box::new(i))\n        }\n        {\n            let mut drain = v.drain();\n            let first = drain.next().unwrap();\n            let last = drain.next_back().unwrap();\n            assert_eq!(0, *first);\n            assert_eq!(9, *last);\n        }\n        assert_eq!(0, v.len());\n        v.push(Box::new(1));\n        assert_eq!(1, *v.pop().unwrap());\n    }\n\n    pub fn test_zst() {\n        let mut v = Vec::new();\n        for _i in 0..10 {\n            v.push(())\n        }\n\n        let mut count = 0;\n\n        for _ in v.into_iter() {\n            count += 1\n        }\n\n        assert_eq!(10, count);\n    }\n}\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Final Code - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"../theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"../what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"../working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"../exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"../aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"../unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"../hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"../subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"../dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"../phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"../borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"../dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"../casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"../transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"../drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"../unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"../destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"../leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"../poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"../send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"../atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../vec/vec-final.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"../arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"../beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"the-final-code\"><a class=\"header\" href=\"#the-final-code\">The Final Code</a></h1>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::alloc::{<span class=\"hljs-keyword\">self</span>, Layout};\n<span class=\"hljs-keyword\">use</span> std::marker::PhantomData;\n<span class=\"hljs-keyword\">use</span> std::mem;\n<span class=\"hljs-keyword\">use</span> std::ops::{Deref, DerefMut};\n<span class=\"hljs-keyword\">use</span> std::ptr::{<span class=\"hljs-keyword\">self</span>, NonNull};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RawVec</span></span>&lt;T&gt; {\n    ptr: NonNull&lt;T&gt;,\n    cap: <span class=\"hljs-built_in\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Send</span>&gt; <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> RawVec&lt;T&gt; {}\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Sync</span>&gt; <span class=\"hljs-built_in\">Sync</span> <span class=\"hljs-keyword\">for</span> RawVec&lt;T&gt; {}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; RawVec&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>() -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-comment\">// !0 is usize::MAX. This branch should be stripped at compile time.</span>\n        <span class=\"hljs-keyword\">let</span> cap = <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> { !<span class=\"hljs-number\">0</span> } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-number\">0</span> };\n\n        <span class=\"hljs-comment\">// `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"</span>\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">grow</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// since we set the capacity to usize::MAX when T has size 0,</span>\n        <span class=\"hljs-comment\">// getting to here necessarily means the Vec is overfull.</span>\n        <span class=\"hljs-built_in\">assert!</span>(mem::size_of::&lt;T&gt;() != <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"capacity overflow\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> (new_cap, new_layout) = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap == <span class=\"hljs-number\">0</span> {\n            (<span class=\"hljs-number\">1</span>, Layout::array::&lt;T&gt;(<span class=\"hljs-number\">1</span>).unwrap())\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// This can't overflow because we ensure self.cap &lt;= isize::MAX.</span>\n            <span class=\"hljs-keyword\">let</span> new_cap = <span class=\"hljs-number\">2</span> * <span class=\"hljs-keyword\">self</span>.cap;\n\n            <span class=\"hljs-comment\">// `Layout::array` checks that the number of bytes is &lt;= usize::MAX,</span>\n            <span class=\"hljs-comment\">// but this is redundant since old_layout.size() &lt;= isize::MAX,</span>\n            <span class=\"hljs-comment\">// so the `unwrap` should never fail.</span>\n            <span class=\"hljs-keyword\">let</span> new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        <span class=\"hljs-comment\">// Ensure that the new allocation doesn't exceed `isize::MAX` bytes.</span>\n        <span class=\"hljs-built_in\">assert!</span>(\n            new_layout.size() &lt;= <span class=\"hljs-built_in\">isize</span>::MAX <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>,\n            <span class=\"hljs-string\">\"Allocation too large\"</span>\n        );\n\n        <span class=\"hljs-keyword\">let</span> new_ptr = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap == <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">unsafe</span> { alloc::alloc(new_layout) }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">let</span> old_layout = Layout::array::&lt;T&gt;(<span class=\"hljs-keyword\">self</span>.cap).unwrap();\n            <span class=\"hljs-keyword\">let</span> old_ptr = <span class=\"hljs-keyword\">self</span>.ptr.as_ptr() <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>;\n            <span class=\"hljs-keyword\">unsafe</span> { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        <span class=\"hljs-comment\">// If allocation fails, `new_ptr` will be null, in which case we abort.</span>\n        <span class=\"hljs-keyword\">self</span>.ptr = <span class=\"hljs-keyword\">match</span> NonNull::new(new_ptr <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> T) {\n            <span class=\"hljs-literal\">Some</span>(p) =&gt; p,\n            <span class=\"hljs-literal\">None</span> =&gt; alloc::handle_alloc_error(new_layout),\n        };\n        <span class=\"hljs-keyword\">self</span>.cap = new_cap;\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> RawVec&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">let</span> elem_size = mem::size_of::&lt;T&gt;();\n\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.cap != <span class=\"hljs-number\">0</span> &amp;&amp; elem_size != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">unsafe</span> {\n                alloc::dealloc(\n                    <span class=\"hljs-keyword\">self</span>.ptr.as_ptr() <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>,\n                    Layout::array::&lt;T&gt;(<span class=\"hljs-keyword\">self</span>.cap).unwrap(),\n                );\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Vec</span></span>&lt;T&gt; {\n    buf: RawVec&lt;T&gt;,\n    len: <span class=\"hljs-built_in\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">ptr</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; *<span class=\"hljs-keyword\">mut</span> T {\n        <span class=\"hljs-keyword\">self</span>.buf.ptr.as_ptr()\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">cap</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">usize</span> {\n        <span class=\"hljs-keyword\">self</span>.buf.cap\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>() -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-built_in\">Vec</span> {\n            buf: RawVec::new(),\n            len: <span class=\"hljs-number\">0</span>,\n        }\n    }\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">push</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, elem: T) {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.len == <span class=\"hljs-keyword\">self</span>.cap() {\n            <span class=\"hljs-keyword\">self</span>.buf.grow();\n        }\n\n        <span class=\"hljs-keyword\">unsafe</span> {\n            ptr::write(<span class=\"hljs-keyword\">self</span>.ptr().add(<span class=\"hljs-keyword\">self</span>.len), elem);\n        }\n\n        <span class=\"hljs-comment\">// Can't overflow, we'll OOM first.</span>\n        <span class=\"hljs-keyword\">self</span>.len += <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">pop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.len == <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">None</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">self</span>.len -= <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">unsafe</span> { <span class=\"hljs-literal\">Some</span>(ptr::read(<span class=\"hljs-keyword\">self</span>.ptr().add(<span class=\"hljs-keyword\">self</span>.len))) }\n        }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">insert</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, index: <span class=\"hljs-built_in\">usize</span>, elem: T) {\n        <span class=\"hljs-built_in\">assert!</span>(index &lt;= <span class=\"hljs-keyword\">self</span>.len, <span class=\"hljs-string\">\"index out of bounds\"</span>);\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.len == <span class=\"hljs-keyword\">self</span>.cap() {\n            <span class=\"hljs-keyword\">self</span>.buf.grow();\n        }\n\n        <span class=\"hljs-keyword\">unsafe</span> {\n            ptr::copy(\n                <span class=\"hljs-keyword\">self</span>.ptr().add(index),\n                <span class=\"hljs-keyword\">self</span>.ptr().add(index + <span class=\"hljs-number\">1</span>),\n                <span class=\"hljs-keyword\">self</span>.len - index,\n            );\n            ptr::write(<span class=\"hljs-keyword\">self</span>.ptr().add(index), elem);\n        }\n\n        <span class=\"hljs-keyword\">self</span>.len += <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">remove</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, index: <span class=\"hljs-built_in\">usize</span>) -&gt; T {\n        <span class=\"hljs-built_in\">assert!</span>(index &lt; <span class=\"hljs-keyword\">self</span>.len, <span class=\"hljs-string\">\"index out of bounds\"</span>);\n\n        <span class=\"hljs-keyword\">self</span>.len -= <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-keyword\">unsafe</span> {\n            <span class=\"hljs-keyword\">let</span> result = ptr::read(<span class=\"hljs-keyword\">self</span>.ptr().add(index));\n            ptr::copy(\n                <span class=\"hljs-keyword\">self</span>.ptr().add(index + <span class=\"hljs-number\">1</span>),\n                <span class=\"hljs-keyword\">self</span>.ptr().add(index),\n                <span class=\"hljs-keyword\">self</span>.len - index,\n            );\n            result\n        }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drain</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Drain&lt;T&gt; {\n        <span class=\"hljs-keyword\">let</span> iter = <span class=\"hljs-keyword\">unsafe</span> { RawValIter::new(&amp;<span class=\"hljs-keyword\">self</span>) };\n\n        <span class=\"hljs-comment\">// this is a mem::forget safety thing. If Drain is forgotten, we just</span>\n        <span class=\"hljs-comment\">// leak the whole Vec's contents. Also we need to do this *eventually*</span>\n        <span class=\"hljs-comment\">// anyway, so why not do it now?</span>\n        <span class=\"hljs-keyword\">self</span>.len = <span class=\"hljs-number\">0</span>;\n\n        Drain {\n            iter,\n            vec: PhantomData,\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(_) = <span class=\"hljs-keyword\">self</span>.pop() {}\n        <span class=\"hljs-comment\">// deallocation is handled by RawVec</span>\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Deref <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = [T];\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;[T] {\n        <span class=\"hljs-keyword\">unsafe</span> { std::slice::from_raw_parts(<span class=\"hljs-keyword\">self</span>.ptr(), <span class=\"hljs-keyword\">self</span>.len) }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; DerefMut <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref_mut</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; &amp;<span class=\"hljs-keyword\">mut</span> [T] {\n        <span class=\"hljs-keyword\">unsafe</span> { std::slice::from_raw_parts_mut(<span class=\"hljs-keyword\">self</span>.ptr(), <span class=\"hljs-keyword\">self</span>.len) }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">IntoIterator</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span> = T;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">IntoIter</span></span> = IntoIter&lt;T&gt;;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">into_iter</span></span>(<span class=\"hljs-keyword\">self</span>) -&gt; IntoIter&lt;T&gt; {\n        <span class=\"hljs-keyword\">let</span> (iter, buf) = <span class=\"hljs-keyword\">unsafe</span> {\n            (RawValIter::new(&amp;<span class=\"hljs-keyword\">self</span>), ptr::read(&amp;<span class=\"hljs-keyword\">self</span>.buf))\n        };\n\n        mem::forget(<span class=\"hljs-keyword\">self</span>);\n\n        IntoIter {\n            iter,\n            _buf: buf,\n        }\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RawValIter</span></span>&lt;T&gt; {\n    start: *<span class=\"hljs-keyword\">const</span> T,\n    end: *<span class=\"hljs-keyword\">const</span> T,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; RawValIter&lt;T&gt; {\n    <span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(slice: &amp;[T]) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                ((slice.as_ptr() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>) + slice.len()) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> slice.len() == <span class=\"hljs-number\">0</span> {\n                slice.as_ptr()\n            } <span class=\"hljs-keyword\">else</span> {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Iterator</span> <span class=\"hljs-keyword\">for</span> RawValIter&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span> = T;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.start == <span class=\"hljs-keyword\">self</span>.end {\n            <span class=\"hljs-literal\">None</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">unsafe</span> {\n                <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">self</span>.start = (<span class=\"hljs-keyword\">self</span>.start <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> + <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _;\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">let</span> old_ptr = <span class=\"hljs-keyword\">self</span>.start;\n                    <span class=\"hljs-keyword\">self</span>.start = <span class=\"hljs-keyword\">self</span>.start.offset(<span class=\"hljs-number\">1</span>);\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(old_ptr))\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">size_hint</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; (<span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">usize</span>&gt;) {\n        <span class=\"hljs-keyword\">let</span> elem_size = mem::size_of::&lt;T&gt;();\n        <span class=\"hljs-keyword\">let</span> len = (<span class=\"hljs-keyword\">self</span>.end <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> - <span class=\"hljs-keyword\">self</span>.start <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>)\n                  / <span class=\"hljs-keyword\">if</span> elem_size == <span class=\"hljs-number\">0</span> { <span class=\"hljs-number\">1</span> } <span class=\"hljs-keyword\">else</span> { elem_size };\n        (len, <span class=\"hljs-literal\">Some</span>(len))\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">DoubleEndedIterator</span> <span class=\"hljs-keyword\">for</span> RawValIter&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next_back</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.start == <span class=\"hljs-keyword\">self</span>.end {\n            <span class=\"hljs-literal\">None</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">unsafe</span> {\n                <span class=\"hljs-keyword\">if</span> mem::size_of::&lt;T&gt;() == <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">self</span>.end = (<span class=\"hljs-keyword\">self</span>.end <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span> - <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _;\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">self</span>.end = <span class=\"hljs-keyword\">self</span>.end.offset(-<span class=\"hljs-number\">1</span>);\n                    <span class=\"hljs-literal\">Some</span>(ptr::read(<span class=\"hljs-keyword\">self</span>.end))\n                }\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">IntoIter</span></span>&lt;T&gt; {\n    _buf: RawVec&lt;T&gt;, <span class=\"hljs-comment\">// we don't actually care about this. Just need it to live.</span>\n    iter: RawValIter&lt;T&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Iterator</span> <span class=\"hljs-keyword\">for</span> IntoIter&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span> = T;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">self</span>.iter.next()\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">size_hint</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; (<span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">usize</span>&gt;) {\n        <span class=\"hljs-keyword\">self</span>.iter.size_hint()\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">DoubleEndedIterator</span> <span class=\"hljs-keyword\">for</span> IntoIter&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next_back</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">self</span>.iter.next_back()\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> IntoIter&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">self</span> {}\n    }\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Drain</span></span>&lt;<span class=\"hljs-symbol\">'a</span>, T: <span class=\"hljs-symbol\">'a</span>&gt; {\n    vec: PhantomData&lt;&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">Vec</span>&lt;T&gt;&gt;,\n    iter: RawValIter&lt;T&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; <span class=\"hljs-built_in\">Iterator</span> <span class=\"hljs-keyword\">for</span> Drain&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span> = T;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">self</span>.iter.next()\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">size_hint</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; (<span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">usize</span>&gt;) {\n        <span class=\"hljs-keyword\">self</span>.iter.size_hint()\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; <span class=\"hljs-built_in\">DoubleEndedIterator</span> <span class=\"hljs-keyword\">for</span> Drain&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">next_back</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;T&gt; {\n        <span class=\"hljs-keyword\">self</span>.iter.next_back()\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Drain&lt;<span class=\"hljs-symbol\">'a</span>, T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-comment\">// pre-drain the iter</span>\n        <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">self</span> {}\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    tests::create_push_pop();\n</span><span class=\"boring\">    tests::iter_test();\n</span><span class=\"boring\">    tests::test_drain();\n</span><span class=\"boring\">    tests::test_zst();\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"All tests finished OK\"</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">create_push_pop</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> v = <span class=\"hljs-built_in\">Vec</span>::new();\n</span><span class=\"boring\">        v.push(<span class=\"hljs-number\">1</span>);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">1</span>, v.len());\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">1</span>, v[<span class=\"hljs-number\">0</span>]);\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> v.iter_mut() {\n</span><span class=\"boring\">            *i += <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">        v.insert(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>);\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> x = v.pop();\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">2</span>), x);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">1</span>, v.len());\n</span><span class=\"boring\">        v.push(<span class=\"hljs-number\">10</span>);\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> x = v.remove(<span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">1</span>, v.len());\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">iter_test</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> v = <span class=\"hljs-built_in\">Vec</span>::new();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span> {\n</span><span class=\"boring\">            v.push(<span class=\"hljs-built_in\">Box</span>::new(i))\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> iter = v.into_iter();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> first = iter.next().unwrap();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> last = iter.next_back().unwrap();\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">drop</span>(iter);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0</span>, *first);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">9</span>, *last);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test_drain</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> v = <span class=\"hljs-built_in\">Vec</span>::new();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span> {\n</span><span class=\"boring\">            v.push(<span class=\"hljs-built_in\">Box</span>::new(i))\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">        {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> drain = v.drain();\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> first = drain.next().unwrap();\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> last = drain.next_back().unwrap();\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0</span>, *first);\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">9</span>, *last);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0</span>, v.len());\n</span><span class=\"boring\">        v.push(<span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-number\">1</span>));\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">1</span>, *v.pop().unwrap());\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test_zst</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> v = <span class=\"hljs-built_in\">Vec</span>::new();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> _i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span> {\n</span><span class=\"boring\">            v.push(())\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> count = <span class=\"hljs-number\">0</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> v.into_iter() {\n</span><span class=\"boring\">            count += <span class=\"hljs-number\">1</span>\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">10</span>, count);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../vec/vec-zsts.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../arc-mutex/arc-and-mutex.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../vec/vec-zsts.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../arc-mutex/arc-and-mutex.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:11.232Z"
}