{
	"title": "SemVer Compatibility - The Cargo Book",
	"url": "https://doc.rust-lang.org/cargo/reference/semver.html",
	"markdown": "# SemVer Compatibility - The Cargo Book\n\nThis chapter provides details on what is conventionally considered a compatible or breaking SemVer change for new releases of a package. See the [SemVer compatibility](about:blank/resolver.html#semver-compatibility) section for details on what SemVer is, and how Cargo uses it to ensure compatibility of libraries.\n\nThese are only _guidelines_, and not necessarily hard-and-fast rules that all projects will obey. The [Change categories](#change-categories) section details how this guide classifies the level and severity of a change. Most of this guide focuses on changes that will cause `cargo` and `rustc` to fail to build something that previously worked. Almost every change carries some risk that it will negatively affect the runtime behavior, and for those cases it is usually a judgment call by the project maintainers whether or not it is a SemVer-incompatible change.\n\n## [Change categories](#change-categories)\n\nAll of the policies listed below are categorized by the level of change:\n\n-   **Major change**: a change that requires a major SemVer bump.\n-   **Minor change**: a change that requires only a minor SemVer bump.\n-   **Possibly-breaking change**: a change that some projects may consider major and others consider minor.\n\nThe “Possibly-breaking” category covers changes that have the _potential_ to break during an update, but may not necessarily cause a breakage. The impact of these changes should be considered carefully. The exact nature will depend on the change and the principles of the project maintainers.\n\nSome projects may choose to only bump the patch number on a minor change. It is encouraged to follow the SemVer spec, and only apply bug fixes in patch releases. However, a bug fix may require an API change that is marked as a “minor change”, and shouldn’t affect compatibility. This guide does not take a stance on how each individual “minor change” should be treated, as the difference between minor and patch changes are conventions that depend on the nature of the change.\n\nSome changes are marked as “minor”, even though they carry the potential risk of breaking a build. This is for situations where the potential is extremely low, and the potentially breaking code is unlikely to be written in idiomatic Rust, or is specifically discouraged from use.\n\nThis guide uses the terms “major” and “minor” assuming this relates to a “1.0.0” release or later. Initial development releases starting with “0.y.z” can treat changes in “y” as a major release, and “z” as a minor release. “0.0.z” releases are always major changes. This is because Cargo uses the convention that only changes in the left-most non-zero component are considered incompatible.\n\n-   API compatibility\n    -   Items\n        -   [Major: renaming/moving/removing any public items](#item-remove)\n        -   [Minor: adding new public items](#item-new)\n    -   Types\n        -   [Major: Changing the alignment, layout, or size of a well-defined type](#type-layout)\n    -   Structs\n        -   [Major: adding a private struct field when all current fields are public](#struct-add-private-field-when-public)\n        -   [Major: adding a public field when no private field exists](#struct-add-public-field-when-no-private)\n        -   [Minor: adding or removing private fields when at least one already exists](#struct-private-fields-with-private)\n        -   [Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa](#struct-tuple-normal-with-private)\n    -   Enums\n        -   [Major: adding new enum variants (without `non_exhaustive`)](#enum-variant-new)\n        -   [Major: adding new fields to an enum variant](#enum-fields-new)\n    -   Traits\n        -   [Major: adding a non-defaulted trait item](#trait-new-item-no-default)\n        -   [Major: any change to trait item signatures](#trait-item-signature)\n        -   [Possibly-breaking: adding a defaulted trait item](#trait-new-default-item)\n        -   [Major: adding a trait item that makes the trait non-object safe](#trait-object-safety)\n        -   [Major: adding a type parameter without a default](#trait-new-parameter-no-default)\n        -   [Minor: adding a defaulted trait type parameter](#trait-new-parameter-default)\n    -   Implementations\n        -   [Possibly-breaking change: adding any inherent items](#impl-item-new)\n    -   Generics\n        -   [Major: tightening generic bounds](#generic-bounds-tighten)\n        -   [Minor: loosening generic bounds](#generic-bounds-loosen)\n        -   [Minor: adding defaulted type parameters](#generic-new-default)\n        -   [Minor: generalizing a type to use generics (with identical types)](#generic-generalize-identical)\n        -   [Major: generalizing a type to use generics (with possibly different types)](#generic-generalize-different)\n        -   [Minor: changing a generic type to a more generic type](#generic-more-generic)\n    -   Functions\n        -   [Major: adding/removing function parameters](#fn-change-arity)\n        -   [Possibly-breaking: introducing a new function type parameter](#fn-generic-new)\n        -   [Minor: generalizing a function to use generics (supporting original type)](#fn-generalize-compatible)\n        -   [Major: generalizing a function to use generics with type mismatch](#fn-generalize-mismatch)\n        -   [Minor: making an `unsafe` function safe](#fn-unsafe-safe)\n    -   Attributes\n        -   [Major: switching from `no_std` support to requiring `std`](#attr-no-std-to-std)\n        -   [Major: adding `non_exhaustive` to an existing enum, variant, or struct with no private fields](#attr-adding-non-exhaustive)\n-   Tooling and environment compatibility\n    -   [Possibly-breaking: changing the minimum version of Rust required](#env-new-rust)\n    -   [Possibly-breaking: changing the platform and environment requirements](#env-change-requirements)\n    -   [Minor: introducing new lints](#new-lints)\n    -   Cargo\n        -   [Minor: adding a new Cargo feature](#cargo-feature-add)\n        -   [Major: removing a Cargo feature](#cargo-feature-remove)\n        -   [Major: removing a feature from a feature list if that changes functionality or public items](#cargo-feature-remove-another)\n        -   [Possibly-breaking: removing an optional dependency](#cargo-remove-opt-dep)\n        -   [Minor: changing dependency features](#cargo-change-dep-feature)\n        -   [Minor: adding dependencies](#cargo-dep-add)\n-   [Application compatibility](#application-compatibility)\n\n## [API compatibility](#api-compatibility)\n\nAll of the examples below contain three parts: the original code, the code after it has been modified, and an example usage of the code that could appear in another project. In a minor change, the example usage should successfully build with both the before and after versions.\n\n### [Major: renaming/moving/removing any public items](#item-remove)\n\nThe absence of a publicly exposed [item](../../reference/items.html) will cause any uses of that item to fail to compile.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// After\n// ... item has been removed\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    updated_crate::foo(); // Error: cannot find function `foo`\n}\n```\n\nThis includes adding any sort of [`cfg` attribute](about:blank/reference/conditional-compilation.html#the-cfg-attribute) which can change which items or behavior is available based on [conditional compilation](../../reference/conditional-compilation.html).\n\nMitigating strategies:\n\n-   Mark items to be removed as [deprecated](about:blank/reference/attributes/diagnostics.html#the-deprecated-attribute), and then remove them at a later date in a SemVer-breaking release.\n-   Mark renamed items as [deprecated](about:blank/reference/attributes/diagnostics.html#the-deprecated-attribute), and use a [`pub use`](../../reference/items/use-declarations.html) item to re-export to the old name.\n\n### [Minor: adding new public items](#item-new)\n\nAdding new, public [items](../../reference/items.html) is a minor change.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n// ... absence of item\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\n// `foo` is not used since it didn't previously exist.\n```\n\nNote that in some rare cases this can be a **breaking change** due to glob imports. For example, if you add a new trait, and a project has used a glob import that brings that trait into scope, and the new trait introduces an associated item that conflicts with any types it is implemented on, this can cause a compile-time error due to the ambiguity. Example:\n\n```rust\n// Breaking change example\n\n///////////////////////////////////////////////////////////\n// Before\n// ... absence of trait\n\n///////////////////////////////////////////////////////////\n// After\npub trait NewTrait {\n    fn foo(&self) {}\n}\n\nimpl NewTrait for i32 {}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::*;\n\npub trait LocalTrait {\n    fn foo(&self) {}\n}\n\nimpl LocalTrait for i32 {}\n\nfn main() {\n    123i32.foo(); // Error:  multiple applicable items in scope\n}\n```\n\nThis is not considered a major change because conventionally glob imports are a known forwards-compatibility hazard. Glob imports of items from external crates should be avoided.\n\n### [Major: Changing the alignment, layout, or size of a well-defined type](#type-layout)\n\nIt is a breaking change to change the alignment, layout, or size of a type that was previously well-defined.\n\nIn general, types that use the [the default representation](about:blank/reference/type-layout.html#the-default-representation) do not have a well-defined alignment, layout, or size. The compiler is free to alter the alignment, layout, or size, so code should not make any assumptions about it.\n\n> **Note**: It may be possible for external crates to break if they make assumptions about the alignment, layout, or size of a type even if it is not well-defined. This is not considered a SemVer breaking change since those assumptions should not be made.\n\nSome examples of changes that are not a breaking change are (assuming no other rules in this guide are violated):\n\n-   Adding, removing, reordering, or changing fields of a default representation struct, union, or enum in such a way that the change follows the other rules in this guide (for example, using `non_exhaustive` to allow those changes, or changes to private fields that are already private). See [struct-add-private-field-when-public](#struct-add-private-field-when-public), [struct-add-public-field-when-no-private](#struct-add-public-field-when-no-private), [struct-private-fields-with-private](#struct-private-fields-with-private), [enum-fields-new](#enum-fields-new).\n-   Adding variants to a default representation enum, if the enum uses `non_exhaustive`. This may change the alignment or size of the enumeration, but those are not well-defined. See [enum-variant-new](#enum-variant-new).\n-   Adding, removing, reordering, or changing private fields of a `repr(C)` struct, union, or enum, following the other rules in this guide (for example, using `non_exhaustive`, or adding private fields when other private fields already exist). See [repr-c-private-change](#repr-c-private-change).\n-   Adding variants to a `repr(C)` enum, if the enum uses `non_exhaustive`. See [repr-c-enum-variant-new](#repr-c-enum-variant-new).\n-   Adding `repr(C)` to a default representation struct, union, or enum. See [repr-c-add](#repr-c-add).\n-   Adding `repr(<int>)` [primitive representation](about:blank/reference/type-layout.html#primitive-representations) to an enum. See [repr-int-enum-add](#repr-int-enum-add).\n-   Adding `repr(transparent)` to a default representation struct or enum. See [repr-transparent-add](#repr-transparent-add).\n\nTypes that use the [`repr` attribute](about:blank/reference/type-layout.html#representations) can be said to have an alignment and layout that is defined in some way that code may make some assumptions about that may break as a result of changing that type.\n\nIn some cases, types with a `repr` attribute may not have an alignment, layout, or size that is well-defined. In these cases, it may be safe to make changes to the types, though care should be exercised. For example, types with private fields that do not otherwise document their alignment, layout, or size guarantees cannot be relied upon by external crates since the public API does not fully define the alignment, layout, or size of the type.\n\nA common example where a type with _private_ fields is well-defined is a type with a single private field with a generic type, using `repr(transparent)`, and the prose of the documentation discusses that it is transparent to the generic type. For example, see [`UnsafeCell`](about:blank/std/cell/struct.UnsafeCell.html#memory-layout).\n\nSome examples of breaking changes are:\n\n-   Adding `repr(packed)` to a struct or union. See [repr-packed-add](#repr-packed-add).\n-   Adding `repr(align)` to a struct, union, or enum. See [repr-align-add](#repr-align-add).\n-   Removing `repr(packed)` from a struct or union. See [repr-packed-remove](#repr-packed-remove).\n-   Changing the value N of `repr(packed(N))` if that changes the alignment or layout. See [repr-packed-n-change](#repr-packed-n-change).\n-   Changing the value N of `repr(align(N))` if that changes the alignment. See [repr-align-n-change](#repr-align-n-change).\n-   Removing `repr(align)` from a struct, union, or enum. See [repr-align-remove](#repr-align-remove).\n-   Changing the order of public fields of a `repr(C)` type. See [repr-c-shuffle](#repr-c-shuffle).\n-   Removing `repr(C)` from a struct, union, or enum. See [repr-c-remove](#repr-c-remove).\n-   Removing `repr(<int>)` from an enum. See [repr-int-enum-remove](#repr-int-enum-remove).\n-   Changing the primitive representation of a `repr(<int>)` enum. See [repr-int-enum-change](#repr-int-enum-change).\n-   Removing `repr(transparent)` from a struct or enum. See [repr-transparent-remove](#repr-transparent-remove).\n\n#### [Minor: `repr(C)` add, remove, or change a private field](#repr-c-private-change)\n\nIt is usually safe to add, remove, or change a private field of a `repr(C)` struct, union, or enum, assuming it follows the other guidelines in this guide (see [struct-add-private-field-when-public](#struct-add-private-field-when-public), [struct-add-public-field-when-no-private](#struct-add-public-field-when-no-private), [struct-private-fields-with-private](#struct-private-fields-with-private), [enum-fields-new](#enum-fields-new)).\n\nFor example, adding private fields can only be done if there are already other private fields, or it is `non_exhaustive`. Public fields may be added if there are private fields, or it is `non_exhaustive`, and the addition does not alter the layout of the other fields.\n\nHowever, this may change the size and alignment of the type. Care should be taken if the size or alignment changes. Code should not make assumptions about the size or alignment of types with private fields or `non_exhaustive` unless it has a documented size or alignment.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[derive(Default)]\n#[repr(C)]\npub struct Example {\n    pub f1: i32,\n    f2: i32, // a private field\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[derive(Default)]\n#[repr(C)]\npub struct Example {\n    pub f1: i32,\n    f2: i32,\n    f3: i32, // a new field\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    // NOTE: Users should not make assumptions about the size or alignment\n    // since they are not documented.\n    let f = updated_crate::Example::default();\n}\n```\n\n#### [Minor: `repr(C)` add enum variant](#repr-c-enum-variant-new)\n\nIt is usually safe to add variants to a `repr(C)` enum, if the enum uses `non_exhaustive`. See [enum-variant-new](#enum-variant-new) for more discussion.\n\nNote that this may be a breaking change since it changes the size and alignment of the type. See [repr-c-private-change](#repr-c-private-change) for similar concerns.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(C)]\n#[non_exhaustive]\npub enum Example {\n    Variant1 { f1: i16 },\n    Variant2 { f1: i32 },\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(C)]\n#[non_exhaustive]\npub enum Example {\n    Variant1 { f1: i16 },\n    Variant2 { f1: i32 },\n    Variant3 { f1: i64 }, // added\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    // NOTE: Users should not make assumptions about the size or alignment\n    // since they are not specified. For example, this raised the size from 8\n    // to 16 bytes.\n    let f = updated_crate::Example::Variant2 { f1: 123 };\n}\n```\n\n#### [Minor: Adding `repr(C)` to a default representation](#repr-c-add)\n\nIt is safe to add `repr(C)` to a struct, union, or enum with [the default representation](about:blank/reference/type-layout.html#the-default-representation). This is safe because users should not make assumptions about the alignment, layout, or size of types with with the default representation.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Example {\n    pub f1: i32,\n    pub f2: i16,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(C)] // added\npub struct Example {\n    pub f1: i32,\n    pub f2: i16,\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    let f = updated_crate::Example { f1: 123, f2: 456 };\n}\n```\n\n#### [Minor: Adding `repr(<int>)` to an enum](#repr-int-enum-add)\n\nIt is safe to add `repr(<int>)` [primitive representation](about:blank/reference/type-layout.html#primitive-representations) to an enum with [the default representation](about:blank/reference/type-layout.html#the-default-representation). This is safe because users should not make assumptions about the alignment, layout, or size of an enum with the default representation.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub enum E {\n    Variant1,\n    Variant2(i32),\n    Variant3 { f1: f64 },\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(i32)] // added\npub enum E {\n    Variant1,\n    Variant2(i32),\n    Variant3 { f1: f64 },\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    let x = updated_crate::E::Variant3 { f1: 1.23 };\n}\n```\n\n#### [Minor: Adding `repr(transparent)` to a default representation struct or enum](#repr-transparent-add)\n\nIt is safe to add `repr(transparent)` to a struct or enum with [the default representation](about:blank/reference/type-layout.html#the-default-representation). This is safe because users should not make assumptions about the alignment, layout, or size of a struct or enum with the default representation.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[derive(Default)]\npub struct Example<T>(T);\n\n///////////////////////////////////////////////////////////\n// After\n#[derive(Default)]\n#[repr(transparent)] // added\npub struct Example<T>(T);\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    let x = updated_crate::Example::<i32>::default();\n}\n```\n\n#### [Major: Adding `repr(packed)` to a struct or union](#repr-packed-add)\n\nIt is a breaking change to add `repr(packed)` to a struct or union. Making a type `repr(packed)` makes changes that can break code, such as being invalid to take a reference to a field, or causing truncation of disjoint closure captures.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Example {\n    pub f1: u8,\n    pub f2: u16,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(packed)] // added\npub struct Example {\n    pub f1: u8,\n    pub f2: u16,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    let f = updated_crate::Example { f1: 1, f2: 2 };\n    let x = &f.f2; // Error: reference to packed field is unaligned\n}\n```\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Example(pub i32, pub i32);\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(packed)]\npub struct Example(pub i32, pub i32);\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    let mut f = updated_crate::Example(123, 456);\n    let c = || {\n        // Without repr(packed), the closure precisely captures `&f.0`.\n        // With repr(packed), the closure captures `&f` to avoid undefined behavior.\n        let a = f.0;\n    };\n    f.1 = 789; // Error: cannot assign to `f.1` because it is borrowed\n    c();\n}\n```\n\n#### [Major: Adding `repr(align)` to a struct, union, or enum](#repr-align-add)\n\nIt is a breaking change to add `repr(align)` to a struct, union, or enum. Making a type `repr(align)` would break any use of that type in a `repr(packed)` type because that combination is not allowed.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Aligned {\n    pub a: i32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(align(8))] // added\npub struct Aligned {\n    pub a: i32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Aligned;\n\n#[repr(packed)]\npub struct Packed { // Error: packed type cannot transitively contain a `#[repr(align)]` type\n    f1: Aligned,\n}\n\nfn main() {\n    let p = Packed {\n        f1: Aligned { a: 123 },\n    };\n}\n```\n\n#### [Major: Removing `repr(packed)` from a struct or union](#repr-packed-remove)\n\nIt is a breaking change to remove `repr(packed)` from a struct or union. This may change the alignment or layout that extern crates are relying on.\n\nIf any fields are public, then removing `repr(packed)` may change the way disjoint closure captures work. In some cases, this can cause code to break, similar to those outlined in the [edition guide](../../edition-guide/rust-2021/disjoint-capture-in-closures.html).\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(C, packed)]\npub struct Packed {\n    pub a: u8,\n    pub b: u16,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(C)] // removed packed\npub struct Packed {\n    pub a: u8,\n    pub b: u16,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Packed;\n\nfn main() {\n    let p = Packed { a: 1, b: 2 };\n    // Some assumption about the size of the type.\n    // Without `packed`, this fails since the size is 4.\n    const _: () = assert!(std::mem::size_of::<Packed>() == 3); // Error: evaluation of constant value failed\n}\n```\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(C, packed)]\npub struct Packed {\n    pub a: *mut i32,\n    pub b: i32,\n}\nunsafe impl Send for Packed {}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(C)] // removed packed\npub struct Packed {\n    pub a: *mut i32,\n    pub b: i32,\n}\nunsafe impl Send for Packed {}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Packed;\n\nfn main() {\n    let mut x = 123;\n\n    let p = Packed {\n        a: &mut x as *mut i32,\n        b: 456,\n    };\n\n    // When the structure was packed, the closure captures `p` which is Send.\n    // When `packed` is removed, this ends up capturing `p.a` which is not Send.\n    std::thread::spawn(move || unsafe {\n        *(p.a) += 1; // Error: cannot be sent between threads safely\n    });\n}\n```\n\n#### [Major: Changing the value N of `repr(packed(N))` if that changes the alignment or layout](#repr-packed-n-change)\n\nIt is a breaking change to change the value of N of `repr(packed(N))` if that changes the alignment or layout. This may change the alignment or layout that external crates are relying on.\n\nIf the value `N` is lowered below the alignment of a public field, then that would break any code that attempts to take a reference of that field.\n\nNote that some changes to `N` may not change the alignment or layout, for example increasing it when the current value is already equal to the natural alignment of the type.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(packed(4))]\npub struct Packed {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(packed(2))] // changed to 2\npub struct Packed {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Packed;\n\nfn main() {\n    let p = Packed { a: 1, b: 2 };\n    let x = &p.b; // Error: reference to packed field is unaligned\n}\n```\n\n#### [Major: Changing the value N of `repr(align(N))` if that changes the alignment](#repr-align-n-change)\n\nIt is a breaking change to change the value `N` of `repr(align(N))` if that changes the alignment. This may change the alignment that external crates are relying on.\n\nThis change should be safe to make if the type is not well-defined as discussed in [type layout](#type-layout) (such as having any private fields and having an undocumented alignment or layout).\n\nNote that some changes to `N` may not change the alignment or layout, for example decreasing it when the current value is already equal to or less than the natural alignment of the type.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(align(8))]\npub struct Packed {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(align(4))] // changed to 4\npub struct Packed {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Packed;\n\nfn main() {\n    let p = Packed { a: 1, b: 2 };\n    // Some assumption about the size of the type.\n    // The alignment has changed from 8 to 4.\n    const _: () = assert!(std::mem::align_of::<Packed>() == 8); // Error: evaluation of constant value failed\n}\n```\n\n#### [Major: Removing `repr(align)` from a struct, union, or enum](#repr-align-remove)\n\nIt is a breaking change to remove `repr(align)` from a struct, union, or enum, if their layout was well-defined. This may change the alignment or layout that external crates are relying on.\n\nThis change should be safe to make if the type is not well-defined as discussed in [type layout](#type-layout) (such as having any private fields and having an undocumented alignment).\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(C, align(8))]\npub struct Packed {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(C)] // removed align\npub struct Packed {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Packed;\n\nfn main() {\n    let p = Packed { a: 1, b: 2 };\n    // Some assumption about the size of the type.\n    // The alignment has changed from 8 to 4.\n    const _: () = assert!(std::mem::align_of::<Packed>() == 8); // Error: evaluation of constant value failed\n}\n```\n\n#### [Major: Changing the order of public fields of a `repr(C)` type](#repr-c-shuffle)\n\nIt is a breaking change to change the order of public fields of a `repr(C)` type. External crates may be relying on the specific ordering of the fields.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(C)]\npub struct SpecificLayout {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(C)]\npub struct SpecificLayout {\n    pub b: u32, // changed order\n    pub a: u8,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::SpecificLayout;\n\nextern \"C\" {\n    // This C function is assuming a specific layout defined in a C header.\n    fn c_fn_get_b(x: &SpecificLayout) -> u32;\n}\n\nfn main() {\n    let p = SpecificLayout { a: 1, b: 2 };\n    unsafe { assert_eq!(c_fn_get_b(&p), 2) } // Error: value not equal to 2\n}\n\nmod cdep {\n    // This simulates what would normally be something included from a build script.\n    // This definition would be in a C header.\n    #[repr(C)]\n    pub struct SpecificLayout {\n        pub a: u8,\n        pub b: u32,\n    }\n\n    #[no_mangle]\n    pub fn c_fn_get_b(x: &SpecificLayout) -> u32 {\n        x.b\n    }\n}\n```\n\n#### [Major: Removing `repr(C)` from a struct, union, or enum](#repr-c-remove)\n\nIt is a breaking change to remove `repr(C)` from a struct, union, or enum. External crates may be relying on the specific layout of the type.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(C)]\npub struct SpecificLayout {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n// removed repr(C)\npub struct SpecificLayout {\n    pub a: u8,\n    pub b: u32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::SpecificLayout;\n\nextern \"C\" {\n    // This C function is assuming a specific layout defined in a C header.\n    fn c_fn_get_b(x: &SpecificLayout) -> u32; // Error: is not FFI-safe\n}\n\nfn main() {\n    let p = SpecificLayout { a: 1, b: 2 };\n    unsafe { assert_eq!(c_fn_get_b(&p), 2) }\n}\n\nmod cdep {\n    // This simulates what would normally be something included from a build script.\n    // This definition would be in a C header.\n    #[repr(C)]\n    pub struct SpecificLayout {\n        pub a: u8,\n        pub b: u32,\n    }\n\n    #[no_mangle]\n    pub fn c_fn_get_b(x: &SpecificLayout) -> u32 {\n        x.b\n    }\n}\n```\n\n#### [Major: Removing `repr(<int>)` from an enum](#repr-int-enum-remove)\n\nIt is a breaking change to remove `repr(<int>)` from an enum. External crates may be assuming that the discriminant is a specific size. For example, [`std::mem::transmute`](../../std/mem/fn.transmute.html) of an enum may fail.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(u16)]\npub enum Example {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n///////////////////////////////////////////////////////////\n// After\n// removed repr(u16)\npub enum Example {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\n\nfn main() {\n    let e = updated_crate::Example::Variant2;\n    let i: u16 = unsafe { std::mem::transmute(e) }; // Error: cannot transmute between types of different sizes\n}\n```\n\n#### [Major: Changing the primitive representation of a `repr(<int>)` enum](#repr-int-enum-change)\n\nIt is a breaking change to change the primitive representation of a `repr(<int>)` enum. External crates may be assuming that the discriminant is a specific size. For example, [`std::mem::transmute`](../../std/mem/fn.transmute.html) of an enum may fail.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(u16)]\npub enum Example {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[repr(u8)] // changed repr size\npub enum Example {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\n\nfn main() {\n    let e = updated_crate::Example::Variant2;\n    let i: u16 = unsafe { std::mem::transmute(e) }; // Error: cannot transmute between types of different sizes\n}\n```\n\n#### [Major: Removing `repr(transparent)` from a struct or enum](#repr-transparent-remove)\n\nIt is a breaking change to remove `repr(transparent)` from a struct or enum. External crates may be relying on the type having the alignment, layout, or size of the transparent field.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[repr(transparent)]\npub struct Transparent<T>(T);\n\n///////////////////////////////////////////////////////////\n// After\n// removed repr\npub struct Transparent<T>(T);\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\n#![deny(improper_ctypes)]\nuse updated_crate::Transparent;\n\nextern \"C\" {\n    fn c_fn() -> Transparent<f64>; // Error: is not FFI-safe\n}\n\nfn main() {}\n```\n\n### [Major: adding a private struct field when all current fields are public](#struct-add-private-field-when-public)\n\nWhen a private field is added to a struct that previously had all public fields, this will break any code that attempts to construct it with a [struct literal](../../reference/expressions/struct-expr.html).\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo {\n    pub f1: i32,\n}\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo {\n    pub f1: i32,\n    f2: i32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    let x = updated_crate::Foo { f1: 123 }; // Error: cannot construct `Foo`\n}\n```\n\nMitigation strategies:\n\n-   Do not add new fields to all-public field structs.\n-   Mark structs as [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) when first introducing a struct to prevent users from using struct literal syntax, and instead provide a constructor method and/or [Default](../../std/default/trait.Default.html) implementation.\n\n### [Major: adding a public field when no private field exists](#struct-add-public-field-when-no-private)\n\nWhen a public field is added to a struct that has all public fields, this will break any code that attempts to construct it with a [struct literal](../../reference/expressions/struct-expr.html).\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo {\n    pub f1: i32,\n}\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo {\n    pub f1: i32,\n    pub f2: i32,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    let x = updated_crate::Foo { f1: 123 }; // Error: missing field `f2`\n}\n```\n\nMitigation strategies:\n\n-   Do not add new new fields to all-public field structs.\n-   Mark structs as [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) when first introducing a struct to prevent users from using struct literal syntax, and instead provide a constructor method and/or [Default](../../std/default/trait.Default.html) implementation.\n\n### [Minor: adding or removing private fields when at least one already exists](#struct-private-fields-with-private)\n\nIt is safe to add or remove private fields from a struct when the struct already has at least one private field.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[derive(Default)]\npub struct Foo {\n    f1: i32,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[derive(Default)]\npub struct Foo {\n    f2: f64,\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    // Cannot access private fields.\n    let x = updated_crate::Foo::default();\n}\n```\n\nThis is safe because existing code cannot use a [struct literal](../../reference/expressions/struct-expr.html) to construct it, nor exhaustively match its contents.\n\nNote that for tuple structs, this is a **major change** if the tuple contains public fields, and the addition or removal of a private field changes the index of any public field.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[derive(Default)]\npub struct Foo(pub i32, i32);\n\n///////////////////////////////////////////////////////////\n// After\n#[derive(Default)]\npub struct Foo(f64, pub i32, i32);\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    let x = updated_crate::Foo::default();\n    let y = x.0; // Error: is private\n}\n```\n\n### [Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa](#struct-tuple-normal-with-private)\n\nChanging a tuple struct to a normal struct (or vice-versa) is safe if all fields are private.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[derive(Default)]\npub struct Foo(i32);\n\n///////////////////////////////////////////////////////////\n// After\n#[derive(Default)]\npub struct Foo {\n    f1: i32,\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nfn main() {\n    // Cannot access private fields.\n    let x = updated_crate::Foo::default();\n}\n```\n\nThis is safe because existing code cannot use a [struct literal](../../reference/expressions/struct-expr.html) to construct it, nor match its contents.\n\n### [Major: adding new enum variants (without `non_exhaustive`)](#enum-variant-new)\n\nIt is a breaking change to add a new enum variant if the enum does not use the [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) attribute.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub enum E {\n    Variant1,\n}\n\n///////////////////////////////////////////////////////////\n// After\npub enum E {\n    Variant1,\n    Variant2,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    use updated_crate::E;\n    let x = E::Variant1;\n    match x { // Error: `E::Variant2` not covered\n        E::Variant1 => {}\n    }\n}\n```\n\nMitigation strategies:\n\n-   When introducing the enum, mark it as [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) to force users to use [wildcard patterns](about:blank/reference/patterns.html#wildcard-pattern) to catch new variants.\n\n### [Major: adding new fields to an enum variant](#enum-fields-new)\n\nIt is a breaking change to add new fields to an enum variant because all fields are public, and constructors and matching will fail to compile.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub enum E {\n    Variant1 { f1: i32 },\n}\n\n///////////////////////////////////////////////////////////\n// After\npub enum E {\n    Variant1 { f1: i32, f2: i32 },\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    use updated_crate::E;\n    let x = E::Variant1 { f1: 1 }; // Error: missing f2\n    match x {\n        E::Variant1 { f1 } => {} // Error: missing f2\n    }\n}\n```\n\nMitigation strategies:\n\n-   When introducing the enum, mark the variant as [`non_exhaustive`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) so that it cannot be constructed or matched without wildcards.\n    ```rust\n    pub enum E {\n        #[non_exhaustive]\n        Variant1{f1: i32}\n    }\n    ```\n    \n-   When introducing the enum, use an explicit struct as a value, where you can have control over the field visibility.\n    ```rust\n    pub struct Foo {\n       f1: i32,\n       f2: i32,\n    }\n    pub enum E {\n        Variant1(Foo)\n    }\n    ```\n    \n\n### [Major: adding a non-defaulted trait item](#trait-new-item-no-default)\n\nIt is a breaking change to add a non-defaulted item to a trait. This will break any implementors of the trait.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait {\n    fn foo(&self);\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Trait;\nstruct Foo;\n\nimpl Trait for Foo {}  // Error: not all trait items implemented\n```\n\nMitigation strategies:\n\n-   Always provide a default implementation or value for new associated trait items.\n-   When introducing the trait, use the [sealed trait](https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed) technique to prevent users outside of the crate from implementing the trait.\n\n### [Major: any change to trait item signatures](#trait-item-signature)\n\nIt is a breaking change to make any change to a trait item signature. This can break external implementors of the trait.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {\n    fn f(&self, x: i32) {}\n}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait {\n    // For sealed traits or normal functions, this would be a minor change\n    // because generalizing with generics strictly expands the possible uses.\n    // But in this case, trait implementations must use the same signature.\n    fn f<V>(&self, x: V) {}\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Trait;\nstruct Foo;\n\nimpl Trait for Foo {\n    fn f(&self, x: i32) {}  // Error: trait declaration has 1 type parameter\n}\n```\n\nMitigation strategies:\n\n-   Introduce new items with default implementations to cover the new functionality instead of modifying existing items.\n-   When introducing the trait, use the [sealed trait](https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed) technique to prevent users outside of the crate from implementing the trait.\n\n### [Possibly-breaking: adding a defaulted trait item](#trait-new-default-item)\n\nIt is usually safe to add a defaulted trait item. However, this can sometimes cause a compile error. For example, this can introduce an ambiguity if a method of the same name exists in another trait.\n\n```rust\n// Breaking change example\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait {\n    fn foo(&self) {}\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Trait;\nstruct Foo;\n\ntrait LocalTrait {\n    fn foo(&self) {}\n}\n\nimpl Trait for Foo {}\nimpl LocalTrait for Foo {}\n\nfn main() {\n    let x = Foo;\n    x.foo(); // Error: multiple applicable items in scope\n}\n```\n\nNote that this ambiguity does _not_ exist for name collisions on [inherent implementations](about:blank/reference/items/implementations.html#inherent-implementations), as they take priority over trait items.\n\nSee [trait-object-safety](#trait-object-safety) for a special case to consider when adding trait items.\n\nMitigation strategies:\n\n-   Some projects may deem this acceptable breakage, particularly if the new item name is unlikely to collide with any existing code. Choose names carefully to help avoid these collisions. Additionally, it may be acceptable to require downstream users to add [disambiguation syntax](about:blank/reference/expressions/call-expr.html#disambiguating-function-calls) to select the correct function when updating the dependency.\n\n### [Major: adding a trait item that makes the trait non-object safe](#trait-object-safety)\n\nIt is a breaking change to add a trait item that changes the trait to not be [object safe](about:blank/reference/items/traits.html#object-safety).\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait {\n    // An associated const makes the trait not object-safe.\n    const CONST: i32 = 123;\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Trait;\nstruct Foo;\n\nimpl Trait for Foo {}\n\nfn main() {\n    let obj: Box<dyn Trait> = Box::new(Foo); // Error: cannot be made into an object\n}\n```\n\nIt is safe to do the converse (making a non-object safe trait into a safe one).\n\n### [Major: adding a type parameter without a default](#trait-new-parameter-no-default)\n\nIt is a breaking change to add a type parameter without a default to a trait.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait<T> {}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Trait;\nstruct Foo;\n\nimpl Trait for Foo {}  // Error: missing generics\n```\n\nMitigating strategies:\n\n-   See [adding a defaulted trait type parameter](#trait-new-parameter-default).\n\n### [Minor: adding a defaulted trait type parameter](#trait-new-parameter-default)\n\nIt is safe to add a type parameter to a trait as long as it has a default. External implementors will use the default without needing to specify the parameter.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait<T = i32> {}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::Trait;\nstruct Foo;\n\nimpl Trait for Foo {}\n```\n\n### [Possibly-breaking change: adding any inherent items](#impl-item-new)\n\nUsually adding inherent items to an implementation should be safe because inherent items take priority over trait items. However, in some cases the collision can cause problems if the name is the same as an implemented trait item with a different signature.\n\n```rust\n// Breaking change example\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo;\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo;\n\nimpl Foo {\n    pub fn foo(&self) {}\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Foo;\n\ntrait Trait {\n    fn foo(&self, x: i32) {}\n}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x = Foo;\n    x.foo(1); // Error: this method takes 0 arguments but 1 argument was supplied\n}\n```\n\nNote that if the signatures match, there would not be a compile-time error, but possibly a silent change in runtime behavior (because it is now executing a different function).\n\nMitigation strategies:\n\n-   Some projects may deem this acceptable breakage, particularly if the new item name is unlikely to collide with any existing code. Choose names carefully to help avoid these collisions. Additionally, it may be acceptable to require downstream users to add [disambiguation syntax](about:blank/reference/expressions/call-expr.html#disambiguating-function-calls) to select the correct function when updating the dependency.\n\n### [Major: tightening generic bounds](#generic-bounds-tighten)\n\nIt is a breaking change to tighten generic bounds on a type since this can break users expecting the looser bounds.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo<A> {\n    pub f1: A,\n}\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo<A: Eq> {\n    pub f1: A,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Foo;\n\nfn main() {\n    let s = Foo { f1: 1.23 }; // Error: the trait bound `{float}: Eq` is not satisfied\n}\n```\n\n### [Minor: loosening generic bounds](#generic-bounds-loosen)\n\nIt is safe to loosen the generic bounds on a type, as it only expands what is allowed.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo<A: Clone> {\n    pub f1: A,\n}\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo<A> {\n    pub f1: A,\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::Foo;\n\nfn main() {\n    let s = Foo { f1: 123 };\n}\n```\n\n### [Minor: adding defaulted type parameters](#generic-new-default)\n\nIt is safe to add a type parameter to a type as long as it has a default. All existing references will use the default without needing to specify the parameter.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#[derive(Default)]\npub struct Foo {}\n\n///////////////////////////////////////////////////////////\n// After\n#[derive(Default)]\npub struct Foo<A = i32> {\n    f1: A,\n}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::Foo;\n\nfn main() {\n    let s: Foo = Default::default();\n}\n```\n\n### [Minor: generalizing a type to use generics (with identical types)](#generic-generalize-identical)\n\nA struct or enum field can change from a concrete type to a generic type parameter, provided that the change results in an identical type for all existing use cases. For example, the following change is permitted:\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo(pub u8);\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo<T = u8>(pub T);\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::Foo;\n\nfn main() {\n    let s: Foo = Foo(123);\n}\n```\n\nbecause existing uses of `Foo` are shorthand for `Foo<u8>` which yields the identical field type.\n\n### [Major: generalizing a type to use generics (with possibly different types)](#generic-generalize-different)\n\nChanging a struct or enum field from a concrete type to a generic type parameter can break if the type can change.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo<T = u8>(pub T, pub u8);\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo<T = u8>(pub T, pub T);\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::Foo;\n\nfn main() {\n    let s: Foo<f32> = Foo(3.14, 123); // Error: mismatched types\n}\n```\n\n### [Minor: changing a generic type to a more generic type](#generic-more-generic)\n\nIt is safe to change a generic type to a more generic one. For example, the following adds a generic parameter that defaults to the original type, which is safe because all existing users will be using the same type for both fields, the defaulted parameter does not need to be specified.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo<T>(pub T, pub T);\n\n///////////////////////////////////////////////////////////\n// After\npub struct Foo<T, U = T>(pub T, pub U);\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::Foo;\n\nfn main() {\n    let s: Foo<f32> = Foo(1.0, 2.0);\n}\n```\n\n### [Major: adding/removing function parameters](#fn-change-arity)\n\nChanging the arity of a function is a breaking change.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo(x: i32) {}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nfn main() {\n    updated_crate::foo(); // Error: this function takes 1 argument\n}\n```\n\nMitigating strategies:\n\n-   Introduce a new function with the new signature and possibly [deprecate](about:blank/reference/attributes/diagnostics.html#the-deprecated-attribute) the old one.\n-   Introduce functions that take a struct argument, where the struct is built with the builder pattern. This allows new fields to be added to the struct in the future.\n\n### [Possibly-breaking: introducing a new function type parameter](#fn-generic-new)\n\nUsually, adding a non-defaulted type parameter is safe, but in some cases it can be a breaking change:\n\n```rust\n// Breaking change example\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo<T>() {}\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo<T, U>() {}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::foo;\n\nfn main() {\n    foo::<u8>(); // Error: function takes 2 generic arguments but 1 generic argument was supplied\n}\n```\n\nHowever, such explicit calls are rare enough (and can usually be written in other ways) that this breakage is usually acceptable. One should take into account how likely it is that the function in question is being called with explicit type arguments.\n\n### [Minor: generalizing a function to use generics (supporting original type)](#fn-generalize-compatible)\n\nThe type of a parameter to a function, or its return value, can be _generalized_ to use generics, including by introducing a new type parameter, as long as it can be instantiated to the original type. For example, the following changes are allowed:\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo(x: u8) -> u8 {\n    x\n}\npub fn bar<T: Iterator<Item = u8>>(t: T) {}\n\n///////////////////////////////////////////////////////////\n// After\nuse std::ops::Add;\npub fn foo<T: Add>(x: T) -> T {\n    x\n}\npub fn bar<T: IntoIterator<Item = u8>>(t: T) {}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::{bar, foo};\n\nfn main() {\n    foo(1);\n    bar(vec![1, 2, 3].into_iter());\n}\n```\n\nbecause all existing uses are instantiations of the new signature.\n\nPerhaps somewhat surprisingly, generalization applies to trait objects as well, given that every trait implements itself:\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub trait Trait {}\npub fn foo(t: &dyn Trait) {}\n\n///////////////////////////////////////////////////////////\n// After\npub trait Trait {}\npub fn foo<T: Trait + ?Sized>(t: &T) {}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\nuse updated_crate::{foo, Trait};\n\nstruct Foo;\nimpl Trait for Foo {}\n\nfn main() {\n    let obj = Foo;\n    foo(&obj);\n}\n```\n\n(The use of `?Sized` is essential; otherwise you couldn’t recover the original signature.)\n\nIntroducing generics in this way can potentially create type inference failures. These are usually rare, and may be acceptable breakage for some projects, as this can be fixed with additional type annotations.\n\n```rust\n// Breaking change example\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo() -> i32 {\n    0\n}\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo<T: Default>() -> T {\n    Default::default()\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::foo;\n\nfn main() {\n    let x = foo(); // Error: type annotations needed\n}\n```\n\n### [Major: generalizing a function to use generics with type mismatch](#fn-generalize-mismatch)\n\nIt is a breaking change to change a function parameter or return type if the generic type constrains or changes the types previously allowed. For example, the following adds a generic constraint that may not be satisfied by existing code:\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo(x: Vec<u8>) {}\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo<T: Copy + IntoIterator<Item = u8>>(x: T) {}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::foo;\n\nfn main() {\n    foo(vec![1, 2, 3]); // Error: `Copy` is not implemented for `Vec<u8>`\n}\n```\n\n### [Minor: making an `unsafe` function safe](#fn-unsafe-safe)\n\nA previously `unsafe` function can be made safe without breaking code.\n\nNote however that it may cause the [`unused_unsafe`](about:blank/rustc/lints/listing/warn-by-default.html#unused-unsafe) lint to trigger as in the example below, which will cause local crates that have specified `#![deny(warnings)]` to stop compiling. Per [introducing new lints](#new-lints), it is allowed for updates to introduce new warnings.\n\nGoing the other way (making a safe function `unsafe`) is a breaking change.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub unsafe fn foo() {}\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will trigger a lint.\nuse updated_crate::foo;\n\nunsafe fn bar(f: unsafe fn()) {\n    f()\n}\n\nfn main() {\n    unsafe { foo() }; // The `unused_unsafe` lint will trigger here\n    unsafe { bar(foo) };\n}\n```\n\nMaking a previously `unsafe` associated function or method on structs / enums safe is also a minor change, while the same is not true for associated function on traits (see [any change to trait item signatures](#trait-item-signature)).\n\n### [Major: switching from `no_std` support to requiring `std`](#attr-no-std-to-std)\n\nIf your library specifically supports a [`no_std`](about:blank/reference/names/preludes.html#the-no_std-attribute) environment, it is a breaking change to make a new release that requires `std`.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\n#![no_std]\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// After\npub fn foo() {\n    std::time::SystemTime::now();\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\n// This will fail to link for no_std targets because they don't have a `std` crate.\n#![no_std]\nuse updated_crate::foo;\n\nfn example() {\n    foo();\n}\n```\n\nMitigation strategies:\n\n-   A common idiom to avoid this is to include a `std` [Cargo feature](features.html) that optionally enables `std` support, and when the feature is off, the library can be used in a `no_std` environment.\n\n### [Major: adding `non_exhaustive` to an existing enum, variant, or struct with no private fields](#attr-adding-non-exhaustive)\n\nMaking items [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) changes how they may be used outside the crate where they are defined:\n\n-   Non-exhaustive structs and enum variants cannot be constructed using [struct literal](../../reference/expressions/struct-expr.html) syntax, including [functional update syntax](about:blank/reference/expressions/struct-expr.html#functional-update-syntax).\n-   Pattern matching on non-exhaustive structs requires `..` and matching on enums does not count towards exhaustiveness.\n-   Casting enum variants to their discriminant with `as` is not allowed.\n\nStructs with private fields cannot be constructed using [struct literal](../../reference/expressions/struct-expr.html) syntax regardless of whether [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) is used. Adding [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) to such a struct is not a breaking change.\n\n```rust\n// MAJOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub struct Foo {\n    pub bar: usize,\n}\n\npub enum Bar {\n    X,\n    Y(usize),\n    Z { a: usize },\n}\n\npub enum Quux {\n    Var,\n}\n\n///////////////////////////////////////////////////////////\n// After\n#[non_exhaustive]\npub struct Foo {\n    pub bar: usize,\n}\n\npub enum Bar {\n    #[non_exhaustive]\n    X,\n\n    #[non_exhaustive]\n    Y(usize),\n\n    #[non_exhaustive]\n    Z { a: usize },\n}\n\n#[non_exhaustive]\npub enum Quux {\n    Var,\n}\n\n///////////////////////////////////////////////////////////\n// Example usage that will break.\nuse updated_crate::{Bar, Foo, Quux};\n\nfn main() {\n    let foo = Foo { bar: 0 }; // Error: cannot create non-exhaustive struct using struct expression\n\n    let bar_x = Bar::X; // Error: unit variant `X` is private\n    let bar_y = Bar::Y(0); // Error: tuple variant `Y` is private\n    let bar_z = Bar::Z { a: 0 }; // Error: cannot create non-exhaustive variant using struct expression\n\n    let q = Quux::Var;\n    match q {\n        Quux::Var => 0,\n        // Error: non-exhaustive patterns: `_` not covered\n    };\n}\n```\n\nMitigation strategies:\n\n-   Mark structs, enums, and enum variants as [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) when first introducing them, rather than adding [`#[non_exhaustive]`](about:blank/reference/attributes/type_system.html#the-non_exhaustive-attribute) later on.\n\n### [Possibly-breaking: changing the minimum version of Rust required](#env-new-rust)\n\nIntroducing the use of new features in a new release of Rust can break projects that are using older versions of Rust. This also includes using new features in a new release of Cargo, and requiring the use of a nightly-only feature in a crate that previously worked on stable.\n\nIt is generally recommended to treat this as a minor change, rather than as a major change, for [various reasons](https://github.com/rust-lang/api-guidelines/discussions/231). It is usually relatively easy to update to a newer version of Rust. Rust also has a rapid 6-week release cycle, and some projects will provide compatibility within a window of releases (such as the current stable release plus N previous releases). Just keep in mind that some large projects may not be able to update their Rust toolchain rapidly.\n\nMitigation strategies:\n\n-   Use [Cargo features](features.html) to make the new features opt-in.\n-   Provide a large window of support for older releases.\n-   Copy the source of new standard library items if possible so that you can continue to use an older version but take advantage of the new feature.\n-   Provide a separate branch of older minor releases that can receive backports of important bugfixes.\n-   Keep an eye out for the [`[cfg(version(..))]`](https://github.com/rust-lang/rust/issues/64796) and [`#[cfg(accessible(..))]`](https://github.com/rust-lang/rust/issues/64797) features which provide an opt-in mechanism for new features. These are currently unstable and only available in the nightly channel.\n\n### [Possibly-breaking: changing the platform and environment requirements](#env-change-requirements)\n\nThere is a very wide range of assumptions a library makes about the environment that it runs in, such as the host platform, operating system version, available services, filesystem support, etc. It can be a breaking change if you make a new release that restricts what was previously supported, for example requiring a newer version of an operating system. These changes can be difficult to track, since you may not always know if a change breaks in an environment that is not automatically tested.\n\nSome projects may deem this acceptable breakage, particularly if the breakage is unlikely for most users, or the project doesn’t have the resources to support all environments. Another notable situation is when a vendor discontinues support for some hardware or OS, the project may deem it reasonable to also discontinue support.\n\nMitigation strategies:\n\n-   Document the platforms and environments you specifically support.\n-   Test your code on a wide range of environments in CI.\n\n### [Minor: introducing new lints](#new-lints)\n\nSome changes to a library may cause new lints to be triggered in users of that library. This should generally be considered a compatible change.\n\n```rust\n// MINOR CHANGE\n\n///////////////////////////////////////////////////////////\n// Before\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// After\n#[deprecated]\npub fn foo() {}\n\n///////////////////////////////////////////////////////////\n// Example use of the library that will safely work.\n\nfn main() {\n    updated_crate::foo(); // Warning: use of deprecated function\n}\n```\n\nBeware that it may be possible for this to technically cause a project to fail if they have explicitly denied the warning, and the updated crate is a direct dependency. Denying warnings should be done with care and the understanding that new lints may be introduced over time. However, library authors should be cautious about introducing new warnings and may want to consider the potential impact on their users.\n\nThe following lints are examples of those that may be introduced when updating a dependency:\n\n-   [`deprecated`](about:blank/rustc/lints/listing/warn-by-default.html#deprecated) — Introduced when a dependency adds the [`#[deprecated]` attribute](about:blank/reference/attributes/diagnostics.html#the-deprecated-attribute) to an item you are using.\n-   [`unused_must_use`](about:blank/rustc/lints/listing/warn-by-default.html#unused-must-use) — Introduced when a dependency adds the [`#[must_use]` attribute](about:blank/reference/attributes/diagnostics.html#the-must_use-attribute) to an item where you are not consuming the result.\n-   [`unused_unsafe`](about:blank/rustc/lints/listing/warn-by-default.html#unused-unsafe) — Introduced when a dependency _removes_ the `unsafe` qualifier from a function, and that is the only unsafe function called in an unsafe block.\n\nAdditionally, updating `rustc` to a new version may introduce new lints.\n\nTransitive dependencies which introduce new lints should not usually cause a failure because Cargo uses [`--cap-lints`](about:blank/rustc/lints/levels.html#capping-lints) to suppress all lints in dependencies.\n\nMitigating strategies:\n\n-   If you build with warnings denied, understand you may need to deal with resolving new warnings whenever you update your dependencies. If using RUSTFLAGS to pass `-Dwarnings`, also add the `-A` flag to allow lints that are likely to cause issues, such as `-Adeprecated`.\n-   Introduce deprecations behind a [feature](features.html). For example `#[cfg_attr(feature = \"deprecated\", deprecated=\"use bar instead\")]`. Then, when you plan to remove an item in a future SemVer breaking change, you can communicate with your users that they should enable the `deprecated` feature _before_ updating to remove the use of the deprecated items. This allows users to choose when to respond to deprecations without needing to immediately respond to them. A downside is that it can be difficult to communicate to users that they need to take these manual steps to prepare for a major update.\n\n### [Cargo](#cargo)\n\n#### [Minor: adding a new Cargo feature](#cargo-feature-add)\n\nIt is usually safe to add new [Cargo features](features.html). If the feature introduces new changes that cause a breaking change, this can cause difficulties for projects that have stricter backwards-compatibility needs. In that scenario, avoid adding the feature to the “default” list, and possibly document the consequences of enabling the feature.\n\n```toml\n# MINOR CHANGE\n\n###########################################################\n# Before\n[features]\n# ..empty\n\n###########################################################\n# After\n[features]\nstd = []\n\n```\n\n#### [Major: removing a Cargo feature](#cargo-feature-remove)\n\nIt is usually a breaking change to remove [Cargo features](features.html). This will cause an error for any project that enabled the feature.\n\n```toml\n# MAJOR CHANGE\n\n###########################################################\n# Before\n[features]\nlogging = []\n\n###########################################################\n# After\n[dependencies]\n# ..logging removed\n\n```\n\nMitigation strategies:\n\n-   Clearly document your features. If there is an internal or experimental feature, mark it as such, so that users know the status of the feature.\n-   Leave the old feature in `Cargo.toml`, but otherwise remove its functionality. Document that the feature is deprecated, and remove it in a future major SemVer release.\n\n#### [Major: removing a feature from a feature list if that changes functionality or public items](#cargo-feature-remove-another)\n\nIf removing a feature from another feature, this can break existing users if they are expecting that functionality to be available through that feature.\n\n```toml\n# Breaking change example\n\n###########################################################\n# Before\n[features]\ndefault = [\"std\"]\nstd = []\n\n###########################################################\n# After\n[features]\ndefault = []  # This may cause packages to fail if they are expecting std to be enabled.\nstd = []\n\n```\n\n#### [Possibly-breaking: removing an optional dependency](#cargo-remove-opt-dep)\n\nRemoving an [optional dependency](about:blank/features.html#optional-dependencies) can break a project using your library because another project may be enabling that dependency via [Cargo features](features.html).\n\nWhen there is an optional dependency, cargo implicitly defines a feature of the same name to provide a mechanism to enable the dependency and to check when it is enabled. This problem can be avoided by using the `dep:` syntax in the `[features]` table, which disables this implicit feature. Using `dep:` makes it possible to hide the existence of optional dependencies under more semantically-relevant names which can be more safely modified.\n\n```toml\n# Breaking change example\n\n###########################################################\n# Before\n[dependencies]\ncurl = { version = \"0.4.31\", optional = true }\n\n###########################################################\n# After\n[dependencies]\n# ..curl removed\n\n```\n\n```toml\n# MINOR CHANGE\n#\n# This example shows how to avoid breaking changes with optional dependencies.\n\n###########################################################\n# Before\n[dependencies]\ncurl = { version = \"0.4.31\", optional = true }\n\n[features]\nnetworking = [\"dep:curl\"]\n\n###########################################################\n# After\n[dependencies]\n# Here, one optional dependency was replaced with another.\nhyper = { version = \"0.14.27\", optional = true }\n\n[features]\nnetworking = [\"dep:hyper\"]\n\n```\n\nMitigation strategies:\n\n-   Use the `dep:` syntax in the `[features]` table to avoid exposing optional dependencies in the first place. See [optional dependencies](about:blank/features.html#optional-dependencies) for more information.\n-   Clearly document your features. If the optional dependency is not included in the documented list of features, then you may decide to consider it safe to change undocumented entries.\n-   Leave the optional dependency, and just don’t use it within your library.\n-   Replace the optional dependency with a [Cargo feature](features.html) that does nothing, and document that it is deprecated.\n-   Use high-level features which enable optional dependencies, and document those as the preferred way to enable the extended functionality. For example, if your library has optional support for something like “networking”, create a generic feature name “networking” that enables the optional dependencies necessary to implement “networking”. Then document the “networking” feature.\n\n#### [Minor: changing dependency features](#cargo-change-dep-feature)\n\nIt is usually safe to change the features on a dependency, as long as the feature does not introduce a breaking change.\n\n```toml\n# MINOR CHANGE\n\n###########################################################\n# Before\n[dependencies]\nrand = { version = \"0.7.3\", features = [\"small_rng\"] }\n\n\n###########################################################\n# After\n[dependencies]\nrand = \"0.7.3\"\n\n```\n\n#### [Minor: adding dependencies](#cargo-dep-add)\n\nIt is usually safe to add new dependencies, as long as the new dependency does not introduce new requirements that result in a breaking change. For example, adding a new dependency that requires nightly in a project that previously worked on stable is a major change.\n\n```toml\n# MINOR CHANGE\n\n###########################################################\n# Before\n[dependencies]\n# ..empty\n\n###########################################################\n# After\n[dependencies]\nlog = \"0.4.11\"\n\n```\n\n## [Application compatibility](#application-compatibility)\n\nCargo projects may also include executable binaries which have their own interfaces (such as a CLI interface, OS-level interaction, etc.). Since these are part of the Cargo package, they often use and share the same version as the package. You will need to decide if and how you want to employ a SemVer contract with your users in the changes you make to your application. The potential breaking and compatible changes to an application are too numerous to list, so you are encouraged to use the spirit of the [SemVer](https://semver.org/) spec to guide your decisions on how to apply versioning to your application, or at least document what your commitments are.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>SemVer Compatibility - The Cargo Book</title>\n\n\n        <!-- Custom HTML head -->\n        <style>\n            dd {\n                margin-bottom: 1em;\n            }\n        </style>\n\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../index.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../getting-started/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../getting-started/installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"../getting-started/first-steps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> First Steps with Cargo</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../guide/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Cargo Guide</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../guide/why-cargo-exists.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Why Cargo Exists</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/creating-a-new-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Creating a New Package</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/working-on-an-existing-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Working on an Existing Package</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Dependencies</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/project-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Package Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/cargo-toml-vs-cargo-lock.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.7.</strong> Tests</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/continuous-integration.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.8.</strong> Continuous Integration</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/cargo-home.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.9.</strong> Cargo Home</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/build-cache.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.10.</strong> Build Cache</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Cargo Reference</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/specifying-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Specifying Dependencies</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/overriding-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.1.</strong> Overriding Dependencies</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/manifest.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> The Manifest Format</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/cargo-targets.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.1.</strong> Cargo Targets</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/features-examples.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.1.</strong> Features Examples</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/config.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Configuration</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/build-scripts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Build Scripts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/build-script-examples.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.1.</strong> Build Script Examples</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/publishing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Publishing on crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/pkgid-spec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> Package ID Specifications</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/source-replacement.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Source Replacement</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/external-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.12.</strong> External Tools</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/registries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.</strong> Registries</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/registry-authentication.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.1.</strong> Registry Authentication</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/credential-provider-protocol.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.1.1.</strong> Credential Provider Protocol</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/running-a-registry.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.2.</strong> Running a Registry</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/registry-index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.2.1.</strong> Registry Index</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/registry-web-api.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.2.2.</strong> Registry Web API</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/resolver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.14.</strong> Dependency Resolution</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/semver.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.15.</strong> SemVer Compatibility</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/future-incompat-report.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.16.</strong> Future incompat report</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/timings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.17.</strong> Reporting build timings</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/unstable.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.18.</strong> Unstable Features</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Cargo Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/general-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> General Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.1.</strong> cargo</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-help.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.2.</strong> cargo help</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-version.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.3.</strong> cargo version</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/build-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Build Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-bench.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.1.</strong> cargo bench</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-build.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.2.</strong> cargo build</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-check.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.3.</strong> cargo check</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-clean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.4.</strong> cargo clean</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-doc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.5.</strong> cargo doc</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-fetch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.6.</strong> cargo fetch</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-fix.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.7.</strong> cargo fix</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-run.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.8.</strong> cargo run</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-rustc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.9.</strong> cargo rustc</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-rustdoc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.10.</strong> cargo rustdoc</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-test.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.11.</strong> cargo test</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-report.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.12.</strong> cargo report</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/manifest-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Manifest Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-add.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.1.</strong> cargo add</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-generate-lockfile.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.2.</strong> cargo generate-lockfile</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-locate-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.3.</strong> cargo locate-project</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-metadata.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.4.</strong> cargo metadata</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-pkgid.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.5.</strong> cargo pkgid</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.6.</strong> cargo remove</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.7.</strong> cargo tree</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-update.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.8.</strong> cargo update</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-vendor.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.9.</strong> cargo vendor</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-verify-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.10.</strong> cargo verify-project</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/package-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Package Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-init.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.1.</strong> cargo init</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-install.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.2.</strong> cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-new.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.3.</strong> cargo new</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-search.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.4.</strong> cargo search</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-uninstall.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/publishing-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Publishing Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-login.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.1.</strong> cargo login</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-logout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.2.</strong> cargo logout</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-owner.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.3.</strong> cargo owner</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-package.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.4.</strong> cargo package</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-publish.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.5.</strong> cargo publish</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-yank.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.6.</strong> cargo yank</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../faq.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> FAQ</a></li><li class=\"chapter-item expanded \"><a href=\"../appendix/glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Appendix: Glossary</a></li><li class=\"chapter-item expanded \"><a href=\"../appendix/git-authentication.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Appendix: Git Authentication</a></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Cargo Book</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/cargo/tree/master/src/doc/src\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/semver.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"semver-compatibility\"><a class=\"header\" href=\"#semver-compatibility\">SemVer Compatibility</a></h1>\n<p>This chapter provides details on what is conventionally considered a\ncompatible or breaking SemVer change for new releases of a package. See the\n<a href=\"resolver.html#semver-compatibility\">SemVer compatibility</a> section for details on what SemVer is, and how Cargo\nuses it to ensure compatibility of libraries.</p>\n<p>These are only <em>guidelines</em>, and not necessarily hard-and-fast rules that all\nprojects will obey. The <a href=\"#change-categories\">Change categories</a> section details how this guide\nclassifies the level and severity of a change. Most of this guide focuses on\nchanges that will cause <code class=\"hljs\">cargo</code> and <code class=\"hljs\">rustc</code> to fail to build something that\npreviously worked. Almost every change carries some risk that it will\nnegatively affect the runtime behavior, and for those cases it is usually a\njudgment call by the project maintainers whether or not it is a\nSemVer-incompatible change.</p>\n<h2 id=\"change-categories\"><a class=\"header\" href=\"#change-categories\">Change categories</a></h2>\n<p>All of the policies listed below are categorized by the level of change:</p>\n<ul>\n<li><strong>Major change</strong>: a change that requires a major SemVer bump.</li>\n<li><strong>Minor change</strong>: a change that requires only a minor SemVer bump.</li>\n<li><strong>Possibly-breaking change</strong>: a change that some projects may consider major\nand others consider minor.</li>\n</ul>\n<p>The “Possibly-breaking” category covers changes that have the <em>potential</em> to\nbreak during an update, but may not necessarily cause a breakage. The impact\nof these changes should be considered carefully. The exact nature will depend\non the change and the principles of the project maintainers.</p>\n<p>Some projects may choose to only bump the patch number on a minor change. It\nis encouraged to follow the SemVer spec, and only apply bug fixes in patch\nreleases. However, a bug fix may require an API change that is marked as a\n“minor change”, and shouldn’t affect compatibility. This guide does not take a\nstance on how each individual “minor change” should be treated, as the\ndifference between minor and patch changes are conventions that depend on the\nnature of the change.</p>\n<p>Some changes are marked as “minor”, even though they carry the potential risk\nof breaking a build. This is for situations where the potential is extremely\nlow, and the potentially breaking code is unlikely to be written in idiomatic\nRust, or is specifically discouraged from use.</p>\n<p>This guide uses the terms “major” and “minor” assuming this relates to a\n“1.0.0” release or later. Initial development releases starting with “0.y.z”\ncan treat changes in “y” as a major release, and “z” as a minor release.\n“0.0.z” releases are always major changes. This is because Cargo uses the\nconvention that only changes in the left-most non-zero component are\nconsidered incompatible.</p>\n<ul>\n<li>API compatibility\n<ul>\n<li>Items\n<ul>\n<li><a href=\"#item-remove\">Major: renaming/moving/removing any public items</a></li>\n<li><a href=\"#item-new\">Minor: adding new public items</a></li>\n</ul>\n</li>\n<li>Types\n<ul>\n<li><a href=\"#type-layout\">Major: Changing the alignment, layout, or size of a well-defined type</a></li>\n</ul>\n</li>\n<li>Structs\n<ul>\n<li><a href=\"#struct-add-private-field-when-public\">Major: adding a private struct field when all current fields are public</a></li>\n<li><a href=\"#struct-add-public-field-when-no-private\">Major: adding a public field when no private field exists</a></li>\n<li><a href=\"#struct-private-fields-with-private\">Minor: adding or removing private fields when at least one already exists</a></li>\n<li><a href=\"#struct-tuple-normal-with-private\">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></li>\n</ul>\n</li>\n<li>Enums\n<ul>\n<li><a href=\"#enum-variant-new\">Major: adding new enum variants (without <code class=\"hljs\">non_exhaustive</code>)</a></li>\n<li><a href=\"#enum-fields-new\">Major: adding new fields to an enum variant</a></li>\n</ul>\n</li>\n<li>Traits\n<ul>\n<li><a href=\"#trait-new-item-no-default\">Major: adding a non-defaulted trait item</a></li>\n<li><a href=\"#trait-item-signature\">Major: any change to trait item signatures</a></li>\n<li><a href=\"#trait-new-default-item\">Possibly-breaking: adding a defaulted trait item</a></li>\n<li><a href=\"#trait-object-safety\">Major: adding a trait item that makes the trait non-object safe</a></li>\n<li><a href=\"#trait-new-parameter-no-default\">Major: adding a type parameter without a default</a></li>\n<li><a href=\"#trait-new-parameter-default\">Minor: adding a defaulted trait type parameter</a></li>\n</ul>\n</li>\n<li>Implementations\n<ul>\n<li><a href=\"#impl-item-new\">Possibly-breaking change: adding any inherent items</a></li>\n</ul>\n</li>\n<li>Generics\n<ul>\n<li><a href=\"#generic-bounds-tighten\">Major: tightening generic bounds</a></li>\n<li><a href=\"#generic-bounds-loosen\">Minor: loosening generic bounds</a></li>\n<li><a href=\"#generic-new-default\">Minor: adding defaulted type parameters</a></li>\n<li><a href=\"#generic-generalize-identical\">Minor: generalizing a type to use generics (with identical types)</a></li>\n<li><a href=\"#generic-generalize-different\">Major: generalizing a type to use generics (with possibly different types)</a></li>\n<li><a href=\"#generic-more-generic\">Minor: changing a generic type to a more generic type</a></li>\n</ul>\n</li>\n<li>Functions\n<ul>\n<li><a href=\"#fn-change-arity\">Major: adding/removing function parameters</a></li>\n<li><a href=\"#fn-generic-new\">Possibly-breaking: introducing a new function type parameter</a></li>\n<li><a href=\"#fn-generalize-compatible\">Minor: generalizing a function to use generics (supporting original type)</a></li>\n<li><a href=\"#fn-generalize-mismatch\">Major: generalizing a function to use generics with type mismatch</a></li>\n<li><a href=\"#fn-unsafe-safe\">Minor: making an <code class=\"hljs\">unsafe</code> function safe</a></li>\n</ul>\n</li>\n<li>Attributes\n<ul>\n<li><a href=\"#attr-no-std-to-std\">Major: switching from <code class=\"hljs\">no_std</code> support to requiring <code class=\"hljs\">std</code></a></li>\n<li><a href=\"#attr-adding-non-exhaustive\">Major: adding <code class=\"hljs\">non_exhaustive</code> to an existing enum, variant, or struct with no private fields</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Tooling and environment compatibility\n<ul>\n<li><a href=\"#env-new-rust\">Possibly-breaking: changing the minimum version of Rust required</a></li>\n<li><a href=\"#env-change-requirements\">Possibly-breaking: changing the platform and environment requirements</a></li>\n<li><a href=\"#new-lints\">Minor: introducing new lints</a></li>\n<li>Cargo\n<ul>\n<li><a href=\"#cargo-feature-add\">Minor: adding a new Cargo feature</a></li>\n<li><a href=\"#cargo-feature-remove\">Major: removing a Cargo feature</a></li>\n<li><a href=\"#cargo-feature-remove-another\">Major: removing a feature from a feature list if that changes functionality or public items</a></li>\n<li><a href=\"#cargo-remove-opt-dep\">Possibly-breaking: removing an optional dependency</a></li>\n<li><a href=\"#cargo-change-dep-feature\">Minor: changing dependency features</a></li>\n<li><a href=\"#cargo-dep-add\">Minor: adding dependencies</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#application-compatibility\">Application compatibility</a></li>\n</ul>\n<h2 id=\"api-compatibility\"><a class=\"header\" href=\"#api-compatibility\">API compatibility</a></h2>\n<p>All of the examples below contain three parts: the original code, the code\nafter it has been modified, and an example usage of the code that could appear\nin another project. In a minor change, the example usage should successfully\nbuild with both the before and after versions.</p>\n<h3 id=\"item-remove\"><a class=\"header\" href=\"#item-remove\">Major: renaming/moving/removing any public items</a></h3>\n<p>The absence of a publicly exposed <a href=\"../../reference/items.html\">item</a> will cause any uses of that item to\nfail to compile.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-comment\">// ... item has been removed</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    updated_crate::foo(); <span class=\"hljs-comment\">// Error: cannot find function `foo`</span>\n}</code></pre>\n<p>This includes adding any sort of <a href=\"../../reference/conditional-compilation.html#the-cfg-attribute\"><code class=\"hljs\">cfg</code> attribute</a> which can change which\nitems or behavior is available based on <a href=\"../../reference/conditional-compilation.html\">conditional compilation</a>.</p>\n<p>Mitigating strategies:</p>\n<ul>\n<li>Mark items to be removed as <a href=\"../../reference/attributes/diagnostics.html#the-deprecated-attribute\">deprecated</a>, and then remove them at a later\ndate in a SemVer-breaking release.</li>\n<li>Mark renamed items as <a href=\"../../reference/attributes/diagnostics.html#the-deprecated-attribute\">deprecated</a>, and use a <a href=\"../../reference/items/use-declarations.html\"><code class=\"hljs\">pub use</code></a> item to re-export\nto the old name.</li>\n</ul>\n<h3 id=\"item-new\"><a class=\"header\" href=\"#item-new\">Minor: adding new public items</a></h3>\n<p>Adding new, public <a href=\"../../reference/items.html\">items</a> is a minor change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-comment\">// ... absence of item</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-comment\">// `foo` is not used since it didn't previously exist.</span></code></pre>\n<p>Note that in some rare cases this can be a <strong>breaking change</strong> due to glob\nimports. For example, if you add a new trait, and a project has used a glob\nimport that brings that trait into scope, and the new trait introduces an\nassociated item that conflicts with any types it is implemented on, this can\ncause a compile-time error due to the ambiguity. Example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Breaking change example</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-comment\">// ... absence of trait</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">NewTrait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">impl</span> NewTrait <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">i32</span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::*;\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">LocalTrait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">impl</span> LocalTrait <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">i32</span> {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-number\">123i32</span>.foo(); <span class=\"hljs-comment\">// Error:  multiple applicable items in scope</span>\n}</code></pre>\n<p>This is not considered a major change because conventionally glob imports are\na known forwards-compatibility hazard. Glob imports of items from external\ncrates should be avoided.</p>\n<h3 id=\"type-layout\"><a class=\"header\" href=\"#type-layout\">Major: Changing the alignment, layout, or size of a well-defined type</a></h3>\n<p>It is a breaking change to change the alignment, layout, or size of a type that was previously well-defined.</p>\n<p>In general, types that use the <a href=\"../../reference/type-layout.html#the-default-representation\">the default representation</a> do not have a well-defined alignment, layout, or size.\nThe compiler is free to alter the alignment, layout, or size, so code should not make any assumptions about it.</p>\n<blockquote>\n<p><strong>Note</strong>: It may be possible for external crates to break if they make assumptions about the alignment, layout, or size of a type even if it is not well-defined.\nThis is not considered a SemVer breaking change since those assumptions should not be made.</p>\n</blockquote>\n<p>Some examples of changes that are not a breaking change are (assuming no other rules in this guide are violated):</p>\n<ul>\n<li>Adding, removing, reordering, or changing fields of a default representation struct, union, or enum in such a way that the change follows the other rules in this guide (for example, using <code class=\"hljs\">non_exhaustive</code> to allow those changes, or changes to private fields that are already private).\nSee <a href=\"#struct-add-private-field-when-public\">struct-add-private-field-when-public</a>, <a href=\"#struct-add-public-field-when-no-private\">struct-add-public-field-when-no-private</a>, <a href=\"#struct-private-fields-with-private\">struct-private-fields-with-private</a>, <a href=\"#enum-fields-new\">enum-fields-new</a>.</li>\n<li>Adding variants to a default representation enum, if the enum uses <code class=\"hljs\">non_exhaustive</code>.\nThis may change the alignment or size of the enumeration, but those are not well-defined.\nSee <a href=\"#enum-variant-new\">enum-variant-new</a>.</li>\n<li>Adding, removing, reordering, or changing private fields of a <code class=\"hljs\">repr(C)</code> struct, union, or enum, following the other rules in this guide (for example, using <code class=\"hljs\">non_exhaustive</code>, or adding private fields when other private fields already exist).\nSee <a href=\"#repr-c-private-change\">repr-c-private-change</a>.</li>\n<li>Adding variants to a <code class=\"hljs\">repr(C)</code> enum, if the enum uses <code class=\"hljs\">non_exhaustive</code>.\nSee <a href=\"#repr-c-enum-variant-new\">repr-c-enum-variant-new</a>.</li>\n<li>Adding <code class=\"hljs\">repr(C)</code> to a default representation struct, union, or enum.\nSee <a href=\"#repr-c-add\">repr-c-add</a>.</li>\n<li>Adding <code class=\"hljs\">repr(&lt;int&gt;)</code> <a href=\"../../reference/type-layout.html#primitive-representations\">primitive representation</a> to an enum.\nSee <a href=\"#repr-int-enum-add\">repr-int-enum-add</a>.</li>\n<li>Adding <code class=\"hljs\">repr(transparent)</code> to a default representation struct or enum.\nSee <a href=\"#repr-transparent-add\">repr-transparent-add</a>.</li>\n</ul>\n<p>Types that use the <a href=\"../../reference/type-layout.html#representations\"><code class=\"hljs\">repr</code> attribute</a> can be said to have an alignment and layout that is defined in some way that code may make some assumptions about that may break as a result of changing that type.</p>\n<p>In some cases, types with a <code class=\"hljs\">repr</code> attribute may not have an alignment, layout, or size that is well-defined.\nIn these cases, it may be safe to make changes to the types, though care should be exercised.\nFor example, types with private fields that do not otherwise document their alignment, layout, or size guarantees cannot be relied upon by external crates since the public API does not fully define the alignment, layout, or size of the type.</p>\n<p>A common example where a type with <em>private</em> fields is well-defined is a type with a single private field with a generic type, using <code class=\"hljs\">repr(transparent)</code>,\nand the prose of the documentation discusses that it is transparent to the generic type.\nFor example, see <a href=\"../../std/cell/struct.UnsafeCell.html#memory-layout\"><code class=\"hljs\">UnsafeCell</code></a>.</p>\n<p>Some examples of breaking changes are:</p>\n<ul>\n<li>Adding <code class=\"hljs\">repr(packed)</code> to a struct or union.\nSee <a href=\"#repr-packed-add\">repr-packed-add</a>.</li>\n<li>Adding <code class=\"hljs\">repr(align)</code> to a struct, union, or enum.\nSee <a href=\"#repr-align-add\">repr-align-add</a>.</li>\n<li>Removing <code class=\"hljs\">repr(packed)</code> from a struct or union.\nSee <a href=\"#repr-packed-remove\">repr-packed-remove</a>.</li>\n<li>Changing the value N of <code class=\"hljs\">repr(packed(N))</code> if that changes the alignment or layout.\nSee <a href=\"#repr-packed-n-change\">repr-packed-n-change</a>.</li>\n<li>Changing the value N of <code class=\"hljs\">repr(align(N))</code> if that changes the alignment.\nSee <a href=\"#repr-align-n-change\">repr-align-n-change</a>.</li>\n<li>Removing <code class=\"hljs\">repr(align)</code> from a struct, union, or enum.\nSee <a href=\"#repr-align-remove\">repr-align-remove</a>.</li>\n<li>Changing the order of public fields of a <code class=\"hljs\">repr(C)</code> type.\nSee <a href=\"#repr-c-shuffle\">repr-c-shuffle</a>.</li>\n<li>Removing <code class=\"hljs\">repr(C)</code> from a struct, union, or enum.\nSee <a href=\"#repr-c-remove\">repr-c-remove</a>.</li>\n<li>Removing <code class=\"hljs\">repr(&lt;int&gt;)</code> from an enum.\nSee <a href=\"#repr-int-enum-remove\">repr-int-enum-remove</a>.</li>\n<li>Changing the primitive representation of a <code class=\"hljs\">repr(&lt;int&gt;)</code> enum.\nSee <a href=\"#repr-int-enum-change\">repr-int-enum-change</a>.</li>\n<li>Removing <code class=\"hljs\">repr(transparent)</code> from a struct or enum.\nSee <a href=\"#repr-transparent-remove\">repr-transparent-remove</a>.</li>\n</ul>\n<h4 id=\"repr-c-private-change\"><a class=\"header\" href=\"#repr-c-private-change\">Minor: <code>repr(C)</code> add, remove, or change a private field</a></h4>\n<p>It is usually safe to add, remove, or change a private field of a <code class=\"hljs\">repr(C)</code> struct, union, or enum, assuming it follows the other guidelines in this guide (see <a href=\"#struct-add-private-field-when-public\">struct-add-private-field-when-public</a>, <a href=\"#struct-add-public-field-when-no-private\">struct-add-public-field-when-no-private</a>, <a href=\"#struct-private-fields-with-private\">struct-private-fields-with-private</a>, <a href=\"#enum-fields-new\">enum-fields-new</a>).</p>\n<p>For example, adding private fields can only be done if there are already other private fields, or it is <code class=\"hljs\">non_exhaustive</code>.\nPublic fields may be added if there are private fields, or it is <code class=\"hljs\">non_exhaustive</code>, and the addition does not alter the layout of the other fields.</p>\n<p>However, this may change the size and alignment of the type.\nCare should be taken if the size or alignment changes.\nCode should not make assumptions about the size or alignment of types with private fields or <code class=\"hljs\">non_exhaustive</code> unless it has a documented size or alignment.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n    f2: <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-comment\">// a private field</span>\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n    f2: <span class=\"hljs-built_in\">i32</span>,\n    f3: <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-comment\">// a new field</span>\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> Users should not make assumptions about the size or alignment</span>\n    <span class=\"hljs-comment\">// since they are not documented.</span>\n    <span class=\"hljs-keyword\">let</span> f = updated_crate::Example::default();\n}</code></pre>\n<h4 id=\"repr-c-enum-variant-new\"><a class=\"header\" href=\"#repr-c-enum-variant-new\">Minor: <code>repr(C)</code> add enum variant</a></h4>\n<p>It is usually safe to add variants to a <code class=\"hljs\">repr(C)</code> enum, if the enum uses <code class=\"hljs\">non_exhaustive</code>.\nSee <a href=\"#enum-variant-new\">enum-variant-new</a> for more discussion.</p>\n<p>Note that this may be a breaking change since it changes the size and alignment of the type.\nSee <a href=\"#repr-c-private-change\">repr-c-private-change</a> for similar concerns.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[non_exhaustive]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Example</span></span> {\n    Variant1 { f1: <span class=\"hljs-built_in\">i16</span> },\n    Variant2 { f1: <span class=\"hljs-built_in\">i32</span> },\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-meta\">#[non_exhaustive]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Example</span></span> {\n    Variant1 { f1: <span class=\"hljs-built_in\">i16</span> },\n    Variant2 { f1: <span class=\"hljs-built_in\">i32</span> },\n    Variant3 { f1: <span class=\"hljs-built_in\">i64</span> }, <span class=\"hljs-comment\">// added</span>\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> Users should not make assumptions about the size or alignment</span>\n    <span class=\"hljs-comment\">// since they are not specified. For example, this raised the size from 8</span>\n    <span class=\"hljs-comment\">// to 16 bytes.</span>\n    <span class=\"hljs-keyword\">let</span> f = updated_crate::Example::Variant2 { f1: <span class=\"hljs-number\">123</span> };\n}</code></pre>\n<h4 id=\"repr-c-add\"><a class=\"header\" href=\"#repr-c-add\">Minor: Adding <code>repr(C)</code> to a default representation</a></h4>\n<p>It is safe to add <code class=\"hljs\">repr(C)</code> to a struct, union, or enum with <a href=\"../../reference/type-layout.html#the-default-representation\">the default representation</a>.\nThis is safe because users should not make assumptions about the alignment, layout, or size of types with with the default representation.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n    <span class=\"hljs-keyword\">pub</span> f2: <span class=\"hljs-built_in\">i16</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(C)]</span> <span class=\"hljs-comment\">// added</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n    <span class=\"hljs-keyword\">pub</span> f2: <span class=\"hljs-built_in\">i16</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> f = updated_crate::Example { f1: <span class=\"hljs-number\">123</span>, f2: <span class=\"hljs-number\">456</span> };\n}</code></pre>\n<h4 id=\"repr-int-enum-add\"><a class=\"header\" href=\"#repr-int-enum-add\">Minor: Adding <code>repr(&lt;int&gt;)</code> to an enum</a></h4>\n<p>It is safe to add <code class=\"hljs\">repr(&lt;int&gt;)</code> <a href=\"../../reference/type-layout.html#primitive-representations\">primitive representation</a> to an enum with <a href=\"../../reference/type-layout.html#the-default-representation\">the default representation</a>.\nThis is safe because users should not make assumptions about the alignment, layout, or size of an enum with the default representation.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1,\n    Variant2(<span class=\"hljs-built_in\">i32</span>),\n    Variant3 { f1: <span class=\"hljs-built_in\">f64</span> },\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(i32)]</span> <span class=\"hljs-comment\">// added</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1,\n    Variant2(<span class=\"hljs-built_in\">i32</span>),\n    Variant3 { f1: <span class=\"hljs-built_in\">f64</span> },\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::E::Variant3 { f1: <span class=\"hljs-number\">1.23</span> };\n}</code></pre>\n<h4 id=\"repr-transparent-add\"><a class=\"header\" href=\"#repr-transparent-add\">Minor: Adding <code>repr(transparent)</code> to a default representation struct or enum</a></h4>\n<p>It is safe to add <code class=\"hljs\">repr(transparent)</code> to a struct or enum with <a href=\"../../reference/type-layout.html#the-default-representation\">the default representation</a>.\nThis is safe because users should not make assumptions about the alignment, layout, or size of a struct or enum with the default representation.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span>&lt;T&gt;(T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-meta\">#[repr(transparent)]</span> <span class=\"hljs-comment\">// added</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span>&lt;T&gt;(T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::Example::&lt;<span class=\"hljs-built_in\">i32</span>&gt;::default();\n}</code></pre>\n<h4 id=\"repr-packed-add\"><a class=\"header\" href=\"#repr-packed-add\">Major: Adding <code>repr(packed)</code> to a struct or union</a></h4>\n<p>It is a breaking change to add <code class=\"hljs\">repr(packed)</code> to a struct or union.\nMaking a type <code class=\"hljs\">repr(packed)</code> makes changes that can break code, such as being invalid to take a reference to a field, or causing truncation of disjoint closure captures.</p>\n<!-- TODO: If all fields are private, should this be safe to do? -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> f2: <span class=\"hljs-built_in\">u16</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(packed)]</span> <span class=\"hljs-comment\">// added</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> f2: <span class=\"hljs-built_in\">u16</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> f = updated_crate::Example { f1: <span class=\"hljs-number\">1</span>, f2: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-keyword\">let</span> x = &amp;f.f2; <span class=\"hljs-comment\">// Error: reference to packed field is unaligned</span>\n}</code></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span>(<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(packed)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Example</span></span>(<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> f = updated_crate::Example(<span class=\"hljs-number\">123</span>, <span class=\"hljs-number\">456</span>);\n    <span class=\"hljs-keyword\">let</span> c = || {\n        <span class=\"hljs-comment\">// Without repr(packed), the closure precisely captures `&amp;f.0`.</span>\n        <span class=\"hljs-comment\">// With repr(packed), the closure captures `&amp;f` to avoid undefined behavior.</span>\n        <span class=\"hljs-keyword\">let</span> a = f.<span class=\"hljs-number\">0</span>;\n    };\n    f.<span class=\"hljs-number\">1</span> = <span class=\"hljs-number\">789</span>; <span class=\"hljs-comment\">// Error: cannot assign to `f.1` because it is borrowed</span>\n    c();\n}</code></pre>\n<h4 id=\"repr-align-add\"><a class=\"header\" href=\"#repr-align-add\">Major: Adding <code>repr(align)</code> to a struct, union, or enum</a></h4>\n<p>It is a breaking change to add <code class=\"hljs\">repr(align)</code> to a struct, union, or enum.\nMaking a type <code class=\"hljs\">repr(align)</code> would break any use of that type in a <code class=\"hljs\">repr(packed)</code> type because that combination is not allowed.</p>\n<!-- TODO: This seems like it should be extraordinarily rare. Should there be any exceptions carved out for this? -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Aligned</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(align(8))]</span> <span class=\"hljs-comment\">// added</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Aligned</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Aligned;\n\n<span class=\"hljs-meta\">#[repr(packed)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> { <span class=\"hljs-comment\">// Error: packed type cannot transitively contain a `#[repr(align)]` type</span>\n    f1: Aligned,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Packed {\n        f1: Aligned { a: <span class=\"hljs-number\">123</span> },\n    };\n}</code></pre>\n<h4 id=\"repr-packed-remove\"><a class=\"header\" href=\"#repr-packed-remove\">Major: Removing <code>repr(packed)</code> from a struct or union</a></h4>\n<p>It is a breaking change to remove <code class=\"hljs\">repr(packed)</code> from a struct or union.\nThis may change the alignment or layout that extern crates are relying on.</p>\n<p>If any fields are public, then removing <code class=\"hljs\">repr(packed)</code> may change the way disjoint closure captures work.\nIn some cases, this can cause code to break, similar to those outlined in the <a href=\"../../edition-guide/rust-2021/disjoint-capture-in-closures.html\">edition guide</a>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(C, packed)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u16</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(C)]</span> <span class=\"hljs-comment\">// removed packed</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u16</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Packed;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Packed { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-comment\">// Some assumption about the size of the type.</span>\n    <span class=\"hljs-comment\">// Without `packed`, this fails since the size is 4.</span>\n    <span class=\"hljs-keyword\">const</span> _: () = <span class=\"hljs-built_in\">assert!</span>(std::mem::size_of::&lt;Packed&gt;() == <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// Error: evaluation of constant value failed</span>\n}</code></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(C, packed)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">i32</span>,\n}\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> Packed {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(C)]</span> <span class=\"hljs-comment\">// removed packed</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">i32</span>,\n}\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> Packed {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Packed;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">123</span>;\n\n    <span class=\"hljs-keyword\">let</span> p = Packed {\n        a: &amp;<span class=\"hljs-keyword\">mut</span> x <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>,\n        b: <span class=\"hljs-number\">456</span>,\n    };\n\n    <span class=\"hljs-comment\">// When the structure was packed, the closure captures `p` which is Send.</span>\n    <span class=\"hljs-comment\">// When `packed` is removed, this ends up capturing `p.a` which is not Send.</span>\n    std::thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">unsafe</span> {\n        *(p.a) += <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Error: cannot be sent between threads safely</span>\n    });\n}</code></pre>\n<h4 id=\"repr-packed-n-change\"><a class=\"header\" href=\"#repr-packed-n-change\">Major: Changing the value N of <code>repr(packed(N))</code> if that changes the alignment or layout</a></h4>\n<p>It is a breaking change to change the value of N of <code class=\"hljs\">repr(packed(N))</code> if that changes the alignment or layout.\nThis may change the alignment or layout that external crates are relying on.</p>\n<p>If the value <code class=\"hljs\">N</code> is lowered below the alignment of a public field, then that would break any code that attempts to take a reference of that field.</p>\n<p>Note that some changes to <code class=\"hljs\">N</code> may not change the alignment or layout, for example increasing it when the current value is already equal to the natural alignment of the type.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(packed(4))]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(packed(2))]</span> <span class=\"hljs-comment\">// changed to 2</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Packed;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Packed { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-keyword\">let</span> x = &amp;p.b; <span class=\"hljs-comment\">// Error: reference to packed field is unaligned</span>\n}</code></pre>\n<h4 id=\"repr-align-n-change\"><a class=\"header\" href=\"#repr-align-n-change\">Major: Changing the value N of <code>repr(align(N))</code> if that changes the alignment</a></h4>\n<p>It is a breaking change to change the value <code class=\"hljs\">N</code> of <code class=\"hljs\">repr(align(N))</code> if that changes the alignment.\nThis may change the alignment that external crates are relying on.</p>\n<p>This change should be safe to make if the type is not well-defined as discussed in <a href=\"#type-layout\">type layout</a> (such as having any private fields and having an undocumented alignment or layout).</p>\n<p>Note that some changes to <code class=\"hljs\">N</code> may not change the alignment or layout, for example decreasing it when the current value is already equal to or less than the natural alignment of the type.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(align(8))]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(align(4))]</span> <span class=\"hljs-comment\">// changed to 4</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Packed;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Packed { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-comment\">// Some assumption about the size of the type.</span>\n    <span class=\"hljs-comment\">// The alignment has changed from 8 to 4.</span>\n    <span class=\"hljs-keyword\">const</span> _: () = <span class=\"hljs-built_in\">assert!</span>(std::mem::align_of::&lt;Packed&gt;() == <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// Error: evaluation of constant value failed</span>\n}</code></pre>\n<h4 id=\"repr-align-remove\"><a class=\"header\" href=\"#repr-align-remove\">Major: Removing <code>repr(align)</code> from a struct, union, or enum</a></h4>\n<p>It is a breaking change to remove <code class=\"hljs\">repr(align)</code> from a struct, union, or enum, if their layout was well-defined.\nThis may change the alignment or layout that external crates are relying on.</p>\n<p>This change should be safe to make if the type is not well-defined as discussed in <a href=\"#type-layout\">type layout</a> (such as having any private fields and having an undocumented alignment).</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(C, align(8))]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(C)]</span> <span class=\"hljs-comment\">// removed align</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Packed;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Packed { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-comment\">// Some assumption about the size of the type.</span>\n    <span class=\"hljs-comment\">// The alignment has changed from 8 to 4.</span>\n    <span class=\"hljs-keyword\">const</span> _: () = <span class=\"hljs-built_in\">assert!</span>(std::mem::align_of::&lt;Packed&gt;() == <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// Error: evaluation of constant value failed</span>\n}</code></pre>\n<h4 id=\"repr-c-shuffle\"><a class=\"header\" href=\"#repr-c-shuffle\">Major: Changing the order of public fields of a <code>repr(C)</code> type</a></h4>\n<p>It is a breaking change to change the order of public fields of a <code class=\"hljs\">repr(C)</code> type.\nExternal crates may be relying on the specific ordering of the fields.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore run-fail hljs hide-boring\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecificLayout</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecificLayout</span></span> {\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>, <span class=\"hljs-comment\">// changed order</span>\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::SpecificLayout;\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-comment\">// This C function is assuming a specific layout defined in a C header.</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">c_fn_get_b</span></span>(x: &amp;SpecificLayout) -&gt; <span class=\"hljs-built_in\">u32</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = SpecificLayout { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-keyword\">unsafe</span> { <span class=\"hljs-built_in\">assert_eq!</span>(c_fn_get_b(&amp;p), <span class=\"hljs-number\">2</span>) } <span class=\"hljs-comment\">// Error: value not equal to 2</span>\n}\n\n<span class=\"boring\"><span class=\"hljs-keyword\">mod</span> cdep {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// This simulates what would normally be something included from a build script.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// This definition would be in a C header.</span>\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[repr(C)]</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecificLayout</span></span> {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[no_mangle]</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">c_fn_get_b</span></span>(x: &amp;SpecificLayout) -&gt; <span class=\"hljs-built_in\">u32</span> {\n</span><span class=\"boring\">        x.b\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<h4 id=\"repr-c-remove\"><a class=\"header\" href=\"#repr-c-remove\">Major: Removing <code>repr(C)</code> from a struct, union, or enum</a></h4>\n<p>It is a breaking change to remove <code class=\"hljs\">repr(C)</code> from a struct, union, or enum.\nExternal crates may be relying on the specific layout of the type.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(C)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecificLayout</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-comment\">// removed repr(C)</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecificLayout</span></span> {\n    <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n    <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::SpecificLayout;\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-comment\">// This C function is assuming a specific layout defined in a C header.</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">c_fn_get_b</span></span>(x: &amp;SpecificLayout) -&gt; <span class=\"hljs-built_in\">u32</span>; <span class=\"hljs-comment\">// Error: is not FFI-safe</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = SpecificLayout { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };\n    <span class=\"hljs-keyword\">unsafe</span> { <span class=\"hljs-built_in\">assert_eq!</span>(c_fn_get_b(&amp;p), <span class=\"hljs-number\">2</span>) }\n}\n\n<span class=\"boring\"><span class=\"hljs-keyword\">mod</span> cdep {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// This simulates what would normally be something included from a build script.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">// This definition would be in a C header.</span>\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[repr(C)]</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SpecificLayout</span></span> {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">pub</span> a: <span class=\"hljs-built_in\">u8</span>,\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">pub</span> b: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[no_mangle]</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">c_fn_get_b</span></span>(x: &amp;SpecificLayout) -&gt; <span class=\"hljs-built_in\">u32</span> {\n</span><span class=\"boring\">        x.b\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<h4 id=\"repr-int-enum-remove\"><a class=\"header\" href=\"#repr-int-enum-remove\">Major: Removing <code>repr(&lt;int&gt;)</code> from an enum</a></h4>\n<p>It is a breaking change to remove <code class=\"hljs\">repr(&lt;int&gt;)</code> from an enum.\nExternal crates may be assuming that the discriminant is a specific size.\nFor example, <a href=\"../../std/mem/fn.transmute.html\"><code class=\"hljs\">std::mem::transmute</code></a> of an enum may fail.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(u16)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Example</span></span> {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-comment\">// removed repr(u16)</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Example</span></span> {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> e = updated_crate::Example::Variant2;\n    <span class=\"hljs-keyword\">let</span> i: <span class=\"hljs-built_in\">u16</span> = <span class=\"hljs-keyword\">unsafe</span> { std::mem::transmute(e) }; <span class=\"hljs-comment\">// Error: cannot transmute between types of different sizes</span>\n}</code></pre>\n<h4 id=\"repr-int-enum-change\"><a class=\"header\" href=\"#repr-int-enum-change\">Major: Changing the primitive representation of a <code>repr(&lt;int&gt;)</code> enum</a></h4>\n<p>It is a breaking change to change the primitive representation of a <code class=\"hljs\">repr(&lt;int&gt;)</code> enum.\nExternal crates may be assuming that the discriminant is a specific size.\nFor example, <a href=\"../../std/mem/fn.transmute.html\"><code class=\"hljs\">std::mem::transmute</code></a> of an enum may fail.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(u16)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Example</span></span> {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[repr(u8)]</span> <span class=\"hljs-comment\">// changed repr size</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Example</span></span> {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> e = updated_crate::Example::Variant2;\n    <span class=\"hljs-keyword\">let</span> i: <span class=\"hljs-built_in\">u16</span> = <span class=\"hljs-keyword\">unsafe</span> { std::mem::transmute(e) }; <span class=\"hljs-comment\">// Error: cannot transmute between types of different sizes</span>\n}</code></pre>\n<h4 id=\"repr-transparent-remove\"><a class=\"header\" href=\"#repr-transparent-remove\">Major: Removing <code>repr(transparent)</code> from a struct or enum</a></h4>\n<p>It is a breaking change to remove <code class=\"hljs\">repr(transparent)</code> from a struct or enum.\nExternal crates may be relying on the type having the alignment, layout, or size of the transparent field.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[repr(transparent)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Transparent</span></span>&lt;T&gt;(T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-comment\">// removed repr</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Transparent</span></span>&lt;T&gt;(T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-meta\">#![deny(improper_ctypes)]</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Transparent;\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">c_fn</span></span>() -&gt; Transparent&lt;<span class=\"hljs-built_in\">f64</span>&gt;; <span class=\"hljs-comment\">// Error: is not FFI-safe</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</code></pre>\n<h3 id=\"struct-add-private-field-when-public\"><a class=\"header\" href=\"#struct-add-private-field-when-public\">Major: adding a private struct field when all current fields are public</a></h3>\n<p>When a private field is added to a struct that previously had all public fields,\nthis will break any code that attempts to construct it with a <a href=\"../../reference/expressions/struct-expr.html\">struct literal</a>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n    f2: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::Foo { f1: <span class=\"hljs-number\">123</span> }; <span class=\"hljs-comment\">// Error: cannot construct `Foo`</span>\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Do not add new fields to all-public field structs.</li>\n<li>Mark structs as <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> when first introducing\na struct to prevent users from using struct literal syntax, and instead\nprovide a constructor method and/or <a href=\"../../std/default/trait.Default.html\">Default</a> implementation.</li>\n</ul>\n<h3 id=\"struct-add-public-field-when-no-private\"><a class=\"header\" href=\"#struct-add-public-field-when-no-private\">Major: adding a public field when no private field exists</a></h3>\n<p>When a public field is added to a struct that has all public fields, this will\nbreak any code that attempts to construct it with a <a href=\"../../reference/expressions/struct-expr.html\">struct literal</a>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-keyword\">pub</span> f1: <span class=\"hljs-built_in\">i32</span>,\n    <span class=\"hljs-keyword\">pub</span> f2: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::Foo { f1: <span class=\"hljs-number\">123</span> }; <span class=\"hljs-comment\">// Error: missing field `f2`</span>\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Do not add new new fields to all-public field structs.</li>\n<li>Mark structs as <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> when first introducing\na struct to prevent users from using struct literal syntax, and instead\nprovide a constructor method and/or <a href=\"../../std/default/trait.Default.html\">Default</a> implementation.</li>\n</ul>\n<h3 id=\"struct-private-fields-with-private\"><a class=\"header\" href=\"#struct-private-fields-with-private\">Minor: adding or removing private fields when at least one already exists</a></h3>\n<p>It is safe to add or remove private fields from a struct when the struct\nalready has at least one private field.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    f1: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    f2: <span class=\"hljs-built_in\">f64</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// Cannot access private fields.</span>\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::Foo::default();\n}</code></pre>\n<p>This is safe because existing code cannot use a <a href=\"../../reference/expressions/struct-expr.html\">struct literal</a> to construct\nit, nor exhaustively match its contents.</p>\n<p>Note that for tuple structs, this is a <strong>major change</strong> if the tuple contains\npublic fields, and the addition or removal of a private field changes the\nindex of any public field.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>(<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>(<span class=\"hljs-built_in\">f64</span>, <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::Foo::default();\n    <span class=\"hljs-keyword\">let</span> y = x.<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Error: is private</span>\n}</code></pre>\n<h3 id=\"struct-tuple-normal-with-private\"><a class=\"header\" href=\"#struct-tuple-normal-with-private\">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></h3>\n<p>Changing a tuple struct to a normal struct (or vice-versa) is safe if all\nfields are private.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>(<span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    f1: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// Cannot access private fields.</span>\n    <span class=\"hljs-keyword\">let</span> x = updated_crate::Foo::default();\n}</code></pre>\n<p>This is safe because existing code cannot use a <a href=\"../../reference/expressions/struct-expr.html\">struct literal</a> to construct\nit, nor match its contents.</p>\n<h3 id=\"enum-variant-new\"><a class=\"header\" href=\"#enum-variant-new\">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></h3>\n<p>It is a breaking change to add a new enum variant if the enum does not use the\n<a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> attribute.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1,\n    Variant2,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">use</span> updated_crate::E;\n    <span class=\"hljs-keyword\">let</span> x = E::Variant1;\n    <span class=\"hljs-keyword\">match</span> x { <span class=\"hljs-comment\">// Error: `E::Variant2` not covered</span>\n        E::Variant1 =&gt; {}\n    }\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>When introducing the enum, mark it as <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a>\nto force users to use <a href=\"../../reference/patterns.html#wildcard-pattern\">wildcard patterns</a> to catch new variants.</li>\n</ul>\n<h3 id=\"enum-fields-new\"><a class=\"header\" href=\"#enum-fields-new\">Major: adding new fields to an enum variant</a></h3>\n<p>It is a breaking change to add new fields to an enum variant because all\nfields are public, and constructors and matching will fail to compile.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1 { f1: <span class=\"hljs-built_in\">i32</span> },\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1 { f1: <span class=\"hljs-built_in\">i32</span>, f2: <span class=\"hljs-built_in\">i32</span> },\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">use</span> updated_crate::E;\n    <span class=\"hljs-keyword\">let</span> x = E::Variant1 { f1: <span class=\"hljs-number\">1</span> }; <span class=\"hljs-comment\">// Error: missing f2</span>\n    <span class=\"hljs-keyword\">match</span> x {\n        E::Variant1 { f1 } =&gt; {} <span class=\"hljs-comment\">// Error: missing f2</span>\n    }\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>When introducing the enum, mark the variant as <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">non_exhaustive</code></a>\nso that it cannot be constructed or matched without wildcards.\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore skip hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    <span class=\"hljs-meta\">#[non_exhaustive]</span>\n    Variant1{f1: <span class=\"hljs-built_in\">i32</span>}\n}</code></pre>\n</li>\n<li>When introducing the enum, use an explicit struct as a value, where you can\nhave control over the field visibility.\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore skip hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n   f1: <span class=\"hljs-built_in\">i32</span>,\n   f2: <span class=\"hljs-built_in\">i32</span>,\n}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">E</span></span> {\n    Variant1(Foo)\n}</code></pre>\n</li>\n</ul>\n<h3 id=\"trait-new-item-no-default\"><a class=\"header\" href=\"#trait-new-item-no-default\">Major: adding a non-defaulted trait item</a></h3>\n<p>It is a breaking change to add a non-defaulted item to a trait. This will\nbreak any implementors of the trait.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>);\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Trait;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}  <span class=\"hljs-comment\">// Error: not all trait items implemented</span></code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Always provide a default implementation or value for new associated trait\nitems.</li>\n<li>When introducing the trait, use the <a href=\"https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed\">sealed trait</a> technique to prevent\nusers outside of the crate from implementing the trait.</li>\n</ul>\n<h3 id=\"trait-item-signature\"><a class=\"header\" href=\"#trait-item-signature\">Major: any change to trait item signatures</a></h3>\n<p>It is a breaking change to make any change to a trait item signature. This can\nbreak external implementors of the trait.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">f</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, x: <span class=\"hljs-built_in\">i32</span>) {}\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-comment\">// For sealed traits or normal functions, this would be a minor change</span>\n    <span class=\"hljs-comment\">// because generalizing with generics strictly expands the possible uses.</span>\n    <span class=\"hljs-comment\">// But in this case, trait implementations must use the same signature.</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">f</span></span>&lt;V&gt;(&amp;<span class=\"hljs-keyword\">self</span>, x: V) {}\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Trait;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">f</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, x: <span class=\"hljs-built_in\">i32</span>) {}  <span class=\"hljs-comment\">// Error: trait declaration has 1 type parameter</span>\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Introduce new items with default implementations to cover the new\nfunctionality instead of modifying existing items.</li>\n<li>When introducing the trait, use the <a href=\"https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed\">sealed trait</a> technique to prevent\nusers outside of the crate from implementing the trait.</li>\n</ul>\n<h3 id=\"trait-new-default-item\"><a class=\"header\" href=\"#trait-new-default-item\">Possibly-breaking: adding a defaulted trait item</a></h3>\n<p>It is usually safe to add a defaulted trait item. However, this can sometimes\ncause a compile error. For example, this can introduce an ambiguity if a\nmethod of the same name exists in another trait.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Breaking change example</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Trait;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">LocalTrait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}\n<span class=\"hljs-keyword\">impl</span> LocalTrait <span class=\"hljs-keyword\">for</span> Foo {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = Foo;\n    x.foo(); <span class=\"hljs-comment\">// Error: multiple applicable items in scope</span>\n}</code></pre>\n<p>Note that this ambiguity does <em>not</em> exist for name collisions on <a href=\"../../reference/items/implementations.html#inherent-implementations\">inherent\nimplementations</a>, as they take priority over trait items.</p>\n<p>See <a href=\"#trait-object-safety\">trait-object-safety</a> for a special case to consider\nwhen adding trait items.</p>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Some projects may deem this acceptable breakage, particularly if the new\nitem name is unlikely to collide with any existing code. Choose names\ncarefully to help avoid these collisions. Additionally, it may be acceptable\nto require downstream users to add <a href=\"../../reference/expressions/call-expr.html#disambiguating-function-calls\">disambiguation syntax</a> to select the\ncorrect function when updating the dependency.</li>\n</ul>\n<h3 id=\"trait-object-safety\"><a class=\"header\" href=\"#trait-object-safety\">Major: adding a trait item that makes the trait non-object safe</a></h3>\n<p>It is a breaking change to add a trait item that changes the trait to not be\n<a href=\"../../reference/items/traits.html#object-safety\">object safe</a>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-comment\">// An associated const makes the trait not object-safe.</span>\n    <span class=\"hljs-keyword\">const</span> CONST: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">123</span>;\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Trait;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> obj: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Trait&gt; = <span class=\"hljs-built_in\">Box</span>::new(Foo); <span class=\"hljs-comment\">// Error: cannot be made into an object</span>\n}</code></pre>\n<p>It is safe to do the converse (making a non-object safe trait into a safe\none).</p>\n<h3 id=\"trait-new-parameter-no-default\"><a class=\"header\" href=\"#trait-new-parameter-no-default\">Major: adding a type parameter without a default</a></h3>\n<p>It is a breaking change to add a type parameter without a default to a trait.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span>&lt;T&gt; {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Trait;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}  <span class=\"hljs-comment\">// Error: missing generics</span></code></pre>\n<p>Mitigating strategies:</p>\n<ul>\n<li>See <a href=\"#trait-new-parameter-default\">adding a defaulted trait type parameter</a>.</li>\n</ul>\n<h3 id=\"trait-new-parameter-default\"><a class=\"header\" href=\"#trait-new-parameter-default\">Minor: adding a defaulted trait type parameter</a></h3>\n<p>It is safe to add a type parameter to a trait as long as it has a default.\nExternal implementors will use the default without needing to specify the\nparameter.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span>&lt;T = <span class=\"hljs-built_in\">i32</span>&gt; {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Trait;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}</code></pre>\n<h3 id=\"impl-item-new\"><a class=\"header\" href=\"#impl-item-new\">Possibly-breaking change: adding any inherent items</a></h3>\n<p>Usually adding inherent items to an implementation should be safe because\ninherent items take priority over trait items. However, in some cases the\ncollision can cause problems if the name is the same as an implemented trait\nitem with a different signature.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Breaking change example</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n\n<span class=\"hljs-keyword\">impl</span> Foo {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, x: <span class=\"hljs-built_in\">i32</span>) {}\n}\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = Foo;\n    x.foo(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Error: this method takes 0 arguments but 1 argument was supplied</span>\n}</code></pre>\n<p>Note that if the signatures match, there would not be a compile-time error,\nbut possibly a silent change in runtime behavior (because it is now executing\na different function).</p>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Some projects may deem this acceptable breakage, particularly if the new\nitem name is unlikely to collide with any existing code. Choose names\ncarefully to help avoid these collisions. Additionally, it may be acceptable\nto require downstream users to add <a href=\"../../reference/expressions/call-expr.html#disambiguating-function-calls\">disambiguation syntax</a> to select the\ncorrect function when updating the dependency.</li>\n</ul>\n<h3 id=\"generic-bounds-tighten\"><a class=\"header\" href=\"#generic-bounds-tighten\">Major: tightening generic bounds</a></h3>\n<p>It is a breaking change to tighten generic bounds on a type since this can\nbreak users expecting the looser bounds.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;A&gt; {\n    <span class=\"hljs-keyword\">pub</span> f1: A,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;A: <span class=\"hljs-built_in\">Eq</span>&gt; {\n    <span class=\"hljs-keyword\">pub</span> f1: A,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s = Foo { f1: <span class=\"hljs-number\">1.23</span> }; <span class=\"hljs-comment\">// Error: the trait bound `{float}: Eq` is not satisfied</span>\n}</code></pre>\n<h3 id=\"generic-bounds-loosen\"><a class=\"header\" href=\"#generic-bounds-loosen\">Minor: loosening generic bounds</a></h3>\n<p>It is safe to loosen the generic bounds on a type, as it only expands what is\nallowed.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;A: <span class=\"hljs-built_in\">Clone</span>&gt; {\n    <span class=\"hljs-keyword\">pub</span> f1: A,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;A&gt; {\n    <span class=\"hljs-keyword\">pub</span> f1: A,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s = Foo { f1: <span class=\"hljs-number\">123</span> };\n}</code></pre>\n<h3 id=\"generic-new-default\"><a class=\"header\" href=\"#generic-new-default\">Minor: adding defaulted type parameters</a></h3>\n<p>It is safe to add a type parameter to a type as long as it has a default. All\nexisting references will use the default without needing to specify the\nparameter.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[derive(Default)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;A = <span class=\"hljs-built_in\">i32</span>&gt; {\n    f1: A,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s: Foo = <span class=\"hljs-built_in\">Default</span>::default();\n}</code></pre>\n<h3 id=\"generic-generalize-identical\"><a class=\"header\" href=\"#generic-generalize-identical\">Minor: generalizing a type to use generics (with identical types)</a></h3>\n<p>A struct or enum field can change from a concrete type to a generic type\nparameter, provided that the change results in an identical type for all\nexisting use cases. For example, the following change is permitted:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>(<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">u8</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;T = <span class=\"hljs-built_in\">u8</span>&gt;(<span class=\"hljs-keyword\">pub</span> T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s: Foo = Foo(<span class=\"hljs-number\">123</span>);\n}</code></pre>\n<p>because existing uses of <code class=\"hljs\">Foo</code> are shorthand for <code class=\"hljs\">Foo&lt;u8&gt;</code> which yields the\nidentical field type.</p>\n<h3 id=\"generic-generalize-different\"><a class=\"header\" href=\"#generic-generalize-different\">Major: generalizing a type to use generics (with possibly different types)</a></h3>\n<p>Changing a struct or enum field from a concrete type to a generic type\nparameter can break if the type can change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;T = <span class=\"hljs-built_in\">u8</span>&gt;(<span class=\"hljs-keyword\">pub</span> T, <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-built_in\">u8</span>);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;T = <span class=\"hljs-built_in\">u8</span>&gt;(<span class=\"hljs-keyword\">pub</span> T, <span class=\"hljs-keyword\">pub</span> T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s: Foo&lt;<span class=\"hljs-built_in\">f32</span>&gt; = Foo(<span class=\"hljs-number\">3.14</span>, <span class=\"hljs-number\">123</span>); <span class=\"hljs-comment\">// Error: mismatched types</span>\n}</code></pre>\n<h3 id=\"generic-more-generic\"><a class=\"header\" href=\"#generic-more-generic\">Minor: changing a generic type to a more generic type</a></h3>\n<p>It is safe to change a generic type to a more generic one. For example, the\nfollowing adds a generic parameter that defaults to the original type, which\nis safe because all existing users will be using the same type for both\nfields, the defaulted parameter does not need to be specified.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;T&gt;(<span class=\"hljs-keyword\">pub</span> T, <span class=\"hljs-keyword\">pub</span> T);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;T, U = T&gt;(<span class=\"hljs-keyword\">pub</span> T, <span class=\"hljs-keyword\">pub</span> U);\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::Foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s: Foo&lt;<span class=\"hljs-built_in\">f32</span>&gt; = Foo(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">2.0</span>);\n}</code></pre>\n<h3 id=\"fn-change-arity\"><a class=\"header\" href=\"#fn-change-arity\">Major: adding/removing function parameters</a></h3>\n<p>Changing the arity of a function is a breaking change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(x: <span class=\"hljs-built_in\">i32</span>) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    updated_crate::foo(); <span class=\"hljs-comment\">// Error: this function takes 1 argument</span>\n}</code></pre>\n<p>Mitigating strategies:</p>\n<ul>\n<li>Introduce a new function with the new signature and possibly\n<a href=\"../../reference/attributes/diagnostics.html#the-deprecated-attribute\">deprecate</a> the old one.</li>\n<li>Introduce functions that take a struct argument, where the struct is built\nwith the builder pattern. This allows new fields to be added to the struct\nin the future.</li>\n</ul>\n<h3 id=\"fn-generic-new\"><a class=\"header\" href=\"#fn-generic-new\">Possibly-breaking: introducing a new function type parameter</a></h3>\n<p>Usually, adding a non-defaulted type parameter is safe, but in some\ncases it can be a breaking change:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Breaking change example</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T&gt;() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T, U&gt;() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    foo::&lt;<span class=\"hljs-built_in\">u8</span>&gt;(); <span class=\"hljs-comment\">// Error: function takes 2 generic arguments but 1 generic argument was supplied</span>\n}</code></pre>\n<p>However, such explicit calls are rare enough (and can usually be written in\nother ways) that this breakage is usually acceptable. One should take into\naccount how likely it is that the function in question is being called with\nexplicit type arguments.</p>\n<h3 id=\"fn-generalize-compatible\"><a class=\"header\" href=\"#fn-generalize-compatible\">Minor: generalizing a function to use generics (supporting original type)</a></h3>\n<p>The type of a parameter to a function, or its return value, can be\n<em>generalized</em> to use generics, including by introducing a new type parameter,\nas long as it can be instantiated to the original type. For example, the\nfollowing changes are allowed:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(x: <span class=\"hljs-built_in\">u8</span>) -&gt; <span class=\"hljs-built_in\">u8</span> {\n    x\n}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>&lt;T: <span class=\"hljs-built_in\">Iterator</span>&lt;Item = <span class=\"hljs-built_in\">u8</span>&gt;&gt;(t: T) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">use</span> std::ops::Add;\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T: Add&gt;(x: T) -&gt; T {\n    x\n}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>&lt;T: <span class=\"hljs-built_in\">IntoIterator</span>&lt;Item = <span class=\"hljs-built_in\">u8</span>&gt;&gt;(t: T) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::{bar, foo};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    foo(<span class=\"hljs-number\">1</span>);\n    bar(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].into_iter());\n}</code></pre>\n<p>because all existing uses are instantiations of the new signature.</p>\n<p>Perhaps somewhat surprisingly, generalization applies to trait objects as\nwell, given that every trait implements itself:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(t: &amp;<span class=\"hljs-keyword\">dyn</span> Trait) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T: Trait + ?<span class=\"hljs-built_in\">Sized</span>&gt;(t: &amp;T) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::{foo, Trait};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>;\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> Foo {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> obj = Foo;\n    foo(&amp;obj);\n}</code></pre>\n<p>(The use of <code class=\"hljs\">?Sized</code> is essential; otherwise you couldn’t recover the original\nsignature.)</p>\n<p>Introducing generics in this way can potentially create type inference\nfailures. These are usually rare, and may be acceptable breakage for some\nprojects, as this can be fixed with additional type annotations.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Breaking change example</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() -&gt; <span class=\"hljs-built_in\">i32</span> {\n    <span class=\"hljs-number\">0</span>\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T: <span class=\"hljs-built_in\">Default</span>&gt;() -&gt; T {\n    <span class=\"hljs-built_in\">Default</span>::default()\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = foo(); <span class=\"hljs-comment\">// Error: type annotations needed</span>\n}</code></pre>\n<h3 id=\"fn-generalize-mismatch\"><a class=\"header\" href=\"#fn-generalize-mismatch\">Major: generalizing a function to use generics with type mismatch</a></h3>\n<p>It is a breaking change to change a function parameter or return type if the\ngeneric type constrains or changes the types previously allowed. For example,\nthe following adds a generic constraint that may not be satisfied by existing\ncode:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(x: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt;) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>&lt;T: <span class=\"hljs-built_in\">Copy</span> + <span class=\"hljs-built_in\">IntoIterator</span>&lt;Item = <span class=\"hljs-built_in\">u8</span>&gt;&gt;(x: T) {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    foo(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// Error: `Copy` is not implemented for `Vec&lt;u8&gt;`</span>\n}</code></pre>\n<h3 id=\"fn-unsafe-safe\"><a class=\"header\" href=\"#fn-unsafe-safe\">Minor: making an <code>unsafe</code> function safe</a></h3>\n<p>A previously <code class=\"hljs\">unsafe</code> function can be made safe without breaking code.</p>\n<p>Note however that it may cause the <a href=\"../../rustc/lints/listing/warn-by-default.html#unused-unsafe\"><code class=\"hljs\">unused_unsafe</code></a> lint to\ntrigger as in the example below, which will cause local crates that have\nspecified <code class=\"hljs\">#![deny(warnings)]</code> to stop compiling. Per <a href=\"#new-lints\">introducing new\nlints</a>, it is allowed for updates to introduce new warnings.</p>\n<p>Going the other way (making a safe function <code class=\"hljs\">unsafe</code>) is a breaking change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will trigger a lint.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::foo;\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>(f: <span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>()) {\n    f()\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">unsafe</span> { foo() }; <span class=\"hljs-comment\">// The `unused_unsafe` lint will trigger here</span>\n    <span class=\"hljs-keyword\">unsafe</span> { bar(foo) };\n}</code></pre>\n<p>Making a previously <code class=\"hljs\">unsafe</code> associated function or method on structs / enums\nsafe is also a minor change, while the same is not true for associated\nfunction on traits (see <a href=\"#trait-item-signature\">any change to trait item signatures</a>).</p>\n<h3 id=\"attr-no-std-to-std\"><a class=\"header\" href=\"#attr-no-std-to-std\">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></h3>\n<p>If your library specifically supports a <a href=\"../../reference/names/preludes.html#the-no_std-attribute\"><code class=\"hljs\">no_std</code></a> environment, it is a\nbreaking change to make a new release that requires <code class=\"hljs\">std</code>.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore skip hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-meta\">#![no_std]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    std::time::SystemTime::now();\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-comment\">// This will fail to link for no_std targets because they don't have a `std` crate.</span>\n<span class=\"hljs-meta\">#![no_std]</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::foo;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">example</span></span>() {\n    foo();\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>A common idiom to avoid this is to include a <code class=\"hljs\">std</code> <a href=\"features.html\">Cargo feature</a> that\noptionally enables <code class=\"hljs\">std</code> support, and when the feature is off, the library\ncan be used in a <code class=\"hljs\">no_std</code> environment.</li>\n</ul>\n<h3 id=\"attr-adding-non-exhaustive\"><a class=\"header\" href=\"#attr-adding-non-exhaustive\">Major: adding <code>non_exhaustive</code> to an existing enum, variant, or struct with no private fields</a></h3>\n<p>Making items <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> changes how they may\nbe used outside the crate where they are defined:</p>\n<ul>\n<li>Non-exhaustive structs and enum variants cannot be constructed\nusing <a href=\"../../reference/expressions/struct-expr.html\">struct literal</a> syntax, including <a href=\"../../reference/expressions/struct-expr.html#functional-update-syntax\">functional update syntax</a>.</li>\n<li>Pattern matching on non-exhaustive structs requires <code class=\"hljs\">..</code> and\nmatching on enums does not count towards exhaustiveness.</li>\n<li>Casting enum variants to their discriminant with <code class=\"hljs\">as</code> is not allowed.</li>\n</ul>\n<p>Structs with private fields cannot be constructed using <a href=\"../../reference/expressions/struct-expr.html\">struct literal</a> syntax\nregardless of whether <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> is used.\nAdding <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> to such a struct is not\na breaking change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-keyword\">pub</span> bar: <span class=\"hljs-built_in\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Bar</span></span> {\n    X,\n    Y(<span class=\"hljs-built_in\">usize</span>),\n    Z { a: <span class=\"hljs-built_in\">usize</span> },\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Quux</span></span> {\n    Var,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[non_exhaustive]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-keyword\">pub</span> bar: <span class=\"hljs-built_in\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Bar</span></span> {\n    <span class=\"hljs-meta\">#[non_exhaustive]</span>\n    X,\n\n    <span class=\"hljs-meta\">#[non_exhaustive]</span>\n    Y(<span class=\"hljs-built_in\">usize</span>),\n\n    <span class=\"hljs-meta\">#[non_exhaustive]</span>\n    Z { a: <span class=\"hljs-built_in\">usize</span> },\n}\n\n<span class=\"hljs-meta\">#[non_exhaustive]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Quux</span></span> {\n    Var,\n}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example usage that will break.</span>\n<span class=\"hljs-keyword\">use</span> updated_crate::{Bar, Foo, Quux};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> foo = Foo { bar: <span class=\"hljs-number\">0</span> }; <span class=\"hljs-comment\">// Error: cannot create non-exhaustive struct using struct expression</span>\n\n    <span class=\"hljs-keyword\">let</span> bar_x = Bar::X; <span class=\"hljs-comment\">// Error: unit variant `X` is private</span>\n    <span class=\"hljs-keyword\">let</span> bar_y = Bar::Y(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Error: tuple variant `Y` is private</span>\n    <span class=\"hljs-keyword\">let</span> bar_z = Bar::Z { a: <span class=\"hljs-number\">0</span> }; <span class=\"hljs-comment\">// Error: cannot create non-exhaustive variant using struct expression</span>\n\n    <span class=\"hljs-keyword\">let</span> q = Quux::Var;\n    <span class=\"hljs-keyword\">match</span> q {\n        Quux::Var =&gt; <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-comment\">// Error: non-exhaustive patterns: `_` not covered</span>\n    };\n}</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Mark structs, enums, and enum variants as\n<a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> when first introducing them,\nrather than adding <a href=\"../../reference/attributes/type_system.html#the-non_exhaustive-attribute\"><code class=\"hljs\">#[non_exhaustive]</code></a> later on.</li>\n</ul>\n<h2 id=\"tooling-and-environment-compatibility\"><a class=\"header\" href=\"#tooling-and-environment-compatibility\">Tooling and environment compatibility</a></h2>\n<h3 id=\"env-new-rust\"><a class=\"header\" href=\"#env-new-rust\">Possibly-breaking: changing the minimum version of Rust required</a></h3>\n<p>Introducing the use of new features in a new release of Rust can break\nprojects that are using older versions of Rust. This also includes using new\nfeatures in a new release of Cargo, and requiring the use of a nightly-only\nfeature in a crate that previously worked on stable.</p>\n<p>It is generally recommended to treat this as a minor change, rather than as\na major change, for <a href=\"https://github.com/rust-lang/api-guidelines/discussions/231\">various reasons</a>. It\nis usually relatively easy to update to a newer version of Rust. Rust also has\na rapid 6-week release cycle, and some projects will provide compatibility\nwithin a window of releases (such as the current stable release plus N\nprevious releases). Just keep in mind that some large projects may not be able\nto update their Rust toolchain rapidly.</p>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Use <a href=\"features.html\">Cargo features</a> to make the new features opt-in.</li>\n<li>Provide a large window of support for older releases.</li>\n<li>Copy the source of new standard library items if possible so that you\ncan continue to use an older version but take advantage of the new feature.</li>\n<li>Provide a separate branch of older minor releases that can receive backports\nof important bugfixes.</li>\n<li>Keep an eye out for the <a href=\"https://github.com/rust-lang/rust/issues/64796\"><code class=\"hljs\">[cfg(version(..))]</code></a> and\n<a href=\"https://github.com/rust-lang/rust/issues/64797\"><code class=\"hljs\">#[cfg(accessible(..))]</code></a> features which provide an opt-in\nmechanism for new features. These are currently unstable and only available\nin the nightly channel.</li>\n</ul>\n<h3 id=\"env-change-requirements\"><a class=\"header\" href=\"#env-change-requirements\">Possibly-breaking: changing the platform and environment requirements</a></h3>\n<p>There is a very wide range of assumptions a library makes about the\nenvironment that it runs in, such as the host platform, operating system\nversion, available services, filesystem support, etc. It can be a breaking\nchange if you make a new release that restricts what was previously supported,\nfor example requiring a newer version of an operating system. These changes\ncan be difficult to track, since you may not always know if a change breaks in\nan environment that is not automatically tested.</p>\n<p>Some projects may deem this acceptable breakage, particularly if the breakage\nis unlikely for most users, or the project doesn’t have the resources to\nsupport all environments. Another notable situation is when a vendor\ndiscontinues support for some hardware or OS, the project may deem it\nreasonable to also discontinue support.</p>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Document the platforms and environments you specifically support.</li>\n<li>Test your code on a wide range of environments in CI.</li>\n</ul>\n<h3 id=\"new-lints\"><a class=\"header\" href=\"#new-lints\">Minor: introducing new lints</a></h3>\n<p>Some changes to a library may cause new lints to be triggered in users of that library.\nThis should generally be considered a compatible change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore dont-deny hljs\"><span class=\"hljs-comment\">// MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-meta\">#[deprecated]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {}\n\n<span class=\"hljs-comment\">///////////////////////////////////////////////////////////</span>\n<span class=\"hljs-comment\">// Example use of the library that will safely work.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    updated_crate::foo(); <span class=\"hljs-comment\">// Warning: use of deprecated function</span>\n}</code></pre>\n<p>Beware that it may be possible for this to technically cause a project to fail if they have explicitly denied the warning, and the updated crate is a direct dependency.\nDenying warnings should be done with care and the understanding that new lints may be introduced over time.\nHowever, library authors should be cautious about introducing new warnings and may want to consider the potential impact on their users.</p>\n<p>The following lints are examples of those that may be introduced when updating a dependency:</p>\n<ul>\n<li><a href=\"../../rustc/lints/listing/warn-by-default.html#deprecated\"><code class=\"hljs\">deprecated</code></a> — Introduced when a dependency adds the <a href=\"../../reference/attributes/diagnostics.html#the-deprecated-attribute\"><code class=\"hljs\">#[deprecated]</code> attribute</a> to an item you are using.</li>\n<li><a href=\"../../rustc/lints/listing/warn-by-default.html#unused-must-use\"><code class=\"hljs\">unused_must_use</code></a> — Introduced when a dependency adds the <a href=\"../../reference/attributes/diagnostics.html#the-must_use-attribute\"><code class=\"hljs\">#[must_use]</code> attribute</a> to an item where you are not consuming the result.</li>\n<li><a href=\"../../rustc/lints/listing/warn-by-default.html#unused-unsafe\"><code class=\"hljs\">unused_unsafe</code></a> — Introduced when a dependency <em>removes</em> the <code class=\"hljs\">unsafe</code> qualifier from a function, and that is the only unsafe function called in an unsafe block.</li>\n</ul>\n<p>Additionally, updating <code class=\"hljs\">rustc</code> to a new version may introduce new lints.</p>\n<p>Transitive dependencies which introduce new lints should not usually cause a failure because Cargo uses <a href=\"../../rustc/lints/levels.html#capping-lints\"><code class=\"hljs\">--cap-lints</code></a> to suppress all lints in dependencies.</p>\n<p>Mitigating strategies:</p>\n<ul>\n<li>If you build with warnings denied, understand you may need to deal with resolving new warnings whenever you update your dependencies.\nIf using RUSTFLAGS to pass <code class=\"hljs\">-Dwarnings</code>, also add the <code class=\"hljs\">-A</code> flag to allow lints that are likely to cause issues, such as <code class=\"hljs\">-Adeprecated</code>.</li>\n<li>Introduce deprecations behind a <a href=\"features.html\">feature</a>.\nFor example <code class=\"hljs\">#[cfg_attr(feature = \"deprecated\", deprecated=\"use bar instead\")]</code>.\nThen, when you plan to remove an item in a future SemVer breaking change, you can communicate with your users that they should enable the <code class=\"hljs\">deprecated</code> feature <em>before</em> updating to remove the use of the deprecated items.\nThis allows users to choose when to respond to deprecations without needing to immediately respond to them.\nA downside is that it can be difficult to communicate to users that they need to take these manual steps to prepare for a major update.</li>\n</ul>\n<h3 id=\"cargo\"><a class=\"header\" href=\"#cargo\">Cargo</a></h3>\n<h4 id=\"cargo-feature-add\"><a class=\"header\" href=\"#cargo-feature-add\">Minor: adding a new Cargo feature</a></h4>\n<p>It is usually safe to add new <a href=\"features.html\">Cargo features</a>. If the feature introduces new\nchanges that cause a breaking change, this can cause difficulties for projects\nthat have stricter backwards-compatibility needs. In that scenario, avoid\nadding the feature to the “default” list, and possibly document the\nconsequences of enabling the feature.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-comment\"># ..empty</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">std</span> = []\n</code></pre>\n<h4 id=\"cargo-feature-remove\"><a class=\"header\" href=\"#cargo-feature-remove\">Major: removing a Cargo feature</a></h4>\n<p>It is usually a breaking change to remove <a href=\"features.html\">Cargo features</a>. This will cause\nan error for any project that enabled the feature.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># MAJOR CHANGE</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">logging</span> = []\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-comment\"># ..logging removed</span>\n</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Clearly document your features. If there is an internal or experimental\nfeature, mark it as such, so that users know the status of the feature.</li>\n<li>Leave the old feature in <code class=\"hljs\">Cargo.toml</code>, but otherwise remove its\nfunctionality. Document that the feature is deprecated, and remove it in a\nfuture major SemVer release.</li>\n</ul>\n<h4 id=\"cargo-feature-remove-another\"><a class=\"header\" href=\"#cargo-feature-remove-another\">Major: removing a feature from a feature list if that changes functionality or public items</a></h4>\n<p>If removing a feature from another feature, this can break existing users if\nthey are expecting that functionality to be available through that feature.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Breaking change example</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">default</span> = [<span class=\"hljs-string\">\"std\"</span>]\n<span class=\"hljs-attr\">std</span> = []\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">default</span> = []  <span class=\"hljs-comment\"># This may cause packages to fail if they are expecting std to be enabled.</span>\n<span class=\"hljs-attr\">std</span> = []\n</code></pre>\n<h4 id=\"cargo-remove-opt-dep\"><a class=\"header\" href=\"#cargo-remove-opt-dep\">Possibly-breaking: removing an optional dependency</a></h4>\n<p>Removing an <a href=\"features.html#optional-dependencies\">optional dependency</a> can break a project using your library because\nanother project may be enabling that dependency via <a href=\"features.html\">Cargo features</a>.</p>\n<p>When there is an optional dependency, cargo implicitly defines a feature of\nthe same name to provide a mechanism to enable the dependency and to check\nwhen it is enabled. This problem can be avoided by using the <code class=\"hljs\">dep:</code> syntax in\nthe <code class=\"hljs\">[features]</code> table, which disables this implicit feature. Using <code class=\"hljs\">dep:</code>\nmakes it possible to hide the existence of optional dependencies under more\nsemantically-relevant names which can be more safely modified.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Breaking change example</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">curl</span> = { version = <span class=\"hljs-string\">\"0.4.31\"</span>, optional = <span class=\"hljs-literal\">true</span> }\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-comment\"># ..curl removed</span>\n</code></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># MINOR CHANGE</span>\n<span class=\"hljs-comment\">#</span>\n<span class=\"hljs-comment\"># This example shows how to avoid breaking changes with optional dependencies.</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">curl</span> = { version = <span class=\"hljs-string\">\"0.4.31\"</span>, optional = <span class=\"hljs-literal\">true</span> }\n\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">networking</span> = [<span class=\"hljs-string\">\"dep:curl\"</span>]\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-comment\"># Here, one optional dependency was replaced with another.</span>\n<span class=\"hljs-attr\">hyper</span> = { version = <span class=\"hljs-string\">\"0.14.27\"</span>, optional = <span class=\"hljs-literal\">true</span> }\n\n<span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">networking</span> = [<span class=\"hljs-string\">\"dep:hyper\"</span>]\n</code></pre>\n<p>Mitigation strategies:</p>\n<ul>\n<li>Use the <code class=\"hljs\">dep:</code> syntax in the <code class=\"hljs\">[features]</code> table to avoid exposing optional\ndependencies in the first place. See <a href=\"features.html#optional-dependencies\">optional dependencies</a> for\nmore information.</li>\n<li>Clearly document your features. If the optional dependency is not included\nin the documented list of features, then you may decide to consider it safe\nto change undocumented entries.</li>\n<li>Leave the optional dependency, and just don’t use it within your library.</li>\n<li>Replace the optional dependency with a <a href=\"features.html\">Cargo feature</a> that does nothing,\nand document that it is deprecated.</li>\n<li>Use high-level features which enable optional dependencies, and document\nthose as the preferred way to enable the extended functionality. For\nexample, if your library has optional support for something like\n“networking”, create a generic feature name “networking” that enables the\noptional dependencies necessary to implement “networking”. Then document the\n“networking” feature.</li>\n</ul>\n<h4 id=\"cargo-change-dep-feature\"><a class=\"header\" href=\"#cargo-change-dep-feature\">Minor: changing dependency features</a></h4>\n<p>It is usually safe to change the features on a dependency, as long as the\nfeature does not introduce a breaking change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">rand</span> = { version = <span class=\"hljs-string\">\"0.7.3\"</span>, features = [<span class=\"hljs-string\">\"small_rng\"</span>] }\n\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">rand</span> = <span class=\"hljs-string\">\"0.7.3\"</span>\n</code></pre>\n<h4 id=\"cargo-dep-add\"><a class=\"header\" href=\"#cargo-dep-add\">Minor: adding dependencies</a></h4>\n<p>It is usually safe to add new dependencies, as long as the new dependency\ndoes not introduce new requirements that result in a breaking change.\nFor example, adding a new dependency that requires nightly in a project\nthat previously worked on stable is a major change.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># MINOR CHANGE</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># Before</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-comment\"># ..empty</span>\n\n<span class=\"hljs-comment\">###########################################################</span>\n<span class=\"hljs-comment\"># After</span>\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">log</span> = <span class=\"hljs-string\">\"0.4.11\"</span>\n</code></pre>\n<h2 id=\"application-compatibility\"><a class=\"header\" href=\"#application-compatibility\">Application compatibility</a></h2>\n<p>Cargo projects may also include executable binaries which have their own\ninterfaces (such as a CLI interface, OS-level interaction, etc.). Since these\nare part of the Cargo package, they often use and share the same version as\nthe package. You will need to decide if and how you want to employ a SemVer\ncontract with your users in the changes you make to your application. The\npotential breaking and compatible changes to an application are too numerous\nto list, so you are encouraged to use the spirit of the <a href=\"https://semver.org/\">SemVer</a> spec to guide\nyour decisions on how to apply versioning to your application, or at least\ndocument what your commitments are.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../reference/resolver.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../reference/future-incompat-report.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../reference/resolver.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../reference/future-incompat-report.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:09:24.554Z"
}