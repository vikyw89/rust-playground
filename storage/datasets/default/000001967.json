{
	"title": "Type coercions - The Rust Reference",
	"url": "https://doc.rust-lang.org/reference/type-coercions.html#coercion-sites",
	"markdown": "# Type coercions - The Rust Reference\n\n**Type coercions** are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.\n\nAny conversions allowed by coercion can also be explicitly performed by the [type cast operator](about:blank/expressions/operator-expr.html#type-cast-expressions), `as`.\n\nCoercions are originally defined in [RFC 401](https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md) and expanded upon in [RFC 1558](https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md).\n\n## [Coercion sites](#coercion-sites)\n\nA coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:\n\n-   `let` statements where an explicit type is given.\n    \n    For example, `&mut 42` is coerced to have type `&i8` in the following:\n    \n    ```rust\n    #![allow(unused)]\n    fn main() {\n    let _: &i8 = &mut 42;\n    }\n    ```\n    \n-   `static` and `const` item declarations (similar to `let` statements).\n    \n-   Arguments for function calls\n    \n    The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.\n    \n    For example, `&mut 42` is coerced to have type `&i8` in the following:\n    \n    ```rust\n    fn bar(_: &i8) { }\n    \n    fn main() {\n        bar(&mut 42);\n    }\n    ```\n    \n    For method calls, the receiver (`self` parameter) type is coerced differently, see the documentation on [method-call expressions](expressions/method-call-expr.html) for details.\n    \n-   Instantiations of struct, union, or enum variant fields\n    \n    For example, `&mut 42` is coerced to have type `&i8` in the following:\n    \n    ```rust\n    struct Foo<'a> { x: &'a i8 }\n    \n    fn main() {\n        Foo { x: &mut 42 };\n    }\n    ```\n    \n-   Function resultsâ€”either the final line of a block if it is not semicolon-terminated or any expression in a `return` statement\n    \n    For example, `x` is coerced to have type `&dyn Display` in the following:\n    \n    ```rust\n    #![allow(unused)]\n    fn main() {\n    use std::fmt::Display;\n    fn foo(x: &u32) -> &dyn Display {\n        x\n    }\n    }\n    ```\n    \n\nIf the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:\n\n-   Array literals, where the array has type `[U; n]`. Each sub-expression in the array literal is a coercion site for coercion to type `U`.\n    \n-   Array literals with repeating syntax, where the array has type `[U; n]`. The repeated sub-expression is a coercion site for coercion to type `U`.\n    \n-   Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type `U_0`.\n    \n-   Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then the sub-expression is a coercion site to `U`.\n    \n-   Blocks: if a block has type `U`, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to `U`. This includes blocks which are part of control flow statements, such as `if`/`else`, if the block has a known type.\n    \n\n## [Coercion types](#coercion-types)\n\nCoercion is allowed between the following types:\n\n-   `T` to `U` if `T` is a [subtype](subtyping.html) of `U` (_reflexive case_)\n    \n-   `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3` (_transitive case_)\n    \n    Note that this is not fully supported yet.\n    \n-   `&mut T` to `&T`\n    \n-   `*mut T` to `*const T`\n    \n-   `&T` to `*const T`\n    \n-   `&mut T` to `*mut T`\n    \n-   `&T` or `&mut T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n    \n    ```rust\n    use std::ops::Deref;\n    \n    struct CharContainer {\n        value: char,\n    }\n    \n    impl Deref for CharContainer {\n        type Target = char;\n    \n        fn deref<'a>(&'a self) -> &'a char {\n            &self.value\n        }\n    }\n    \n    fn foo(arg: &char) {}\n    \n    fn main() {\n        let x = &mut CharContainer { value: 'y' };\n        foo(x); //&mut CharContainer is coerced to &char.\n    }\n    ```\n    \n-   `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n    \n-   TyCtor(`T`) to TyCtor(`U`), where TyCtor(`T`) is one of\n    \n    -   `&T`\n    -   `&mut T`\n    -   `*const T`\n    -   `*mut T`\n    -   `Box<T>`\n    \n    and where `U` can be obtained from `T` by [unsized coercion](#unsized-coercions).\n    \n-   Function item types to `fn` pointers\n    \n-   Non capturing closures to `fn` pointers\n    \n-   `!` to any `T`\n    \n\n### [Unsized Coercions](#unsized-coercions)\n\nThe following coercions are called `unsized coercions`, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.\n\nTwo traits, [`Unsize`](../std/marker/trait.Unsize.html) and [`CoerceUnsized`](../std/ops/trait.CoerceUnsized.html), are used to assist in this process and expose it for library use. The following coercions are built-ins and, if `T` can be coerced to `U` with one of them, then an implementation of `Unsize<U>` for `T` will be provided:\n\n-   `[T; n]` to `[T]`.\n    \n-   `T` to `dyn U`, when `T` implements `U + Sized`, and `U` is [object safe](about:blank/items/traits.html#object-safety).\n    \n-   `Foo<..., T, ...>` to `Foo<..., U, ...>`, when:\n    \n    -   `Foo` is a struct.\n    -   `T` implements `Unsize<U>`.\n    -   The last field of `Foo` has a type involving `T`.\n    -   If that field has type `Bar<T>`, then `Bar<T>` implements `Unsized<Bar<U>>`.\n    -   T is not part of the type of any other fields.\n\nAdditionally, a type `Foo<T>` can implement `CoerceUnsized<Foo<U>>` when `T` implements `Unsize<U>` or `CoerceUnsized<Foo<U>>`. This allows it to provide a unsized coercion to `Foo<U>`.\n\n> Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.\n\n## [Least upper bound coercions](#least-upper-bound-coercions)\n\nIn some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a \"Least Upper Bound\" coercion. LUB coercion is used and only used in the following situations:\n\n-   To find the common type for a series of if branches.\n-   To find the common type for a series of match arms.\n-   To find the common type for array elements.\n-   To find the type for the return type of a closure with multiple return statements.\n-   To check the type for the return type of a function with multiple return statements.\n\nIn each such case, there are a set of types `T0..Tn` to be mutually coerced to some target type `T_t`, which is unknown to start. Computing the LUB coercion is done iteratively. The target type `T_t` begins as the type `T0`. For each new type `Ti`, we consider whether\n\n-   If `Ti` can be coerced to the current target type `T_t`, then no change is made.\n-   Otherwise, check whether `T_t` can be coerced to `Ti`; if so, the `T_t` is changed to `Ti`. (This check is also conditioned on whether all of the source expressions considered thus far have implicit coercions.)\n-   If not, try to compute a mutual supertype of `T_t` and `Ti`, which will become the new target type.\n\n### [Examples:](#examples)\n\n```rust\n#![allow(unused)]\nfn main() {\nlet (a, b, c) = (0, 1, 2);\n// For if branches\nlet bar = if true {\n    a\n} else if false {\n    b\n} else {\n    c\n};\n\n// For match arms\nlet baw = match 42 {\n    0 => a,\n    1 => b,\n    _ => c,\n};\n\n// For array elements\nlet bax = [a, b, c];\n\n// For closure with multiple return statements\nlet clo = || {\n    if true {\n        a\n    } else if false {\n        b\n    } else {\n        c\n    }\n};\nlet baz = clo();\n\n// For type checking of function with multiple return statements\nfn foo() -> i32 {\n    let (a, b, c) = (0, 1, 2);\n    match 42 {\n        0 => a,\n        1 => b,\n        _ => c,\n    }\n}\n}\n```\n\nIn these examples, types of the `ba*` are found by LUB coercion. And the compiler checks whether LUB coercion result of `a`, `b`, `c` is `i32` in the processing of the function `foo`.\n\n### [Caveat](#caveat)\n\nThis description is obviously informal. Making it more precise is expected to proceed as part of a general effort to specify the Rust type checker more precisely.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Type coercions - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar bordered\" style=\"top: 184px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/type-coercions.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"type-coercions\"><a class=\"header\" href=\"#type-coercions\">Type coercions</a></h1>\n<p><strong>Type coercions</strong> are implicit operations that change the type of a value.\nThey happen automatically at specific locations and are highly restricted in\nwhat types actually coerce.</p>\n<p>Any conversions allowed by coercion can also be explicitly performed by the\n<a href=\"expressions/operator-expr.html#type-cast-expressions\">type cast operator</a>, <code class=\"hljs\">as</code>.</p>\n<p>Coercions are originally defined in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\">RFC 401</a> and expanded upon in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md\">RFC 1558</a>.</p>\n<h2 id=\"coercion-sites\"><a class=\"header\" href=\"#coercion-sites\">Coercion sites</a></h2>\n<p>A coercion can only occur at certain coercion sites in a program; these are\ntypically places where the desired type is explicit or can be derived by\npropagation from explicit types (without type inference). Possible coercion\nsites are:</p>\n<ul>\n<li>\n<p><code class=\"hljs\">let</code> statements where an explicit type is given.</p>\n<p>For example, <code class=\"hljs\">&amp;mut 42</code> is coerced to have type <code class=\"hljs\">&amp;i8</code> in the following:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> _: &amp;<span class=\"hljs-built_in\">i8</span> = &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">42</span>;\n<span class=\"boring\">}</span></code></pre></pre>\n</li>\n<li>\n<p><code class=\"hljs\">static</code> and <code class=\"hljs\">const</code> item declarations (similar to <code class=\"hljs\">let</code> statements).</p>\n</li>\n<li>\n<p>Arguments for function calls</p>\n<p>The value being coerced is the actual parameter, and it is coerced to\nthe type of the formal parameter.</p>\n<p>For example, <code class=\"hljs\">&amp;mut 42</code> is coerced to have type <code class=\"hljs\">&amp;i8</code> in the following:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>(_: &amp;<span class=\"hljs-built_in\">i8</span>) { }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    bar(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">42</span>);\n}</code></pre></pre>\n<p>For method calls, the receiver (<code class=\"hljs\">self</code> parameter) type is coerced\ndifferently, see the documentation on <a href=\"expressions/method-call-expr.html\">method-call expressions</a> for details.</p>\n</li>\n<li>\n<p>Instantiations of struct, union, or enum variant fields</p>\n<p>For example, <code class=\"hljs\">&amp;mut 42</code> is coerced to have type <code class=\"hljs\">&amp;i8</code> in the following:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Foo</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt; { x: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">i8</span> }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    Foo { x: &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">42</span> };\n}</code></pre></pre>\n</li>\n<li>\n<p>Function resultsâ€”either the final line of a block if it is not\nsemicolon-terminated or any expression in a <code class=\"hljs\">return</code> statement</p>\n<p>For example, <code class=\"hljs\">x</code> is coerced to have type <code class=\"hljs\">&amp;dyn Display</code> in the following:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::fmt::Display;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(x: &amp;<span class=\"hljs-built_in\">u32</span>) -&gt; &amp;<span class=\"hljs-keyword\">dyn</span> Display {\n    x\n}\n<span class=\"boring\">}</span></code></pre></pre>\n</li>\n</ul>\n<p>If the expression in one of these coercion sites is a coercion-propagating\nexpression, then the relevant sub-expressions in that expression are also\ncoercion sites. Propagation recurses from these new coercion sites.\nPropagating expressions and their relevant sub-expressions are:</p>\n<ul>\n<li>\n<p>Array literals, where the array has type <code class=\"hljs\">[U; n]</code>. Each sub-expression in\nthe array literal is a coercion site for coercion to type <code class=\"hljs\">U</code>.</p>\n</li>\n<li>\n<p>Array literals with repeating syntax, where the array has type <code class=\"hljs\">[U; n]</code>. The\nrepeated sub-expression is a coercion site for coercion to type <code class=\"hljs\">U</code>.</p>\n</li>\n<li>\n<p>Tuples, where a tuple is a coercion site to type <code class=\"hljs\">(U_0, U_1, ..., U_n)</code>.\nEach sub-expression is a coercion site to the respective type, e.g. the\nzeroth sub-expression is a coercion site to type <code class=\"hljs\">U_0</code>.</p>\n</li>\n<li>\n<p>Parenthesized sub-expressions (<code class=\"hljs\">(e)</code>): if the expression has type <code class=\"hljs\">U</code>, then\nthe sub-expression is a coercion site to <code class=\"hljs\">U</code>.</p>\n</li>\n<li>\n<p>Blocks: if a block has type <code class=\"hljs\">U</code>, then the last expression in the block (if\nit is not semicolon-terminated) is a coercion site to <code class=\"hljs\">U</code>. This includes\nblocks which are part of control flow statements, such as <code class=\"hljs\">if</code>/<code class=\"hljs\">else</code>, if\nthe block has a known type.</p>\n</li>\n</ul>\n<h2 id=\"coercion-types\"><a class=\"header\" href=\"#coercion-types\">Coercion types</a></h2>\n<p>Coercion is allowed between the following types:</p>\n<ul>\n<li>\n<p><code class=\"hljs\">T</code> to <code class=\"hljs\">U</code> if <code class=\"hljs\">T</code> is a <a href=\"subtyping.html\">subtype</a> of <code class=\"hljs\">U</code> (<em>reflexive case</em>)</p>\n</li>\n<li>\n<p><code class=\"hljs\">T_1</code> to <code class=\"hljs\">T_3</code> where <code class=\"hljs\">T_1</code> coerces to <code class=\"hljs\">T_2</code> and <code class=\"hljs\">T_2</code> coerces to <code class=\"hljs\">T_3</code>\n(<em>transitive case</em>)</p>\n<p>Note that this is not fully supported yet.</p>\n</li>\n<li>\n<p><code class=\"hljs\">&amp;mut T</code> to <code class=\"hljs\">&amp;T</code></p>\n</li>\n<li>\n<p><code class=\"hljs\">*mut T</code> to <code class=\"hljs\">*const T</code></p>\n</li>\n<li>\n<p><code class=\"hljs\">&amp;T</code> to <code class=\"hljs\">*const T</code></p>\n</li>\n<li>\n<p><code class=\"hljs\">&amp;mut T</code> to <code class=\"hljs\">*mut T</code></p>\n</li>\n<li>\n<p><code class=\"hljs\">&amp;T</code> or <code class=\"hljs\">&amp;mut T</code> to <code class=\"hljs\">&amp;U</code> if <code class=\"hljs\">T</code> implements <code class=\"hljs\">Deref&lt;Target = U&gt;</code>. For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-keyword\">use</span> std::ops::Deref;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">CharContainer</span></span> {\n    value: <span class=\"hljs-built_in\">char</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Deref <span class=\"hljs-keyword\">for</span> CharContainer {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = <span class=\"hljs-built_in\">char</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-keyword\">self</span>) -&gt; &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">char</span> {\n        &amp;<span class=\"hljs-keyword\">self</span>.value\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(arg: &amp;<span class=\"hljs-built_in\">char</span>) {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = &amp;<span class=\"hljs-keyword\">mut</span> CharContainer { value: <span class=\"hljs-string\">'y'</span> };\n    foo(x); <span class=\"hljs-comment\">//&amp;mut CharContainer is coerced to &amp;char.</span>\n}</code></pre></pre>\n</li>\n<li>\n<p><code class=\"hljs\">&amp;mut T</code> to <code class=\"hljs\">&amp;mut U</code> if <code class=\"hljs\">T</code> implements <code class=\"hljs\">DerefMut&lt;Target = U&gt;</code>.</p>\n</li>\n<li>\n<p>TyCtor(<code class=\"hljs\">T</code>) to TyCtor(<code class=\"hljs\">U</code>), where TyCtor(<code class=\"hljs\">T</code>) is one of</p>\n<ul>\n<li><code class=\"hljs\">&amp;T</code></li>\n<li><code class=\"hljs\">&amp;mut T</code></li>\n<li><code class=\"hljs\">*const T</code></li>\n<li><code class=\"hljs\">*mut T</code></li>\n<li><code class=\"hljs\">Box&lt;T&gt;</code></li>\n</ul>\n<p>and where <code class=\"hljs\">U</code> can be obtained from <code class=\"hljs\">T</code> by <a href=\"#unsized-coercions\">unsized coercion</a>.</p>\n  <!--In the future, coerce_inner will be recursively extended to tuples and\n  structs. In addition, coercions from subtraits to supertraits will be\n  added. See [RFC 401] for more details.-->\n</li>\n<li>\n<p>Function item types to <code class=\"hljs\">fn</code> pointers</p>\n</li>\n<li>\n<p>Non capturing closures to <code class=\"hljs\">fn</code> pointers</p>\n</li>\n<li>\n<p><code class=\"hljs\">!</code> to any <code class=\"hljs\">T</code></p>\n</li>\n</ul>\n<h3 id=\"unsized-coercions\"><a class=\"header\" href=\"#unsized-coercions\">Unsized Coercions</a></h3>\n<p>The following coercions are called <code class=\"hljs\">unsized coercions</code>, since they\nrelate to converting sized types to unsized types, and are permitted in a few\ncases where other coercions are not, as described above. They can still happen\nanywhere else a coercion can occur.</p>\n<p>Two traits, <a href=\"../std/marker/trait.Unsize.html\"><code class=\"hljs\">Unsize</code></a> and <a href=\"../std/ops/trait.CoerceUnsized.html\"><code class=\"hljs\">CoerceUnsized</code></a>, are used\nto assist in this process and expose it for library use. The following\ncoercions are built-ins and, if <code class=\"hljs\">T</code> can be coerced to <code class=\"hljs\">U</code> with one of them, then\nan implementation of <code class=\"hljs\">Unsize&lt;U&gt;</code> for <code class=\"hljs\">T</code> will be provided:</p>\n<ul>\n<li>\n<p><code class=\"hljs\">[T; n]</code> to <code class=\"hljs\">[T]</code>.</p>\n</li>\n<li>\n<p><code class=\"hljs\">T</code> to <code class=\"hljs\">dyn U</code>, when <code class=\"hljs\">T</code> implements <code class=\"hljs\">U + Sized</code>, and <code class=\"hljs\">U</code> is <a href=\"items/traits.html#object-safety\">object safe</a>.</p>\n</li>\n<li>\n<p><code class=\"hljs\">Foo&lt;..., T, ...&gt;</code> to <code class=\"hljs\">Foo&lt;..., U, ...&gt;</code>, when:</p>\n<ul>\n<li><code class=\"hljs\">Foo</code> is a struct.</li>\n<li><code class=\"hljs\">T</code> implements <code class=\"hljs\">Unsize&lt;U&gt;</code>.</li>\n<li>The last field of <code class=\"hljs\">Foo</code> has a type involving <code class=\"hljs\">T</code>.</li>\n<li>If that field has type <code class=\"hljs\">Bar&lt;T&gt;</code>, then <code class=\"hljs\">Bar&lt;T&gt;</code> implements <code class=\"hljs\">Unsized&lt;Bar&lt;U&gt;&gt;</code>.</li>\n<li>T is not part of the type of any other fields.</li>\n</ul>\n</li>\n</ul>\n<p>Additionally, a type <code class=\"hljs\">Foo&lt;T&gt;</code> can implement <code class=\"hljs\">CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> when <code class=\"hljs\">T</code>\nimplements <code class=\"hljs\">Unsize&lt;U&gt;</code> or <code class=\"hljs\">CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>. This allows it to provide a\nunsized coercion to <code class=\"hljs\">Foo&lt;U&gt;</code>.</p>\n<blockquote>\n<p>Note: While the definition of the unsized coercions and their implementation\nhas been stabilized, the traits themselves are not yet stable and therefore\ncan't be used directly in stable Rust.</p>\n</blockquote>\n<h2 id=\"least-upper-bound-coercions\"><a class=\"header\" href=\"#least-upper-bound-coercions\">Least upper bound coercions</a></h2>\n<p>In some contexts, the compiler must coerce together multiple types to try and\nfind the most general type. This is called a \"Least Upper Bound\" coercion.\nLUB coercion is used and only used in the following situations:</p>\n<ul>\n<li>To find the common type for a series of if branches.</li>\n<li>To find the common type for a series of match arms.</li>\n<li>To find the common type for array elements.</li>\n<li>To find the type for the return type of a closure with multiple return statements.</li>\n<li>To check the type for the return type of a function with multiple return statements.</li>\n</ul>\n<p>In each such case, there are a set of types <code class=\"hljs\">T0..Tn</code> to be mutually coerced\nto some target type <code class=\"hljs\">T_t</code>, which is unknown to start. Computing the LUB\ncoercion is done iteratively. The target type <code class=\"hljs\">T_t</code> begins as the type <code class=\"hljs\">T0</code>.\nFor each new type <code class=\"hljs\">Ti</code>, we consider whether</p>\n<ul>\n<li>If <code class=\"hljs\">Ti</code> can be coerced to the current target type <code class=\"hljs\">T_t</code>, then no change is made.</li>\n<li>Otherwise, check whether <code class=\"hljs\">T_t</code> can be coerced to <code class=\"hljs\">Ti</code>; if so, the <code class=\"hljs\">T_t</code> is\nchanged to <code class=\"hljs\">Ti</code>. (This check is also conditioned on whether all of the source\nexpressions considered thus far have implicit coercions.)</li>\n<li>If not, try to compute a mutual supertype of <code class=\"hljs\">T_t</code> and <code class=\"hljs\">Ti</code>, which will become the new target type.</li>\n</ul>\n<h3 id=\"examples\"><a class=\"header\" href=\"#examples\">Examples:</a></h3>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> (a, b, c) = (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n</span><span class=\"hljs-comment\">// For if branches</span>\n<span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">true</span> {\n    a\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">false</span> {\n    b\n} <span class=\"hljs-keyword\">else</span> {\n    c\n};\n\n<span class=\"hljs-comment\">// For match arms</span>\n<span class=\"hljs-keyword\">let</span> baw = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-number\">42</span> {\n    <span class=\"hljs-number\">0</span> =&gt; a,\n    <span class=\"hljs-number\">1</span> =&gt; b,\n    _ =&gt; c,\n};\n\n<span class=\"hljs-comment\">// For array elements</span>\n<span class=\"hljs-keyword\">let</span> bax = [a, b, c];\n\n<span class=\"hljs-comment\">// For closure with multiple return statements</span>\n<span class=\"hljs-keyword\">let</span> clo = || {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">true</span> {\n        a\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">false</span> {\n        b\n    } <span class=\"hljs-keyword\">else</span> {\n        c\n    }\n};\n<span class=\"hljs-keyword\">let</span> baz = clo();\n\n<span class=\"hljs-comment\">// For type checking of function with multiple return statements</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() -&gt; <span class=\"hljs-built_in\">i32</span> {\n    <span class=\"hljs-keyword\">let</span> (a, b, c) = (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-number\">42</span> {\n        <span class=\"hljs-number\">0</span> =&gt; a,\n        <span class=\"hljs-number\">1</span> =&gt; b,\n        _ =&gt; c,\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In these examples, types of the <code class=\"hljs\">ba*</code> are found by LUB coercion. And the\ncompiler checks whether LUB coercion result of <code class=\"hljs\">a</code>, <code class=\"hljs\">b</code>, <code class=\"hljs\">c</code> is <code class=\"hljs\">i32</code> in the\nprocessing of the function <code class=\"hljs\">foo</code>.</p>\n<h3 id=\"caveat\"><a class=\"header\" href=\"#caveat\">Caveat</a></h3>\n<p>This description is obviously informal. Making it more precise is expected to\nproceed as part of a general effort to specify the Rust type checker more\nprecisely.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"trait-bounds.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"destructors.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"trait-bounds.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"destructors.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:21:37.033Z"
}