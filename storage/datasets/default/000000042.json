{
	"title": "Generic Data Types - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch10-01-syntax.html",
	"markdown": "# Generic Data Types - The Rust Programming Language\n\nWe use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let’s first look at how to define functions, structs, enums, and methods using generics. Then we’ll discuss how generics affect code performance.\n\n### [In Function Definitions](#in-function-definitions)\n\nWhen defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.\n\nContinuing with our `largest` function, Listing 10-4 shows two functions that both find the largest value in a slice. We’ll then combine these into a single function that uses generics.\n\nFilename: src/main.rs\n\n```rust\nfn largest_i32(list: &[i32]) -> &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -> &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {result}\");\n    assert_eq!(*result, 100);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {result}\");\n    assert_eq!(*result, 'y');\n}\n```\n\nListing 10-4: Two functions that differ only in their names and in the types in their signatures\n\nThe `largest_i32` function is the one we extracted in Listing 10-3 that finds the largest `i32` in a slice. The `largest_char` function finds the largest `char` in a slice. The function bodies have the same code, so let’s eliminate the duplication by introducing a generic type parameter in a single function.\n\nTo parameterize the types in a new single function, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we’ll use `T` because, by convention, type parameter names in Rust are short, often just one letter, and Rust’s type-naming convention is UpperCamelCase. Short for _type_, `T` is the default choice of most Rust programmers.\n\nWhen we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic `largest` function, we place type name declarations inside angle brackets, `<>`, between the name of the function and the parameter list, like this:\n\n```rust\nfn largest<T>(list: &[T]) -> &T {\n```\n\nWe read this definition as: the function `largest` is generic over some type `T`. This function has one parameter named `list`, which is a slice of values of type `T`. The `largest` function will return a reference to a value of the same type `T`.\n\nListing 10-5 shows the combined `largest` function definition using the generic data type in its signature. The listing also shows how we can call the function with either a slice of `i32` values or `char` values. Note that this code won’t compile yet, but we’ll fix it later in this chapter.\n\nFilename: src/main.rs\n\n```rust\nfn largest<T>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {result}\");\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {result}\");\n}\n```\n\nListing 10-5: The `largest` function using generic type parameters; this doesn’t compile yet\n\nIf we compile this code right now, we’ll get this error:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0369]: binary operation `>` cannot be applied to type `&T`\n --> src/main.rs:5:17\n  |\n5 |         if item > largest {\n  |            ---- ^ ------- &T\n  |            |\n  |            &T\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {\n  |             ++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n\n```\n\nThe help text mentions `std::cmp::PartialOrd`, which is a _trait_, and we’re going to talk about traits in the next section. For now, know that this error states that the body of `largest` won’t work for all possible types that `T` could be. Because we want to compare values of type `T` in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the `std::cmp::PartialOrd` trait that you can implement on types (see Appendix C for more on this trait). By following the help text’s suggestion, we restrict the types valid for `T` to only those that implement `PartialOrd` and this example will compile, because the standard library implements `PartialOrd` on both `i32` and `char`.\n\n### [In Struct Definitions](#in-struct-definitions)\n\nWe can also define structs to use a generic type parameter in one or more fields using the `<>` syntax. Listing 10-6 defines a `Point<T>` struct to hold `x` and `y` coordinate values of any type.\n\nFilename: src/main.rs\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n```\n\nListing 10-6: A `Point<T>` struct that holds `x` and `y` values of type `T`\n\nThe syntax for using generics in struct definitions is similar to that used in function definitions. First we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types.\n\nNote that because we’ve used only one generic type to define `Point<T>`, this definition says that the `Point<T>` struct is generic over some type `T`, and the fields `x` and `y` are _both_ that same type, whatever that type may be. If we create an instance of a `Point<T>` that has values of different types, as in Listing 10-7, our code won’t compile.\n\nFilename: src/main.rs\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}\n```\n\nListing 10-7: The fields `x` and `y` must be the same type because both have the same generic data type `T`.\n\nIn this example, when we assign the integer value `5` to `x`, we let the compiler know that the generic type `T` will be an integer for this instance of `Point<T>`. Then when we specify `4.0` for `y`, which we’ve defined to have the same type as `x`, we’ll get a type mismatch error like this:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n --> src/main.rs:7:38\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n\n```\n\nTo define a `Point` struct where `x` and `y` are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we change the definition of `Point` to be generic over types `T` and `U` where `x` is of type `T` and `y` is of type `U`.\n\nFilename: src/main.rs\n\n```rust\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n```\n\nListing 10-8: A `Point<T, U>` generic over two types so that `x` and `y` can be values of different types\n\nNow all the instances of `Point` shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. If you’re finding you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.\n\n### [In Enum Definitions](#in-enum-definitions)\n\nAs we did with structs, we can define enums to hold generic data types in their variants. Let’s take another look at the `Option<T>` enum that the standard library provides, which we used in Chapter 6:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Option<T> {\n    Some(T),\n    None,\n}\n}\n```\n\nThis definition should now make more sense to you. As you can see, the `Option<T>` enum is generic over type `T` and has two variants: `Some`, which holds one value of type `T`, and a `None` variant that doesn’t hold any value. By using the `Option<T>` enum, we can express the abstract concept of an optional value, and because `Option<T>` is generic, we can use this abstraction no matter what the type of the optional value is.\n\nEnums can use multiple generic types as well. The definition of the `Result` enum that we used in Chapter 9 is one example:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n}\n```\n\nThe `Result` enum is generic over two types, `T` and `E`, and has two variants: `Ok`, which holds a value of type `T`, and `Err`, which holds a value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (return a value of some type `T`) or fail (return an error of some type `E`). In fact, this is what we used to open a file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when the file was opened successfully and `E` was filled in with the type `std::io::Error` when there were problems opening the file.\n\nWhen you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.\n\n### [In Method Definitions](#in-method-definitions)\n\nWe can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions too. Listing 10-9 shows the `Point<T>` struct we defined in Listing 10-6 with a method named `x` implemented on it.\n\nFilename: src/main.rs\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n\nListing 10-9: Implementing a method named `x` on the `Point<T>` struct that will return a reference to the `x` field of type `T`\n\nHere, we’ve defined a method named `x` on `Point<T>` that returns a reference to the data in the field `x`.\n\nNote that we have to declare `T` just after `impl` so we can use `T` to specify that we’re implementing methods on the type `Point<T>`. By declaring `T` as a generic type after `impl`, Rust can identify that the type in the angle brackets in `Point` is a generic type rather than a concrete type. We could have chosen a different name for this generic parameter than the generic parameter declared in the struct definition, but using the same name is conventional. Methods written within an `impl` that declares the generic type will be defined on any instance of the type, no matter what concrete type ends up substituting for the generic type.\n\nWe can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only on `Point<f32>` instances rather than on `Point<T>` instances with any generic type. In Listing 10-10 we use the concrete type `f32`, meaning we don’t declare any types after `impl`.\n\nFilename: src/main.rs\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n\nListing 10-10: An `impl` block that only applies to a struct with a particular concrete type for the generic type parameter `T`\n\nThis code means the type `Point<f32>` will have a `distance_from_origin` method; other instances of `Point<T>` where `T` is not of type `f32` will not have this method defined. The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating-point types.\n\nGeneric type parameters in a struct definition aren’t always the same as those you use in that same struct’s method signatures. Listing 10-11 uses the generic types `X1` and `Y1` for the `Point` struct and `X2` `Y2` for the `mixup` method signature to make the example clearer. The method creates a new `Point` instance with the `x` value from the `self` `Point` (of type `X1`) and the `y` value from the passed-in `Point` (of type `Y2`).\n\nFilename: src/main.rs\n\n```rust\nstruct Point<X1, Y1> {\n    x: X1,\n    y: Y1,\n}\n\nimpl<X1, Y1> Point<X1, Y1> {\n    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n```\n\nListing 10-11: A method that uses generic types different from its struct’s definition\n\nIn `main`, we’ve defined a `Point` that has an `i32` for `x` (with value `5`) and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct that has a string slice for `x` (with value `\"Hello\"`) and a `char` for `y` (with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`, which will have an `i32` for `x` because `x` came from `p1`. The `p3` variable will have a `char` for `y` because `y` came from `p2`. The `println!` macro call will print `p3.x = 5, p3.y = c`.\n\nThe purpose of this example is to demonstrate a situation in which some generic parameters are declared with `impl` and some are declared with the method definition. Here, the generic parameters `X1` and `Y1` are declared after `impl` because they go with the struct definition. The generic parameters `X2` and `Y2` are declared after `fn mixup` because they’re only relevant to the method.\n\n### [Performance of Code Using Generics](#performance-of-code-using-generics)\n\nYou might be wondering whether there is a runtime cost when using generic type parameters. The good news is that using generic types won’t make your program run any slower than it would with concrete types.\n\nRust accomplishes this by performing monomorphization of the code using generics at compile time. _Monomorphization_ is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.\n\nLet’s look at how this works by using the standard library’s generic `Option<T>` enum:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet integer = Some(5);\nlet float = Some(5.0);\n}\n```\n\nWhen Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in `Option<T>` instances and identifies two kinds of `Option<T>`: one is `i32` and the other is `f64`. As such, it expands the generic definition of `Option<T>` into two definitions specialized to `i32` and `f64`, thereby replacing the generic definition with the specific ones.\n\nThe monomorphized version of the code looks similar to the following (the compiler uses different names than what we’re using here for illustration):\n\nFilename: src/main.rs\n\n```rust\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n```\n\nThe generic `Option<T>` is replaced with the specific definitions created by the compiler. Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust’s generics extremely efficient at runtime.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Generic Data Types - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"generic-data-types\"><a class=\"header\" href=\"#generic-data-types\">Generic Data Types</a></h2>\n<p>We use generics to create definitions for items like function signatures or\nstructs, which we can then use with many different concrete data types. Let’s\nfirst look at how to define functions, structs, enums, and methods using\ngenerics. Then we’ll discuss how generics affect code performance.</p>\n<h3 id=\"in-function-definitions\"><a class=\"header\" href=\"#in-function-definitions\">In Function Definitions</a></h3>\n<p>When defining a function that uses generics, we place the generics in the\nsignature of the function where we would usually specify the data types of the\nparameters and return value. Doing so makes our code more flexible and provides\nmore functionality to callers of our function while preventing code duplication.</p>\n<p>Continuing with our <code class=\"hljs\">largest</code> function, Listing 10-4 shows two functions that\nboth find the largest value in a slice. We’ll then combine these into a single\nfunction that uses generics.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">largest_i32</span></span>(list: &amp;[<span class=\"hljs-built_in\">i32</span>]) -&gt; &amp;<span class=\"hljs-built_in\">i32</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> largest = &amp;list[<span class=\"hljs-number\">0</span>];\n\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> list {\n        <span class=\"hljs-keyword\">if</span> item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">largest_char</span></span>(list: &amp;[<span class=\"hljs-built_in\">char</span>]) -&gt; &amp;<span class=\"hljs-built_in\">char</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> largest = &amp;list[<span class=\"hljs-number\">0</span>];\n\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> list {\n        <span class=\"hljs-keyword\">if</span> item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> number_list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">65</span>];\n\n    <span class=\"hljs-keyword\">let</span> result = largest_i32(&amp;number_list);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The largest number is {result}\"</span>);\n<span class=\"boring\">    <span class=\"hljs-built_in\">assert_eq!</span>(*result, <span class=\"hljs-number\">100</span>);\n</span>\n    <span class=\"hljs-keyword\">let</span> char_list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'m'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'q'</span>];\n\n    <span class=\"hljs-keyword\">let</span> result = largest_char(&amp;char_list);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The largest char is {result}\"</span>);\n<span class=\"boring\">    <span class=\"hljs-built_in\">assert_eq!</span>(*result, <span class=\"hljs-string\">'y'</span>);\n</span>}</code></pre></pre>\n<p><span class=\"caption\">Listing 10-4: Two functions that differ only in their\nnames and in the types in their signatures</span></p>\n<p>The <code class=\"hljs\">largest_i32</code> function is the one we extracted in Listing 10-3 that finds\nthe largest <code class=\"hljs\">i32</code> in a slice. The <code class=\"hljs\">largest_char</code> function finds the largest\n<code class=\"hljs\">char</code> in a slice. The function bodies have the same code, so let’s eliminate\nthe duplication by introducing a generic type parameter in a single function.</p>\n<p>To parameterize the types in a new single function, we need to name the type\nparameter, just as we do for the value parameters to a function. You can use\nany identifier as a type parameter name. But we’ll use <code class=\"hljs\">T</code> because, by\nconvention, type parameter names in Rust are short, often just one letter, and\nRust’s type-naming convention is UpperCamelCase. Short for <em>type</em>, <code class=\"hljs\">T</code> is the\ndefault choice of most Rust programmers.</p>\n<p>When we use a parameter in the body of the function, we have to declare the\nparameter name in the signature so the compiler knows what that name means.\nSimilarly, when we use a type parameter name in a function signature, we have\nto declare the type parameter name before we use it. To define the generic\n<code class=\"hljs\">largest</code> function, we place type name declarations inside angle brackets,\n<code class=\"hljs\">&lt;&gt;</code>, between the name of the function and the parameter list, like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>\n<p>We read this definition as: the function <code class=\"hljs\">largest</code> is generic over some type\n<code class=\"hljs\">T</code>. This function has one parameter named <code class=\"hljs\">list</code>, which is a slice of values\nof type <code class=\"hljs\">T</code>. The <code class=\"hljs\">largest</code> function will return a reference to a value of the\nsame type <code class=\"hljs\">T</code>.</p>\n<p>Listing 10-5 shows the combined <code class=\"hljs\">largest</code> function definition using the generic\ndata type in its signature. The listing also shows how we can call the function\nwith either a slice of <code class=\"hljs\">i32</code> values or <code class=\"hljs\">char</code> values. Note that this code won’t\ncompile yet, but we’ll fix it later in this chapter.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> largest = &amp;list[<span class=\"hljs-number\">0</span>];\n\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> list {\n        <span class=\"hljs-keyword\">if</span> item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> number_list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">65</span>];\n\n    <span class=\"hljs-keyword\">let</span> result = largest(&amp;number_list);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The largest number is {result}\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> char_list = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'m'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'q'</span>];\n\n    <span class=\"hljs-keyword\">let</span> result = largest(&amp;char_list);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The largest char is {result}\"</span>);\n}</code></pre>\n<p><span class=\"caption\">Listing 10-5: The <code class=\"hljs\">largest</code> function using generic type\nparameters; this doesn’t compile yet</span></p>\n<p>If we compile this code right now, we’ll get this error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:5:17</span>\n  |\n5 |         if item &gt; largest {\n  |            ---- ^ ------- &amp;T\n  |            |\n  |            &amp;T\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {\n  |             ++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n</code></pre>\n<p>The help text mentions <code class=\"hljs\">std::cmp::PartialOrd</code>, which is a <em>trait</em>, and we’re\ngoing to talk about traits in the next section. For now, know that this error\nstates that the body of <code class=\"hljs\">largest</code> won’t work for all possible types that <code class=\"hljs\">T</code>\ncould be. Because we want to compare values of type <code class=\"hljs\">T</code> in the body, we can\nonly use types whose values can be ordered. To enable comparisons, the standard\nlibrary has the <code class=\"hljs\">std::cmp::PartialOrd</code> trait that you can implement on types\n(see Appendix C for more on this trait). By following the help text’s\nsuggestion, we restrict the types valid for <code class=\"hljs\">T</code> to only those that implement\n<code class=\"hljs\">PartialOrd</code> and this example will compile, because the standard library\nimplements <code class=\"hljs\">PartialOrd</code> on both <code class=\"hljs\">i32</code> and <code class=\"hljs\">char</code>.</p>\n<h3 id=\"in-struct-definitions\"><a class=\"header\" href=\"#in-struct-definitions\">In Struct Definitions</a></h3>\n<p>We can also define structs to use a generic type parameter in one or more\nfields using the <code class=\"hljs\">&lt;&gt;</code> syntax. Listing 10-6 defines a <code class=\"hljs\">Point&lt;T&gt;</code> struct to hold\n<code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> coordinate values of any type.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> integer = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">10</span> };\n    <span class=\"hljs-keyword\">let</span> float = Point { x: <span class=\"hljs-number\">1.0</span>, y: <span class=\"hljs-number\">4.0</span> };\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 10-6: A <code class=\"hljs\">Point&lt;T&gt;</code> struct that holds <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code>\nvalues of type <code class=\"hljs\">T</code></span></p>\n<p>The syntax for using generics in struct definitions is similar to that used in\nfunction definitions. First we declare the name of the type parameter inside\nangle brackets just after the name of the struct. Then we use the generic\ntype in the struct definition where we would otherwise specify concrete data\ntypes.</p>\n<p>Note that because we’ve used only one generic type to define <code class=\"hljs\">Point&lt;T&gt;</code>, this\ndefinition says that the <code class=\"hljs\">Point&lt;T&gt;</code> struct is generic over some type <code class=\"hljs\">T</code>, and\nthe fields <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> are <em>both</em> that same type, whatever that type may be. If\nwe create an instance of a <code class=\"hljs\">Point&lt;T&gt;</code> that has values of different types, as in\nListing 10-7, our code won’t compile.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> wont_work = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">4.0</span> };\n}</code></pre>\n<p><span class=\"caption\">Listing 10-7: The fields <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> must be the same\ntype because both have the same generic data type <code class=\"hljs\">T</code>.</span></p>\n<p>In this example, when we assign the integer value <code class=\"hljs\">5</code> to <code class=\"hljs\">x</code>, we let the\ncompiler know that the generic type <code class=\"hljs\">T</code> will be an integer for this instance of\n<code class=\"hljs\">Point&lt;T&gt;</code>. Then when we specify <code class=\"hljs\">4.0</code> for <code class=\"hljs\">y</code>, which we’ve defined to have the\nsame type as <code class=\"hljs\">x</code>, we’ll get a type mismatch error like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:7:38</span>\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n</code></pre>\n<p>To define a <code class=\"hljs\">Point</code> struct where <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> are both generics but could have\ndifferent types, we can use multiple generic type parameters. For example, in\nListing 10-8, we change the definition of <code class=\"hljs\">Point</code> to be generic over types <code class=\"hljs\">T</code>\nand <code class=\"hljs\">U</code> where <code class=\"hljs\">x</code> is of type <code class=\"hljs\">T</code> and <code class=\"hljs\">y</code> is of type <code class=\"hljs\">U</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> both_integer = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">10</span> };\n    <span class=\"hljs-keyword\">let</span> both_float = Point { x: <span class=\"hljs-number\">1.0</span>, y: <span class=\"hljs-number\">4.0</span> };\n    <span class=\"hljs-keyword\">let</span> integer_and_float = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">4.0</span> };\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 10-8: A <code class=\"hljs\">Point&lt;T, U&gt;</code> generic over two types so\nthat <code class=\"hljs\">x</code> and <code class=\"hljs\">y</code> can be values of different types</span></p>\n<p>Now all the instances of <code class=\"hljs\">Point</code> shown are allowed! You can use as many generic\ntype parameters in a definition as you want, but using more than a few makes\nyour code hard to read. If you’re finding you need lots of generic types in\nyour code, it could indicate that your code needs restructuring into smaller\npieces.</p>\n<h3 id=\"in-enum-definitions\"><a class=\"header\" href=\"#in-enum-definitions\">In Enum Definitions</a></h3>\n<p>As we did with structs, we can define enums to hold generic data types in their\nvariants. Let’s take another look at the <code class=\"hljs\">Option&lt;T&gt;</code> enum that the standard\nlibrary provides, which we used in Chapter 6:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Option</span></span>&lt;T&gt; {\n    <span class=\"hljs-literal\">Some</span>(T),\n    <span class=\"hljs-literal\">None</span>,\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This definition should now make more sense to you. As you can see, the\n<code class=\"hljs\">Option&lt;T&gt;</code> enum is generic over type <code class=\"hljs\">T</code> and has two variants: <code class=\"hljs\">Some</code>, which\nholds one value of type <code class=\"hljs\">T</code>, and a <code class=\"hljs\">None</code> variant that doesn’t hold any value.\nBy using the <code class=\"hljs\">Option&lt;T&gt;</code> enum, we can express the abstract concept of an\noptional value, and because <code class=\"hljs\">Option&lt;T&gt;</code> is generic, we can use this abstraction\nno matter what the type of the optional value is.</p>\n<p>Enums can use multiple generic types as well. The definition of the <code class=\"hljs\">Result</code>\nenum that we used in Chapter 9 is one example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Result</span></span>&lt;T, E&gt; {\n    <span class=\"hljs-literal\">Ok</span>(T),\n    <span class=\"hljs-literal\">Err</span>(E),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The <code class=\"hljs\">Result</code> enum is generic over two types, <code class=\"hljs\">T</code> and <code class=\"hljs\">E</code>, and has two variants:\n<code class=\"hljs\">Ok</code>, which holds a value of type <code class=\"hljs\">T</code>, and <code class=\"hljs\">Err</code>, which holds a value of type\n<code class=\"hljs\">E</code>. This definition makes it convenient to use the <code class=\"hljs\">Result</code> enum anywhere we\nhave an operation that might succeed (return a value of some type <code class=\"hljs\">T</code>) or fail\n(return an error of some type <code class=\"hljs\">E</code>). In fact, this is what we used to open a\nfile in Listing 9-3, where <code class=\"hljs\">T</code> was filled in with the type <code class=\"hljs\">std::fs::File</code> when\nthe file was opened successfully and <code class=\"hljs\">E</code> was filled in with the type\n<code class=\"hljs\">std::io::Error</code> when there were problems opening the file.</p>\n<p>When you recognize situations in your code with multiple struct or enum\ndefinitions that differ only in the types of the values they hold, you can\navoid duplication by using generic types instead.</p>\n<h3 id=\"in-method-definitions\"><a class=\"header\" href=\"#in-method-definitions\">In Method Definitions</a></h3>\n<p>We can implement methods on structs and enums (as we did in Chapter 5) and use\ngeneric types in their definitions too. Listing 10-9 shows the <code class=\"hljs\">Point&lt;T&gt;</code>\nstruct we defined in Listing 10-6 with a method named <code class=\"hljs\">x</code> implemented on it.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Point&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">x</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;T {\n        &amp;<span class=\"hljs-keyword\">self</span>.x\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">10</span> };\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"p.x = {}\"</span>, p.x());\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 10-9: Implementing a method named <code class=\"hljs\">x</code> on the\n<code class=\"hljs\">Point&lt;T&gt;</code> struct that will return a reference to the <code class=\"hljs\">x</code> field of type\n<code class=\"hljs\">T</code></span></p>\n<p>Here, we’ve defined a method named <code class=\"hljs\">x</code> on <code class=\"hljs\">Point&lt;T&gt;</code> that returns a reference\nto the data in the field <code class=\"hljs\">x</code>.</p>\n<p>Note that we have to declare <code class=\"hljs\">T</code> just after <code class=\"hljs\">impl</code> so we can use <code class=\"hljs\">T</code> to specify\nthat we’re implementing methods on the type <code class=\"hljs\">Point&lt;T&gt;</code>. By declaring <code class=\"hljs\">T</code> as a\ngeneric type after <code class=\"hljs\">impl</code>, Rust can identify that the type in the angle\nbrackets in <code class=\"hljs\">Point</code> is a generic type rather than a concrete type. We could\nhave chosen a different name for this generic parameter than the generic\nparameter declared in the struct definition, but using the same name is\nconventional. Methods written within an <code class=\"hljs\">impl</code> that declares the generic type\nwill be defined on any instance of the type, no matter what concrete type ends\nup substituting for the generic type.</p>\n<p>We can also specify constraints on generic types when defining methods on the\ntype. We could, for example, implement methods only on <code class=\"hljs\">Point&lt;f32&gt;</code> instances\nrather than on <code class=\"hljs\">Point&lt;T&gt;</code> instances with any generic type. In Listing 10-10 we\nuse the concrete type <code class=\"hljs\">f32</code>, meaning we don’t declare any types after <code class=\"hljs\">impl</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>&lt;T&gt; {\n</span><span class=\"boring\">    x: T,\n</span><span class=\"boring\">    y: T,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; Point&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">x</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;T {\n</span><span class=\"boring\">        &amp;<span class=\"hljs-keyword\">self</span>.x\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Point&lt;<span class=\"hljs-built_in\">f32</span>&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">distance_from_origin</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">f32</span> {\n        (<span class=\"hljs-keyword\">self</span>.x.powi(<span class=\"hljs-number\">2</span>) + <span class=\"hljs-keyword\">self</span>.y.powi(<span class=\"hljs-number\">2</span>)).sqrt()\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> p = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">10</span> };\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"p.x = {}\"</span>, p.x());\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 10-10: An <code class=\"hljs\">impl</code> block that only applies to a\nstruct with a particular concrete type for the generic type parameter <code class=\"hljs\">T</code></span></p>\n<p>This code means the type <code class=\"hljs\">Point&lt;f32&gt;</code> will have a <code class=\"hljs\">distance_from_origin</code>\nmethod; other instances of <code class=\"hljs\">Point&lt;T&gt;</code> where <code class=\"hljs\">T</code> is not of type <code class=\"hljs\">f32</code> will not\nhave this method defined. The method measures how far our point is from the\npoint at coordinates (0.0, 0.0) and uses mathematical operations that are\navailable only for floating-point types.</p>\n<p>Generic type parameters in a struct definition aren’t always the same as those\nyou use in that same struct’s method signatures. Listing 10-11 uses the generic\ntypes <code class=\"hljs\">X1</code> and <code class=\"hljs\">Y1</code> for the <code class=\"hljs\">Point</code> struct and <code class=\"hljs\">X2</code> <code class=\"hljs\">Y2</code> for the <code class=\"hljs\">mixup</code> method\nsignature to make the example clearer. The method creates a new <code class=\"hljs\">Point</code>\ninstance with the <code class=\"hljs\">x</code> value from the <code class=\"hljs\">self</code> <code class=\"hljs\">Point</code> (of type <code class=\"hljs\">X1</code>) and the <code class=\"hljs\">y</code>\nvalue from the passed-in <code class=\"hljs\">Point</code> (of type <code class=\"hljs\">Y2</code>).</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>&lt;X1, Y1&gt; {\n    x: X1,\n    y: Y1,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">mixup</span></span>&lt;X2, Y2&gt;(<span class=\"hljs-keyword\">self</span>, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {\n        Point {\n            x: <span class=\"hljs-keyword\">self</span>.x,\n            y: other.y,\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> p1 = Point { x: <span class=\"hljs-number\">5</span>, y: <span class=\"hljs-number\">10.4</span> };\n    <span class=\"hljs-keyword\">let</span> p2 = Point { x: <span class=\"hljs-string\">\"Hello\"</span>, y: <span class=\"hljs-string\">'c'</span> };\n\n    <span class=\"hljs-keyword\">let</span> p3 = p1.mixup(p2);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"p3.x = {}, p3.y = {}\"</span>, p3.x, p3.y);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 10-11: A method that uses generic types different\nfrom its struct’s definition</span></p>\n<p>In <code class=\"hljs\">main</code>, we’ve defined a <code class=\"hljs\">Point</code> that has an <code class=\"hljs\">i32</code> for <code class=\"hljs\">x</code> (with value <code class=\"hljs\">5</code>)\nand an <code class=\"hljs\">f64</code> for <code class=\"hljs\">y</code> (with value <code class=\"hljs\">10.4</code>). The <code class=\"hljs\">p2</code> variable is a <code class=\"hljs\">Point</code> struct\nthat has a string slice for <code class=\"hljs\">x</code> (with value <code class=\"hljs\">\"Hello\"</code>) and a <code class=\"hljs\">char</code> for <code class=\"hljs\">y</code>\n(with value <code class=\"hljs\">c</code>). Calling <code class=\"hljs\">mixup</code> on <code class=\"hljs\">p1</code> with the argument <code class=\"hljs\">p2</code> gives us <code class=\"hljs\">p3</code>,\nwhich will have an <code class=\"hljs\">i32</code> for <code class=\"hljs\">x</code> because <code class=\"hljs\">x</code> came from <code class=\"hljs\">p1</code>. The <code class=\"hljs\">p3</code> variable\nwill have a <code class=\"hljs\">char</code> for <code class=\"hljs\">y</code> because <code class=\"hljs\">y</code> came from <code class=\"hljs\">p2</code>. The <code class=\"hljs\">println!</code> macro\ncall will print <code class=\"hljs\">p3.x = 5, p3.y = c</code>.</p>\n<p>The purpose of this example is to demonstrate a situation in which some generic\nparameters are declared with <code class=\"hljs\">impl</code> and some are declared with the method\ndefinition. Here, the generic parameters <code class=\"hljs\">X1</code> and <code class=\"hljs\">Y1</code> are declared after\n<code class=\"hljs\">impl</code> because they go with the struct definition. The generic parameters <code class=\"hljs\">X2</code>\nand <code class=\"hljs\">Y2</code> are declared after <code class=\"hljs\">fn mixup</code> because they’re only relevant to the\nmethod.</p>\n<h3 id=\"performance-of-code-using-generics\"><a class=\"header\" href=\"#performance-of-code-using-generics\">Performance of Code Using Generics</a></h3>\n<p>You might be wondering whether there is a runtime cost when using generic type\nparameters. The good news is that using generic types won’t make your program\nrun any slower than it would with concrete types.</p>\n<p>Rust accomplishes this by performing monomorphization of the code using\ngenerics at compile time. <em>Monomorphization</em> is the process of turning generic\ncode into specific code by filling in the concrete types that are used when\ncompiled. In this process, the compiler does the opposite of the steps we used\nto create the generic function in Listing 10-5: the compiler looks at all the\nplaces where generic code is called and generates code for the concrete types\nthe generic code is called with.</p>\n<p>Let’s look at how this works by using the standard library’s generic\n<code class=\"hljs\">Option&lt;T&gt;</code> enum:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> integer = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-keyword\">let</span> float = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5.0</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>When Rust compiles this code, it performs monomorphization. During that\nprocess, the compiler reads the values that have been used in <code class=\"hljs\">Option&lt;T&gt;</code>\ninstances and identifies two kinds of <code class=\"hljs\">Option&lt;T&gt;</code>: one is <code class=\"hljs\">i32</code> and the other\nis <code class=\"hljs\">f64</code>. As such, it expands the generic definition of <code class=\"hljs\">Option&lt;T&gt;</code> into two\ndefinitions specialized to <code class=\"hljs\">i32</code> and <code class=\"hljs\">f64</code>, thereby replacing the generic\ndefinition with the specific ones.</p>\n<p>The monomorphized version of the code looks similar to the following (the\ncompiler uses different names than what we’re using here for illustration):</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Option_i32</span></span> {\n    <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-built_in\">i32</span>),\n    <span class=\"hljs-literal\">None</span>,\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Option_f64</span></span> {\n    <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-built_in\">f64</span>),\n    <span class=\"hljs-literal\">None</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> integer = Option_i32::<span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> float = Option_f64::<span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5.0</span>);\n}</code></pre></pre>\n<p>The generic <code class=\"hljs\">Option&lt;T&gt;</code> is replaced with the specific definitions created by\nthe compiler. Because Rust compiles generic code into code that specifies the\ntype in each instance, we pay no runtime cost for using generics. When the code\nruns, it performs just as it would if we had duplicated each definition by\nhand. The process of monomorphization makes Rust’s generics extremely efficient\nat runtime.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch10-00-generics.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch10-02-traits.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch10-00-generics.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch10-02-traits.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:22.023Z"
}