{
	"title": "Using Message Passing to Transfer Data Between Threads - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch16-02-message-passing.html",
	"markdown": "# Using Message Passing to Transfer Data Between Threads\n\nOne increasingly popular approach to ensuring safe concurrency is _message passing_, where threads or actors communicate by sending each other messages containing data. Here’s the idea in a slogan from [the Go language documentation](https://golang.org/doc/effective_go.html#concurrency): “Do not communicate by sharing memory; instead, share memory by communicating.”\n\nTo accomplish message-sending concurrency, Rust’s standard library provides an implementation of _channels_. A channel is a general programming concept by which data is sent from one thread to another.\n\nYou can imagine a channel in programming as being like a directional channel of water, such as a stream or a river. If you put something like a rubber duck into a river, it will travel downstream to the end of the waterway.\n\nA channel has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be _closed_ if either the transmitter or receiver half is dropped.\n\nHere, we’ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We’ll be sending simple values between threads using a channel to illustrate the feature. Once you’re familiar with the technique, you could use channels for any threads that need to communicate between each other, such as a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.\n\nFirst, in Listing 16-6, we’ll create a channel but not do anything with it. Note that this won’t compile yet because Rust can’t tell what type of values we want to send over the channel.\n\nFilename: src/main.rs\n\n```rust\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n```\n\nListing 16-6: Creating a channel and assigning the two halves to `tx` and `rx`\n\nWe create a new channel using the `mpsc::channel` function; `mpsc` stands for _multiple producer, single consumer_. In short, the way Rust’s standard library implements channels means a channel can have multiple _sending_ ends that produce values but only one _receiving_ end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We’ll start with a single producer for now, but we’ll add multiple producers when we get this example working.\n\nThe `mpsc::channel` function returns a tuple, the first element of which is the sending end—the transmitter—and the second element is the receiving end—the receiver. The abbreviations `tx` and `rx` are traditionally used in many fields for _transmitter_ and _receiver_ respectively, so we name our variables as such to indicate each end. We’re using a `let` statement with a pattern that destructures the tuples; we’ll discuss the use of patterns in `let` statements and destructuring in Chapter 18. For now, know that using a `let` statement this way is a convenient approach to extract the pieces of the tuple returned by `mpsc::channel`.\n\nLet’s move the transmitting end into a spawned thread and have it send one string so the spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.\n\nFilename: src/main.rs\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n}\n```\n\nListing 16-7: Moving `tx` to a spawned thread and sending “hi”\n\nAgain, we’re using `thread::spawn` to create a new thread and then using `move` to move `tx` into the closure so the spawned thread owns `tx`. The spawned thread needs to own the transmitter to be able to send messages through the channel. The transmitter has a `send` method that takes the value we want to send. The `send` method returns a `Result<T, E>` type, so if the receiver has already been dropped and there’s nowhere to send a value, the send operation will return an error. In this example, we’re calling `unwrap` to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.\n\nIn Listing 16-8, we’ll get the value from the receiver in the main thread. This is like retrieving the rubber duck from the water at the end of the river or receiving a chat message.\n\nFilename: src/main.rs\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {received}\");\n}\n```\n\nListing 16-8: Receiving the value “hi” in the main thread and printing it\n\nThe receiver has two useful methods: `recv` and `try_recv`. We’re using `recv`, short for _receive_, which will block the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, `recv` will return it in a `Result<T, E>`. When the transmitter closes, `recv` will return an error to signal that no more values will be coming.\n\nThe `try_recv` method doesn’t block, but will instead return a `Result<T, E>` immediately: an `Ok` value holding a message if one is available and an `Err` value if there aren’t any messages this time. Using `try_recv` is useful if this thread has other work to do while waiting for messages: we could write a loop that calls `try_recv` every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.\n\nWe’ve used `recv` in this example for simplicity; we don’t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.\n\nWhen we run the code in Listing 16-8, we’ll see the value printed from the main thread:\n\n```text\nGot: hi\n\n```\n\nPerfect!\n\n### [Channels and Ownership Transference](#channels-and-ownership-transference)\n\nThe ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let’s do an experiment to show how channels and ownership work together to prevent problems: we’ll try to use a `val` value in the spawned thread _after_ we’ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn’t allowed:\n\nFilename: src/main.rs\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n        println!(\"val is {val}\");\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {received}\");\n}\n```\n\nListing 16-9: Attempting to use `val` after we’ve sent it down the channel\n\nHere, we try to print `val` after we’ve sent it down the channel via `tx.send`. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread’s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:\n\n```console\n$ cargo run\n   Compiling message-passing v0.1.0 (file:///projects/message-passing)\nerror[E0382]: borrow of moved value: `val`\n  --> src/main.rs:10:26\n   |\n8  |         let val = String::from(\"hi\");\n   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait\n9  |         tx.send(val).unwrap();\n   |                 --- value moved here\n10 |         println!(\"val is {val}\");\n   |                          ^^^^^ value borrowed here after move\n   |\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n9  |         tx.send(val.clone()).unwrap();\n   |                    ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `message-passing` (bin \"message-passing\") due to 1 previous error\n\n```\n\nOur concurrency mistake has caused a compile time error. The `send` function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. This stops us from accidentally using the value again after sending it; the ownership system checks that everything is okay.\n\n### [Sending Multiple Values and Seeing the Receiver Waiting](#sending-multiple-values-and-seeing-the-receiver-waiting)\n\nThe code in Listing 16-8 compiled and ran, but it didn’t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we’ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.\n\nFilename: src/main.rs\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n}\n```\n\nListing 16-10: Sending multiple messages and pausing between each\n\nThis time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the `thread::sleep` function with a `Duration` value of 1 second.\n\nIn the main thread, we’re not calling the `recv` function explicitly anymore: instead, we’re treating `rx` as an iterator. For each value received, we’re printing it. When the channel is closed, iteration will end.\n\nWhen running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:\n\n```text\nGot: hi\nGot: from\nGot: the\nGot: thread\n\n```\n\nBecause we don’t have any code that pauses or delays in the `for` loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.\n\n### [Creating Multiple Producers by Cloning the Transmitter](#creating-multiple-producers-by-cloning-the-transmitter)\n\nEarlier we mentioned that `mpsc` was an acronym for _multiple producer, single consumer_. Let’s put `mpsc` to use and expand the code in Listing 16-10 to create multiple threads that all send values to the same receiver. We can do so by cloning the transmitter, as shown in Listing 16-11:\n\nFilename: src/main.rs\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n\n    // --snip--\n}\n```\n\nListing 16-11: Sending multiple messages from multiple producers\n\nThis time, before we create the first spawned thread, we call `clone` on the transmitter. This will give us a new transmitter we can pass to the first spawned thread. We pass the original transmitter to a second spawned thread. This gives us two threads, each sending different messages to the one receiver.\n\nWhen you run the code, your output should look something like this:\n\n```text\nGot: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n\n```\n\nYou might see the values in another order, depending on your system. This is what makes concurrency interesting as well as difficult. If you experiment with `thread::sleep`, giving it various values in the different threads, each run will be more nondeterministic and create different output each time.\n\nNow that we’ve looked at how channels work, let’s look at a different method of concurrency.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Using Message Passing to Transfer Data Between Threads - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"using-message-passing-to-transfer-data-between-threads\"><a class=\"header\" href=\"#using-message-passing-to-transfer-data-between-threads\">Using Message Passing to Transfer Data Between Threads</a></h2>\n<p>One increasingly popular approach to ensuring safe concurrency is <em>message\npassing</em>, where threads or actors communicate by sending each other messages\ncontaining data. Here’s the idea in a slogan from <a href=\"https://golang.org/doc/effective_go.html#concurrency\">the Go language\ndocumentation</a>:\n“Do not communicate by sharing memory; instead, share memory by communicating.”</p>\n<p>To accomplish message-sending concurrency, Rust’s standard library provides an\nimplementation of <em>channels</em>. A channel is a general programming concept by\nwhich data is sent from one thread to another.</p>\n<p>You can imagine a channel in programming as being like a directional channel of\nwater, such as a stream or a river. If you put something like a rubber duck\ninto a river, it will travel downstream to the end of the waterway.</p>\n<p>A channel has two halves: a transmitter and a receiver. The transmitter half is\nthe upstream location where you put rubber ducks into the river, and the\nreceiver half is where the rubber duck ends up downstream. One part of your\ncode calls methods on the transmitter with the data you want to send, and\nanother part checks the receiving end for arriving messages. A channel is said\nto be <em>closed</em> if either the transmitter or receiver half is dropped.</p>\n<p>Here, we’ll work up to a program that has one thread to generate values and\nsend them down a channel, and another thread that will receive the values and\nprint them out. We’ll be sending simple values between threads using a channel\nto illustrate the feature. Once you’re familiar with the technique, you could\nuse channels for any threads that need to communicate between each other, such\nas a chat system or a system where many threads perform parts of a calculation\nand send the parts to one thread that aggregates the results.</p>\n<p>First, in Listing 16-6, we’ll create a channel but not do anything with it.\nNote that this won’t compile yet because Rust can’t tell what type of values we\nwant to send over the channel.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::channel();\n}</code></pre>\n<p><span class=\"caption\">Listing 16-6: Creating a channel and assigning the two\nhalves to <code class=\"hljs\">tx</code> and <code class=\"hljs\">rx</code></span></p>\n<p>We create a new channel using the <code class=\"hljs\">mpsc::channel</code> function; <code class=\"hljs\">mpsc</code> stands for\n<em>multiple producer, single consumer</em>. In short, the way Rust’s standard library\nimplements channels means a channel can have multiple <em>sending</em> ends that\nproduce values but only one <em>receiving</em> end that consumes those values. Imagine\nmultiple streams flowing together into one big river: everything sent down any\nof the streams will end up in one river at the end. We’ll start with a single\nproducer for now, but we’ll add multiple producers when we get this example\nworking.</p>\n<p>The <code class=\"hljs\">mpsc::channel</code> function returns a tuple, the first element of which is the\nsending end—the transmitter—and the second element is the receiving end—the\nreceiver. The abbreviations <code class=\"hljs\">tx</code> and <code class=\"hljs\">rx</code> are traditionally used in many fields\nfor <em>transmitter</em> and <em>receiver</em> respectively, so we name our variables as such\nto indicate each end. We’re using a <code class=\"hljs\">let</code> statement with a pattern that\ndestructures the tuples; we’ll discuss the use of patterns in <code class=\"hljs\">let</code> statements\nand destructuring in Chapter 18. For now, know that using a <code class=\"hljs\">let</code> statement\nthis way is a convenient approach to extract the pieces of the tuple returned\nby <code class=\"hljs\">mpsc::channel</code>.</p>\n<p>Let’s move the transmitting end into a spawned thread and have it send one\nstring so the spawned thread is communicating with the main thread, as shown in\nListing 16-7. This is like putting a rubber duck in the river upstream or\nsending a chat message from one thread to another.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n<span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::channel();\n\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hi\"</span>);\n        tx.send(val).unwrap();\n    });\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 16-7: Moving <code class=\"hljs\">tx</code> to a spawned thread and sending\n“hi”</span></p>\n<p>Again, we’re using <code class=\"hljs\">thread::spawn</code> to create a new thread and then using <code class=\"hljs\">move</code>\nto move <code class=\"hljs\">tx</code> into the closure so the spawned thread owns <code class=\"hljs\">tx</code>. The spawned\nthread needs to own the transmitter to be able to send messages through the\nchannel. The transmitter has a <code class=\"hljs\">send</code> method that takes the value we want to\nsend. The <code class=\"hljs\">send</code> method returns a <code class=\"hljs\">Result&lt;T, E&gt;</code> type, so if the receiver has\nalready been dropped and there’s nowhere to send a value, the send operation\nwill return an error. In this example, we’re calling <code class=\"hljs\">unwrap</code> to panic in case\nof an error. But in a real application, we would handle it properly: return to\nChapter 9 to review strategies for proper error handling.</p>\n<p>In Listing 16-8, we’ll get the value from the receiver in the main thread. This\nis like retrieving the rubber duck from the water at the end of the river or\nreceiving a chat message.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n<span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::channel();\n\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hi\"</span>);\n        tx.send(val).unwrap();\n    });\n\n    <span class=\"hljs-keyword\">let</span> received = rx.recv().unwrap();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got: {received}\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 16-8: Receiving the value “hi” in the main thread\nand printing it</span></p>\n<p>The receiver has two useful methods: <code class=\"hljs\">recv</code> and <code class=\"hljs\">try_recv</code>. We’re using <code class=\"hljs\">recv</code>,\nshort for <em>receive</em>, which will block the main thread’s execution and wait\nuntil a value is sent down the channel. Once a value is sent, <code class=\"hljs\">recv</code> will\nreturn it in a <code class=\"hljs\">Result&lt;T, E&gt;</code>. When the transmitter closes, <code class=\"hljs\">recv</code> will return\nan error to signal that no more values will be coming.</p>\n<p>The <code class=\"hljs\">try_recv</code> method doesn’t block, but will instead return a <code class=\"hljs\">Result&lt;T, E&gt;</code>\nimmediately: an <code class=\"hljs\">Ok</code> value holding a message if one is available and an <code class=\"hljs\">Err</code>\nvalue if there aren’t any messages this time. Using <code class=\"hljs\">try_recv</code> is useful if\nthis thread has other work to do while waiting for messages: we could write a\nloop that calls <code class=\"hljs\">try_recv</code> every so often, handles a message if one is\navailable, and otherwise does other work for a little while until checking\nagain.</p>\n<p>We’ve used <code class=\"hljs\">recv</code> in this example for simplicity; we don’t have any other work\nfor the main thread to do other than wait for messages, so blocking the main\nthread is appropriate.</p>\n<p>When we run the code in Listing 16-8, we’ll see the value printed from the main\nthread:</p>\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">Got: hi\n</code></pre>\n<p>Perfect!</p>\n<h3 id=\"channels-and-ownership-transference\"><a class=\"header\" href=\"#channels-and-ownership-transference\">Channels and Ownership Transference</a></h3>\n<p>The ownership rules play a vital role in message sending because they help you\nwrite safe, concurrent code. Preventing errors in concurrent programming is the\nadvantage of thinking about ownership throughout your Rust programs. Let’s do\nan experiment to show how channels and ownership work together to prevent\nproblems: we’ll try to use a <code class=\"hljs\">val</code> value in the spawned thread <em>after</em> we’ve\nsent it down the channel. Try compiling the code in Listing 16-9 to see why\nthis code isn’t allowed:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n<span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::channel();\n\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hi\"</span>);\n        tx.send(val).unwrap();\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"val is {val}\"</span>);\n    });\n\n    <span class=\"hljs-keyword\">let</span> received = rx.recv().unwrap();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got: {received}\"</span>);\n}</code></pre>\n<p><span class=\"caption\">Listing 16-9: Attempting to use <code class=\"hljs\">val</code> after we’ve sent it\ndown the channel</span></p>\n<p>Here, we try to print <code class=\"hljs\">val</code> after we’ve sent it down the channel via <code class=\"hljs\">tx.send</code>.\nAllowing this would be a bad idea: once the value has been sent to another\nthread, that thread could modify or drop it before we try to use the value\nagain. Potentially, the other thread’s modifications could cause errors or\nunexpected results due to inconsistent or nonexistent data. However, Rust gives\nus an error if we try to compile the code in Listing 16-9:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling message-passing v0.1.0 (file:///projects/message-passing)\nerror[E0382]: borrow of moved value: `val`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:10:26</span>\n   |\n8  |         let val = String::from(\"hi\");\n   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait\n9  |         tx.send(val).unwrap();\n   |                 --- value moved here\n10 |         println!(\"val is {val}\");\n   |                          ^^^^^ value borrowed here after move\n   |\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n9  |         tx.send(val.clone()).unwrap();\n   |                    ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `message-passing` (bin \"message-passing\") due to 1 previous error\n</code></pre>\n<p>Our concurrency mistake has caused a compile time error. The <code class=\"hljs\">send</code> function\ntakes ownership of its parameter, and when the value is moved, the receiver\ntakes ownership of it. This stops us from accidentally using the value again\nafter sending it; the ownership system checks that everything is okay.</p>\n<h3 id=\"sending-multiple-values-and-seeing-the-receiver-waiting\"><a class=\"header\" href=\"#sending-multiple-values-and-seeing-the-receiver-waiting\">Sending Multiple Values and Seeing the Receiver Waiting</a></h3>\n<p>The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that\ntwo separate threads were talking to each other over the channel. In Listing\n16-10 we’ve made some modifications that will prove the code in Listing 16-8 is\nrunning concurrently: the spawned thread will now send multiple messages and\npause for a second between each message.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n<span class=\"hljs-keyword\">use</span> std::thread;\n<span class=\"hljs-keyword\">use</span> std::time::Duration;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::channel();\n\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> vals = <span class=\"hljs-built_in\">vec!</span>[\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hi\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"from\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"the\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"thread\"</span>),\n        ];\n\n        <span class=\"hljs-keyword\">for</span> val <span class=\"hljs-keyword\">in</span> vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    <span class=\"hljs-keyword\">for</span> received <span class=\"hljs-keyword\">in</span> rx {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got: {received}\"</span>);\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 16-10: Sending multiple messages and pausing\nbetween each</span></p>\n<p>This time, the spawned thread has a vector of strings that we want to send to\nthe main thread. We iterate over them, sending each individually, and pause\nbetween each by calling the <code class=\"hljs\">thread::sleep</code> function with a <code class=\"hljs\">Duration</code> value of\n1 second.</p>\n<p>In the main thread, we’re not calling the <code class=\"hljs\">recv</code> function explicitly anymore:\ninstead, we’re treating <code class=\"hljs\">rx</code> as an iterator. For each value received, we’re\nprinting it. When the channel is closed, iteration will end.</p>\n<p>When running the code in Listing 16-10, you should see the following output\nwith a 1-second pause in between each line:</p>\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">Got: hi\nGot: from\nGot: the\nGot: thread\n</code></pre>\n<p>Because we don’t have any code that pauses or delays in the <code class=\"hljs\">for</code> loop in the\nmain thread, we can tell that the main thread is waiting to receive values from\nthe spawned thread.</p>\n<h3 id=\"creating-multiple-producers-by-cloning-the-transmitter\"><a class=\"header\" href=\"#creating-multiple-producers-by-cloning-the-transmitter\">Creating Multiple Producers by Cloning the Transmitter</a></h3>\n<p>Earlier we mentioned that <code class=\"hljs\">mpsc</code> was an acronym for <em>multiple producer,\nsingle consumer</em>. Let’s put <code class=\"hljs\">mpsc</code> to use and expand the code in Listing 16-10\nto create multiple threads that all send values to the same receiver. We can do\nso by cloning the transmitter, as shown in Listing 16-11:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::thread;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::time::Duration;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-comment\">// --snip--</span>\n\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::channel();\n\n    <span class=\"hljs-keyword\">let</span> tx1 = tx.clone();\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> vals = <span class=\"hljs-built_in\">vec!</span>[\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hi\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"from\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"the\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"thread\"</span>),\n        ];\n\n        <span class=\"hljs-keyword\">for</span> val <span class=\"hljs-keyword\">in</span> vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> vals = <span class=\"hljs-built_in\">vec!</span>[\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"more\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"messages\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"for\"</span>),\n            <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"you\"</span>),\n        ];\n\n        <span class=\"hljs-keyword\">for</span> val <span class=\"hljs-keyword\">in</span> vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    <span class=\"hljs-keyword\">for</span> received <span class=\"hljs-keyword\">in</span> rx {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got: {received}\"</span>);\n    }\n\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 16-11: Sending multiple messages from multiple\nproducers</span></p>\n<p>This time, before we create the first spawned thread, we call <code class=\"hljs\">clone</code> on the\ntransmitter. This will give us a new transmitter we can pass to the first\nspawned thread. We pass the original transmitter to a second spawned thread.\nThis gives us two threads, each sending different messages to the one receiver.</p>\n<p>When you run the code, your output should look something like this:</p>\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">Got: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n</code></pre>\n<p>You might see the values in another order, depending on your system. This is\nwhat makes concurrency interesting as well as difficult. If you experiment with\n<code class=\"hljs\">thread::sleep</code>, giving it various values in the different threads, each run\nwill be more nondeterministic and create different output each time.</p>\n<p>Now that we’ve looked at how channels work, let’s look at a different method of\nconcurrency.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch16-01-threads.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch16-03-shared-state.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch16-01-threads.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch16-03-shared-state.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:30.781Z"
}