{
	"title": "The Dot Operator - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/dot-operator.html",
	"markdown": "# The Dot Operator - The Rustonomicon\n\nThe dot operator will perform a lot of magic to convert types. It will perform auto-referencing, auto-dereferencing, and coercion until types match. The detailed mechanics of method lookup are defined [here](https://rustc-dev-guide.rust-lang.org/method-lookup.html), but here is a brief overview that outlines the main steps.\n\nSuppose we have a function `foo` that has a receiver (a `self`, `&self` or `&mut self` parameter). If we call `value.foo()`, the compiler needs to determine what type `Self` is before it can call the correct implementation of the function. For this example, we will say that `value` has type `T`.\n\nWe will use [fully-qualified syntax](about:blank/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name) to be more clear about exactly which type we are calling a function on.\n\n-   First, the compiler checks if it can call `T::foo(value)` directly. This is called a \"by value\" method call.\n-   If it can't call this function (for example, if the function has the wrong type or a trait isn't implemented for `Self`), then the compiler tries to add in an automatic reference. This means that the compiler tries `<&T>::foo(value)` and `<&mut T>::foo(value)`. This is called an \"autoref\" method call.\n-   If none of these candidates worked, it dereferences `T` and tries again. This uses the `Deref` trait - if `T: Deref<Target = U>` then it tries again with type `U` instead of `T`. If it can't dereference `T`, it can also try _unsizing_ `T`. This just means that if `T` has a size parameter known at compile time, it \"forgets\" it for the purpose of resolving methods. For instance, this unsizing step can convert `[i32; 2]` into `[i32]` by \"forgetting\" the size of the array.\n\nHere is an example of the method lookup algorithm:\n\n```rust\nlet array: Rc<Box<[T; 3]>> = ...;\nlet first_entry = array[0];\n```\n\nHow does the compiler actually compute `array[0]` when the array is behind so many indirections? First, `array[0]` is really just syntax sugar for the [`Index`](../std/ops/trait.Index.html) trait - the compiler will convert `array[0]` into `array.index(0)`. Now, the compiler checks to see if `array` implements `Index`, so that it can call the function.\n\nThen, the compiler checks if `Rc<Box<[T; 3]>>` implements `Index`, but it does not, and neither do `&Rc<Box<[T; 3]>>` or `&mut Rc<Box<[T; 3]>>`. Since none of these worked, the compiler dereferences the `Rc<Box<[T; 3]>>` into `Box<[T; 3]>` and tries again. `Box<[T; 3]>`, `&Box<[T; 3]>`, and `&mut Box<[T; 3]>` do not implement `Index`, so it dereferences again. `[T; 3]` and its autorefs also do not implement `Index`. It can't dereference `[T; 3]`, so the compiler unsizes it, giving `[T]`. Finally, `[T]` implements `Index`, so it can now call the actual `index` function.\n\nConsider the following more complicated example of the dot operator at work:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn do_stuff<T: Clone>(value: &T) {\n    let cloned = value.clone();\n}\n}\n```\n\nWhat type is `cloned`? First, the compiler checks if it can call by value. The type of `value` is `&T`, and so the `clone` function has signature `fn clone(&T) -> T`. It knows that `T: Clone`, so the compiler finds that `cloned: T`.\n\nWhat would happen if the `T: Clone` restriction was removed? It would not be able to call by value, since there is no implementation of `Clone` for `T`. So the compiler tries to call by autoref. In this case, the function has the signature `fn clone(&&T) -> &T` since `Self = &T`. The compiler sees that `&T: Clone`, and then deduces that `cloned: &T`.\n\nHere is another example where the autoref behavior is used to create some subtle effects:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::sync::Arc;\n\n#[derive(Clone)]\nstruct Container<T>(Arc<T>);\n\nfn clone_containers<T>(foo: &Container<i32>, bar: &Container<T>) {\n    let foo_cloned = foo.clone();\n    let bar_cloned = bar.clone();\n}\n}\n```\n\nWhat types are `foo_cloned` and `bar_cloned`? We know that `Container<i32>: Clone`, so the compiler calls `clone` by value to give `foo_cloned: Container<i32>`. However, `bar_cloned` actually has type `&Container<T>`. Surely this doesn't make sense - we added `#[derive(Clone)]` to `Container`, so it must implement `Clone`! Looking closer, the code generated by the `derive` macro is (roughly):\n\n```rust\nimpl<T> Clone for Container<T> where T: Clone {\n    fn clone(&self) -> Self {\n        Self(Arc::clone(&self.0))\n    }\n}\n```\n\nThe derived `Clone` implementation is [only defined where `T: Clone`](about:blank/std/clone/trait.Clone.html#derivable), so there is no implementation for `Container<T>: Clone` for a generic `T`. The compiler then looks to see if `&Container<T>` implements `Clone`, which it does. So it deduces that `clone` is called by autoref, and so `bar_cloned` has type `&Container<T>`.\n\nWe can fix this by implementing `Clone` manually without requiring `T: Clone`:\n\n```rust\nimpl<T> Clone for Container<T> {\n    fn clone(&self) -> Self {\n        Self(Arc::clone(&self.0))\n    }\n}\n```\n\nNow, the type checker deduces that `bar_cloned: Container<T>`.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>The Dot Operator - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"the-dot-operator\"><a class=\"header\" href=\"#the-dot-operator\">The Dot Operator</a></h1>\n<p>The dot operator will perform a lot of magic to convert types.\nIt will perform auto-referencing, auto-dereferencing, and coercion until types\nmatch.\nThe detailed mechanics of method lookup are defined <a href=\"https://rustc-dev-guide.rust-lang.org/method-lookup.html\">here</a>,\nbut here is a brief overview that outlines the main steps.</p>\n<p>Suppose we have a function <code class=\"hljs\">foo</code> that has a receiver (a <code class=\"hljs\">self</code>, <code class=\"hljs\">&amp;self</code> or\n<code class=\"hljs\">&amp;mut self</code> parameter).\nIf we call <code class=\"hljs\">value.foo()</code>, the compiler needs to determine what type <code class=\"hljs\">Self</code> is before\nit can call the correct implementation of the function.\nFor this example, we will say that <code class=\"hljs\">value</code> has type <code class=\"hljs\">T</code>.</p>\n<p>We will use <a href=\"../book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\">fully-qualified syntax</a> to be more clear about exactly which\ntype we are calling a function on.</p>\n<ul>\n<li>First, the compiler checks if it can call <code class=\"hljs\">T::foo(value)</code> directly.\nThis is called a \"by value\" method call.</li>\n<li>If it can't call this function (for example, if the function has the wrong type\nor a trait isn't implemented for <code class=\"hljs\">Self</code>), then the compiler tries to add in an\nautomatic reference.\nThis means that the compiler tries <code class=\"hljs\">&lt;&amp;T&gt;::foo(value)</code> and <code class=\"hljs\">&lt;&amp;mut T&gt;::foo(value)</code>.\nThis is called an \"autoref\" method call.</li>\n<li>If none of these candidates worked, it dereferences <code class=\"hljs\">T</code> and tries again.\nThis uses the <code class=\"hljs\">Deref</code> trait - if <code class=\"hljs\">T: Deref&lt;Target = U&gt;</code> then it tries again with\ntype <code class=\"hljs\">U</code> instead of <code class=\"hljs\">T</code>.\nIf it can't dereference <code class=\"hljs\">T</code>, it can also try <em>unsizing</em> <code class=\"hljs\">T</code>.\nThis just means that if <code class=\"hljs\">T</code> has a size parameter known at compile time, it \"forgets\"\nit for the purpose of resolving methods.\nFor instance, this unsizing step can convert <code class=\"hljs\">[i32; 2]</code> into <code class=\"hljs\">[i32]</code> by \"forgetting\"\nthe size of the array.</li>\n</ul>\n<p>Here is an example of the method lookup algorithm:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> array: Rc&lt;<span class=\"hljs-built_in\">Box</span>&lt;[T; <span class=\"hljs-number\">3</span>]&gt;&gt; = ...;\n<span class=\"hljs-keyword\">let</span> first_entry = array[<span class=\"hljs-number\">0</span>];</code></pre>\n<p>How does the compiler actually compute <code class=\"hljs\">array[0]</code> when the array is behind so\nmany indirections?\nFirst, <code class=\"hljs\">array[0]</code> is really just syntax sugar for the <a href=\"../std/ops/trait.Index.html\"><code class=\"hljs\">Index</code></a> trait -\nthe compiler will convert <code class=\"hljs\">array[0]</code> into <code class=\"hljs\">array.index(0)</code>.\nNow, the compiler checks to see if <code class=\"hljs\">array</code> implements <code class=\"hljs\">Index</code>, so that it can call\nthe function.</p>\n<p>Then, the compiler checks if <code class=\"hljs\">Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> implements <code class=\"hljs\">Index</code>, but it\ndoes not, and neither do <code class=\"hljs\">&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> or <code class=\"hljs\">&amp;mut Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>.\nSince none of these worked, the compiler dereferences the <code class=\"hljs\">Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> into\n<code class=\"hljs\">Box&lt;[T; 3]&gt;</code> and tries again.\n<code class=\"hljs\">Box&lt;[T; 3]&gt;</code>, <code class=\"hljs\">&amp;Box&lt;[T; 3]&gt;</code>, and <code class=\"hljs\">&amp;mut Box&lt;[T; 3]&gt;</code> do not implement <code class=\"hljs\">Index</code>,\nso it dereferences again.\n<code class=\"hljs\">[T; 3]</code> and its autorefs also do not implement <code class=\"hljs\">Index</code>.\nIt can't dereference <code class=\"hljs\">[T; 3]</code>, so the compiler unsizes it, giving <code class=\"hljs\">[T]</code>.\nFinally, <code class=\"hljs\">[T]</code> implements <code class=\"hljs\">Index</code>, so it can now call the actual <code class=\"hljs\">index</code> function.</p>\n<p>Consider the following more complicated example of the dot operator at work:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">do_stuff</span></span>&lt;T: <span class=\"hljs-built_in\">Clone</span>&gt;(value: &amp;T) {\n    <span class=\"hljs-keyword\">let</span> cloned = value.clone();\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>What type is <code class=\"hljs\">cloned</code>?\nFirst, the compiler checks if it can call by value.\nThe type of <code class=\"hljs\">value</code> is <code class=\"hljs\">&amp;T</code>, and so the <code class=\"hljs\">clone</code> function has signature\n<code class=\"hljs\">fn clone(&amp;T) -&gt; T</code>.\nIt knows that <code class=\"hljs\">T: Clone</code>, so the compiler finds that <code class=\"hljs\">cloned: T</code>.</p>\n<p>What would happen if the <code class=\"hljs\">T: Clone</code> restriction was removed? It would not be able\nto call by value, since there is no implementation of <code class=\"hljs\">Clone</code> for <code class=\"hljs\">T</code>.\nSo the compiler tries to call by autoref.\nIn this case, the function has the signature <code class=\"hljs\">fn clone(&amp;&amp;T) -&gt; &amp;T</code> since\n<code class=\"hljs\">Self = &amp;T</code>.\nThe compiler sees that <code class=\"hljs\">&amp;T: Clone</code>, and then deduces that <code class=\"hljs\">cloned: &amp;T</code>.</p>\n<p>Here is another example where the autoref behavior is used to create some subtle\neffects:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::sync::Arc;\n</span><span class=\"boring\">\n</span><span class=\"hljs-meta\">#[derive(Clone)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Container</span></span>&lt;T&gt;(Arc&lt;T&gt;);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">clone_containers</span></span>&lt;T&gt;(foo: &amp;Container&lt;<span class=\"hljs-built_in\">i32</span>&gt;, bar: &amp;Container&lt;T&gt;) {\n    <span class=\"hljs-keyword\">let</span> foo_cloned = foo.clone();\n    <span class=\"hljs-keyword\">let</span> bar_cloned = bar.clone();\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>What types are <code class=\"hljs\">foo_cloned</code> and <code class=\"hljs\">bar_cloned</code>?\nWe know that <code class=\"hljs\">Container&lt;i32&gt;: Clone</code>, so the compiler calls <code class=\"hljs\">clone</code> by value to give\n<code class=\"hljs\">foo_cloned: Container&lt;i32&gt;</code>.\nHowever, <code class=\"hljs\">bar_cloned</code> actually has type <code class=\"hljs\">&amp;Container&lt;T&gt;</code>.\nSurely this doesn't make sense - we added <code class=\"hljs\">#[derive(Clone)]</code> to <code class=\"hljs\">Container</code>, so it\nmust implement <code class=\"hljs\">Clone</code>!\nLooking closer, the code generated by the <code class=\"hljs\">derive</code> macro is (roughly):</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Clone</span> <span class=\"hljs-keyword\">for</span> Container&lt;T&gt; <span class=\"hljs-keyword\">where</span> T: <span class=\"hljs-built_in\">Clone</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">clone</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">Self</span>(Arc::clone(&amp;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>))\n    }\n}</code></pre>\n<p>The derived <code class=\"hljs\">Clone</code> implementation is <a href=\"../std/clone/trait.Clone.html#derivable\">only defined where <code class=\"hljs\">T: Clone</code></a>,\nso there is no implementation for <code class=\"hljs\">Container&lt;T&gt;: Clone</code> for a generic <code class=\"hljs\">T</code>.\nThe compiler then looks to see if <code class=\"hljs\">&amp;Container&lt;T&gt;</code> implements <code class=\"hljs\">Clone</code>, which it does.\nSo it deduces that <code class=\"hljs\">clone</code> is called by autoref, and so <code class=\"hljs\">bar_cloned</code> has type\n<code class=\"hljs\">&amp;Container&lt;T&gt;</code>.</p>\n<p>We can fix this by implementing <code class=\"hljs\">Clone</code> manually without requiring <code class=\"hljs\">T: Clone</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; <span class=\"hljs-built_in\">Clone</span> <span class=\"hljs-keyword\">for</span> Container&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">clone</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">Self</span>(Arc::clone(&amp;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>))\n    }\n}</code></pre>\n<p>Now, the type checker deduces that <code class=\"hljs\">bar_cloned: Container&lt;T&gt;</code>.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"coercions.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"casts.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"coercions.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"casts.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:07.355Z"
}