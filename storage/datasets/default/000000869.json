{
	"title": "How Safe and Unsafe Interact - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/safe-unsafe-meaning.html",
	"markdown": "# How Safe and Unsafe Interact\n\nWhat's the relationship between Safe Rust and Unsafe Rust? How do they interact?\n\nThe separation between Safe Rust and Unsafe Rust is controlled with the `unsafe` keyword, which acts as an interface from one to the other. This is why we can say Safe Rust is a safe language: all the unsafe parts are kept exclusively behind the `unsafe` boundary. If you wish, you can even toss `#![forbid(unsafe_code)]` into your code base to statically guarantee that you're only writing Safe Rust.\n\nThe `unsafe` keyword has two uses: to declare the existence of contracts the compiler can't check, and to declare that a programmer has checked that these contracts have been upheld.\n\nYou can use `unsafe` to indicate the existence of unchecked contracts on _functions_ and _trait declarations_. On functions, `unsafe` means that users of the function must check that function's documentation to ensure they are using it in a way that maintains the contracts the function requires. On trait declarations, `unsafe` means that implementors of the trait must check the trait documentation to ensure their implementation maintains the contracts the trait requires.\n\nYou can use `unsafe` on a block to declare that all unsafe actions performed within are verified to uphold the contracts of those operations. For instance, the index passed to [`slice::get_unchecked`](about:blank/std/primitive.slice.html#method.get_unchecked) is in-bounds.\n\nYou can use `unsafe` on a trait implementation to declare that the implementation upholds the trait's contract. For instance, that a type implementing [`Send`](../std/marker/trait.Send.html) is really safe to move to another thread.\n\nThe standard library has a number of unsafe functions, including:\n\n-   [`slice::get_unchecked`](about:blank/std/primitive.slice.html#method.get_unchecked), which performs unchecked indexing, allowing memory safety to be freely violated.\n-   [`mem::transmute`](../std/mem/fn.transmute.html) reinterprets some value as having a given type, bypassing type safety in arbitrary ways (see [conversions](conversions.html) for details).\n-   Every raw pointer to a sized type has an [`offset`](about:blank/std/primitive.pointer.html#method.offset) method that invokes Undefined Behavior if the passed offset is not [\"in bounds\"](about:blank/std/primitive.pointer.html#method.offset).\n-   All FFI (Foreign Function Interface) functions are `unsafe` to call because the other language can do arbitrary operations that the Rust compiler can't check.\n\nAs of Rust 1.29.2 the standard library defines the following unsafe traits (there are others, but they are not stabilized yet and some of them may never be):\n\n-   [`Send`](../std/marker/trait.Send.html) is a marker trait (a trait with no API) that promises implementors are safe to send (move) to another thread.\n-   [`Sync`](../std/marker/trait.Sync.html) is a marker trait that promises threads can safely share implementors through a shared reference.\n-   [`GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html) allows customizing the memory allocator of the whole program.\n\nMuch of the Rust standard library also uses Unsafe Rust internally. These implementations have generally been rigorously manually checked, so the Safe Rust interfaces built on top of these implementations can be assumed to be safe.\n\nThe need for all of this separation boils down a single fundamental property of Safe Rust, the _soundness property_:\n\n**No matter what, Safe Rust can't cause Undefined Behavior.**\n\nThe design of the safe/unsafe split means that there is an asymmetric trust relationship between Safe and Unsafe Rust. Safe Rust inherently has to trust that any Unsafe Rust it touches has been written correctly. On the other hand, Unsafe Rust cannot trust Safe Rust without care.\n\nAs an example, Rust has the [`PartialOrd`](../std/cmp/trait.PartialOrd.html) and [`Ord`](../std/cmp/trait.Ord.html) traits to differentiate between types which can \"just\" be compared, and those that provide a \"total\" ordering (which basically means that comparison behaves reasonably).\n\n[`BTreeMap`](../std/collections/struct.BTreeMap.html) doesn't really make sense for partially-ordered types, and so it requires that its keys implement `Ord`. However, `BTreeMap` has Unsafe Rust code inside of its implementation. Because it would be unacceptable for a sloppy `Ord` implementation (which is Safe to write) to cause Undefined Behavior, the Unsafe code in BTreeMap must be written to be robust against `Ord` implementations which aren't actually total â€” even though that's the whole point of requiring `Ord`.\n\nThe Unsafe Rust code just can't trust the Safe Rust code to be written correctly. That said, `BTreeMap` will still behave completely erratically if you feed in values that don't have a total ordering. It just won't ever cause Undefined Behavior.\n\nOne may wonder, if `BTreeMap` cannot trust `Ord` because it's Safe, why can it trust _any_ Safe code? For instance `BTreeMap` relies on integers and slices to be implemented correctly. Those are safe too, right?\n\nThe difference is one of scope. When `BTreeMap` relies on integers and slices, it's relying on one very specific implementation. This is a measured risk that can be weighed against the benefit. In this case there's basically zero risk; if integers and slices are broken, _everyone_ is broken. Also, they're maintained by the same people who maintain `BTreeMap`, so it's easy to keep tabs on them.\n\nOn the other hand, `BTreeMap`'s key type is generic. Trusting its `Ord` implementation means trusting every `Ord` implementation in the past, present, and future. Here the risk is high: someone somewhere is going to make a mistake and mess up their `Ord` implementation, or even just straight up lie about providing a total ordering because \"it seems to work\". When that happens, `BTreeMap` needs to be prepared.\n\nThe same logic applies to trusting a closure that's passed to you to behave correctly.\n\nThis problem of unbounded generic trust is the problem that `unsafe` traits exist to resolve. The `BTreeMap` type could theoretically require that keys implement a new trait called `UnsafeOrd`, rather than `Ord`, that might look like this:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::cmp::Ordering;\n\nunsafe trait UnsafeOrd {\n    fn cmp(&self, other: &Self) -> Ordering;\n}\n}\n```\n\nThen, a type would use `unsafe` to implement `UnsafeOrd`, indicating that they've ensured their implementation maintains whatever contracts the trait expects. In this situation, the Unsafe Rust in the internals of `BTreeMap` would be justified in trusting that the key type's `UnsafeOrd` implementation is correct. If it isn't, it's the fault of the unsafe trait implementation, which is consistent with Rust's safety guarantees.\n\nThe decision of whether to mark a trait `unsafe` is an API design choice. A safe trait is easier to implement, but any unsafe code that relies on it must defend against incorrect behavior. Marking a trait `unsafe` shifts this responsibility to the implementor. Rust has traditionally avoided marking traits `unsafe` because it makes Unsafe Rust pervasive, which isn't desirable.\n\n`Send` and `Sync` are marked unsafe because thread safety is a _fundamental property_ that unsafe code can't possibly hope to defend against in the way it could defend against a buggy `Ord` implementation. Similarly, `GlobalAllocator` is keeping accounts of all the memory in the program and other things like `Box` or `Vec` build on top of it. If it does something weird (giving the same chunk of memory to another request when it is still in use), there's no chance to detect that and do anything about it.\n\nThe decision of whether to mark your own traits `unsafe` depends on the same sort of consideration. If `unsafe` code can't reasonably expect to defend against a broken implementation of the trait, then marking the trait `unsafe` is a reasonable choice.\n\nAs an aside, while `Send` and `Sync` are `unsafe` traits, they are _also_ automatically implemented for types when such derivations are provably safe to do. `Send` is automatically derived for all types composed only of values whose types also implement `Send`. `Sync` is automatically derived for all types composed only of values whose types also implement `Sync`. This minimizes the pervasive unsafety of making these two traits `unsafe`. And not many people are going to _implement_ memory allocators (or use them directly, for that matter).\n\nThis is the balance between Safe and Unsafe Rust. The separation is designed to make using Safe Rust as ergonomic as possible, but requires extra effort and care when writing Unsafe Rust. The rest of this book is largely a discussion of the sort of care that must be taken, and what contracts Unsafe Rust must uphold.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>How Safe and Unsafe Interact - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"how-safe-and-unsafe-interact\"><a class=\"header\" href=\"#how-safe-and-unsafe-interact\">How Safe and Unsafe Interact</a></h1>\n<p>What's the relationship between Safe Rust and Unsafe Rust? How do they\ninteract?</p>\n<p>The separation between Safe Rust and Unsafe Rust is controlled with the\n<code class=\"hljs\">unsafe</code> keyword, which acts as an interface from one to the other. This is\nwhy we can say Safe Rust is a safe language: all the unsafe parts are kept\nexclusively behind the <code class=\"hljs\">unsafe</code> boundary. If you wish, you can even toss\n<code class=\"hljs\">#![forbid(unsafe_code)]</code> into your code base to statically guarantee that\nyou're only writing Safe Rust.</p>\n<p>The <code class=\"hljs\">unsafe</code> keyword has two uses: to declare the existence of contracts the\ncompiler can't check, and to declare that a programmer has checked that these\ncontracts have been upheld.</p>\n<p>You can use <code class=\"hljs\">unsafe</code> to indicate the existence of unchecked contracts on\n<em>functions</em> and <em>trait declarations</em>. On functions, <code class=\"hljs\">unsafe</code> means that\nusers of the function must check that function's documentation to ensure\nthey are using it in a way that maintains the contracts the function\nrequires. On trait declarations, <code class=\"hljs\">unsafe</code> means that implementors of the\ntrait must check the trait documentation to ensure their implementation\nmaintains the contracts the trait requires.</p>\n<p>You can use <code class=\"hljs\">unsafe</code> on a block to declare that all unsafe actions performed\nwithin are verified to uphold the contracts of those operations. For instance,\nthe index passed to <a href=\"../std/primitive.slice.html#method.get_unchecked\"><code class=\"hljs\">slice::get_unchecked</code></a> is in-bounds.</p>\n<p>You can use <code class=\"hljs\">unsafe</code> on a trait implementation to declare that the implementation\nupholds the trait's contract. For instance, that a type implementing <a href=\"../std/marker/trait.Send.html\"><code class=\"hljs\">Send</code></a> is\nreally safe to move to another thread.</p>\n<p>The standard library has a number of unsafe functions, including:</p>\n<ul>\n<li><a href=\"../std/primitive.slice.html#method.get_unchecked\"><code class=\"hljs\">slice::get_unchecked</code></a>, which performs unchecked indexing,\nallowing memory safety to be freely violated.</li>\n<li><a href=\"../std/mem/fn.transmute.html\"><code class=\"hljs\">mem::transmute</code></a> reinterprets some value as having a given type,\nbypassing type safety in arbitrary ways (see <a href=\"conversions.html\">conversions</a> for details).</li>\n<li>Every raw pointer to a sized type has an <a href=\"../std/primitive.pointer.html#method.offset\"><code class=\"hljs\">offset</code></a> method that\ninvokes Undefined Behavior if the passed offset is not <a href=\"../std/primitive.pointer.html#method.offset\">\"in bounds\"</a>.</li>\n<li>All FFI (Foreign Function Interface) functions are <code class=\"hljs\">unsafe</code> to call because the\nother language can do arbitrary operations that the Rust compiler can't check.</li>\n</ul>\n<p>As of Rust 1.29.2 the standard library defines the following unsafe traits\n(there are others, but they are not stabilized yet and some of them may never\nbe):</p>\n<ul>\n<li><a href=\"../std/marker/trait.Send.html\"><code class=\"hljs\">Send</code></a> is a marker trait (a trait with no API) that promises implementors\nare safe to send (move) to another thread.</li>\n<li><a href=\"../std/marker/trait.Sync.html\"><code class=\"hljs\">Sync</code></a> is a marker trait that promises threads can safely share implementors\nthrough a shared reference.</li>\n<li><a href=\"../std/alloc/trait.GlobalAlloc.html\"><code class=\"hljs\">GlobalAlloc</code></a> allows customizing the memory allocator of the whole program.</li>\n</ul>\n<p>Much of the Rust standard library also uses Unsafe Rust internally. These\nimplementations have generally been rigorously manually checked, so the Safe Rust\ninterfaces built on top of these implementations can be assumed to be safe.</p>\n<p>The need for all of this separation boils down a single fundamental property\nof Safe Rust, the <em>soundness property</em>:</p>\n<p><strong>No matter what, Safe Rust can't cause Undefined Behavior.</strong></p>\n<p>The design of the safe/unsafe split means that there is an asymmetric trust\nrelationship between Safe and Unsafe Rust. Safe Rust inherently has to\ntrust that any Unsafe Rust it touches has been written correctly.\nOn the other hand, Unsafe Rust cannot trust Safe Rust without care.</p>\n<p>As an example, Rust has the <a href=\"../std/cmp/trait.PartialOrd.html\"><code class=\"hljs\">PartialOrd</code></a> and <a href=\"../std/cmp/trait.Ord.html\"><code class=\"hljs\">Ord</code></a> traits to differentiate\nbetween types which can \"just\" be compared, and those that provide a \"total\"\nordering (which basically means that comparison behaves reasonably).</p>\n<p><a href=\"../std/collections/struct.BTreeMap.html\"><code class=\"hljs\">BTreeMap</code></a> doesn't really make sense for partially-ordered types, and so it\nrequires that its keys implement <code class=\"hljs\">Ord</code>. However, <code class=\"hljs\">BTreeMap</code> has Unsafe Rust code\ninside of its implementation. Because it would be unacceptable for a sloppy <code class=\"hljs\">Ord</code>\nimplementation (which is Safe to write) to cause Undefined Behavior, the Unsafe\ncode in BTreeMap must be written to be robust against <code class=\"hljs\">Ord</code> implementations which\naren't actually total â€” even though that's the whole point of requiring <code class=\"hljs\">Ord</code>.</p>\n<p>The Unsafe Rust code just can't trust the Safe Rust code to be written correctly.\nThat said, <code class=\"hljs\">BTreeMap</code> will still behave completely erratically if you feed in\nvalues that don't have a total ordering. It just won't ever cause Undefined\nBehavior.</p>\n<p>One may wonder, if <code class=\"hljs\">BTreeMap</code> cannot trust <code class=\"hljs\">Ord</code> because it's Safe, why can it\ntrust <em>any</em> Safe code? For instance <code class=\"hljs\">BTreeMap</code> relies on integers and slices to\nbe implemented correctly. Those are safe too, right?</p>\n<p>The difference is one of scope. When <code class=\"hljs\">BTreeMap</code> relies on integers and slices,\nit's relying on one very specific implementation. This is a measured risk that\ncan be weighed against the benefit. In this case there's basically zero risk;\nif integers and slices are broken, <em>everyone</em> is broken. Also, they're maintained\nby the same people who maintain <code class=\"hljs\">BTreeMap</code>, so it's easy to keep tabs on them.</p>\n<p>On the other hand, <code class=\"hljs\">BTreeMap</code>'s key type is generic. Trusting its <code class=\"hljs\">Ord</code> implementation\nmeans trusting every <code class=\"hljs\">Ord</code> implementation in the past, present, and future.\nHere the risk is high: someone somewhere is going to make a mistake and mess up\ntheir <code class=\"hljs\">Ord</code> implementation, or even just straight up lie about providing a total\nordering because \"it seems to work\". When that happens, <code class=\"hljs\">BTreeMap</code> needs to be\nprepared.</p>\n<p>The same logic applies to trusting a closure that's passed to you to behave\ncorrectly.</p>\n<p>This problem of unbounded generic trust is the problem that <code class=\"hljs\">unsafe</code> traits\nexist to resolve. The <code class=\"hljs\">BTreeMap</code> type could theoretically require that keys\nimplement a new trait called <code class=\"hljs\">UnsafeOrd</code>, rather than <code class=\"hljs\">Ord</code>, that might look\nlike this:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::cmp::Ordering;\n\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">UnsafeOrd</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">cmp</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;<span class=\"hljs-keyword\">Self</span>) -&gt; Ordering;\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Then, a type would use <code class=\"hljs\">unsafe</code> to implement <code class=\"hljs\">UnsafeOrd</code>, indicating that\nthey've ensured their implementation maintains whatever contracts the\ntrait expects. In this situation, the Unsafe Rust in the internals of\n<code class=\"hljs\">BTreeMap</code> would be justified in trusting that the key type's <code class=\"hljs\">UnsafeOrd</code>\nimplementation is correct. If it isn't, it's the fault of the unsafe trait\nimplementation, which is consistent with Rust's safety guarantees.</p>\n<p>The decision of whether to mark a trait <code class=\"hljs\">unsafe</code> is an API design choice. A\nsafe trait is easier to implement, but any unsafe code that relies on it must\ndefend against incorrect behavior. Marking a trait <code class=\"hljs\">unsafe</code> shifts this\nresponsibility to the implementor. Rust has traditionally avoided marking\ntraits <code class=\"hljs\">unsafe</code> because it makes Unsafe Rust pervasive, which isn't desirable.</p>\n<p><code class=\"hljs\">Send</code> and <code class=\"hljs\">Sync</code> are marked unsafe because thread safety is a <em>fundamental\nproperty</em> that unsafe code can't possibly hope to defend against in the way it\ncould defend against a buggy <code class=\"hljs\">Ord</code> implementation. Similarly, <code class=\"hljs\">GlobalAllocator</code>\nis keeping accounts of all the memory in the program and other things like\n<code class=\"hljs\">Box</code> or <code class=\"hljs\">Vec</code> build on top of it. If it does something weird (giving the same\nchunk of memory to another request when it is still in use), there's no chance\nto detect that and do anything about it.</p>\n<p>The decision of whether to mark your own traits <code class=\"hljs\">unsafe</code> depends on the same\nsort of consideration. If <code class=\"hljs\">unsafe</code> code can't reasonably expect to defend\nagainst a broken implementation of the trait, then marking the trait <code class=\"hljs\">unsafe</code> is\na reasonable choice.</p>\n<p>As an aside, while <code class=\"hljs\">Send</code> and <code class=\"hljs\">Sync</code> are <code class=\"hljs\">unsafe</code> traits, they are <em>also</em>\nautomatically implemented for types when such derivations are provably safe\nto do. <code class=\"hljs\">Send</code> is automatically derived for all types composed only of values\nwhose types also implement <code class=\"hljs\">Send</code>. <code class=\"hljs\">Sync</code> is automatically derived for all\ntypes composed only of values whose types also implement <code class=\"hljs\">Sync</code>. This minimizes\nthe pervasive unsafety of making these two traits <code class=\"hljs\">unsafe</code>. And not many people\nare going to <em>implement</em> memory allocators (or use them directly, for that\nmatter).</p>\n<p>This is the balance between Safe and Unsafe Rust. The separation is designed to\nmake using Safe Rust as ergonomic as possible, but requires extra effort and\ncare when writing Unsafe Rust. The rest of this book is largely a discussion\nof the sort of care that must be taken, and what contracts Unsafe Rust must uphold.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"meet-safe-and-unsafe.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"what-unsafe-does.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"meet-safe-and-unsafe.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"what-unsafe-does.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:04.443Z"
}