{
	"title": "park in std::thread - Rust",
	"url": "https://doc.rust-lang.org/stable/std/thread/fn.park.html",
	"markdown": "# park in std::thread - Rust\n\n## Function [std](../index.html)::[thread](index.html)::[park](#)\n\n1.0.0 · [source](about:blank/src/std/thread/mod.rs.html#1100-1108) ·\n\n```\npub fn park()\n```\n\nExpand description\n\nBlocks unless or until the current thread’s token is made available.\n\nA call to `park` does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility. However, it is guaranteed that this function will not panic (it may abort the process if the implementation encounters some rare errors).\n\n## [§](#park-and-unpark)`park` and `unpark`\n\nEvery thread is equipped with some basic low-level blocking support, via the [`thread::park`](fn.park.html \"fn std::thread::park\") function and [`thread::Thread::unpark`](about:blank/struct.Thread.html#method.unpark \"method std::thread::Thread::unpark\") method. [`park`](fn.park.html \"fn std::thread::park\") blocks the current thread, which can then be resumed from another thread by calling the [`unpark`](about:blank/struct.Thread.html#method.unpark \"method std::thread::Thread::unpark\") method on the blocked thread’s handle.\n\nConceptually, each [`Thread`](struct.Thread.html \"struct std::thread::Thread\") handle has an associated token, which is initially not present:\n\n-   The [`thread::park`](fn.park.html \"fn std::thread::park\") function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return _spuriously_, without consuming the token. [`thread::park_timeout`](fn.park_timeout.html \"fn std::thread::park_timeout\") does the same, but allows specifying a maximum time to block the thread for.\n    \n-   The [`unpark`](about:blank/struct.Thread.html#method.unpark \"method std::thread::Thread::unpark\") method on a [`Thread`](struct.Thread.html \"struct std::thread::Thread\") atomically makes the token available if it wasn’t already. Because the token is initially absent, [`unpark`](about:blank/struct.Thread.html#method.unpark \"method std::thread::Thread::unpark\") followed by [`park`](fn.park.html \"fn std::thread::park\") will result in the second call returning immediately.\n    \n\nThe API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then `park`ing in a loop. When some desired condition is met, another thread calls [`unpark`](about:blank/struct.Thread.html#method.unpark \"method std::thread::Thread::unpark\") on the handle.\n\nThe motivation for this design is twofold:\n\n-   It avoids the need to allocate mutexes and condvars when building new synchronization primitives; the threads already provide basic blocking/signaling.\n    \n-   It can be implemented very efficiently on many platforms.\n    \n\n## [§](#memory-ordering)Memory Ordering\n\nCalls to `park` _synchronize-with_ calls to `unpark`, meaning that memory operations performed before a call to `unpark` are made visible to the thread that consumes the token and returns from `park`. Note that all `park` and `unpark` operations for a given thread form a total order and `park` synchronizes-with _all_ prior `unpark` operations.\n\nIn atomic ordering terms, `unpark` performs a `Release` operation and `park` performs the corresponding `Acquire` operation. Calls to `unpark` for the same thread form a [release sequence](https://en.cppreference.com/w/cpp/atomic/memory_order#Release_sequence).\n\nNote that being unblocked does not imply a call was made to `unpark`, because wakeups can also be spurious. For example, a valid, but inefficient, implementation could have `park` and `unpark` return immediately without doing anything, making _all_ wakeups spurious.\n\n## [§](#examples)Examples\n\n```\nuse std::thread;\nuse std::sync::{Arc, atomic::{Ordering, AtomicBool}};\nuse std::time::Duration;\n\nlet flag = Arc::new(AtomicBool::new(false));\nlet flag2 = Arc::clone(&flag);\n\nlet parked_thread = thread::spawn(move || {\n    // We want to wait until the flag is set. We *could* just spin, but using\n    // park/unpark is more efficient.\n    while !flag2.load(Ordering::Relaxed) {\n        println!(\"Parking thread\");\n        thread::park();\n        // We *could* get here spuriously, i.e., way before the 10ms below are over!\n        // But that is no problem, we are in a loop until the flag is set anyway.\n        println!(\"Thread unparked\");\n    }\n    println!(\"Flag received\");\n});\n\n// Let some time pass for the thread to be spawned.\nthread::sleep(Duration::from_millis(10));\n\n// Set the flag, and let the thread wake up.\n// There is no race condition here, if `unpark`\n// happens first, `park` will return immediately.\n// Hence there is no risk of a deadlock.\nflag.store(true, Ordering::Relaxed);\nprintln!(\"Unpark the thread\");\nparked_thread.thread().unpark();\n\nparked_thread.join().unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::%7BArc,+atomic::%7BOrdering,+AtomicBool%7D%7D;%0A++++use+std::time::Duration;%0A++++%0A++++let+flag+=+Arc::new(AtomicBool::new(false));%0A++++let+flag2+=+Arc::clone(%26flag);%0A++++%0A++++let+parked_thread+=+thread::spawn(move+%7C%7C+%7B%0A++++++++//+We+want+to+wait+until+the+flag+is+set.+We+*could*+just+spin,+but+using%0A++++++++//+park/unpark+is+more+efficient.%0A++++++++while+!flag2.load(Ordering::Relaxed)+%7B%0A++++++++++++println!(%22Parking+thread%22);%0A++++++++++++thread::park();%0A++++++++++++//+We+*could*+get+here+spuriously,+i.e.,+way+before+the+10ms+below+are+over!%0A++++++++++++//+But+that+is+no+problem,+we+are+in+a+loop+until+the+flag+is+set+anyway.%0A++++++++++++println!(%22Thread+unparked%22);%0A++++++++%7D%0A++++++++println!(%22Flag+received%22);%0A++++%7D);%0A++++%0A++++//+Let+some+time+pass+for+the+thread+to+be+spawned.%0A++++thread::sleep(Duration::from_millis(10));%0A++++%0A++++//+Set+the+flag,+and+let+the+thread+wake+up.%0A++++//+There+is+no+race+condition+here,+if+%60unpark%60%0A++++//+happens+first,+%60park%60+will+return+immediately.%0A++++//+Hence+there+is+no+risk+of+a+deadlock.%0A++++flag.store(true,+Ordering::Relaxed);%0A++++println!(%22Unpark+the+thread%22);%0A++++parked_thread.thread().unpark();%0A++++%0A++++parked_thread.join().unwrap();%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Blocks unless or until the current thread’s token is made available.\"><title>park in std::thread - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::thread</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AccessError.html\">AccessError</a></li><li><a href=\"struct.Builder.html\">Builder</a></li><li><a href=\"struct.JoinHandle.html\">JoinHandle</a></li><li><a href=\"struct.LocalKey.html\">LocalKey</a></li><li><a href=\"struct.Scope.html\">Scope</a></li><li><a href=\"struct.ScopedJoinHandle.html\">ScopedJoinHandle</a></li><li><a href=\"struct.Thread.html\">Thread</a></li><li><a href=\"struct.ThreadId.html\">ThreadId</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.available_parallelism.html\">available_parallelism</a></li><li><a href=\"fn.current.html\">current</a></li><li><a href=\"fn.panicking.html\">panicking</a></li><li><a href=\"fn.park.html\">park</a></li><li><a href=\"fn.park_timeout.html\">park_timeout</a></li><li><a href=\"fn.park_timeout_ms.html\">park_timeout_ms</a></li><li><a href=\"fn.scope.html\">scope</a></li><li><a href=\"fn.sleep.html\">sleep</a></li><li><a href=\"fn.sleep_ms.html\">sleep_ms</a></li><li><a href=\"fn.sleep_until.html\">sleep_until</a></li><li><a href=\"fn.spawn.html\">spawn</a></li><li><a href=\"fn.yield_now.html\">yield_now</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.Result.html\">Result</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">thread</a>::<wbr><a class=\"fn\" href=\"#\">park</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/thread/mod.rs.html#1100-1108\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub fn park()</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Blocks unless or until the current thread’s token is made available.</p>\n<p>A call to <code>park</code> does not guarantee that the thread will remain parked\nforever, and callers should be prepared for this possibility. However,\nit is guaranteed that this function will not panic (it may abort the\nprocess if the implementation encounters some rare errors).</p>\n<h2 id=\"park-and-unpark\"><a class=\"doc-anchor\" href=\"#park-and-unpark\">§</a><code>park</code> and <code>unpark</code></h2>\n<p>Every thread is equipped with some basic low-level blocking support, via the\n<a href=\"fn.park.html\" title=\"fn std::thread::park\"><code>thread::park</code></a> function and <a href=\"struct.Thread.html#method.unpark\" title=\"method std::thread::Thread::unpark\"><code>thread::Thread::unpark</code></a>\nmethod. <a href=\"fn.park.html\" title=\"fn std::thread::park\"><code>park</code></a> blocks the current thread, which can then be resumed from\nanother thread by calling the <a href=\"struct.Thread.html#method.unpark\" title=\"method std::thread::Thread::unpark\"><code>unpark</code></a> method on the blocked thread’s\nhandle.</p>\n<p>Conceptually, each <a href=\"struct.Thread.html\" title=\"struct std::thread::Thread\"><code>Thread</code></a> handle has an associated token, which is\ninitially not present:</p>\n<ul>\n<li>\n<p>The <a href=\"fn.park.html\" title=\"fn std::thread::park\"><code>thread::park</code></a> function blocks the current thread unless or\nuntil the token is available for its thread handle, at which point it\natomically consumes the token. It may also return <em>spuriously</em>, without\nconsuming the token. <a href=\"fn.park_timeout.html\" title=\"fn std::thread::park_timeout\"><code>thread::park_timeout</code></a> does the same, but allows\nspecifying a maximum time to block the thread for.</p>\n</li>\n<li>\n<p>The <a href=\"struct.Thread.html#method.unpark\" title=\"method std::thread::Thread::unpark\"><code>unpark</code></a> method on a <a href=\"struct.Thread.html\" title=\"struct std::thread::Thread\"><code>Thread</code></a> atomically makes the token available\nif it wasn’t already. Because the token is initially absent, <a href=\"struct.Thread.html#method.unpark\" title=\"method std::thread::Thread::unpark\"><code>unpark</code></a>\nfollowed by <a href=\"fn.park.html\" title=\"fn std::thread::park\"><code>park</code></a> will result in the second call returning immediately.</p>\n</li>\n</ul>\n<p>The API is typically used by acquiring a handle to the current thread,\nplacing that handle in a shared data structure so that other threads can\nfind it, and then <code>park</code>ing in a loop. When some desired condition is met, another\nthread calls <a href=\"struct.Thread.html#method.unpark\" title=\"method std::thread::Thread::unpark\"><code>unpark</code></a> on the handle.</p>\n<p>The motivation for this design is twofold:</p>\n<ul>\n<li>\n<p>It avoids the need to allocate mutexes and condvars when building new\nsynchronization primitives; the threads already provide basic\nblocking/signaling.</p>\n</li>\n<li>\n<p>It can be implemented very efficiently on many platforms.</p>\n</li>\n</ul>\n<h2 id=\"memory-ordering\"><a class=\"doc-anchor\" href=\"#memory-ordering\">§</a>Memory Ordering</h2>\n<p>Calls to <code>park</code> <em>synchronize-with</em> calls to <code>unpark</code>, meaning that memory\noperations performed before a call to <code>unpark</code> are made visible to the thread that\nconsumes the token and returns from <code>park</code>. Note that all <code>park</code> and <code>unpark</code>\noperations for a given thread form a total order and <code>park</code> synchronizes-with\n<em>all</em> prior <code>unpark</code> operations.</p>\n<p>In atomic ordering terms, <code>unpark</code> performs a <code>Release</code> operation and <code>park</code>\nperforms the corresponding <code>Acquire</code> operation. Calls to <code>unpark</code> for the same\nthread form a <a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order#Release_sequence\">release sequence</a>.</p>\n<p>Note that being unblocked does not imply a call was made to <code>unpark</code>, because\nwakeups can also be spurious. For example, a valid, but inefficient,\nimplementation could have <code>park</code> and <code>unpark</code> return immediately without doing anything,\nmaking <em>all</em> wakeups spurious.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>std::sync::{Arc, atomic::{Ordering, AtomicBool}};\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">let </span>flag = Arc::new(AtomicBool::new(<span class=\"bool-val\">false</span>));\n<span class=\"kw\">let </span>flag2 = Arc::clone(<span class=\"kw-2\">&amp;</span>flag);\n\n<span class=\"kw\">let </span>parked_thread = thread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"comment\">// We want to wait until the flag is set. We *could* just spin, but using\n    // park/unpark is more efficient.\n    </span><span class=\"kw\">while </span>!flag2.load(Ordering::Relaxed) {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Parking thread\"</span>);\n        thread::park();\n        <span class=\"comment\">// We *could* get here spuriously, i.e., way before the 10ms below are over!\n        // But that is no problem, we are in a loop until the flag is set anyway.\n        </span><span class=\"macro\">println!</span>(<span class=\"string\">\"Thread unparked\"</span>);\n    }\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"Flag received\"</span>);\n});\n\n<span class=\"comment\">// Let some time pass for the thread to be spawned.\n</span>thread::sleep(Duration::from_millis(<span class=\"number\">10</span>));\n\n<span class=\"comment\">// Set the flag, and let the thread wake up.\n// There is no race condition here, if `unpark`\n// happens first, `park` will return immediately.\n// Hence there is no risk of a deadlock.\n</span>flag.store(<span class=\"bool-val\">true</span>, Ordering::Relaxed);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Unpark the thread\"</span>);\nparked_thread.thread().unpark();\n\nparked_thread.join().unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++use+std::sync::%7BArc,+atomic::%7BOrdering,+AtomicBool%7D%7D;%0A++++use+std::time::Duration;%0A++++%0A++++let+flag+=+Arc::new(AtomicBool::new(false));%0A++++let+flag2+=+Arc::clone(%26flag);%0A++++%0A++++let+parked_thread+=+thread::spawn(move+%7C%7C+%7B%0A++++++++//+We+want+to+wait+until+the+flag+is+set.+We+*could*+just+spin,+but+using%0A++++++++//+park/unpark+is+more+efficient.%0A++++++++while+!flag2.load(Ordering::Relaxed)+%7B%0A++++++++++++println!(%22Parking+thread%22);%0A++++++++++++thread::park();%0A++++++++++++//+We+*could*+get+here+spuriously,+i.e.,+way+before+the+10ms+below+are+over!%0A++++++++++++//+But+that+is+no+problem,+we+are+in+a+loop+until+the+flag+is+set+anyway.%0A++++++++++++println!(%22Thread+unparked%22);%0A++++++++%7D%0A++++++++println!(%22Flag+received%22);%0A++++%7D);%0A++++%0A++++//+Let+some+time+pass+for+the+thread+to+be+spawned.%0A++++thread::sleep(Duration::from_millis(10));%0A++++%0A++++//+Set+the+flag,+and+let+the+thread+wake+up.%0A++++//+There+is+no+race+condition+here,+if+%60unpark%60%0A++++//+happens+first,+%60park%60+will+return+immediately.%0A++++//+Hence+there+is+no+risk+of+a+deadlock.%0A++++flag.store(true,+Ordering::Relaxed);%0A++++println!(%22Unpark+the+thread%22);%0A++++parked_thread.thread().unpark();%0A++++%0A++++parked_thread.join().unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:20:27.200Z"
}