{
	"title": "Destructors - The Rust Reference",
	"url": "https://doc.rust-lang.org/stable/reference/destructors.html",
	"markdown": "# Destructors - The Rust Reference\n\nWhen an [initialized](about:blank/glossary.html#initialized) [variable](variables.html) or [temporary](about:blank/expressions.html#temporaries) goes out of [scope](#drop-scopes), its _destructor_ is run, or it is _dropped_. [Assignment](about:blank/expressions/operator-expr.html#assignment-expressions) also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.\n\nThe destructor of a type `T` consists of:\n\n1.  If `T: Drop`, calling [`<T as std::ops::Drop>::drop`](about:blank/std/ops/trait.Drop.html#tymethod.drop)\n2.  Recursively running the destructor of all of its fields.\n    -   The fields of a [struct](types/struct.html) are dropped in declaration order.\n    -   The fields of the active [enum variant](types/enum.html) are dropped in declaration order.\n    -   The fields of a [tuple](types/tuple.html) are dropped in order.\n    -   The elements of an [array](types/array.html) or owned [slice](types/slice.html) are dropped from the first element to the last.\n    -   The variables that a [closure](types/closure.html) captures by move are dropped in an unspecified order.\n    -   [Trait objects](types/trait-object.html) run the destructor of the underlying type.\n    -   Other types don't result in any further drops.\n\nIf a destructor must be run manually, such as when implementing your own smart pointer, [`std::ptr::drop_in_place`](../std/ptr/fn.drop_in_place.html) can be used.\n\nSome examples:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct PrintOnDrop(&'static str);\n\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"{}\", self.0);\n    }\n}\n\nlet mut overwritten = PrintOnDrop(\"drops when overwritten\");\noverwritten = PrintOnDrop(\"drops when scope ends\");\n\nlet tuple = (PrintOnDrop(\"Tuple first\"), PrintOnDrop(\"Tuple second\"));\n\nlet moved;\n// No destructor run on assignment.\nmoved = PrintOnDrop(\"Drops when moved\");\n// Drops now, but is then uninitialized.\nmoved;\n\n// Uninitialized does not drop.\nlet uninitialized: PrintOnDrop;\n\n// After a partial move, only the remaining fields are dropped.\nlet mut partial_move = (PrintOnDrop(\"first\"), PrintOnDrop(\"forgotten\"));\n// Perform a partial move, leaving only `partial_move.0` initialized.\ncore::mem::forget(partial_move.1);\n// When partial_move's scope ends, only the first field is dropped.\n}\n```\n\n## [Drop scopes](#drop-scopes)\n\nEach variable or temporary is associated to a _drop scope_. When control flow leaves a drop scope all variables associated to that scope are dropped in reverse order of declaration (for variables) or creation (for temporaries).\n\nDrop scopes are determined after replacing [`for`](about:blank/expressions/loop-expr.html#iterator-loops), [`if let`](about:blank/expressions/if-expr.html#if-let-expressions), and [`while let`](about:blank/expressions/loop-expr.html#predicate-pattern-loops) expressions with the equivalent expressions using [`match`](expressions/match-expr.html). Overloaded operators are not distinguished from built-in operators and [binding modes](about:blank/patterns.html#binding-modes) are not considered.\n\nGiven a function, or closure, there are drop scopes for:\n\n-   The entire function\n-   Each [statement](statements.html)\n-   Each [expression](expressions.html)\n-   Each block, including the function body\n    -   In the case of a [block expression](expressions/block-expr.html), the scope for the block and the expression are the same scope.\n-   Each arm of a `match` expression\n\nDrop scopes are nested within one another as follows. When multiple scopes are left at once, such as when returning from a function, variables are dropped from the inside outwards.\n\n-   The entire function scope is the outer most scope.\n-   The function body block is contained within the scope of the entire function.\n-   The parent of the expression in an expression statement is the scope of the statement.\n-   The parent of the initializer of a [`let` statement](about:blank/statements.html#let-statements) is the `let` statement's scope.\n-   The parent of a statement scope is the scope of the block that contains the statement.\n-   The parent of the expression for a `match` guard is the scope of the arm that the guard is for.\n-   The parent of the expression after the `=>` in a `match` expression is the scope of the arm that it's in.\n-   The parent of the arm scope is the scope of the `match` expression that it belongs to.\n-   The parent of all other scopes is the scope of the immediately enclosing expression.\n\n### [Scopes of function parameters](#scopes-of-function-parameters)\n\nAll function parameters are in the scope of the entire function body, so are dropped last when evaluating the function. Each actual function parameter is dropped after any bindings introduced in that parameter's pattern.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct PrintOnDrop(&'static str);\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"drop({})\", self.0);\n    }\n}\n// Drops `y`, then the second parameter, then `x`, then the first parameter\nfn patterns_in_parameters(\n    (x, _): (PrintOnDrop, PrintOnDrop),\n    (_, y): (PrintOnDrop, PrintOnDrop),\n) {}\n\n// drop order is 3 2 0 1\npatterns_in_parameters(\n    (PrintOnDrop(\"0\"), PrintOnDrop(\"1\")),\n    (PrintOnDrop(\"2\"), PrintOnDrop(\"3\")),\n);\n}\n```\n\n### [Scopes of local variables](#scopes-of-local-variables)\n\nLocal variables declared in a `let` statement are associated to the scope of the block that contains the `let` statement. Local variables declared in a `match` expression are associated to the arm scope of the `match` arm that they are declared in.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct PrintOnDrop(&'static str);\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"drop({})\", self.0);\n    }\n}\nlet declared_first = PrintOnDrop(\"Dropped last in outer scope\");\n{\n    let declared_in_block = PrintOnDrop(\"Dropped in inner scope\");\n}\nlet declared_last = PrintOnDrop(\"Dropped first in outer scope\");\n}\n```\n\nIf multiple patterns are used in the same arm for a `match` expression, then an unspecified pattern will be used to determine the drop order.\n\n### [Temporary scopes](#temporary-scopes)\n\nThe _temporary scope_ of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a [place context](about:blank/expressions.html#place-expressions-and-value-expressions), unless it is [promoted](about:blank/destructors.html#constant-promotion).\n\nApart from lifetime extension, the temporary scope of an expression is the smallest scope that contains the expression and is one of the following:\n\n-   The entire function.\n-   A statement.\n-   The body of an [`if`](about:blank/expressions/if-expr.html#if-expressions), [`while`](about:blank/expressions/loop-expr.html#predicate-loops) or [`loop`](about:blank/expressions/loop-expr.html#infinite-loops) expression.\n-   The `else` block of an `if` expression.\n-   The condition expression of an `if` or `while` expression, or a `match` guard.\n-   The body expression for a match arm.\n-   The second operand of a [lazy boolean expression](about:blank/expressions/operator-expr.html#lazy-boolean-operators).\n\n> **Notes**:\n> \n> Temporaries that are created in the final expression of a function body are dropped _after_ any named variables bound in the function body. Their drop scope is the entire function, as there is no smaller enclosing temporary scope.\n> \n> The [scrutinee](about:blank/glossary.html#scrutinee) of a `match` expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the `match` expression. For example, the temporary for `1` in `match 1 { ref mut z => z };` lives until the end of the statement.\n\nSome examples:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct PrintOnDrop(&'static str);\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"drop({})\", self.0);\n    }\n}\nlet local_var = PrintOnDrop(\"local var\");\n\n// Dropped once the condition has been evaluated\nif PrintOnDrop(\"If condition\").0 == \"If condition\" {\n    // Dropped at the end of the block\n    PrintOnDrop(\"If body\").0\n} else {\n    unreachable!()\n};\n\n// Dropped at the end of the statement\n(PrintOnDrop(\"first operand\").0 == \"\"\n// Dropped at the )\n|| PrintOnDrop(\"second operand\").0 == \"\")\n// Dropped at the end of the expression\n|| PrintOnDrop(\"third operand\").0 == \"\";\n\n// Dropped at the end of the function, after local variables.\n// Changing this to a statement containing a return expression would make the\n// temporary be dropped before the local variables. Binding to a variable\n// which is then returned would also make the temporary be dropped first.\nmatch PrintOnDrop(\"Matched value in final expression\") {\n    // Dropped once the condition has been evaluated\n    _ if PrintOnDrop(\"guard condition\").0 == \"\" => (),\n    _ => (),\n}\n}\n```\n\n### [Operands](#operands)\n\nTemporaries are also created to hold the result of operands to an expression while the other operands are evaluated. The temporaries are associated to the scope of the expression with that operand. Since the temporaries are moved from once the expression is evaluated, dropping them has no effect unless one of the operands to an expression breaks out of the expression, returns, or panics.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct PrintOnDrop(&'static str);\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"drop({})\", self.0);\n    }\n}\nloop {\n    // Tuple expression doesn't finish evaluating so operands drop in reverse order\n    (\n        PrintOnDrop(\"Outer tuple first\"),\n        PrintOnDrop(\"Outer tuple second\"),\n        (\n            PrintOnDrop(\"Inner tuple first\"),\n            PrintOnDrop(\"Inner tuple second\"),\n            break,\n        ),\n        PrintOnDrop(\"Never created\"),\n    );\n}\n}\n```\n\n### [Constant promotion](#constant-promotion)\n\nPromotion of a value expression to a `'static` slot occurs when the expression could be written in a constant and borrowed, and that borrow could be dereferenced where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain [interior mutability](interior-mutability.html) or [destructors](destructors.html) (these properties are determined based on the value where possible, e.g. `&None` always has the type `&'static Option<_>`, as it contains nothing disallowed).\n\n### [Temporary lifetime extension](#temporary-lifetime-extension)\n\n> **Note**: The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.\n\nThe temporary scopes for expressions in `let` statements are sometimes _extended_ to the scope of the block containing the `let` statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = &mut 0;\n// Usually a temporary would be dropped by now, but the temporary for `0` lives\n// to the end of the block.\nprintln!(\"{}\", x);\n}\n```\n\nIf a [borrow](about:blank/expressions/operator-expr.html#borrow-operators), [dereference](about:blank/expressions/operator-expr.html#the-dereference-operator), [field](expressions/field-expr.html), or [tuple indexing expression](about:blank/expressions/tuple-expr.html#tuple-indexing-expressions) has an extended temporary scope then so does its operand. If an [indexing expression](about:blank/expressions/array-expr.html#array-and-slice-indexing-expressions) has an extended temporary scope then the indexed expression also has an extended temporary scope.\n\n#### [Extending based on patterns](#extending-based-on-patterns)\n\nAn _extending pattern_ is either\n\n-   An [identifier pattern](about:blank/patterns.html#identifier-patterns) that binds by reference or mutable reference.\n-   A [struct](about:blank/patterns.html#struct-patterns), [tuple](about:blank/patterns.html#tuple-patterns), [tuple struct](about:blank/patterns.html#tuple-struct-patterns), or [slice](about:blank/patterns.html#slice-patterns) pattern where at least one of the direct subpatterns is an extending pattern.\n\nSo `ref x`, `V(ref x)` and `[ref x, y]` are all extending patterns, but `x`, `&ref x` and `&(ref x,)` are not.\n\nIf the pattern in a `let` statement is an extending pattern then the temporary scope of the initializer expression is extended.\n\n#### [Extending based on expressions](#extending-based-on-expressions)\n\nFor a let statement with an initializer, an _extending expression_ is an expression which is one of the following:\n\n-   The initializer expression.\n-   The operand of an extending [borrow expression](about:blank/expressions/operator-expr.html#borrow-operators).\n-   The operand(s) of an extending [array](about:blank/expressions/array-expr.html#array-expressions), [cast](about:blank/expressions/operator-expr.html#type-cast-expressions), [braced struct](expressions/struct-expr.html), or [tuple](about:blank/expressions/tuple-expr.html#tuple-expressions) expression.\n-   The final expression of any extending [block expression](expressions/block-expr.html).\n\nSo the borrow expressions in `&mut 0`, `(&1, &mut 2)`, and `Some { 0: &mut 3 }` are all extending expressions. The borrows in `&0 + &1` and `Some(&mut 0)` are not: the latter is syntactically a function call expression.\n\nThe operand of any extending borrow expression has its temporary scope extended.\n\n#### [Examples](#examples)\n\nHere are some examples where expressions have extended temporary scopes:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn temp() {}\ntrait Use { fn use_temp(&self) -> &Self { self } }\nimpl Use for () {}\n// The temporary that stores the result of `temp()` lives in the same scope\n// as x in these cases.\nlet x = &temp();\nlet x = &temp() as &dyn Send;\nlet x = (&*&temp(),);\nlet x = { [Some { 0: &temp(), }] };\nlet ref x = temp();\nlet ref x = *&temp();\nx;\n}\n```\n\nHere are some examples where expressions don't have extended temporary scopes:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn temp() {}\ntrait Use { fn use_temp(&self) -> &Self { self } }\nimpl Use for () {}\n// The temporary that stores the result of `temp()` only lives until the\n// end of the let statement in these cases.\n\nlet x = Some(&temp());         // ERROR\nlet x = (&temp()).use_temp();  // ERROR\nx;\n}\n```\n\n## [Not running destructors](#not-running-destructors)\n\n[`std::mem::forget`](../std/mem/fn.forget.html) can be used to prevent the destructor of a variable from being run, and [`std::mem::ManuallyDrop`](../std/mem/struct.ManuallyDrop.html) provides a wrapper to prevent a variable or field from being dropped automatically.\n\n> Note: Preventing a destructor from being run via [`std::mem::forget`](../std/mem/fn.forget.html) or other means is safe even if it has a type that isn't `'static`. Besides the places where destructors are guaranteed to run as defined by this document, types may _not_ safely rely on a destructor being run for soundness.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Destructors - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/operator-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/destructors.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"destructors\"><a class=\"header\" href=\"#destructors\">Destructors</a></h1>\n<p>When an <a href=\"glossary.html#initialized\">initialized</a> <a href=\"variables.html\">variable</a> or <a href=\"expressions.html#temporaries\">temporary</a> goes out of\n<a href=\"#drop-scopes\">scope</a>, its <em>destructor</em> is run, or it is <em>dropped</em>. <a href=\"expressions/operator-expr.html#assignment-expressions\">Assignment</a>\nalso runs the destructor of its left-hand operand, if it's initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped.</p>\n<p>The destructor of a type <code class=\"hljs\">T</code> consists of:</p>\n<ol>\n<li>If <code class=\"hljs\">T: Drop</code>, calling <a href=\"../std/ops/trait.Drop.html#tymethod.drop\"><code class=\"hljs\">&lt;T as std::ops::Drop&gt;::drop</code></a></li>\n<li>Recursively running the destructor of all of its fields.\n<ul>\n<li>The fields of a <a href=\"types/struct.html\">struct</a> are dropped in declaration order.</li>\n<li>The fields of the active <a href=\"types/enum.html\">enum variant</a> are dropped in declaration order.</li>\n<li>The fields of a <a href=\"types/tuple.html\">tuple</a> are dropped in order.</li>\n<li>The elements of an <a href=\"types/array.html\">array</a> or owned <a href=\"types/slice.html\">slice</a> are dropped from the\nfirst element to the last.</li>\n<li>The variables that a <a href=\"types/closure.html\">closure</a> captures by move are dropped in an\nunspecified order.</li>\n<li><a href=\"types/trait-object.html\">Trait objects</a> run the destructor of the underlying type.</li>\n<li>Other types don't result in any further drops.</li>\n</ul>\n</li>\n</ol>\n<p>If a destructor must be run manually, such as when implementing your own smart\npointer, <a href=\"../std/ptr/fn.drop_in_place.html\"><code class=\"hljs\">std::ptr::drop_in_place</code></a> can be used.</p>\n<p>Some examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PrintOnDrop</span></span>(&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> PrintOnDrop {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> overwritten = PrintOnDrop(<span class=\"hljs-string\">\"drops when overwritten\"</span>);\noverwritten = PrintOnDrop(<span class=\"hljs-string\">\"drops when scope ends\"</span>);\n\n<span class=\"hljs-keyword\">let</span> tuple = (PrintOnDrop(<span class=\"hljs-string\">\"Tuple first\"</span>), PrintOnDrop(<span class=\"hljs-string\">\"Tuple second\"</span>));\n\n<span class=\"hljs-keyword\">let</span> moved;\n<span class=\"hljs-comment\">// No destructor run on assignment.</span>\nmoved = PrintOnDrop(<span class=\"hljs-string\">\"Drops when moved\"</span>);\n<span class=\"hljs-comment\">// Drops now, but is then uninitialized.</span>\nmoved;\n\n<span class=\"hljs-comment\">// Uninitialized does not drop.</span>\n<span class=\"hljs-keyword\">let</span> uninitialized: PrintOnDrop;\n\n<span class=\"hljs-comment\">// After a partial move, only the remaining fields are dropped.</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> partial_move = (PrintOnDrop(<span class=\"hljs-string\">\"first\"</span>), PrintOnDrop(<span class=\"hljs-string\">\"forgotten\"</span>));\n<span class=\"hljs-comment\">// Perform a partial move, leaving only `partial_move.0` initialized.</span>\ncore::mem::forget(partial_move.<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-comment\">// When partial_move's scope ends, only the first field is dropped.</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"drop-scopes\"><a class=\"header\" href=\"#drop-scopes\">Drop scopes</a></h2>\n<p>Each variable or temporary is associated to a <em>drop scope</em>. When control flow\nleaves a drop scope all variables associated to that scope are dropped in\nreverse order of declaration (for variables) or creation (for temporaries).</p>\n<p>Drop scopes are determined after replacing <a href=\"expressions/loop-expr.html#iterator-loops\"><code class=\"hljs\">for</code></a>, <a href=\"expressions/if-expr.html#if-let-expressions\"><code class=\"hljs\">if let</code></a>, and\n<a href=\"expressions/loop-expr.html#predicate-pattern-loops\"><code class=\"hljs\">while let</code></a> expressions with the equivalent expressions using <a href=\"expressions/match-expr.html\"><code class=\"hljs\">match</code></a>.\nOverloaded operators are not distinguished from built-in operators and <a href=\"patterns.html#binding-modes\">binding\nmodes</a> are not considered.</p>\n<p>Given a function, or closure, there are drop scopes for:</p>\n<ul>\n<li>The entire function</li>\n<li>Each <a href=\"statements.html\">statement</a></li>\n<li>Each <a href=\"expressions.html\">expression</a></li>\n<li>Each block, including the function body\n<ul>\n<li>In the case of a <a href=\"expressions/block-expr.html\">block expression</a>, the scope for the block and the\nexpression are the same scope.</li>\n</ul>\n</li>\n<li>Each arm of a <code class=\"hljs\">match</code> expression</li>\n</ul>\n<p>Drop scopes are nested within one another as follows. When multiple scopes are\nleft at once, such as when returning from a function, variables are dropped\nfrom the inside outwards.</p>\n<ul>\n<li>The entire function scope is the outer most scope.</li>\n<li>The function body block is contained within the scope of the entire function.</li>\n<li>The parent of the expression in an expression statement is the scope of the\nstatement.</li>\n<li>The parent of the initializer of a <a href=\"statements.html#let-statements\"><code class=\"hljs\">let</code> statement</a> is the <code class=\"hljs\">let</code> statement's\nscope.</li>\n<li>The parent of a statement scope is the scope of the block that contains the\nstatement.</li>\n<li>The parent of the expression for a <code class=\"hljs\">match</code> guard is the scope of the arm that\nthe guard is for.</li>\n<li>The parent of the expression after the <code class=\"hljs\">=&gt;</code> in a <code class=\"hljs\">match</code> expression is the\nscope of the arm that it's in.</li>\n<li>The parent of the arm scope is the scope of the <code class=\"hljs\">match</code> expression that it\nbelongs to.</li>\n<li>The parent of all other scopes is the scope of the immediately enclosing\nexpression.</li>\n</ul>\n<h3 id=\"scopes-of-function-parameters\"><a class=\"header\" href=\"#scopes-of-function-parameters\">Scopes of function parameters</a></h3>\n<p>All function parameters are in the scope of the entire function body, so are\ndropped last when evaluating the function. Each actual function parameter is\ndropped after any bindings introduced in that parameter's pattern.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PrintOnDrop</span></span>(&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> PrintOnDrop {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"drop({})\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-comment\">// Drops `y`, then the second parameter, then `x`, then the first parameter</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">patterns_in_parameters</span></span>(\n    (x, _): (PrintOnDrop, PrintOnDrop),\n    (_, y): (PrintOnDrop, PrintOnDrop),\n) {}\n\n<span class=\"hljs-comment\">// drop order is 3 2 0 1</span>\npatterns_in_parameters(\n    (PrintOnDrop(<span class=\"hljs-string\">\"0\"</span>), PrintOnDrop(<span class=\"hljs-string\">\"1\"</span>)),\n    (PrintOnDrop(<span class=\"hljs-string\">\"2\"</span>), PrintOnDrop(<span class=\"hljs-string\">\"3\"</span>)),\n);\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"scopes-of-local-variables\"><a class=\"header\" href=\"#scopes-of-local-variables\">Scopes of local variables</a></h3>\n<p>Local variables declared in a <code class=\"hljs\">let</code> statement are associated to the scope of\nthe block that contains the <code class=\"hljs\">let</code> statement. Local variables declared in a\n<code class=\"hljs\">match</code> expression are associated to the arm scope of the <code class=\"hljs\">match</code> arm that they\nare declared in.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PrintOnDrop</span></span>(&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> PrintOnDrop {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"drop({})\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-keyword\">let</span> declared_first = PrintOnDrop(<span class=\"hljs-string\">\"Dropped last in outer scope\"</span>);\n{\n    <span class=\"hljs-keyword\">let</span> declared_in_block = PrintOnDrop(<span class=\"hljs-string\">\"Dropped in inner scope\"</span>);\n}\n<span class=\"hljs-keyword\">let</span> declared_last = PrintOnDrop(<span class=\"hljs-string\">\"Dropped first in outer scope\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>If multiple patterns are used in the same arm for a <code class=\"hljs\">match</code> expression, then an\nunspecified pattern will be used to determine the drop order.</p>\n<h3 id=\"temporary-scopes\"><a class=\"header\" href=\"#temporary-scopes\">Temporary scopes</a></h3>\n<p>The <em>temporary scope</em> of an expression is the scope that is used for the\ntemporary variable that holds the result of that expression when used in a\n<a href=\"expressions.html#place-expressions-and-value-expressions\">place context</a>, unless it is <a href=\"destructors.html#constant-promotion\">promoted</a>.</p>\n<p>Apart from lifetime extension, the temporary scope of an expression is the\nsmallest scope that contains the expression and is one of the following:</p>\n<ul>\n<li>The entire function.</li>\n<li>A statement.</li>\n<li>The body of an <a href=\"expressions/if-expr.html#if-expressions\"><code class=\"hljs\">if</code></a>, <a href=\"expressions/loop-expr.html#predicate-loops\"><code class=\"hljs\">while</code></a> or <a href=\"expressions/loop-expr.html#infinite-loops\"><code class=\"hljs\">loop</code></a> expression.</li>\n<li>The <code class=\"hljs\">else</code> block of an <code class=\"hljs\">if</code> expression.</li>\n<li>The condition expression of an <code class=\"hljs\">if</code> or <code class=\"hljs\">while</code> expression, or a <code class=\"hljs\">match</code>\nguard.</li>\n<li>The body expression for a match arm.</li>\n<li>The second operand of a <a href=\"expressions/operator-expr.html#lazy-boolean-operators\">lazy boolean expression</a>.</li>\n</ul>\n<blockquote>\n<p><strong>Notes</strong>:</p>\n<p>Temporaries that are created in the final expression of a function\nbody are dropped <em>after</em> any named variables bound in the function body.\nTheir drop scope is the entire function, as there is no smaller enclosing temporary scope.</p>\n<p>The <a href=\"glossary.html#scrutinee\">scrutinee</a> of a <code class=\"hljs\">match</code> expression is not a temporary scope, so\ntemporaries in the scrutinee can be dropped after the <code class=\"hljs\">match</code> expression. For\nexample, the temporary for <code class=\"hljs\">1</code> in <code class=\"hljs\">match 1 { ref mut z =&gt; z };</code> lives until\nthe end of the statement.</p>\n</blockquote>\n<p>Some examples:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PrintOnDrop</span></span>(&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> PrintOnDrop {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"drop({})\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-keyword\">let</span> local_var = PrintOnDrop(<span class=\"hljs-string\">\"local var\"</span>);\n\n<span class=\"hljs-comment\">// Dropped once the condition has been evaluated</span>\n<span class=\"hljs-keyword\">if</span> PrintOnDrop(<span class=\"hljs-string\">\"If condition\"</span>).<span class=\"hljs-number\">0</span> == <span class=\"hljs-string\">\"If condition\"</span> {\n    <span class=\"hljs-comment\">// Dropped at the end of the block</span>\n    PrintOnDrop(<span class=\"hljs-string\">\"If body\"</span>).<span class=\"hljs-number\">0</span>\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">unreachable!</span>()\n};\n\n<span class=\"hljs-comment\">// Dropped at the end of the statement</span>\n(PrintOnDrop(<span class=\"hljs-string\">\"first operand\"</span>).<span class=\"hljs-number\">0</span> == <span class=\"hljs-string\">\"\"</span>\n<span class=\"hljs-comment\">// Dropped at the )</span>\n|| PrintOnDrop(<span class=\"hljs-string\">\"second operand\"</span>).<span class=\"hljs-number\">0</span> == <span class=\"hljs-string\">\"\"</span>)\n<span class=\"hljs-comment\">// Dropped at the end of the expression</span>\n|| PrintOnDrop(<span class=\"hljs-string\">\"third operand\"</span>).<span class=\"hljs-number\">0</span> == <span class=\"hljs-string\">\"\"</span>;\n\n<span class=\"hljs-comment\">// Dropped at the end of the function, after local variables.</span>\n<span class=\"hljs-comment\">// Changing this to a statement containing a return expression would make the</span>\n<span class=\"hljs-comment\">// temporary be dropped before the local variables. Binding to a variable</span>\n<span class=\"hljs-comment\">// which is then returned would also make the temporary be dropped first.</span>\n<span class=\"hljs-keyword\">match</span> PrintOnDrop(<span class=\"hljs-string\">\"Matched value in final expression\"</span>) {\n    <span class=\"hljs-comment\">// Dropped once the condition has been evaluated</span>\n    _ <span class=\"hljs-keyword\">if</span> PrintOnDrop(<span class=\"hljs-string\">\"guard condition\"</span>).<span class=\"hljs-number\">0</span> == <span class=\"hljs-string\">\"\"</span> =&gt; (),\n    _ =&gt; (),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"operands\"><a class=\"header\" href=\"#operands\">Operands</a></h3>\n<p>Temporaries are also created to hold the result of operands to an expression\nwhile the other operands are evaluated. The temporaries are associated to the\nscope of the expression with that operand. Since the temporaries are moved from\nonce the expression is evaluated, dropping them has no effect unless one of the\noperands to an expression breaks out of the expression, returns, or panics.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PrintOnDrop</span></span>(&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> PrintOnDrop {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"drop({})\"</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"hljs-keyword\">loop</span> {\n    <span class=\"hljs-comment\">// Tuple expression doesn't finish evaluating so operands drop in reverse order</span>\n    (\n        PrintOnDrop(<span class=\"hljs-string\">\"Outer tuple first\"</span>),\n        PrintOnDrop(<span class=\"hljs-string\">\"Outer tuple second\"</span>),\n        (\n            PrintOnDrop(<span class=\"hljs-string\">\"Inner tuple first\"</span>),\n            PrintOnDrop(<span class=\"hljs-string\">\"Inner tuple second\"</span>),\n            <span class=\"hljs-keyword\">break</span>,\n        ),\n        PrintOnDrop(<span class=\"hljs-string\">\"Never created\"</span>),\n    );\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"constant-promotion\"><a class=\"header\" href=\"#constant-promotion\">Constant promotion</a></h3>\n<p>Promotion of a value expression to a <code class=\"hljs\">'static</code> slot occurs when the expression\ncould be written in a constant and borrowed, and that borrow could be dereferenced\nwhere\nthe expression was originally written, without changing the runtime behavior.\nThat is, the promoted expression can be evaluated at compile-time and the\nresulting value does not contain <a href=\"interior-mutability.html\">interior mutability</a> or <a href=\"destructors.html\">destructors</a> (these\nproperties are determined based on the value where possible, e.g. <code class=\"hljs\">&amp;None</code>\nalways has the type <code class=\"hljs\">&amp;'static Option&lt;_&gt;</code>, as it contains nothing disallowed).</p>\n<h3 id=\"temporary-lifetime-extension\"><a class=\"header\" href=\"#temporary-lifetime-extension\">Temporary lifetime extension</a></h3>\n<blockquote>\n<p><strong>Note</strong>: The exact rules for temporary lifetime extension are subject to\nchange. This is describing the current behavior only.</p>\n</blockquote>\n<p>The temporary scopes for expressions in <code class=\"hljs\">let</code> statements are sometimes\n<em>extended</em> to the scope of the block containing the <code class=\"hljs\">let</code> statement. This is\ndone when the usual temporary scope would be too small, based on certain\nsyntactic rules. For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-comment\">// Usually a temporary would be dropped by now, but the temporary for `0` lives</span>\n<span class=\"hljs-comment\">// to the end of the block.</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>If a <a href=\"expressions/operator-expr.html#borrow-operators\">borrow</a>, <a href=\"expressions/operator-expr.html#the-dereference-operator\">dereference</a>,\n<a href=\"expressions/field-expr.html\">field</a>, or <a href=\"expressions/tuple-expr.html#tuple-indexing-expressions\">tuple indexing expression</a> has an extended\ntemporary scope then so does its operand. If an <a href=\"expressions/array-expr.html#array-and-slice-indexing-expressions\">indexing expression</a> has an\nextended temporary scope then the indexed expression also has an extended\ntemporary scope.</p>\n<h4 id=\"extending-based-on-patterns\"><a class=\"header\" href=\"#extending-based-on-patterns\">Extending based on patterns</a></h4>\n<p>An <em>extending pattern</em> is either</p>\n<ul>\n<li>An <a href=\"patterns.html#identifier-patterns\">identifier pattern</a> that binds by reference or mutable reference.</li>\n<li>A <a href=\"patterns.html#struct-patterns\">struct</a>, <a href=\"patterns.html#tuple-patterns\">tuple</a>, <a href=\"patterns.html#tuple-struct-patterns\">tuple struct</a>, or <a href=\"patterns.html#slice-patterns\">slice</a> pattern where at least one of the\ndirect subpatterns is an extending pattern.</li>\n</ul>\n<p>So <code class=\"hljs\">ref x</code>, <code class=\"hljs\">V(ref x)</code> and <code class=\"hljs\">[ref x, y]</code> are all extending patterns, but <code class=\"hljs\">x</code>,\n<code class=\"hljs\">&amp;ref x</code> and <code class=\"hljs\">&amp;(ref x,)</code> are not.</p>\n<p>If the pattern in a <code class=\"hljs\">let</code> statement is an extending pattern then the temporary\nscope of the initializer expression is extended.</p>\n<h4 id=\"extending-based-on-expressions\"><a class=\"header\" href=\"#extending-based-on-expressions\">Extending based on expressions</a></h4>\n<p>For a let statement with an initializer, an <em>extending expression</em> is an\nexpression which is one of the following:</p>\n<ul>\n<li>The initializer expression.</li>\n<li>The operand of an extending <a href=\"expressions/operator-expr.html#borrow-operators\">borrow expression</a>.</li>\n<li>The operand(s) of an extending <a href=\"expressions/array-expr.html#array-expressions\">array</a>, <a href=\"expressions/operator-expr.html#type-cast-expressions\">cast</a>, <a href=\"expressions/struct-expr.html\">braced struct</a>, or <a href=\"expressions/tuple-expr.html#tuple-expressions\">tuple</a>\nexpression.</li>\n<li>The final expression of any extending <a href=\"expressions/block-expr.html\">block expression</a>.</li>\n</ul>\n<p>So the borrow expressions in <code class=\"hljs\">&amp;mut 0</code>, <code class=\"hljs\">(&amp;1, &amp;mut 2)</code>, and <code class=\"hljs\">Some { 0: &amp;mut 3 }</code>\nare all extending expressions. The borrows in <code class=\"hljs\">&amp;0 + &amp;1</code> and <code class=\"hljs\">Some(&amp;mut 0)</code> are\nnot: the latter is syntactically a function call expression.</p>\n<p>The operand of any extending borrow expression has its temporary scope\nextended.</p>\n<h4 id=\"examples\"><a class=\"header\" href=\"#examples\">Examples</a></h4>\n<p>Here are some examples where expressions have extended temporary scopes:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">temp</span></span>() {}\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Use</span></span> { <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">use_temp</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;<span class=\"hljs-keyword\">Self</span> { <span class=\"hljs-keyword\">self</span> } }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Use <span class=\"hljs-keyword\">for</span> () {}\n</span><span class=\"hljs-comment\">// The temporary that stores the result of `temp()` lives in the same scope</span>\n<span class=\"hljs-comment\">// as x in these cases.</span>\n<span class=\"hljs-keyword\">let</span> x = &amp;temp();\n<span class=\"hljs-keyword\">let</span> x = &amp;temp() <span class=\"hljs-keyword\">as</span> &amp;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">Send</span>;\n<span class=\"hljs-keyword\">let</span> x = (&amp;*&amp;temp(),);\n<span class=\"hljs-keyword\">let</span> x = { [<span class=\"hljs-literal\">Some</span> { <span class=\"hljs-number\">0</span>: &amp;temp(), }] };\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">ref</span> x = temp();\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">ref</span> x = *&amp;temp();\n<span class=\"boring\">x;\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>Here are some examples where expressions don't have extended temporary scopes:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">temp</span></span>() {}\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Use</span></span> { <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">use_temp</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;<span class=\"hljs-keyword\">Self</span> { <span class=\"hljs-keyword\">self</span> } }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Use <span class=\"hljs-keyword\">for</span> () {}\n</span><span class=\"hljs-comment\">// The temporary that stores the result of `temp()` only lives until the</span>\n<span class=\"hljs-comment\">// end of the let statement in these cases.</span>\n\n<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-literal\">Some</span>(&amp;temp());         <span class=\"hljs-comment\">// ERROR</span>\n<span class=\"hljs-keyword\">let</span> x = (&amp;temp()).use_temp();  <span class=\"hljs-comment\">// ERROR</span>\n<span class=\"boring\">x;\n</span><span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"not-running-destructors\"><a class=\"header\" href=\"#not-running-destructors\">Not running destructors</a></h2>\n<p><a href=\"../std/mem/fn.forget.html\"><code class=\"hljs\">std::mem::forget</code></a> can be used to prevent the destructor of a variable from being run,\nand <a href=\"../std/mem/struct.ManuallyDrop.html\"><code class=\"hljs\">std::mem::ManuallyDrop</code></a> provides a wrapper to prevent a\nvariable or field from being dropped automatically.</p>\n<blockquote>\n<p>Note: Preventing a destructor from being run via <a href=\"../std/mem/fn.forget.html\"><code class=\"hljs\">std::mem::forget</code></a> or other means is safe even if it has a type that isn't <code class=\"hljs\">'static</code>.\nBesides the places where destructors are guaranteed to run as defined by this document, types may <em>not</em> safely rely on a destructor being run for soundness.</p>\n</blockquote>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"type-coercions.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"lifetime-elision.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"type-coercions.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"lifetime-elision.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:13:31.322Z"
}