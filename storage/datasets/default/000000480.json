{
	"title": "Iterator in std::iter - Rust",
	"url": "https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html",
	"markdown": "# Iterator in std::iter - Rust\n\n```\npub trait Iterator {\n    type Item;\n\nShow 76 methods    // Required method\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // Provided methods\n    fn next_chunk<const N: usize>(\n        &mut self,\n    ) -> Result<[Self::Item; N], IntoIter<Self::Item, N>>\n       where Self: Sized { ... }\n    fn size_hint(&self) -> (usize, Option<usize>) { ... }\n    fn count(self) -> usize\n       where Self: Sized { ... }\n    fn last(self) -> Option<Self::Item>\n       where Self: Sized { ... }\n    fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> { ... }\n    fn nth(&mut self, n: usize) -> Option<Self::Item> { ... }\n    fn step_by(self, step: usize) -> StepBy<Self> ⓘ\n       where Self: Sized { ... }\n    fn chain<U>(self, other: U) -> Chain<Self, <U as IntoIterator>::IntoIter> ⓘ\n       where Self: Sized,\n             U: IntoIterator<Item = Self::Item> { ... }\n    fn zip<U>(self, other: U) -> Zip<Self, <U as IntoIterator>::IntoIter> ⓘ\n       where Self: Sized,\n             U: IntoIterator { ... }\n    fn intersperse(self, separator: Self::Item) -> Intersperse<Self> ⓘ\n       where Self: Sized,\n             Self::Item: Clone { ... }\n    fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G> ⓘ\n       where Self: Sized,\n             G: FnMut() -> Self::Item { ... }\n    fn map<B, F>(self, f: F) -> Map<Self, F> ⓘ\n       where Self: Sized,\n             F: FnMut(Self::Item) -> B { ... }\n    fn for_each<F>(self, f: F)\n       where Self: Sized,\n             F: FnMut(Self::Item) { ... }\n    fn filter<P>(self, predicate: P) -> Filter<Self, P> ⓘ\n       where Self: Sized,\n             P: FnMut(&Self::Item) -> bool { ... }\n    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> ⓘ\n       where Self: Sized,\n             F: FnMut(Self::Item) -> Option<B> { ... }\n    fn enumerate(self) -> Enumerate<Self> ⓘ\n       where Self: Sized { ... }\n    fn peekable(self) -> Peekable<Self> ⓘ\n       where Self: Sized { ... }\n    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> ⓘ\n       where Self: Sized,\n             P: FnMut(&Self::Item) -> bool { ... }\n    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> ⓘ\n       where Self: Sized,\n             P: FnMut(&Self::Item) -> bool { ... }\n    fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P> ⓘ\n       where Self: Sized,\n             P: FnMut(Self::Item) -> Option<B> { ... }\n    fn skip(self, n: usize) -> Skip<Self> ⓘ\n       where Self: Sized { ... }\n    fn take(self, n: usize) -> Take<Self> ⓘ\n       where Self: Sized { ... }\n    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F> ⓘ\n       where Self: Sized,\n             F: FnMut(&mut St, Self::Item) -> Option<B> { ... }\n    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F> ⓘ\n       where Self: Sized,\n             U: IntoIterator,\n             F: FnMut(Self::Item) -> U { ... }\n    fn flatten(self) -> Flatten<Self> ⓘ\n       where Self: Sized,\n             Self::Item: IntoIterator { ... }\n    fn map_windows<F, R, const N: usize>(self, f: F) -> MapWindows<Self, F, N> ⓘ\n       where Self: Sized,\n             F: FnMut(&[Self::Item; N]) -> R { ... }\n    fn fuse(self) -> Fuse<Self> ⓘ\n       where Self: Sized { ... }\n    fn inspect<F>(self, f: F) -> Inspect<Self, F> ⓘ\n       where Self: Sized,\n             F: FnMut(&Self::Item) { ... }\n    fn by_ref(&mut self) -> &mut Self\n       where Self: Sized { ... }\n    fn collect<B>(self) -> B\n       where B: FromIterator<Self::Item>,\n             Self: Sized { ... }\n    fn try_collect<B>(\n        &mut self,\n    ) -> <<Self::Item as Try>::Residual as Residual<B>>::TryType\n       where Self: Sized,\n             Self::Item: Try,\n             <Self::Item as Try>::Residual: Residual<B>,\n             B: FromIterator<<Self::Item as Try>::Output> { ... }\n    fn collect_into<E>(self, collection: &mut E) -> &mut E\n       where E: Extend<Self::Item>,\n             Self: Sized { ... }\n    fn partition<B, F>(self, f: F) -> (B, B)\n       where Self: Sized,\n             B: Default + Extend<Self::Item>,\n             F: FnMut(&Self::Item) -> bool { ... }\n    fn partition_in_place<'a, T, P>(self, predicate: P) -> usize\n       where T: 'a,\n             Self: Sized + DoubleEndedIterator<Item = &'a mut T>,\n             P: FnMut(&T) -> bool { ... }\n    fn is_partitioned<P>(self, predicate: P) -> bool\n       where Self: Sized,\n             P: FnMut(Self::Item) -> bool { ... }\n    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n       where Self: Sized,\n             F: FnMut(B, Self::Item) -> R,\n             R: Try<Output = B> { ... }\n    fn try_for_each<F, R>(&mut self, f: F) -> R\n       where Self: Sized,\n             F: FnMut(Self::Item) -> R,\n             R: Try<Output = ()> { ... }\n    fn fold<B, F>(self, init: B, f: F) -> B\n       where Self: Sized,\n             F: FnMut(B, Self::Item) -> B { ... }\n    fn reduce<F>(self, f: F) -> Option<Self::Item>\n       where Self: Sized,\n             F: FnMut(Self::Item, Self::Item) -> Self::Item { ... }\n    fn try_reduce<F, R>(\n        &mut self,\n        f: F,\n    ) -> <<R as Try>::Residual as Residual<Option<<R as Try>::Output>>>::TryType\n       where Self: Sized,\n             F: FnMut(Self::Item, Self::Item) -> R,\n             R: Try<Output = Self::Item>,\n             <R as Try>::Residual: Residual<Option<Self::Item>> { ... }\n    fn all<F>(&mut self, f: F) -> bool\n       where Self: Sized,\n             F: FnMut(Self::Item) -> bool { ... }\n    fn any<F>(&mut self, f: F) -> bool\n       where Self: Sized,\n             F: FnMut(Self::Item) -> bool { ... }\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n       where Self: Sized,\n             P: FnMut(&Self::Item) -> bool { ... }\n    fn find_map<B, F>(&mut self, f: F) -> Option<B>\n       where Self: Sized,\n             F: FnMut(Self::Item) -> Option<B> { ... }\n    fn try_find<F, R>(\n        &mut self,\n        f: F,\n    ) -> <<R as Try>::Residual as Residual<Option<Self::Item>>>::TryType\n       where Self: Sized,\n             F: FnMut(&Self::Item) -> R,\n             R: Try<Output = bool>,\n             <R as Try>::Residual: Residual<Option<Self::Item>> { ... }\n    fn position<P>(&mut self, predicate: P) -> Option<usize>\n       where Self: Sized,\n             P: FnMut(Self::Item) -> bool { ... }\n    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n       where P: FnMut(Self::Item) -> bool,\n             Self: Sized + ExactSizeIterator + DoubleEndedIterator { ... }\n    fn max(self) -> Option<Self::Item>\n       where Self: Sized,\n             Self::Item: Ord { ... }\n    fn min(self) -> Option<Self::Item>\n       where Self: Sized,\n             Self::Item: Ord { ... }\n    fn max_by_key<B, F>(self, f: F) -> Option<Self::Item>\n       where B: Ord,\n             Self: Sized,\n             F: FnMut(&Self::Item) -> B { ... }\n    fn max_by<F>(self, compare: F) -> Option<Self::Item>\n       where Self: Sized,\n             F: FnMut(&Self::Item, &Self::Item) -> Ordering { ... }\n    fn min_by_key<B, F>(self, f: F) -> Option<Self::Item>\n       where B: Ord,\n             Self: Sized,\n             F: FnMut(&Self::Item) -> B { ... }\n    fn min_by<F>(self, compare: F) -> Option<Self::Item>\n       where Self: Sized,\n             F: FnMut(&Self::Item, &Self::Item) -> Ordering { ... }\n    fn rev(self) -> Rev<Self> ⓘ\n       where Self: Sized + DoubleEndedIterator { ... }\n    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB)\n       where FromA: Default + Extend<A>,\n             FromB: Default + Extend<B>,\n             Self: Sized + Iterator<Item = (A, B)> { ... }\n    fn copied<'a, T>(self) -> Copied<Self> ⓘ\n       where T: 'a + Copy,\n             Self: Sized + Iterator<Item = &'a T> { ... }\n    fn cloned<'a, T>(self) -> Cloned<Self> ⓘ\n       where T: 'a + Clone,\n             Self: Sized + Iterator<Item = &'a T> { ... }\n    fn cycle(self) -> Cycle<Self> ⓘ\n       where Self: Sized + Clone { ... }\n    fn array_chunks<const N: usize>(self) -> ArrayChunks<Self, N> ⓘ\n       where Self: Sized { ... }\n    fn sum<S>(self) -> S\n       where Self: Sized,\n             S: Sum<Self::Item> { ... }\n    fn product<P>(self) -> P\n       where Self: Sized,\n             P: Product<Self::Item> { ... }\n    fn cmp<I>(self, other: I) -> Ordering\n       where I: IntoIterator<Item = Self::Item>,\n             Self::Item: Ord,\n             Self: Sized { ... }\n    fn cmp_by<I, F>(self, other: I, cmp: F) -> Ordering\n       where Self: Sized,\n             I: IntoIterator,\n             F: FnMut(Self::Item, <I as IntoIterator>::Item) -> Ordering { ... }\n    fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n       where I: IntoIterator,\n             Self::Item: PartialOrd<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn partial_cmp_by<I, F>(self, other: I, partial_cmp: F) -> Option<Ordering>\n       where Self: Sized,\n             I: IntoIterator,\n             F: FnMut(Self::Item, <I as IntoIterator>::Item) -> Option<Ordering> { ... }\n    fn eq<I>(self, other: I) -> bool\n       where I: IntoIterator,\n             Self::Item: PartialEq<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn eq_by<I, F>(self, other: I, eq: F) -> bool\n       where Self: Sized,\n             I: IntoIterator,\n             F: FnMut(Self::Item, <I as IntoIterator>::Item) -> bool { ... }\n    fn ne<I>(self, other: I) -> bool\n       where I: IntoIterator,\n             Self::Item: PartialEq<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn lt<I>(self, other: I) -> bool\n       where I: IntoIterator,\n             Self::Item: PartialOrd<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn le<I>(self, other: I) -> bool\n       where I: IntoIterator,\n             Self::Item: PartialOrd<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn gt<I>(self, other: I) -> bool\n       where I: IntoIterator,\n             Self::Item: PartialOrd<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn ge<I>(self, other: I) -> bool\n       where I: IntoIterator,\n             Self::Item: PartialOrd<<I as IntoIterator>::Item>,\n             Self: Sized { ... }\n    fn is_sorted(self) -> bool\n       where Self: Sized,\n             Self::Item: PartialOrd { ... }\n    fn is_sorted_by<F>(self, compare: F) -> bool\n       where Self: Sized,\n             F: FnMut(&Self::Item, &Self::Item) -> bool { ... }\n    fn is_sorted_by_key<F, K>(self, f: F) -> bool\n       where Self: Sized,\n             F: FnMut(Self::Item) -> K,\n             K: PartialOrd { ... }\n}\n```\n\nExpand description\n\nA trait for dealing with iterators.\n\nThis is the main iterator trait. For more about the concept of iterators generally, please see the [module-level documentation](index.html \"mod std::iter\"). In particular, you may want to know how to [implement `Iterator`](about:blank/index.html#implementing-iterator \"mod std::iter\").\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#48)\n\nThe type of the elements being iterated over.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#80)\n\nAdvances the iterator and returns the next value.\n\nReturns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") when iteration is finished. Individual iterator implementations may choose to resume iteration, and so calling `next()` again may or may not eventually start returning [`Some(Item)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again at some point.\n\n##### [§](#examples)Examples\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\n// A call to next() returns the next value...\nassert_eq!(Some(&1), iter.next());\nassert_eq!(Some(&2), iter.next());\nassert_eq!(Some(&3), iter.next());\n\n// ... and then None once it's over.\nassert_eq!(None, iter.next());\n\n// More calls may or may not return `None`. Here, they always will.\nassert_eq!(None, iter.next());\nassert_eq!(None, iter.next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++//+A+call+to+next()+returns+the+next+value...%0A++++assert_eq!(Some(%261),+iter.next());%0A++++assert_eq!(Some(%262),+iter.next());%0A++++assert_eq!(Some(%263),+iter.next());%0A++++%0A++++//+...+and+then+None+once+it%27s+over.%0A++++assert_eq!(None,+iter.next());%0A++++%0A++++//+More+calls+may+or+may+not+return+%60None%60.+Here,+they+always+will.%0A++++assert_eq!(None,+iter.next());%0A++++assert_eq!(None,+iter.next());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#115-119)\n\n🔬This is a nightly-only experimental API. (`iter_next_chunk` [#98326](https://github.com/rust-lang/rust/issues/98326))\n\nAdvances the iterator and returns an array containing the next `N` values.\n\nIf there are not enough elements to fill the array then `Err` is returned containing an iterator over the remaining elements.\n\n##### [§](#examples-1)Examples\n\nBasic usage:\n\n```\n#![feature(iter_next_chunk)]\n\nlet mut iter = \"lorem\".chars();\n\nassert_eq!(iter.next_chunk().unwrap(), ['l', 'o']);              // N is inferred as 2\nassert_eq!(iter.next_chunk().unwrap(), ['r', 'e', 'm']);         // N is inferred as 3\nassert_eq!(iter.next_chunk::<4>().unwrap_err().as_slice(), &[]); // N is explicitly 4\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_next_chunk)%5D%0A%0Afn+main()+%7B%0A++++let+mut+iter+=+%22lorem%22.chars();%0A++++%0A++++assert_eq!(iter.next_chunk().unwrap(),+%5B%27l%27,+%27o%27%5D);++++++++++++++//+N+is+inferred+as+2%0A++++assert_eq!(iter.next_chunk().unwrap(),+%5B%27r%27,+%27e%27,+%27m%27%5D);+++++++++//+N+is+inferred+as+3%0A++++assert_eq!(iter.next_chunk::%3C4%3E().unwrap_err().as_slice(),+%26%5B%5D);+//+N+is+explicitly+4%0A%7D&version=nightly&edition=2021)\n\nSplit a string and get the first three items.\n\n```\n#![feature(iter_next_chunk)]\n\nlet quote = \"not all those who wander are lost\";\nlet [first, second, third] = quote.split_whitespace().next_chunk().unwrap();\nassert_eq!(first, \"not\");\nassert_eq!(second, \"all\");\nassert_eq!(third, \"those\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_next_chunk)%5D%0A%0Afn+main()+%7B%0A++++let+quote+=+%22not+all+those+who+wander+are+lost%22;%0A++++let+%5Bfirst,+second,+third%5D+=+quote.split_whitespace().next_chunk().unwrap();%0A++++assert_eq!(first,+%22not%22);%0A++++assert_eq!(second,+%22all%22);%0A++++assert_eq!(third,+%22those%22);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#193)\n\nReturns the bounds on the remaining length of the iterator.\n\nSpecifically, `size_hint()` returns a tuple where the first element is the lower bound, and the second element is the upper bound.\n\nThe second half of the tuple that is returned is an `[Option](../option/enum.Option.html \"enum std::option::Option\")<[usize](../primitive.usize.html \"primitive usize\")>`. A [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") here means that either there is no known upper bound, or the upper bound is larger than [`usize`](../primitive.usize.html \"primitive usize\").\n\n##### [§](#implementation-notes)Implementation notes\n\nIt is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.\n\n`size_hint()` is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of `size_hint()` should not lead to memory safety violations.\n\nThat said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait’s protocol.\n\nThe default implementation returns `(0, [None](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"))` which is correct for any iterator.\n\n##### [§](#examples-2)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\nlet mut iter = a.iter();\n\nassert_eq!((3, Some(3)), iter.size_hint());\nlet _ = iter.next();\nassert_eq!((2, Some(2)), iter.size_hint());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!((3,+Some(3)),+iter.size_hint());%0A++++let+_+=+iter.next();%0A++++assert_eq!((2,+Some(2)),+iter.size_hint());%0A%7D&edition=2021)\n\nA more complex example:\n\n```\n// The even numbers in the range of zero to nine.\nlet iter = (0..10).filter(|x| x % 2 == 0);\n\n// We might iterate from zero to ten times. Knowing that it's five\n// exactly wouldn't be possible without executing filter().\nassert_eq!((0, Some(10)), iter.size_hint());\n\n// Let's add five more numbers with chain()\nlet iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n// now both bounds are increased by five\nassert_eq!((5, Some(15)), iter.size_hint());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+The+even+numbers+in+the+range+of+zero+to+nine.%0Afn+main()+%7B%0A++++let+iter+=+(0..10).filter(%7Cx%7C+x+%25+2+==+0);%0A++++%0A++++//+We+might+iterate+from+zero+to+ten+times.+Knowing+that+it%27s+five%0A++++//+exactly+wouldn%27t+be+possible+without+executing+filter().%0A++++assert_eq!((0,+Some(10)),+iter.size_hint());%0A++++%0A++++//+Let%27s+add+five+more+numbers+with+chain()%0A++++let+iter+=+(0..10).filter(%7Cx%7C+x+%25+2+==+0).chain(15..20);%0A++++%0A++++//+now+both+bounds+are+increased+by+five%0A++++assert_eq!((5,+Some(15)),+iter.size_hint());%0A%7D&edition=2021)\n\nReturning `None` for an upper bound:\n\n```\n// an infinite iterator has no upper bound\n// and the maximum possible lower bound\nlet iter = 0..;\n\nassert_eq!((usize::MAX, None), iter.size_hint());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+an+infinite+iterator+has+no+upper+bound%0A//+and+the+maximum+possible+lower+bound%0Afn+main()+%7B%0A++++let+iter+=+0..;%0A++++%0A++++assert_eq!((usize::MAX,+None),+iter.size_hint());%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#229-231)\n\nConsumes the iterator, counting the number of iterations and returning it.\n\nThis method will call [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") repeatedly until [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is encountered, returning the number of times it saw [`Some`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\"). Note that [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") has to be called at least once even if the iterator does not have any elements.\n\n##### [§](#overflow-behavior)Overflow Behavior\n\nThe method does no guarding against overflows, so counting elements of an iterator with more than [`usize::MAX`](about:blank/primitive.usize.html#associatedconstant.MAX \"associated constant usize::MAX\") elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.\n\n##### [§](#panics)Panics\n\nThis function might panic if the iterator has more than [`usize::MAX`](about:blank/primitive.usize.html#associatedconstant.MAX \"associated constant usize::MAX\") elements.\n\n##### [§](#examples-3)Examples\n\n```\nlet a = [1, 2, 3];\nassert_eq!(a.iter().count(), 3);\n\nlet a = [1, 2, 3, 4, 5];\nassert_eq!(a.iter().count(), 5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().count(),+3);%0A++++%0A++++let+a+=+%5B1,+2,+3,+4,+5%5D;%0A++++assert_eq!(a.iter().count(),+5);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#258-260)\n\nConsumes the iterator, returning the last element.\n\nThis method will evaluate the iterator until it returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"). While doing so, it keeps track of the current element. After [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned, `last()` will then return the last element it saw.\n\n##### [§](#examples-4)Examples\n\n```\nlet a = [1, 2, 3];\nassert_eq!(a.iter().last(), Some(&3));\n\nlet a = [1, 2, 3, 4, 5];\nassert_eq!(a.iter().last(), Some(&5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().last(),+Some(%263));%0A++++%0A++++let+a+=+%5B1,+2,+3,+4,+5%5D;%0A++++assert_eq!(a.iter().last(),+Some(%265));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#306)\n\n🔬This is a nightly-only experimental API. (`iter_advance_by` [#77404](https://github.com/rust-lang/rust/issues/77404))\n\nAdvances the iterator by `n` elements.\n\nThis method will eagerly skip `n` elements by calling [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") up to `n` times until [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is encountered.\n\n`advance_by(n)` will return `Ok(())` if the iterator successfully advances by `n` elements, or a `Err(NonZero<usize>)` with value `k` if [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is encountered, where `k` is remaining number of steps that could not be advanced because the iterator ran out. If `self` is empty and `n` is non-zero, then this returns `Err(n)`. Otherwise, `k` is always less than `n`.\n\nCalling `advance_by(0)` can do meaningful work, for example [`Flatten`](struct.Flatten.html \"struct std::iter::Flatten\") can advance its outer iterator until it finds an inner iterator that is not empty, which then often allows it to return a more accurate `size_hint()` than in its initial state.\n\n##### [§](#examples-5)Examples\n\n```\n#![feature(iter_advance_by)]\n\nuse std::num::NonZero;\n\nlet a = [1, 2, 3, 4];\nlet mut iter = a.iter();\n\nassert_eq!(iter.advance_by(2), Ok(()));\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.advance_by(0), Ok(()));\nassert_eq!(iter.advance_by(100), Err(NonZero::new(99).unwrap())); // only `&4` was skipped\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_advance_by)%5D%0A%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.advance_by(2),+Ok(()));%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.advance_by(0),+Ok(()));%0A++++assert_eq!(iter.advance_by(100),+Err(NonZero::new(99).unwrap()));+//+only+%60%264%60+was+skipped%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#358)\n\nReturns the `n`th element of the iterator.\n\nLike most indexing operations, the count starts from zero, so `nth(0)` returns the first value, `nth(1)` the second, and so on.\n\nNote that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling `nth(0)` multiple times on the same iterator will return different elements.\n\n`nth()` will return [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") if `n` is greater than or equal to the length of the iterator.\n\n##### [§](#examples-6)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\nassert_eq!(a.iter().nth(1), Some(&2));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().nth(1),+Some(%262));%0A%7D&edition=2021)\n\nCalling `nth()` multiple times doesn’t rewind the iterator:\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.nth(1), Some(&2));\nassert_eq!(iter.nth(1), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.nth(1),+Some(%262));%0A++++assert_eq!(iter.nth(1),+None);%0A%7D&edition=2021)\n\nReturning `None` if there are less than `n + 1` elements:\n\n```\nlet a = [1, 2, 3];\nassert_eq!(a.iter().nth(10), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().nth(10),+None);%0A%7D&edition=2021)\n\n1.28.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#409-411)\n\nCreates an iterator starting at the same point, but stepping by the given amount at each iteration.\n\nNote 1: The first element of the iterator will always be returned, regardless of the step given.\n\nNote 2: The time at which ignored elements are pulled is not fixed. `StepBy` behaves like the sequence `self.next()`, `self.nth(step-1)`, `self.nth(step-1)`, …, but is also free to behave like the sequence `advance_n_and_return_first(&mut self, step)`, `advance_n_and_return_first(&mut self, step)`, … Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.\n\n`advance_n_and_return_first` is the equivalent of:\n\n```\nfn advance_n_and_return_first<I>(iter: &mut I, n: usize) -> Option<I::Item>\nwhere\n    I: Iterator,\n{\n    let next = iter.next();\n    if n > 1 {\n        iter.nth(n - 2);\n    }\n    next\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+advance_n_and_return_first%3CI%3E(iter:+%26mut+I,+n:+usize)+-%3E+Option%3CI::Item%3E%0A++++where%0A++++++++I:+Iterator,%0A++++%7B%0A++++++++let+next+=+iter.next();%0A++++++++if+n+%3E+1+%7B%0A++++++++++++iter.nth(n+-+2);%0A++++++++%7D%0A++++++++next%0A++++%7D%0A%7D&edition=2021)\n\n##### [§](#panics-1)Panics\n\nThe method will panic if the given step is `0`.\n\n##### [§](#examples-7)Examples\n\n```\nlet a = [0, 1, 2, 3, 4, 5];\nlet mut iter = a.iter().step_by(2);\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&4));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2,+3,+4,+5%5D;%0A++++let+mut+iter+=+a.iter().step_by(2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%264));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#481-484)\n\nTakes two iterators and creates a new iterator over both in sequence.\n\n`chain()` will return a new iterator which will first iterate over values from the first iterator and then over values from the second iterator.\n\nIn other words, it links two iterators together, in a chain. 🔗\n\n[`once`](fn.once.html \"fn std::iter::once\") is commonly used to adapt a single value into a chain of other kinds of iteration.\n\n##### [§](#examples-8)Examples\n\nBasic usage:\n\n```\nlet a1 = [1, 2, 3];\nlet a2 = [4, 5, 6];\n\nlet mut iter = a1.iter().chain(a2.iter());\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), Some(&4));\nassert_eq!(iter.next(), Some(&5));\nassert_eq!(iter.next(), Some(&6));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a1+=+%5B1,+2,+3%5D;%0A++++let+a2+=+%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+a1.iter().chain(a2.iter());%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+Some(%264));%0A++++assert_eq!(iter.next(),+Some(%265));%0A++++assert_eq!(iter.next(),+Some(%266));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nSince the argument to `chain()` uses [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"), we can pass anything that can be converted into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"), not just an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") itself. For example, slices (`&[T]`) implement [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"), and so can be passed to `chain()` directly:\n\n```\nlet s1 = &[1, 2, 3];\nlet s2 = &[4, 5, 6];\n\nlet mut iter = s1.iter().chain(s2);\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), Some(&4));\nassert_eq!(iter.next(), Some(&5));\nassert_eq!(iter.next(), Some(&6));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1+=+%26%5B1,+2,+3%5D;%0A++++let+s2+=+%26%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+s1.iter().chain(s2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+Some(%264));%0A++++assert_eq!(iter.next(),+Some(%265));%0A++++assert_eq!(iter.next(),+Some(%266));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nIf you work with Windows API, you may wish to convert [`OsStr`](../../std/ffi/struct.OsStr.html) to `Vec<u16>`:\n\n```\n#[cfg(windows)]\nfn os_str_to_utf16(s: &std::ffi::OsStr) -> Vec<u16> {\n    use std::os::windows::ffi::OsStrExt;\n    s.encode_wide().chain(std::iter::once(0)).collect()\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(windows)%5D%0A++++fn+os_str_to_utf16(s:+%26std::ffi::OsStr)+-%3E+Vec%3Cu16%3E+%7B%0A++++++++use+std::os::windows::ffi::OsStrExt;%0A++++++++s.encode_wide().chain(std::iter::once(0)).collect()%0A++++%7D%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#600-603)\n\n‘Zips up’ two iterators into a single iterator of pairs.\n\n`zip()` returns a new iterator that will iterate over two other iterators, returning a tuple where the first element comes from the first iterator, and the second element comes from the second iterator.\n\nIn other words, it zips two iterators together, into a single one.\n\nIf either iterator returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"), [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") from the zipped iterator will return [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"). If the zipped iterator has no more elements to return then each further attempt to advance it will first try to advance the first iterator at most one time and if it still yielded an item try to advance the second iterator at most one time.\n\nTo ‘undo’ the result of zipping up two iterators, see [`unzip`](about:blank/trait.Iterator.html#method.unzip \"method std::iter::Iterator::unzip\").\n\n##### [§](#examples-9)Examples\n\nBasic usage:\n\n```\nlet a1 = [1, 2, 3];\nlet a2 = [4, 5, 6];\n\nlet mut iter = a1.iter().zip(a2.iter());\n\nassert_eq!(iter.next(), Some((&1, &4)));\nassert_eq!(iter.next(), Some((&2, &5)));\nassert_eq!(iter.next(), Some((&3, &6)));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a1+=+%5B1,+2,+3%5D;%0A++++let+a2+=+%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+a1.iter().zip(a2.iter());%0A++++%0A++++assert_eq!(iter.next(),+Some((%261,+%264)));%0A++++assert_eq!(iter.next(),+Some((%262,+%265)));%0A++++assert_eq!(iter.next(),+Some((%263,+%266)));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nSince the argument to `zip()` uses [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"), we can pass anything that can be converted into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"), not just an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") itself. For example, slices (`&[T]`) implement [`IntoIterator`](trait.IntoIterator.html \"trait std::iter::IntoIterator\"), and so can be passed to `zip()` directly:\n\n```\nlet s1 = &[1, 2, 3];\nlet s2 = &[4, 5, 6];\n\nlet mut iter = s1.iter().zip(s2);\n\nassert_eq!(iter.next(), Some((&1, &4)));\nassert_eq!(iter.next(), Some((&2, &5)));\nassert_eq!(iter.next(), Some((&3, &6)));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1+=+%26%5B1,+2,+3%5D;%0A++++let+s2+=+%26%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+s1.iter().zip(s2);%0A++++%0A++++assert_eq!(iter.next(),+Some((%261,+%264)));%0A++++assert_eq!(iter.next(),+Some((%262,+%265)));%0A++++assert_eq!(iter.next(),+Some((%263,+%266)));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n`zip()` is often used to zip an infinite iterator to a finite one. This works because the finite iterator will eventually return [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"), ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`](about:blank/trait.Iterator.html#method.enumerate \"method std::iter::Iterator::enumerate\"):\n\n```\nlet enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n\nlet zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n\nassert_eq!((0, 'f'), enumerate[0]);\nassert_eq!((0, 'f'), zipper[0]);\n\nassert_eq!((1, 'o'), enumerate[1]);\nassert_eq!((1, 'o'), zipper[1]);\n\nassert_eq!((2, 'o'), enumerate[2]);\nassert_eq!((2, 'o'), zipper[2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+enumerate:+Vec%3C_%3E+=+%22foo%22.chars().enumerate().collect();%0A++++%0A++++let+zipper:+Vec%3C_%3E+=+(0..).zip(%22foo%22.chars()).collect();%0A++++%0A++++assert_eq!((0,+%27f%27),+enumerate%5B0%5D);%0A++++assert_eq!((0,+%27f%27),+zipper%5B0%5D);%0A++++%0A++++assert_eq!((1,+%27o%27),+enumerate%5B1%5D);%0A++++assert_eq!((1,+%27o%27),+zipper%5B1%5D);%0A++++%0A++++assert_eq!((2,+%27o%27),+enumerate%5B2%5D);%0A++++assert_eq!((2,+%27o%27),+zipper%5B2%5D);%0A%7D&edition=2021)\n\nIf both iterators have roughly equivalent syntax, it may be more readable to use [`zip`](fn.zip.html \"fn std::iter::zip\"):\n\n```\nuse std::iter::zip;\n\nlet a = [1, 2, 3];\nlet b = [2, 3, 4];\n\nlet mut zipped = zip(\n    a.into_iter().map(|x| x * 2).skip(1),\n    b.into_iter().map(|x| x * 2).skip(1),\n);\n\nassert_eq!(zipped.next(), Some((4, 6)));\nassert_eq!(zipped.next(), Some((6, 8)));\nassert_eq!(zipped.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::iter::zip;%0A++++%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b+=+%5B2,+3,+4%5D;%0A++++%0A++++let+mut+zipped+=+zip(%0A++++++++a.into_iter().map(%7Cx%7C+x+*+2).skip(1),%0A++++++++b.into_iter().map(%7Cx%7C+x+*+2).skip(1),%0A++++);%0A++++%0A++++assert_eq!(zipped.next(),+Some((4,+6)));%0A++++assert_eq!(zipped.next(),+Some((6,+8)));%0A++++assert_eq!(zipped.next(),+None);%0A%7D&edition=2021)\n\ncompared to:\n\n```\nlet mut zipped = a\n    .into_iter()\n    .map(|x| x * 2)\n    .skip(1)\n    .zip(b.into_iter().map(|x| x * 2).skip(1));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b+=+%5B2,+3,+4%5D;%0A++++%0A++++let+mut+zipped+=+a%0A++++++++.into_iter()%0A++++++++.map(%7Cx%7C+x+*+2)%0A++++++++.skip(1)%0A++++++++.zip(b.into_iter().map(%7Cx%7C+x+*+2).skip(1));%0A++++%0A++++assert_eq!(zipped.next(),+Some((4,+6)));%0A++++assert_eq!(zipped.next(),+Some((6,+8)));%0A++++assert_eq!(zipped.next(),+None);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#643-646)\n\n🔬This is a nightly-only experimental API. (`iter_intersperse` [#79524](https://github.com/rust-lang/rust/issues/79524))\n\nCreates a new iterator which places a copy of `separator` between adjacent items of the original iterator.\n\nIn case `separator` does not implement [`Clone`](../clone/trait.Clone.html \"trait std::clone::Clone\") or needs to be computed every time, use [`intersperse_with`](about:blank/trait.Iterator.html#method.intersperse_with \"method std::iter::Iterator::intersperse_with\").\n\n##### [§](#examples-10)Examples\n\nBasic usage:\n\n```\n#![feature(iter_intersperse)]\n\nlet mut a = [0, 1, 2].iter().intersperse(&100);\nassert_eq!(a.next(), Some(&0));   // The first element from `a`.\nassert_eq!(a.next(), Some(&100)); // The separator.\nassert_eq!(a.next(), Some(&1));   // The next element from `a`.\nassert_eq!(a.next(), Some(&100)); // The separator.\nassert_eq!(a.next(), Some(&2));   // The last element from `a`.\nassert_eq!(a.next(), None);       // The iterator is finished.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++let+mut+a+=+%5B0,+1,+2%5D.iter().intersperse(%26100);%0A++++assert_eq!(a.next(),+Some(%260));+++//+The+first+element+from+%60a%60.%0A++++assert_eq!(a.next(),+Some(%26100));+//+The+separator.%0A++++assert_eq!(a.next(),+Some(%261));+++//+The+next+element+from+%60a%60.%0A++++assert_eq!(a.next(),+Some(%26100));+//+The+separator.%0A++++assert_eq!(a.next(),+Some(%262));+++//+The+last+element+from+%60a%60.%0A++++assert_eq!(a.next(),+None);+++++++//+The+iterator+is+finished.%0A%7D&version=nightly&edition=2021)\n\n`intersperse` can be very useful to join an iterator’s items using a common element:\n\n```\n#![feature(iter_intersperse)]\n\nlet hello = [\"Hello\", \"World\", \"!\"].iter().copied().intersperse(\" \").collect::<String>();\nassert_eq!(hello, \"Hello World !\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++let+hello+=+%5B%22Hello%22,+%22World%22,+%22!%22%5D.iter().copied().intersperse(%22+%22).collect::%3CString%3E();%0A++++assert_eq!(hello,+%22Hello+World+!%22);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#702-705)\n\n🔬This is a nightly-only experimental API. (`iter_intersperse` [#79524](https://github.com/rust-lang/rust/issues/79524))\n\nCreates a new iterator which places an item generated by `separator` between adjacent items of the original iterator.\n\nThe closure will be called exactly once each time an item is placed between two adjacent items from the underlying iterator; specifically, the closure is not called if the underlying iterator yields less than two items and after the last item is yielded.\n\nIf the iterator’s item implements [`Clone`](../clone/trait.Clone.html \"trait std::clone::Clone\"), it may be easier to use [`intersperse`](about:blank/trait.Iterator.html#method.intersperse \"method std::iter::Iterator::intersperse\").\n\n##### [§](#examples-11)Examples\n\nBasic usage:\n\n```\n#![feature(iter_intersperse)]\n\n#[derive(PartialEq, Debug)]\nstruct NotClone(usize);\n\nlet v = [NotClone(0), NotClone(1), NotClone(2)];\nlet mut it = v.into_iter().intersperse_with(|| NotClone(99));\n\nassert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.\nassert_eq!(it.next(), Some(NotClone(99))); // The separator.\nassert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.\nassert_eq!(it.next(), Some(NotClone(99))); // The separator.\nassert_eq!(it.next(), Some(NotClone(2)));  // The last element from `v`.\nassert_eq!(it.next(), None);               // The iterator is finished.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++%23%5Bderive(PartialEq,+Debug)%5D%0A++++struct+NotClone(usize);%0A++++%0A++++let+v+=+%5BNotClone(0),+NotClone(1),+NotClone(2)%5D;%0A++++let+mut+it+=+v.into_iter().intersperse_with(%7C%7C+NotClone(99));%0A++++%0A++++assert_eq!(it.next(),+Some(NotClone(0)));++//+The+first+element+from+%60v%60.%0A++++assert_eq!(it.next(),+Some(NotClone(99)));+//+The+separator.%0A++++assert_eq!(it.next(),+Some(NotClone(1)));++//+The+next+element+from+%60v%60.%0A++++assert_eq!(it.next(),+Some(NotClone(99)));+//+The+separator.%0A++++assert_eq!(it.next(),+Some(NotClone(2)));++//+The+last+element+from+%60v%60.%0A++++assert_eq!(it.next(),+None);+++++++++++++++//+The+iterator+is+finished.%0A%7D&version=nightly&edition=2021)\n\n`intersperse_with` can be used in situations where the separator needs to be computed:\n\n```\n#![feature(iter_intersperse)]\n\nlet src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();\n\n// The closure mutably borrows its context to generate an item.\nlet mut happy_emojis = [\" ❤️ \", \" 😀 \"].iter().copied();\nlet separator = || happy_emojis.next().unwrap_or(\" 🦀 \");\n\nlet result = src.intersperse_with(separator).collect::<String>();\nassert_eq!(result, \"Hello ❤️ to 😀 all 🦀 people 🦀 !!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++let+src+=+%5B%22Hello%22,+%22to%22,+%22all%22,+%22people%22,+%22!!%22%5D.iter().copied();%0A++++%0A++++//+The+closure+mutably+borrows+its+context+to+generate+an+item.%0A++++let+mut+happy_emojis+=+%5B%22+%E2%9D%A4%EF%B8%8F+%22,+%22+%F0%9F%98%80+%22%5D.iter().copied();%0A++++let+separator+=+%7C%7C+happy_emojis.next().unwrap_or(%22+%F0%9F%A6%80+%22);%0A++++%0A++++let+result+=+src.intersperse_with(separator).collect::%3CString%3E();%0A++++assert_eq!(result,+%22Hello+%E2%9D%A4%EF%B8%8F+to+%F0%9F%98%80+all+%F0%9F%A6%80+people+%F0%9F%A6%80+!!%22);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#762-765)\n\nTakes a closure and creates an iterator which calls that closure on each element.\n\n`map()` transforms one iterator into another, by means of its argument: something that implements [`FnMut`](../ops/trait.FnMut.html \"trait std::ops::FnMut\"). It produces a new iterator which calls this closure on each element of the original iterator.\n\nIf you are good at thinking in types, you can think of `map()` like this: If you have an iterator that gives you elements of some type `A`, and you want an iterator of some other type `B`, you can use `map()`, passing a closure that takes an `A` and returns a `B`.\n\n`map()` is conceptually similar to a [`for`](about:blank/book/ch03-05-control-flow.html#looping-through-a-collection-with-for) loop. However, as `map()` is lazy, it is best used when you’re already working with other iterators. If you’re doing some sort of looping for a side effect, it’s considered more idiomatic to use [`for`](about:blank/book/ch03-05-control-flow.html#looping-through-a-collection-with-for) than `map()`.\n\n##### [§](#examples-12)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter().map(|x| 2 * x);\n\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), Some(6));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().map(%7Cx%7C+2+*+x);%0A++++%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+Some(6));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nIf you’re doing some sort of side effect, prefer [`for`](about:blank/book/ch03-05-control-flow.html#looping-through-a-collection-with-for) to `map()`:\n\n```\n// don't do this:\n(0..5).map(|x| println!(\"{x}\"));\n\n// it won't even execute, as it is lazy. Rust will warn you about this.\n\n// Instead, use for:\nfor x in 0..5 {\n    println!(\"{x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0A//+don%27t+do+this:%0Afn+main()+%7B%0A++++(0..5).map(%7Cx%7C+println!(%22%7Bx%7D%22));%0A++++%0A++++//+it+won%27t+even+execute,+as+it+is+lazy.+Rust+will+warn+you+about+this.%0A++++%0A++++//+Instead,+use+for:%0A++++for+x+in+0..5+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n1.21.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#808-811)\n\nCalls a closure on each element of an iterator.\n\nThis is equivalent to using a [`for`](about:blank/book/ch03-05-control-flow.html#looping-through-a-collection-with-for) loop on the iterator, although `break` and `continue` are not possible from a closure. It’s generally more idiomatic to use a `for` loop, but `for_each` may be more legible when processing items at the end of longer iterator chains. In some cases `for_each` may also be faster than a loop, because it will use internal iteration on adapters like `Chain`.\n\n##### [§](#examples-13)Examples\n\nBasic usage:\n\n```\nuse std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n(0..5).map(|x| x * 2 + 1)\n      .for_each(move |x| tx.send(x).unwrap());\n\nlet v: Vec<_> = rx.iter().collect();\nassert_eq!(v, vec![1, 3, 5, 7, 9]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++let+(tx,+rx)+=+channel();%0A++++(0..5).map(%7Cx%7C+x+*+2+%2B+1)%0A++++++++++.for_each(move+%7Cx%7C+tx.send(x).unwrap());%0A++++%0A++++let+v:+Vec%3C_%3E+=+rx.iter().collect();%0A++++assert_eq!(v,+vec!%5B1,+3,+5,+7,+9%5D);%0A%7D&edition=2021)\n\nFor such a small example, a `for` loop may be cleaner, but `for_each` might be preferable to keep a functional style with longer iterators:\n\n```\n(0..5).flat_map(|x| x * 100 .. x * 110)\n      .enumerate()\n      .filter(|&(i, x)| (i + x) % 3 == 0)\n      .for_each(|(i, x)| println!(\"{i}:{x}\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++(0..5).flat_map(%7Cx%7C+x+*+100+..+x+*+110)%0A++++++++++.enumerate()%0A++++++++++.filter(%7C%26(i,+x)%7C+(i+%2B+x)+%25+3+==+0)%0A++++++++++.for_each(%7C(i,+x)%7C+println!(%22%7Bi%7D:%7Bx%7D%22));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#884-887)\n\nCreates an iterator which uses a closure to determine if an element should be yielded.\n\nGiven an element the closure must return `true` or `false`. The returned iterator will yield only the elements for which the closure returns true.\n\n##### [§](#examples-14)Examples\n\nBasic usage:\n\n```\nlet a = [0i32, 1, 2];\n\nlet mut iter = a.iter().filter(|x| x.is_positive());\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0i32,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7Cx%7C+x.is_positive());%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nBecause the closure passed to `filter()` takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:\n\n```\nlet a = [0, 1, 2];\n\nlet mut iter = a.iter().filter(|x| **x > 1); // need two *s!\n\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7Cx%7C+**x+%3E+1);+//+need+two+*s!%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nIt’s common to instead use destructuring on the argument to strip away one:\n\n```\nlet a = [0, 1, 2];\n\nlet mut iter = a.iter().filter(|&x| *x > 1); // both & and *\n\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7C%26x%7C+*x+%3E+1);+//+both+%26+and+*%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nor both:\n\n```\nlet a = [0, 1, 2];\n\nlet mut iter = a.iter().filter(|&&x| x > 1); // two &s\n\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7C%26%26x%7C+x+%3E+1);+//+two+%26s%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nof these layers.\n\nNote that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#930-933)\n\nCreates an iterator that both filters and maps.\n\nThe returned iterator yields only the `value`s for which the supplied closure returns `Some(value)`.\n\n`filter_map` can be used to make chains of [`filter`](about:blank/trait.Iterator.html#method.filter \"method std::iter::Iterator::filter\") and [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\") more concise. The example below shows how a `map().filter().map()` can be shortened to a single call to `filter_map`.\n\n##### [§](#examples-15)Examples\n\nBasic usage:\n\n```\nlet a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];\n\nlet mut iter = a.iter().filter_map(|s| s.parse().ok());\n\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(5));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%221%22,+%22two%22,+%22NaN%22,+%22four%22,+%225%22%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter_map(%7Cs%7C+s.parse().ok());%0A++++%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(5));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nHere’s the same example, but with [`filter`](about:blank/trait.Iterator.html#method.filter \"method std::iter::Iterator::filter\") and [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\"):\n\n```\nlet a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];\nlet mut iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(5));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%221%22,+%22two%22,+%22NaN%22,+%22four%22,+%225%22%5D;%0A++++let+mut+iter+=+a.iter().map(%7Cs%7C+s.parse()).filter(%7Cs%7C+s.is_ok()).map(%7Cs%7C+s.unwrap());%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(5));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#978-980)\n\nCreates an iterator which gives the current iteration count as well as the next value.\n\nThe iterator returned yields pairs `(i, val)`, where `i` is the current index of iteration and `val` is the value returned by the iterator.\n\n`enumerate()` keeps its count as a [`usize`](../primitive.usize.html \"primitive usize\"). If you want to count by a different sized integer, the [`zip`](about:blank/trait.Iterator.html#method.zip \"method std::iter::Iterator::zip\") function provides similar functionality.\n\n##### [§](#overflow-behavior-1)Overflow Behavior\n\nThe method does no guarding against overflows, so enumerating more than [`usize::MAX`](about:blank/primitive.usize.html#associatedconstant.MAX \"associated constant usize::MAX\") elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.\n\n##### [§](#panics-2)Panics\n\nThe returned iterator might panic if the to-be-returned index would overflow a [`usize`](../primitive.usize.html \"primitive usize\").\n\n##### [§](#examples-16)Examples\n\n```\nlet a = ['a', 'b', 'c'];\n\nlet mut iter = a.iter().enumerate();\n\nassert_eq!(iter.next(), Some((0, &'a')));\nassert_eq!(iter.next(), Some((1, &'b')));\nassert_eq!(iter.next(), Some((2, &'c')));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%27a%27,+%27b%27,+%27c%27%5D;%0A++++%0A++++let+mut+iter+=+a.iter().enumerate();%0A++++%0A++++assert_eq!(iter.next(),+Some((0,+%26%27a%27)));%0A++++assert_eq!(iter.next(),+Some((1,+%26%27b%27)));%0A++++assert_eq!(iter.next(),+Some((2,+%26%27c%27)));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1050-1052)\n\nCreates an iterator which can use the [`peek`](about:blank/struct.Peekable.html#method.peek \"method std::iter::Peekable::peek\") and [`peek_mut`](about:blank/struct.Peekable.html#method.peek_mut \"method std::iter::Peekable::peek_mut\") methods to look at the next element of the iterator without consuming it. See their documentation for more information.\n\nNote that the underlying iterator is still advanced when [`peek`](about:blank/struct.Peekable.html#method.peek \"method std::iter::Peekable::peek\") or [`peek_mut`](about:blank/struct.Peekable.html#method.peek_mut \"method std::iter::Peekable::peek_mut\") are called for the first time: In order to retrieve the next element, [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the [`next`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") method will occur.\n\n##### [§](#examples-17)Examples\n\nBasic usage:\n\n```\nlet xs = [1, 2, 3];\n\nlet mut iter = xs.iter().peekable();\n\n// peek() lets us see into the future\nassert_eq!(iter.peek(), Some(&&1));\nassert_eq!(iter.next(), Some(&1));\n\nassert_eq!(iter.next(), Some(&2));\n\n// we can peek() multiple times, the iterator won't advance\nassert_eq!(iter.peek(), Some(&&3));\nassert_eq!(iter.peek(), Some(&&3));\n\nassert_eq!(iter.next(), Some(&3));\n\n// after the iterator is finished, so is peek()\nassert_eq!(iter.peek(), None);\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+xs+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+xs.iter().peekable();%0A++++%0A++++//+peek()+lets+us+see+into+the+future%0A++++assert_eq!(iter.peek(),+Some(%26%261));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++%0A++++//+we+can+peek()+multiple+times,+the+iterator+won%27t+advance%0A++++assert_eq!(iter.peek(),+Some(%26%263));%0A++++assert_eq!(iter.peek(),+Some(%26%263));%0A++++%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++%0A++++//+after+the+iterator+is+finished,+so+is+peek()%0A++++assert_eq!(iter.peek(),+None);%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nUsing [`peek_mut`](about:blank/struct.Peekable.html#method.peek_mut \"method std::iter::Peekable::peek_mut\") to mutate the next item without advancing the iterator:\n\n```\nlet xs = [1, 2, 3];\n\nlet mut iter = xs.iter().peekable();\n\n// `peek_mut()` lets us see into the future\nassert_eq!(iter.peek_mut(), Some(&mut &1));\nassert_eq!(iter.peek_mut(), Some(&mut &1));\nassert_eq!(iter.next(), Some(&1));\n\nif let Some(mut p) = iter.peek_mut() {\n    assert_eq!(*p, &2);\n    // put a value into the iterator\n    *p = &1000;\n}\n\n// The value reappears as the iterator continues\nassert_eq!(iter.collect::<Vec<_>>(), vec![&1000, &3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+xs+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+xs.iter().peekable();%0A++++%0A++++//+%60peek_mut()%60+lets+us+see+into+the+future%0A++++assert_eq!(iter.peek_mut(),+Some(%26mut+%261));%0A++++assert_eq!(iter.peek_mut(),+Some(%26mut+%261));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++if+let+Some(mut+p)+=+iter.peek_mut()+%7B%0A++++++++assert_eq!(*p,+%262);%0A++++++++//+put+a+value+into+the+iterator%0A++++++++*p+=+%261000;%0A++++%7D%0A++++%0A++++//+The+value+reappears+as+the+iterator+continues%0A++++assert_eq!(iter.collect::%3CVec%3C_%3E%3E(),+vec!%5B%261000,+%263%5D);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1116-1119)\n\nCreates an iterator that [`skip`](about:blank/trait.Iterator.html#method.skip \"method std::iter::Iterator::skip\")s elements based on a predicate.\n\n`skip_while()` takes a closure as an argument. It will call this closure on each element of the iterator, and ignore elements until it returns `false`.\n\nAfter `false` is returned, `skip_while()`’s job is over, and the rest of the elements are yielded.\n\n##### [§](#examples-18)Examples\n\nBasic usage:\n\n```\nlet a = [-1i32, 0, 1];\n\nlet mut iter = a.iter().skip_while(|x| x.is_negative());\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip_while(%7Cx%7C+x.is_negative());%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nBecause the closure passed to `skip_while()` takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure argument is a double reference:\n\n```\nlet a = [-1, 0, 1];\n\nlet mut iter = a.iter().skip_while(|x| **x < 0); // need two *s!\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip_while(%7Cx%7C+**x+%3C+0);+//+need+two+*s!%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nStopping after an initial `false`:\n\n```\nlet a = [-1, 0, 1, -2];\n\nlet mut iter = a.iter().skip_while(|x| **x < 0);\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&1));\n\n// while this would have been false, since we already got a false,\n// skip_while() isn't used any more\nassert_eq!(iter.next(), Some(&-2));\n\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1,+-2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip_while(%7Cx%7C+**x+%3C+0);%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++//+while+this+would+have+been+false,+since+we+already+got+a+false,%0A++++//+skip_while()+isn%27t+used+any+more%0A++++assert_eq!(iter.next(),+Some(%26-2));%0A++++%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1198-1201)\n\nCreates an iterator that yields elements based on a predicate.\n\n`take_while()` takes a closure as an argument. It will call this closure on each element of the iterator, and yield elements while it returns `true`.\n\nAfter `false` is returned, `take_while()`’s job is over, and the rest of the elements are ignored.\n\n##### [§](#examples-19)Examples\n\nBasic usage:\n\n```\nlet a = [-1i32, 0, 1];\n\nlet mut iter = a.iter().take_while(|x| x.is_negative());\n\nassert_eq!(iter.next(), Some(&-1));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take_while(%7Cx%7C+x.is_negative());%0A++++%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nBecause the closure passed to `take_while()` takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:\n\n```\nlet a = [-1, 0, 1];\n\nlet mut iter = a.iter().take_while(|x| **x < 0); // need two *s!\n\nassert_eq!(iter.next(), Some(&-1));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take_while(%7Cx%7C+**x+%3C+0);+//+need+two+*s!%0A++++%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nStopping after an initial `false`:\n\n```\nlet a = [-1, 0, 1, -2];\n\nlet mut iter = a.iter().take_while(|x| **x < 0);\n\nassert_eq!(iter.next(), Some(&-1));\n\n// We have more elements that are less than zero, but since we already\n// got a false, take_while() isn't used any more\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1,+-2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take_while(%7Cx%7C+**x+%3C+0);%0A++++%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A++++%0A++++//+We+have+more+elements+that+are+less+than+zero,+but+since+we+already%0A++++//+got+a+false,+take_while()+isn%27t+used+any+more%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nBecause `take_while()` needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:\n\n```\nlet a = [1, 2, 3, 4];\nlet mut iter = a.iter();\n\nlet result: Vec<i32> = iter.by_ref()\n                           .take_while(|n| **n != 3)\n                           .cloned()\n                           .collect();\n\nassert_eq!(result, &[1, 2]);\n\nlet result: Vec<i32> = iter.cloned().collect();\n\nassert_eq!(result, &[4]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++let+result:+Vec%3Ci32%3E+=+iter.by_ref()%0A+++++++++++++++++++++++++++++++.take_while(%7Cn%7C+**n+!=+3)%0A+++++++++++++++++++++++++++++++.cloned()%0A+++++++++++++++++++++++++++++++.collect();%0A++++%0A++++assert_eq!(result,+%26%5B1,+2%5D);%0A++++%0A++++let+result:+Vec%3Ci32%3E+=+iter.cloned().collect();%0A++++%0A++++assert_eq!(result,+%26%5B4%5D);%0A%7D&edition=2021)\n\nThe `3` is no longer there, because it was consumed in order to see if the iteration should stop, but wasn’t placed back into the iterator.\n\n1.57.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1287-1290)\n\nCreates an iterator that both yields elements based on a predicate and maps.\n\n`map_while()` takes a closure as an argument. It will call this closure on each element of the iterator, and yield elements while it returns [`Some(_)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\").\n\n##### [§](#examples-20)Examples\n\nBasic usage:\n\n```\nlet a = [-1i32, 4, 0, 1];\n\nlet mut iter = a.iter().map_while(|x| 16i32.checked_div(*x));\n\nassert_eq!(iter.next(), Some(-16));\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+4,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().map_while(%7Cx%7C+16i32.checked_div(*x));%0A++++%0A++++assert_eq!(iter.next(),+Some(-16));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nHere’s the same example, but with [`take_while`](about:blank/trait.Iterator.html#method.take_while \"method std::iter::Iterator::take_while\") and [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\"):\n\n```\nlet a = [-1i32, 4, 0, 1];\n\nlet mut iter = a.iter()\n                .map(|x| 16i32.checked_div(*x))\n                .take_while(|x| x.is_some())\n                .map(|x| x.unwrap());\n\nassert_eq!(iter.next(), Some(-16));\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+4,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter()%0A++++++++++++++++++++.map(%7Cx%7C+16i32.checked_div(*x))%0A++++++++++++++++++++.take_while(%7Cx%7C+x.is_some())%0A++++++++++++++++++++.map(%7Cx%7C+x.unwrap());%0A++++%0A++++assert_eq!(iter.next(),+Some(-16));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nStopping after an initial [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"):\n\n```\nlet a = [0, 1, 2, -3, 4, 5, -6];\n\nlet iter = a.iter().map_while(|x| u32::try_from(*x).ok());\nlet vec = iter.collect::<Vec<_>>();\n\n// We have more elements which could fit in u32 (4, 5), but `map_while` returned `None` for `-3`\n// (as the `predicate` returned `None`) and `collect` stops at the first `None` encountered.\nassert_eq!(vec, vec![0, 1, 2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2,+-3,+4,+5,+-6%5D;%0A++++%0A++++let+iter+=+a.iter().map_while(%7Cx%7C+u32::try_from(*x).ok());%0A++++let+vec+=+iter.collect::%3CVec%3C_%3E%3E();%0A++++%0A++++//+We+have+more+elements+which+could+fit+in+u32+(4,+5),+but+%60map_while%60+returned+%60None%60+for+%60-3%60%0A++++//+(as+the+%60predicate%60+returned+%60None%60)+and+%60collect%60+stops+at+the+first+%60None%60+encountered.%0A++++assert_eq!(vec,+vec!%5B0,+1,+2%5D);%0A%7D&edition=2021)\n\nBecause `map_while()` needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:\n\n```\nlet a = [1, 2, -3, 4];\nlet mut iter = a.iter();\n\nlet result: Vec<u32> = iter.by_ref()\n                           .map_while(|n| u32::try_from(*n).ok())\n                           .collect();\n\nassert_eq!(result, &[1, 2]);\n\nlet result: Vec<i32> = iter.cloned().collect();\n\nassert_eq!(result, &[4]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+-3,+4%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++let+result:+Vec%3Cu32%3E+=+iter.by_ref()%0A+++++++++++++++++++++++++++++++.map_while(%7Cn%7C+u32::try_from(*n).ok())%0A+++++++++++++++++++++++++++++++.collect();%0A++++%0A++++assert_eq!(result,+%26%5B1,+2%5D);%0A++++%0A++++let+result:+Vec%3Ci32%3E+=+iter.cloned().collect();%0A++++%0A++++assert_eq!(result,+%26%5B4%5D);%0A%7D&edition=2021)\n\nThe `-3` is no longer there, because it was consumed in order to see if the iteration should stop, but wasn’t placed back into the iterator.\n\nNote that unlike [`take_while`](about:blank/trait.Iterator.html#method.take_while \"method std::iter::Iterator::take_while\") this iterator is **not** fused. It is also not specified what this iterator returns after the first [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned. If you need fused iterator, use [`fuse`](about:blank/trait.Iterator.html#method.fuse \"method std::iter::Iterator::fuse\").\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1317-1319)\n\nCreates an iterator that skips the first `n` elements.\n\n`skip(n)` skips elements until `n` elements are skipped or the end of the iterator is reached (whichever happens first). After that, all the remaining elements are yielded. In particular, if the original iterator is too short, then the returned iterator is empty.\n\nRather than overriding this method directly, instead override the `nth` method.\n\n##### [§](#examples-21)Examples\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter().skip(2);\n\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip(2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1371-1373)\n\nCreates an iterator that yields the first `n` elements, or fewer if the underlying iterator ends sooner.\n\n`take(n)` yields elements until `n` elements are yielded or the end of the iterator is reached (whichever happens first). The returned iterator is a prefix of length `n` if the original iterator contains at least `n` elements, otherwise it contains all of the (fewer than `n`) elements of the original iterator.\n\n##### [§](#examples-22)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter().take(2);\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take(2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n`take()` is often used with an infinite iterator, to make it finite:\n\n```\nlet mut iter = (0..).take(3);\n\nassert_eq!(iter.next(), Some(0));\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+(0..).take(3);%0A++++%0A++++assert_eq!(iter.next(),+Some(0));%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\nIf less than `n` elements are available, `take` will limit itself to the size of the underlying iterator:\n\n```\nlet v = [1, 2];\nlet mut iter = v.into_iter().take(5);\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5B1,+2%5D;%0A++++let+mut+iter+=+v.into_iter().take(5);%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1419-1422)\n\nAn iterator adapter which, like [`fold`](about:blank/trait.Iterator.html#method.fold \"method std::iter::Iterator::fold\"), holds internal state, but unlike [`fold`](about:blank/trait.Iterator.html#method.fold \"method std::iter::Iterator::fold\"), produces a new iterator.\n\n`scan()` takes two arguments: an initial value which seeds the internal state, and a closure with two arguments, the first being a mutable reference to the internal state and the second an iterator element. The closure can assign to the internal state to share state between iterations.\n\nOn iteration, the closure will be applied to each element of the iterator and the return value from the closure, an [`Option`](../option/enum.Option.html \"enum std::option::Option\"), is returned by the `next` method. Thus the closure can return `Some(value)` to yield `value`, or `None` to end the iteration.\n\n##### [§](#examples-23)Examples\n\n```\nlet a = [1, 2, 3, 4];\n\nlet mut iter = a.iter().scan(1, |state, &x| {\n    // each iteration, we'll multiply the state by the element ...\n    *state = *state * x;\n\n    // ... and terminate if the state exceeds 6\n    if *state > 6 {\n        return None;\n    }\n    // ... else yield the negation of the state\n    Some(-*state)\n});\n\nassert_eq!(iter.next(), Some(-1));\nassert_eq!(iter.next(), Some(-2));\nassert_eq!(iter.next(), Some(-6));\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++%0A++++let+mut+iter+=+a.iter().scan(1,+%7Cstate,+%26x%7C+%7B%0A++++++++//+each+iteration,+we%27ll+multiply+the+state+by+the+element+...%0A++++++++*state+=+*state+*+x;%0A++++%0A++++++++//+...+and+terminate+if+the+state+exceeds+6%0A++++++++if+*state+%3E+6+%7B%0A++++++++++++return+None;%0A++++++++%7D%0A++++++++//+...+else+yield+the+negation+of+the+state%0A++++++++Some(-*state)%0A++++%7D);%0A++++%0A++++assert_eq!(iter.next(),+Some(-1));%0A++++assert_eq!(iter.next(),+Some(-2));%0A++++assert_eq!(iter.next(),+Some(-6));%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1458-1462)\n\nCreates an iterator that works like map, but flattens nested structure.\n\nThe [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\") adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there’s an extra layer of indirection. `flat_map()` will remove this extra layer on its own.\n\nYou can think of `flat_map(f)` as the semantic equivalent of [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\")ping, and then [`flatten`](about:blank/trait.Iterator.html#method.flatten \"method std::iter::Iterator::flatten\")ing as in `map(f).flatten()`.\n\nAnother way of thinking about `flat_map()`: [`map`](about:blank/trait.Iterator.html#method.map \"method std::iter::Iterator::map\")’s closure returns one item for each element, and `flat_map()`’s closure returns an iterator for each element.\n\n##### [§](#examples-24)Examples\n\n```\nlet words = [\"alpha\", \"beta\", \"gamma\"];\n\n// chars() returns an iterator\nlet merged: String = words.iter()\n                          .flat_map(|s| s.chars())\n                          .collect();\nassert_eq!(merged, \"alphabetagamma\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+words+=+%5B%22alpha%22,+%22beta%22,+%22gamma%22%5D;%0A++++%0A++++//+chars()+returns+an+iterator%0A++++let+merged:+String+=+words.iter()%0A++++++++++++++++++++++++++++++.flat_map(%7Cs%7C+s.chars())%0A++++++++++++++++++++++++++++++.collect();%0A++++assert_eq!(merged,+%22alphabetagamma%22);%0A%7D&edition=2021)\n\n1.29.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1543-1546)\n\nCreates an iterator that flattens nested structure.\n\nThis is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.\n\n##### [§](#examples-25)Examples\n\nBasic usage:\n\n```\nlet data = vec![vec![1, 2, 3, 4], vec![5, 6]];\nlet flattened = data.into_iter().flatten().collect::<Vec<u8>>();\nassert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+data+=+vec!%5Bvec!%5B1,+2,+3,+4%5D,+vec!%5B5,+6%5D%5D;%0A++++let+flattened+=+data.into_iter().flatten().collect::%3CVec%3Cu8%3E%3E();%0A++++assert_eq!(flattened,+%26%5B1,+2,+3,+4,+5,+6%5D);%0A%7D&edition=2021)\n\nMapping and then flattening:\n\n```\nlet words = [\"alpha\", \"beta\", \"gamma\"];\n\n// chars() returns an iterator\nlet merged: String = words.iter()\n                          .map(|s| s.chars())\n                          .flatten()\n                          .collect();\nassert_eq!(merged, \"alphabetagamma\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+words+=+%5B%22alpha%22,+%22beta%22,+%22gamma%22%5D;%0A++++%0A++++//+chars()+returns+an+iterator%0A++++let+merged:+String+=+words.iter()%0A++++++++++++++++++++++++++++++.map(%7Cs%7C+s.chars())%0A++++++++++++++++++++++++++++++.flatten()%0A++++++++++++++++++++++++++++++.collect();%0A++++assert_eq!(merged,+%22alphabetagamma%22);%0A%7D&edition=2021)\n\nYou can also rewrite this in terms of [`flat_map()`](about:blank/trait.Iterator.html#method.flat_map \"method std::iter::Iterator::flat_map\"), which is preferable in this case since it conveys intent more clearly:\n\n```\nlet words = [\"alpha\", \"beta\", \"gamma\"];\n\n// chars() returns an iterator\nlet merged: String = words.iter()\n                          .flat_map(|s| s.chars())\n                          .collect();\nassert_eq!(merged, \"alphabetagamma\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+words+=+%5B%22alpha%22,+%22beta%22,+%22gamma%22%5D;%0A++++%0A++++//+chars()+returns+an+iterator%0A++++let+merged:+String+=+words.iter()%0A++++++++++++++++++++++++++++++.flat_map(%7Cs%7C+s.chars())%0A++++++++++++++++++++++++++++++.collect();%0A++++assert_eq!(merged,+%22alphabetagamma%22);%0A%7D&edition=2021)\n\nFlattening works on any `IntoIterator` type, including `Option` and `Result`:\n\n```\nlet options = vec![Some(123), Some(321), None, Some(231)];\nlet flattened_options: Vec<_> = options.into_iter().flatten().collect();\nassert_eq!(flattened_options, vec![123, 321, 231]);\n\nlet results = vec![Ok(123), Ok(321), Err(456), Ok(231)];\nlet flattened_results: Vec<_> = results.into_iter().flatten().collect();\nassert_eq!(flattened_results, vec![123, 321, 231]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+options+=+vec!%5BSome(123),+Some(321),+None,+Some(231)%5D;%0A++++let+flattened_options:+Vec%3C_%3E+=+options.into_iter().flatten().collect();%0A++++assert_eq!(flattened_options,+vec!%5B123,+321,+231%5D);%0A++++%0A++++let+results+=+vec!%5BOk(123),+Ok(321),+Err(456),+Ok(231)%5D;%0A++++let+flattened_results:+Vec%3C_%3E+=+results.into_iter().flatten().collect();%0A++++assert_eq!(flattened_results,+vec!%5B123,+321,+231%5D);%0A%7D&edition=2021)\n\nFlattening only removes one level of nesting at a time:\n\n```\nlet d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n\nlet d2 = d3.iter().flatten().collect::<Vec<_>>();\nassert_eq!(d2, [&[1, 2], &[3, 4], &[5, 6], &[7, 8]]);\n\nlet d1 = d3.iter().flatten().flatten().collect::<Vec<_>>();\nassert_eq!(d1, [&1, &2, &3, &4, &5, &6, &7, &8]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+d3+=+%5B%5B%5B1,+2%5D,+%5B3,+4%5D%5D,+%5B%5B5,+6%5D,+%5B7,+8%5D%5D%5D;%0A++++%0A++++let+d2+=+d3.iter().flatten().collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(d2,+%5B%26%5B1,+2%5D,+%26%5B3,+4%5D,+%26%5B5,+6%5D,+%26%5B7,+8%5D%5D);%0A++++%0A++++let+d1+=+d3.iter().flatten().flatten().collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(d1,+%5B%261,+%262,+%263,+%264,+%265,+%266,+%267,+%268%5D);%0A%7D&edition=2021)\n\nHere we see that `flatten()` does not perform a “deep” flatten. Instead, only one level of nesting is removed. That is, if you `flatten()` a three-dimensional array, the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to `flatten()` again.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1700-1703)\n\n🔬This is a nightly-only experimental API. (`iter_map_windows` [#87155](https://github.com/rust-lang/rust/issues/87155))\n\nCalls the given function `f` for each contiguous window of size `N` over `self` and returns an iterator over the outputs of `f`. Like [`slice::windows()`](about:blank/primitive.slice.html#method.windows \"method slice::windows\"), the windows during mapping overlap as well.\n\nIn the following example, the closure is called three times with the arguments `&['a', 'b']`, `&['b', 'c']` and `&['c', 'd']` respectively.\n\n```\n#![feature(iter_map_windows)]\n\nlet strings = \"abcd\".chars()\n    .map_windows(|[x, y]| format!(\"{}+{}\", x, y))\n    .collect::<Vec<String>>();\n\nassert_eq!(strings, vec![\"a+b\", \"b+c\", \"c+d\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+strings+=+%22abcd%22.chars()%0A++++++++.map_windows(%7C%5Bx,+y%5D%7C+format!(%22%7B%7D%2B%7B%7D%22,+x,+y))%0A++++++++.collect::%3CVec%3CString%3E%3E();%0A++++%0A++++assert_eq!(strings,+vec!%5B%22a%2Bb%22,+%22b%2Bc%22,+%22c%2Bd%22%5D);%0A%7D&version=nightly&edition=2021)\n\nNote that the const parameter `N` is usually inferred by the destructured argument in the closure.\n\nThe returned iterator yields 𝑘 − `N` + 1 items (where 𝑘 is the number of items yielded by `self`). If 𝑘 is less than `N`, this method yields an empty iterator.\n\nThe returned iterator implements [`FusedIterator`](trait.FusedIterator.html \"trait std::iter::FusedIterator\"), because once `self` returns `None`, even if it returns a `Some(T)` again in the next iterations, we cannot put it into a contiguous array buffer, and thus the returned iterator should be fused.\n\n##### [§](#panics-3)Panics\n\nPanics if `N` is 0. This check will most probably get changed to a compile time error before this method gets stabilized.\n\n[ⓘ](# \"This example panics\")\n\n```\n#![feature(iter_map_windows)]\n\nlet iter = std::iter::repeat(0).map_windows(|&[]| ());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+iter+=+std::iter::repeat(0).map_windows(%7C%26%5B%5D%7C+());%0A%7D&version=nightly&edition=2021)\n\n##### [§](#examples-26)Examples\n\nBuilding the sums of neighboring numbers.\n\n```\n#![feature(iter_map_windows)]\n\nlet mut it = [1, 3, 8, 1].iter().map_windows(|&[a, b]| a + b);\nassert_eq!(it.next(), Some(4));  // 1 + 3\nassert_eq!(it.next(), Some(11)); // 3 + 8\nassert_eq!(it.next(), Some(9));  // 8 + 1\nassert_eq!(it.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+mut+it+=+%5B1,+3,+8,+1%5D.iter().map_windows(%7C%26%5Ba,+b%5D%7C+a+%2B+b);%0A++++assert_eq!(it.next(),+Some(4));++//+1+%2B+3%0A++++assert_eq!(it.next(),+Some(11));+//+3+%2B+8%0A++++assert_eq!(it.next(),+Some(9));++//+8+%2B+1%0A++++assert_eq!(it.next(),+None);%0A%7D&version=nightly&edition=2021)\n\nSince the elements in the following example implement `Copy`, we can just copy the array and get an iterator over the windows.\n\n```\n#![feature(iter_map_windows)]\n\nlet mut it = \"ferris\".chars().map_windows(|w: &[_; 3]| *w);\nassert_eq!(it.next(), Some(['f', 'e', 'r']));\nassert_eq!(it.next(), Some(['e', 'r', 'r']));\nassert_eq!(it.next(), Some(['r', 'r', 'i']));\nassert_eq!(it.next(), Some(['r', 'i', 's']));\nassert_eq!(it.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+mut+it+=+%22ferris%22.chars().map_windows(%7Cw:+%26%5B_;+3%5D%7C+*w);%0A++++assert_eq!(it.next(),+Some(%5B%27f%27,+%27e%27,+%27r%27%5D));%0A++++assert_eq!(it.next(),+Some(%5B%27e%27,+%27r%27,+%27r%27%5D));%0A++++assert_eq!(it.next(),+Some(%5B%27r%27,+%27r%27,+%27i%27%5D));%0A++++assert_eq!(it.next(),+Some(%5B%27r%27,+%27i%27,+%27s%27%5D));%0A++++assert_eq!(it.next(),+None);%0A%7D&version=nightly&edition=2021)\n\nYou can also use this function to check the sortedness of an iterator. For the simple case, rather use [`Iterator::is_sorted`](about:blank/trait.Iterator.html#method.is_sorted \"method std::iter::Iterator::is_sorted\").\n\n```\n#![feature(iter_map_windows)]\n\nlet mut it = [0.5, 1.0, 3.5, 3.0, 8.5, 8.5, f32::NAN].iter()\n    .map_windows(|[a, b]| a <= b);\n\nassert_eq!(it.next(), Some(true));  // 0.5 <= 1.0\nassert_eq!(it.next(), Some(true));  // 1.0 <= 3.5\nassert_eq!(it.next(), Some(false)); // 3.5 <= 3.0\nassert_eq!(it.next(), Some(true));  // 3.0 <= 8.5\nassert_eq!(it.next(), Some(true));  // 8.5 <= 8.5\nassert_eq!(it.next(), Some(false)); // 8.5 <= NAN\nassert_eq!(it.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+mut+it+=+%5B0.5,+1.0,+3.5,+3.0,+8.5,+8.5,+f32::NAN%5D.iter()%0A++++++++.map_windows(%7C%5Ba,+b%5D%7C+a+%3C=+b);%0A++++%0A++++assert_eq!(it.next(),+Some(true));++//+0.5+%3C=+1.0%0A++++assert_eq!(it.next(),+Some(true));++//+1.0+%3C=+3.5%0A++++assert_eq!(it.next(),+Some(false));+//+3.5+%3C=+3.0%0A++++assert_eq!(it.next(),+Some(true));++//+3.0+%3C=+8.5%0A++++assert_eq!(it.next(),+Some(true));++//+8.5+%3C=+8.5%0A++++assert_eq!(it.next(),+Some(false));+//+8.5+%3C=+NAN%0A++++assert_eq!(it.next(),+None);%0A%7D&version=nightly&edition=2021)\n\nFor non-fused iterators, they are fused after `map_windows`.\n\n```\n#![feature(iter_map_windows)]\n\n#[derive(Default)]\nstruct NonFusedIterator {\n    state: i32,\n}\n\nimpl Iterator for NonFusedIterator {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<i32> {\n        let val = self.state;\n        self.state = self.state + 1;\n\n        // yields `0..5` first, then only even numbers since `6..`.\n        if val < 5 || val % 2 == 0 {\n            Some(val)\n        } else {\n            None\n        }\n    }\n}\n\n\nlet mut iter = NonFusedIterator::default();\n\n// yields 0..5 first.\nassert_eq!(iter.next(), Some(0));\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), Some(3));\nassert_eq!(iter.next(), Some(4));\n// then we can see our iterator going back and forth\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), Some(6));\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), Some(8));\nassert_eq!(iter.next(), None);\n\n// however, with `.map_windows()`, it is fused.\nlet mut iter = NonFusedIterator::default()\n    .map_windows(|arr: &[_; 2]| *arr);\n\nassert_eq!(iter.next(), Some([0, 1]));\nassert_eq!(iter.next(), Some([1, 2]));\nassert_eq!(iter.next(), Some([2, 3]));\nassert_eq!(iter.next(), Some([3, 4]));\nassert_eq!(iter.next(), None);\n\n// it will always return `None` after the first time.\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++%23%5Bderive(Default)%5D%0A++++struct+NonFusedIterator+%7B%0A++++++++state:+i32,%0A++++%7D%0A++++%0A++++impl+Iterator+for+NonFusedIterator+%7B%0A++++++++type+Item+=+i32;%0A++++%0A++++++++fn+next(%26mut+self)+-%3E+Option%3Ci32%3E+%7B%0A++++++++++++let+val+=+self.state;%0A++++++++++++self.state+=+self.state+%2B+1;%0A++++%0A++++++++++++//+yields+%600..5%60+first,+then+only+even+numbers+since+%606..%60.%0A++++++++++++if+val+%3C+5+%7C%7C+val+%25+2+==+0+%7B%0A++++++++++++++++Some(val)%0A++++++++++++%7D+else+%7B%0A++++++++++++++++None%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++%0A++++let+mut+iter+=+NonFusedIterator::default();%0A++++%0A++++//+yields+0..5+first.%0A++++assert_eq!(iter.next(),+Some(0));%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+Some(3));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++//+then+we+can+see+our+iterator+going+back+and+forth%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+Some(6));%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+Some(8));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+however,+with+%60.map_windows()%60,+it+is+fused.%0A++++let+mut+iter+=+NonFusedIterator::default()%0A++++++++.map_windows(%7Carr:+%26%5B_;+2%5D%7C+*arr);%0A++++%0A++++assert_eq!(iter.next(),+Some(%5B0,+1%5D));%0A++++assert_eq!(iter.next(),+Some(%5B1,+2%5D));%0A++++assert_eq!(iter.next(),+Some(%5B2,+3%5D));%0A++++assert_eq!(iter.next(),+Some(%5B3,+4%5D));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+it+will+always+return+%60None%60+after+the+first+time.%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1767-1769)\n\nCreates an iterator which ends after the first [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\nAfter an iterator returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"), future calls may or may not yield [`Some(T)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again. `fuse()` adapts an iterator, ensuring that after a [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is given, it will always return [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") forever.\n\nNote that the [`Fuse`](struct.Fuse.html \"struct std::iter::Fuse\") wrapper is a no-op on iterators that implement the [`FusedIterator`](trait.FusedIterator.html \"trait std::iter::FusedIterator\") trait. `fuse()` may therefore behave incorrectly if the [`FusedIterator`](trait.FusedIterator.html \"trait std::iter::FusedIterator\") trait is improperly implemented.\n\n##### [§](#examples-27)Examples\n\n```\n// an iterator which alternates between Some and None\nstruct Alternate {\n    state: i32,\n}\n\nimpl Iterator for Alternate {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<i32> {\n        let val = self.state;\n        self.state = self.state + 1;\n\n        // if it's even, Some(i32), else None\n        if val % 2 == 0 {\n            Some(val)\n        } else {\n            None\n        }\n    }\n}\n\nlet mut iter = Alternate { state: 0 };\n\n// we can see our iterator going back and forth\nassert_eq!(iter.next(), Some(0));\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), None);\n\n// however, once we fuse it...\nlet mut iter = iter.fuse();\n\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), None);\n\n// it will always return `None` after the first time.\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+an+iterator+which+alternates+between+Some+and+None%0Afn+main()+%7B%0A++++struct+Alternate+%7B%0A++++++++state:+i32,%0A++++%7D%0A++++%0A++++impl+Iterator+for+Alternate+%7B%0A++++++++type+Item+=+i32;%0A++++%0A++++++++fn+next(%26mut+self)+-%3E+Option%3Ci32%3E+%7B%0A++++++++++++let+val+=+self.state;%0A++++++++++++self.state+=+self.state+%2B+1;%0A++++%0A++++++++++++//+if+it%27s+even,+Some(i32),+else+None%0A++++++++++++if+val+%25+2+==+0+%7B%0A++++++++++++++++Some(val)%0A++++++++++++%7D+else+%7B%0A++++++++++++++++None%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+mut+iter+=+Alternate+%7B+state:+0+%7D;%0A++++%0A++++//+we+can+see+our+iterator+going+back+and+forth%0A++++assert_eq!(iter.next(),+Some(0));%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+however,+once+we+fuse+it...%0A++++let+mut+iter+=+iter.fuse();%0A++++%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+it+will+always+return+%60None%60+after+the+first+time.%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1852-1855)\n\nDoes something with each element of an iterator, passing the value on.\n\nWhen using iterators, you’ll often chain several of them together. While working on such code, you might want to check out what’s happening at various parts in the pipeline. To do that, insert a call to `inspect()`.\n\nIt’s more common for `inspect()` to be used as a debugging tool than to exist in your final code, but applications may find it useful in certain situations when errors need to be logged before being discarded.\n\n##### [§](#examples-28)Examples\n\nBasic usage:\n\n```\nlet a = [1, 4, 2, 3];\n\n// this iterator sequence is complex.\nlet sum = a.iter()\n    .cloned()\n    .filter(|x| x % 2 == 0)\n    .fold(0, |sum, i| sum + i);\n\nprintln!(\"{sum}\");\n\n// let's add some inspect() calls to investigate what's happening\nlet sum = a.iter()\n    .cloned()\n    .inspect(|x| println!(\"about to filter: {x}\"))\n    .filter(|x| x % 2 == 0)\n    .inspect(|x| println!(\"made it through filter: {x}\"))\n    .fold(0, |sum, i| sum + i);\n\nprintln!(\"{sum}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+4,+2,+3%5D;%0A++++%0A++++//+this+iterator+sequence+is+complex.%0A++++let+sum+=+a.iter()%0A++++++++.cloned()%0A++++++++.filter(%7Cx%7C+x+%25+2+==+0)%0A++++++++.fold(0,+%7Csum,+i%7C+sum+%2B+i);%0A++++%0A++++println!(%22%7Bsum%7D%22);%0A++++%0A++++//+let%27s+add+some+inspect()+calls+to+investigate+what%27s+happening%0A++++let+sum+=+a.iter()%0A++++++++.cloned()%0A++++++++.inspect(%7Cx%7C+println!(%22about+to+filter:+%7Bx%7D%22))%0A++++++++.filter(%7Cx%7C+x+%25+2+==+0)%0A++++++++.inspect(%7Cx%7C+println!(%22made+it+through+filter:+%7Bx%7D%22))%0A++++++++.fold(0,+%7Csum,+i%7C+sum+%2B+i);%0A++++%0A++++println!(%22%7Bsum%7D%22);%0A%7D&edition=2021)\n\nThis will print:\n\n```text\n6\nabout to filter: 1\nabout to filter: 4\nmade it through filter: 4\nabout to filter: 2\nmade it through filter: 2\nabout to filter: 3\n6\n\n```\n\nLogging errors before discarding them:\n\n```\nlet lines = [\"1\", \"2\", \"a\"];\n\nlet sum: i32 = lines\n    .iter()\n    .map(|line| line.parse::<i32>())\n    .inspect(|num| {\n        if let Err(ref e) = *num {\n            println!(\"Parsing error: {e}\");\n        }\n    })\n    .filter_map(Result::ok)\n    .sum();\n\nprintln!(\"Sum: {sum}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+lines+=+%5B%221%22,+%222%22,+%22a%22%5D;%0A++++%0A++++let+sum:+i32+=+lines%0A++++++++.iter()%0A++++++++.map(%7Cline%7C+line.parse::%3Ci32%3E())%0A++++++++.inspect(%7Cnum%7C+%7B%0A++++++++++++if+let+Err(ref+e)+=+*num+%7B%0A++++++++++++++++println!(%22Parsing+error:+%7Be%7D%22);%0A++++++++++++%7D%0A++++++++%7D)%0A++++++++.filter_map(Result::ok)%0A++++++++.sum();%0A++++%0A++++println!(%22Sum:+%7Bsum%7D%22);%0A%7D&edition=2021)\n\nThis will print:\n\n```text\nParsing error: invalid digit found in string\nSum: 3\n\n``` \n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1881-1883)\n\nBorrows an iterator, rather than consuming it.\n\nThis is useful to allow applying iterator adapters while still retaining ownership of the original iterator.\n\n##### [§](#examples-29)Examples\n\n```\nlet mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();\n\n// Take the first two words.\nlet hello_world: Vec<_> = words.by_ref().take(2).collect();\nassert_eq!(hello_world, vec![\"hello\", \"world\"]);\n\n// Collect the rest of the words.\n// We can only do this because we used `by_ref` earlier.\nlet of_rust: Vec<_> = words.collect();\nassert_eq!(of_rust, vec![\"of\", \"Rust\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+words+=+%5B%22hello%22,+%22world%22,+%22of%22,+%22Rust%22%5D.into_iter();%0A++++%0A++++//+Take+the+first+two+words.%0A++++let+hello_world:+Vec%3C_%3E+=+words.by_ref().take(2).collect();%0A++++assert_eq!(hello_world,+vec!%5B%22hello%22,+%22world%22%5D);%0A++++%0A++++//+Collect+the+rest+of+the+words.%0A++++//+We+can+only+do+this+because+we+used+%60by_ref%60+earlier.%0A++++let+of_rust:+Vec%3C_%3E+=+words.collect();%0A++++assert_eq!(of_rust,+vec!%5B%22of%22,+%22Rust%22%5D);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2001-2003)\n\nTransforms an iterator into a collection.\n\n`collect()` can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the standard library, used in a variety of contexts.\n\nThe most basic pattern in which `collect()` is used is to turn one collection into another. You take a collection, call [`iter`](about:blank/trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") on it, do a bunch of transformations, and then `collect()` at the end.\n\n`collect()` can also create instances of types that are not typical collections. For example, a [`String`](../../std/string/struct.String.html) can be built from [`char`](../primitive.char.html \"primitive char\")s, and an iterator of [`Result<T, E>`](../result/enum.Result.html \"enum std::result::Result\") items can be collected into `Result<Collection<T>, E>`. See the examples below for more.\n\nBecause `collect()` is so general, it can cause problems with type inference. As such, `collect()` is one of the few times you’ll see the syntax affectionately known as the ‘turbofish’: `::<>`. This helps the inference algorithm understand specifically which collection you’re trying to collect into.\n\n##### [§](#examples-30)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nlet doubled: Vec<i32> = a.iter()\n                         .map(|&x| x * 2)\n                         .collect();\n\nassert_eq!(vec![2, 4, 6], doubled);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled:+Vec%3Ci32%3E+=+a.iter()%0A+++++++++++++++++++++++++++++.map(%7C%26x%7C+x+*+2)%0A+++++++++++++++++++++++++++++.collect();%0A++++%0A++++assert_eq!(vec!%5B2,+4,+6%5D,+doubled);%0A%7D&edition=2021)\n\nNote that we needed the `: Vec<i32>` on the left-hand side. This is because we could collect into, for example, a [`VecDeque<T>`](../../std/collections/struct.VecDeque.html) instead:\n\n```\nuse std::collections::VecDeque;\n\nlet a = [1, 2, 3];\n\nlet doubled: VecDeque<i32> = a.iter().map(|&x| x * 2).collect();\n\nassert_eq!(2, doubled[0]);\nassert_eq!(4, doubled[1]);\nassert_eq!(6, doubled[2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::VecDeque;%0A++++%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled:+VecDeque%3Ci32%3E+=+a.iter().map(%7C%26x%7C+x+*+2).collect();%0A++++%0A++++assert_eq!(2,+doubled%5B0%5D);%0A++++assert_eq!(4,+doubled%5B1%5D);%0A++++assert_eq!(6,+doubled%5B2%5D);%0A%7D&edition=2021)\n\nUsing the ‘turbofish’ instead of annotating `doubled`:\n\n```\nlet a = [1, 2, 3];\n\nlet doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\nassert_eq!(vec![2, 4, 6], doubled);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled+=+a.iter().map(%7Cx%7C+x+*+2).collect::%3CVec%3Ci32%3E%3E();%0A++++%0A++++assert_eq!(vec!%5B2,+4,+6%5D,+doubled);%0A%7D&edition=2021)\n\nBecause `collect()` only cares about what you’re collecting into, you can still use a partial type hint, `_`, with the turbofish:\n\n```\nlet a = [1, 2, 3];\n\nlet doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\nassert_eq!(vec![2, 4, 6], doubled);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled+=+a.iter().map(%7Cx%7C+x+*+2).collect::%3CVec%3C_%3E%3E();%0A++++%0A++++assert_eq!(vec!%5B2,+4,+6%5D,+doubled);%0A%7D&edition=2021)\n\nUsing `collect()` to make a [`String`](../../std/string/struct.String.html):\n\n```\nlet chars = ['g', 'd', 'k', 'k', 'n'];\n\nlet hello: String = chars.iter()\n    .map(|&x| x as u8)\n    .map(|x| (x + 1) as char)\n    .collect();\n\nassert_eq!(\"hello\", hello);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+chars+=+%5B%27g%27,+%27d%27,+%27k%27,+%27k%27,+%27n%27%5D;%0A++++%0A++++let+hello:+String+=+chars.iter()%0A++++++++.map(%7C%26x%7C+x+as+u8)%0A++++++++.map(%7Cx%7C+(x+%2B+1)+as+char)%0A++++++++.collect();%0A++++%0A++++assert_eq!(%22hello%22,+hello);%0A%7D&edition=2021)\n\nIf you have a list of [`Result<T, E>`](../result/enum.Result.html \"enum std::result::Result\")s, you can use `collect()` to see if any of them failed:\n\n```\nlet results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\nlet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n\n// gives us the first error\nassert_eq!(Err(\"nope\"), result);\n\nlet results = [Ok(1), Ok(3)];\n\nlet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n\n// gives us the list of answers\nassert_eq!(Ok(vec![1, 3]), result);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+results+=+%5BOk(1),+Err(%22nope%22),+Ok(3),+Err(%22bad%22)%5D;%0A++++%0A++++let+result:+Result%3CVec%3C_%3E,+%26str%3E+=+results.iter().cloned().collect();%0A++++%0A++++//+gives+us+the+first+error%0A++++assert_eq!(Err(%22nope%22),+result);%0A++++%0A++++let+results+=+%5BOk(1),+Ok(3)%5D;%0A++++%0A++++let+result:+Result%3CVec%3C_%3E,+%26str%3E+=+results.iter().cloned().collect();%0A++++%0A++++//+gives+us+the+list+of+answers%0A++++assert_eq!(Ok(vec!%5B1,+3%5D),+result);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2080-2085)\n\n🔬This is a nightly-only experimental API. (`iterator_try_collect` [#94047](https://github.com/rust-lang/rust/issues/94047))\n\nFallibly transforms an iterator into a collection, short circuiting if a failure is encountered.\n\n`try_collect()` is a variation of [`collect()`](about:blank/trait.Iterator.html#method.collect \"method std::iter::Iterator::collect\") that allows fallible conversions during collection. Its main use case is simplifying conversions from iterators yielding [`Option<T>`](../option/enum.Option.html \"enum std::option::Option\") into `Option<Collection<T>>`, or similarly for other [`Try`](../ops/trait.Try.html \"trait std::ops::Try\") types (e.g. [`Result`](../result/enum.Result.html \"enum std::result::Result\")).\n\nImportantly, `try_collect()` doesn’t require that the outer [`Try`](../ops/trait.Try.html \"trait std::ops::Try\") type also implements [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"); only the inner type produced on `Try::Output` must implement it. Concretely, this means that collecting into `ControlFlow<_, Vec<i32>>` is valid because `Vec<i32>` implements [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"), even though [`ControlFlow`](../ops/enum.ControlFlow.html \"enum std::ops::ControlFlow\") doesn’t.\n\nAlso, if a failure is encountered during `try_collect()`, the iterator is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure. See the last example below for an example of how this works.\n\n##### [§](#examples-31)Examples\n\nSuccessfully collecting an iterator of `Option<i32>` into `Option<Vec<i32>>`:\n\n```\n#![feature(iterator_try_collect)]\n\nlet u = vec![Some(1), Some(2), Some(3)];\nlet v = u.into_iter().try_collect::<Vec<i32>>();\nassert_eq!(v, Some(vec![1, 2, 3]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++let+u+=+vec!%5BSome(1),+Some(2),+Some(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+Some(vec!%5B1,+2,+3%5D));%0A%7D&version=nightly&edition=2021)\n\nFailing to collect in the same way:\n\n```\n#![feature(iterator_try_collect)]\n\nlet u = vec![Some(1), Some(2), None, Some(3)];\nlet v = u.into_iter().try_collect::<Vec<i32>>();\nassert_eq!(v, None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++let+u+=+vec!%5BSome(1),+Some(2),+None,+Some(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+None);%0A%7D&version=nightly&edition=2021)\n\nA similar example, but with `Result`:\n\n```\n#![feature(iterator_try_collect)]\n\nlet u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\nlet v = u.into_iter().try_collect::<Vec<i32>>();\nassert_eq!(v, Ok(vec![1, 2, 3]));\n\nlet u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\nlet v = u.into_iter().try_collect::<Vec<i32>>();\nassert_eq!(v, Err(()));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++let+u:+Vec%3CResult%3Ci32,+()%3E%3E+=+vec!%5BOk(1),+Ok(2),+Ok(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+Ok(vec!%5B1,+2,+3%5D));%0A++++%0A++++let+u+=+vec!%5BOk(1),+Ok(2),+Err(()),+Ok(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+Err(()));%0A%7D&version=nightly&edition=2021)\n\nFinally, even [`ControlFlow`](../ops/enum.ControlFlow.html \"enum std::ops::ControlFlow\") works, despite the fact that it doesn’t implement [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"). Note also that the iterator can continue to be used, even if a failure is encountered:\n\n```\n#![feature(iterator_try_collect)]\n\nuse core::ops::ControlFlow::{Break, Continue};\n\nlet u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\nlet mut it = u.into_iter();\n\nlet v = it.try_collect::<Vec<_>>();\nassert_eq!(v, Break(3));\n\nlet v = it.try_collect::<Vec<_>>();\nassert_eq!(v, Continue(vec![4, 5]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++use+core::ops::ControlFlow::%7BBreak,+Continue%7D;%0A++++%0A++++let+u+=+%5BContinue(1),+Continue(2),+Break(3),+Continue(4),+Continue(5)%5D;%0A++++let+mut+it+=+u.into_iter();%0A++++%0A++++let+v+=+it.try_collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(v,+Break(3));%0A++++%0A++++let+v+=+it.try_collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(v,+Continue(vec!%5B4,+5%5D));%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2154-2156)\n\n🔬This is a nightly-only experimental API. (`iter_collect_into` [#94780](https://github.com/rust-lang/rust/issues/94780))\n\nCollects all the items from an iterator into a collection.\n\nThis method consumes the iterator and adds all its items to the passed collection. The collection is then returned, so the call chain can be continued.\n\nThis is useful when you already have a collection and want to add the iterator items to it.\n\nThis method is a convenience method to call [Extend::extend](trait.Extend.html), but instead of being called on a collection, it’s called on an iterator.\n\n##### [§](#examples-32)Examples\n\nBasic usage:\n\n```\n#![feature(iter_collect_into)]\n\nlet a = [1, 2, 3];\nlet mut vec: Vec::<i32> = vec![0, 1];\n\na.iter().map(|&x| x * 2).collect_into(&mut vec);\na.iter().map(|&x| x * 10).collect_into(&mut vec);\n\nassert_eq!(vec, vec![0, 1, 2, 4, 6, 10, 20, 30]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_collect_into)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+vec:+Vec::%3Ci32%3E+=+vec!%5B0,+1%5D;%0A++++%0A++++a.iter().map(%7C%26x%7C+x+*+2).collect_into(%26mut+vec);%0A++++a.iter().map(%7C%26x%7C+x+*+10).collect_into(%26mut+vec);%0A++++%0A++++assert_eq!(vec,+vec!%5B0,+1,+2,+4,+6,+10,+20,+30%5D);%0A%7D&version=nightly&edition=2021)\n\n`Vec` can have a manual set capacity to avoid reallocating it:\n\n```\n#![feature(iter_collect_into)]\n\nlet a = [1, 2, 3];\nlet mut vec: Vec::<i32> = Vec::with_capacity(6);\n\na.iter().map(|&x| x * 2).collect_into(&mut vec);\na.iter().map(|&x| x * 10).collect_into(&mut vec);\n\nassert_eq!(6, vec.capacity());\nassert_eq!(vec, vec![2, 4, 6, 10, 20, 30]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_collect_into)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+vec:+Vec::%3Ci32%3E+=+Vec::with_capacity(6);%0A++++%0A++++a.iter().map(%7C%26x%7C+x+*+2).collect_into(%26mut+vec);%0A++++a.iter().map(%7C%26x%7C+x+*+10).collect_into(%26mut+vec);%0A++++%0A++++assert_eq!(6,+vec.capacity());%0A++++assert_eq!(vec,+vec!%5B2,+4,+6,+10,+20,+30%5D);%0A%7D&version=nightly&edition=2021)\n\nThe returned mutable reference can be used to continue the call chain:\n\n```\n#![feature(iter_collect_into)]\n\nlet a = [1, 2, 3];\nlet mut vec: Vec::<i32> = Vec::with_capacity(6);\n\nlet count = a.iter().collect_into(&mut vec).iter().count();\n\nassert_eq!(count, vec.len());\nassert_eq!(vec, vec![1, 2, 3]);\n\nlet count = a.iter().collect_into(&mut vec).iter().count();\n\nassert_eq!(count, vec.len());\nassert_eq!(vec, vec![1, 2, 3, 1, 2, 3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_collect_into)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+vec:+Vec::%3Ci32%3E+=+Vec::with_capacity(6);%0A++++%0A++++let+count+=+a.iter().collect_into(%26mut+vec).iter().count();%0A++++%0A++++assert_eq!(count,+vec.len());%0A++++assert_eq!(vec,+vec!%5B1,+2,+3%5D);%0A++++%0A++++let+count+=+a.iter().collect_into(%26mut+vec).iter().count();%0A++++%0A++++assert_eq!(count,+vec.len());%0A++++assert_eq!(vec,+vec!%5B1,+2,+3,+1,+2,+3%5D);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2187-2191)\n\nConsumes an iterator, creating two collections from it.\n\nThe predicate passed to `partition()` can return `true`, or `false`. `partition()` returns a pair, all of the elements for which it returned `true`, and all of the elements for which it returned `false`.\n\nSee also [`is_partitioned()`](about:blank/trait.Iterator.html#method.is_partitioned \"method std::iter::Iterator::is_partitioned\") and [`partition_in_place()`](about:blank/trait.Iterator.html#method.partition_in_place \"method std::iter::Iterator::partition_in_place\").\n\n##### [§](#examples-33)Examples\n\n```\nlet a = [1, 2, 3];\n\nlet (even, odd): (Vec<_>, Vec<_>) = a\n    .into_iter()\n    .partition(|n| n % 2 == 0);\n\nassert_eq!(even, vec![2]);\nassert_eq!(odd, vec![1, 3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+(even,+odd):+(Vec%3C_%3E,+Vec%3C_%3E)+=+a%0A++++++++.into_iter()%0A++++++++.partition(%7Cn%7C+n+%25+2+==+0);%0A++++%0A++++assert_eq!(even,+vec!%5B2%5D);%0A++++assert_eq!(odd,+vec!%5B1,+3%5D);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2250-2253)\n\n🔬This is a nightly-only experimental API. (`iter_partition_in_place` [#62543](https://github.com/rust-lang/rust/issues/62543))\n\nReorders the elements of this iterator _in-place_ according to the given predicate, such that all those that return `true` precede all those that return `false`. Returns the number of `true` elements found.\n\nThe relative order of partitioned items is not maintained.\n\n##### [§](#current-implementation)Current implementation\n\nThe current algorithm tries to find the first element for which the predicate evaluates to false and the last element for which it evaluates to true, and repeatedly swaps them.\n\nTime complexity: _O_(_n_)\n\nSee also [`is_partitioned()`](about:blank/trait.Iterator.html#method.is_partitioned \"method std::iter::Iterator::is_partitioned\") and [`partition()`](about:blank/trait.Iterator.html#method.partition \"method std::iter::Iterator::partition\").\n\n##### [§](#examples-34)Examples\n\n```\n#![feature(iter_partition_in_place)]\n\nlet mut a = [1, 2, 3, 4, 5, 6, 7];\n\n// Partition in-place between evens and odds\nlet i = a.iter_mut().partition_in_place(|&n| n % 2 == 0);\n\nassert_eq!(i, 3);\nassert!(a[..i].iter().all(|&n| n % 2 == 0)); // evens\nassert!(a[i..].iter().all(|&n| n % 2 == 1)); // odds\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_partition_in_place)%5D%0A%0Afn+main()+%7B%0A++++let+mut+a+=+%5B1,+2,+3,+4,+5,+6,+7%5D;%0A++++%0A++++//+Partition+in-place+between+evens+and+odds%0A++++let+i+=+a.iter_mut().partition_in_place(%7C%26n%7C+n+%25+2+==+0);%0A++++%0A++++assert_eq!(i,+3);%0A++++assert!(a%5B..i%5D.iter().all(%7C%26n%7C+n+%25+2+==+0));+//+evens%0A++++assert!(a%5Bi..%5D.iter().all(%7C%26n%7C+n+%25+2+==+1));+//+odds%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2308-2311)\n\n🔬This is a nightly-only experimental API. (`iter_is_partitioned` [#62544](https://github.com/rust-lang/rust/issues/62544))\n\nChecks if the elements of this iterator are partitioned according to the given predicate, such that all those that return `true` precede all those that return `false`.\n\nSee also [`partition()`](about:blank/trait.Iterator.html#method.partition \"method std::iter::Iterator::partition\") and [`partition_in_place()`](about:blank/trait.Iterator.html#method.partition_in_place \"method std::iter::Iterator::partition_in_place\").\n\n##### [§](#examples-35)Examples\n\n```\n#![feature(iter_is_partitioned)]\n\nassert!(\"Iterator\".chars().is_partitioned(char::is_uppercase));\nassert!(!\"IntoIterator\".chars().is_partitioned(char::is_uppercase));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_is_partitioned)%5D%0A%0Afn+main()+%7B%0A++++assert!(%22Iterator%22.chars().is_partitioned(char::is_uppercase));%0A++++assert!(!%22IntoIterator%22.chars().is_partitioned(char::is_uppercase));%0A%7D&version=nightly&edition=2021)\n\n1.27.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2403-2407)\n\nAn iterator method that applies a function as long as it returns successfully, producing a single, final value.\n\n`try_fold()` takes two arguments: an initial value, and a closure with two arguments: an ‘accumulator’, and an element. The closure either returns successfully, with the value that the accumulator should have for the next iteration, or it returns failure, with an error value that is propagated back to the caller immediately (short-circuiting).\n\nThe initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, `try_fold()` returns the final accumulator as success.\n\nFolding is useful whenever you have a collection of something, and want to produce a single value from it.\n\n##### [§](#note-to-implementors)Note to Implementors\n\nSeveral of the other (forward) methods have default implementations in terms of this one, so try to implement this explicitly if it can do something better than the default `for` loop implementation.\n\nIn particular, try to have this call `try_fold()` on the internal parts from which this iterator is composed. If multiple calls are needed, the `?` operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a `&mut self` method, so iteration needs to be resumable after hitting an error here.\n\n##### [§](#examples-36)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\n// the checked sum of all of the elements of the array\nlet sum = a.iter().try_fold(0i8, |acc, &x| acc.checked_add(x));\n\nassert_eq!(sum, Some(6));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++//+the+checked+sum+of+all+of+the+elements+of+the+array%0A++++let+sum+=+a.iter().try_fold(0i8,+%7Cacc,+%26x%7C+acc.checked_add(x));%0A++++%0A++++assert_eq!(sum,+Some(6));%0A%7D&edition=2021)\n\nShort-circuiting:\n\n```\nlet a = [10, 20, 30, 100, 40, 50];\nlet mut it = a.iter();\n\n// This sum overflows when adding the 100 element\nlet sum = it.try_fold(0i8, |acc, &x| acc.checked_add(x));\nassert_eq!(sum, None);\n\n// Because it short-circuited, the remaining elements are still\n// available through the iterator.\nassert_eq!(it.len(), 2);\nassert_eq!(it.next(), Some(&40));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B10,+20,+30,+100,+40,+50%5D;%0A++++let+mut+it+=+a.iter();%0A++++%0A++++//+This+sum+overflows+when+adding+the+100+element%0A++++let+sum+=+it.try_fold(0i8,+%7Cacc,+%26x%7C+acc.checked_add(x));%0A++++assert_eq!(sum,+None);%0A++++%0A++++//+Because+it+short-circuited,+the+remaining+elements+are+still%0A++++//+available+through+the+iterator.%0A++++assert_eq!(it.len(),+2);%0A++++assert_eq!(it.next(),+Some(%2640));%0A%7D&edition=2021)\n\nWhile you cannot `break` from a closure, the [`ControlFlow`](../ops/enum.ControlFlow.html \"enum std::ops::ControlFlow\") type allows a similar idea:\n\n```\nuse std::ops::ControlFlow;\n\nlet triangular = (1..30).try_fold(0_i8, |prev, x| {\n    if let Some(next) = prev.checked_add(x) {\n        ControlFlow::Continue(next)\n    } else {\n        ControlFlow::Break(prev)\n    }\n});\nassert_eq!(triangular, ControlFlow::Break(120));\n\nlet triangular = (1..30).try_fold(0_u64, |prev, x| {\n    if let Some(next) = prev.checked_add(x) {\n        ControlFlow::Continue(next)\n    } else {\n        ControlFlow::Break(prev)\n    }\n});\nassert_eq!(triangular, ControlFlow::Continue(435));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ops::ControlFlow;%0A++++%0A++++let+triangular+=+(1..30).try_fold(0_i8,+%7Cprev,+x%7C+%7B%0A++++++++if+let+Some(next)+=+prev.checked_add(x)+%7B%0A++++++++++++ControlFlow::Continue(next)%0A++++++++%7D+else+%7B%0A++++++++++++ControlFlow::Break(prev)%0A++++++++%7D%0A++++%7D);%0A++++assert_eq!(triangular,+ControlFlow::Break(120));%0A++++%0A++++let+triangular+=+(1..30).try_fold(0_u64,+%7Cprev,+x%7C+%7B%0A++++++++if+let+Some(next)+=+prev.checked_add(x)+%7B%0A++++++++++++ControlFlow::Continue(next)%0A++++++++%7D+else+%7B%0A++++++++++++ControlFlow::Break(prev)%0A++++++++%7D%0A++++%7D);%0A++++assert_eq!(triangular,+ControlFlow::Continue(435));%0A%7D&edition=2021)\n\n1.27.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2462-2466)\n\nAn iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.\n\nThis can also be thought of as the fallible form of [`for_each()`](about:blank/trait.Iterator.html#method.for_each \"method std::iter::Iterator::for_each\") or as the stateless version of [`try_fold()`](about:blank/trait.Iterator.html#method.try_fold \"method std::iter::Iterator::try_fold\").\n\n##### [§](#examples-37)Examples\n\n```\nuse std::fs::rename;\nuse std::io::{stdout, Write};\nuse std::path::Path;\n\nlet data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n\nlet res = data.iter().try_for_each(|x| writeln!(stdout(), \"{x}\"));\nassert!(res.is_ok());\n\nlet mut it = data.iter().cloned();\nlet res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\nassert!(res.is_err());\n// It short-circuited, so the remaining items are still in the iterator:\nassert_eq!(it.next(), Some(\"stale_bread.json\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::rename;%0A++++use+std::io::%7Bstdout,+Write%7D;%0A++++use+std::path::Path;%0A++++%0A++++let+data+=+%5B%22no_tea.txt%22,+%22stale_bread.json%22,+%22torrential_rain.png%22%5D;%0A++++%0A++++let+res+=+data.iter().try_for_each(%7Cx%7C+writeln!(stdout(),+%22%7Bx%7D%22));%0A++++assert!(res.is_ok());%0A++++%0A++++let+mut+it+=+data.iter().cloned();%0A++++let+res+=+it.try_for_each(%7Cx%7C+rename(x,+Path::new(x).with_extension(%22old%22)));%0A++++assert!(res.is_err());%0A++++//+It+short-circuited,+so+the+remaining+items+are+still+in+the+iterator:%0A++++assert_eq!(it.next(),+Some(%22stale_bread.json%22));%0A%7D&edition=2021)\n\nThe [`ControlFlow`](../ops/enum.ControlFlow.html \"enum std::ops::ControlFlow\") type can be used with this method for the situations in which you’d use `break` and `continue` in a normal loop:\n\n```\nuse std::ops::ControlFlow;\n\nlet r = (2..100).try_for_each(|x| {\n    if 323 % x == 0 {\n        return ControlFlow::Break(x)\n    }\n\n    ControlFlow::Continue(())\n});\nassert_eq!(r, ControlFlow::Break(17));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ops::ControlFlow;%0A++++%0A++++let+r+=+(2..100).try_for_each(%7Cx%7C+%7B%0A++++++++if+323+%25+x+==+0+%7B%0A++++++++++++return+ControlFlow::Break(x)%0A++++++++%7D%0A++++%0A++++++++ControlFlow::Continue(())%0A++++%7D);%0A++++assert_eq!(r,+ControlFlow::Break(17));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2582-2585)\n\nFolds every element into an accumulator by applying an operation, returning the final result.\n\n`fold()` takes two arguments: an initial value, and a closure with two arguments: an ‘accumulator’, and an element. The closure returns the value that the accumulator should have for the next iteration.\n\nThe initial value is the value the accumulator will have on the first call.\n\nAfter applying this closure to every element of the iterator, `fold()` returns the accumulator.\n\nThis operation is sometimes called ‘reduce’ or ‘inject’.\n\nFolding is useful whenever you have a collection of something, and want to produce a single value from it.\n\nNote: `fold()`, and similar methods that traverse the entire iterator, might not terminate for infinite iterators, even on traits for which a result is determinable in finite time.\n\nNote: [`reduce()`](about:blank/trait.Iterator.html#method.reduce \"method std::iter::Iterator::reduce\") can be used to use the first element as the initial value, if the accumulator type and item type is the same.\n\nNote: `fold()` combines elements in a _left-associative_ fashion. For associative operators like `+`, the order the elements are combined in is not important, but for non-associative operators like `-` the order will affect the final result. For a _right-associative_ version of `fold()`, see [`DoubleEndedIterator::rfold()`](about:blank/trait.DoubleEndedIterator.html#method.rfold \"method std::iter::DoubleEndedIterator::rfold\").\n\n##### [§](#note-to-implementors-1)Note to Implementors\n\nSeveral of the other (forward) methods have default implementations in terms of this one, so try to implement this explicitly if it can do something better than the default `for` loop implementation.\n\nIn particular, try to have this call `fold()` on the internal parts from which this iterator is composed.\n\n##### [§](#examples-38)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\n// the sum of all of the elements of the array\nlet sum = a.iter().fold(0, |acc, x| acc + x);\n\nassert_eq!(sum, 6);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++//+the+sum+of+all+of+the+elements+of+the+array%0A++++let+sum+=+a.iter().fold(0,+%7Cacc,+x%7C+acc+%2B+x);%0A++++%0A++++assert_eq!(sum,+6);%0A%7D&edition=2021)\n\nLet’s walk through each step of the iteration here:\n\n| element | acc | x | result |\n| --- | --- | --- | --- |\n|  | 0 |  |  |\n| 1 | 0 | 1 | 1 |\n| 2 | 1 | 2 | 3 |\n| 3 | 3 | 3 | 6 |\n\nAnd so, our final result, `6`.\n\nThis example demonstrates the left-associative nature of `fold()`: it builds a string, starting with an initial value and continuing with each element from the front until the back:\n\n```\nlet numbers = [1, 2, 3, 4, 5];\n\nlet zero = \"0\".to_string();\n\nlet result = numbers.iter().fold(zero, |acc, &x| {\n    format!(\"({acc} + {x})\")\n});\n\nassert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++let+zero+=+%220%22.to_string();%0A++++%0A++++let+result+=+numbers.iter().fold(zero,+%7Cacc,+%26x%7C+%7B%0A++++++++format!(%22(%7Bacc%7D+%2B+%7Bx%7D)%22)%0A++++%7D);%0A++++%0A++++assert_eq!(result,+%22(((((0+%2B+1)+%2B+2)+%2B+3)+%2B+4)+%2B+5)%22);%0A%7D&edition=2021)\n\nIt’s common for people who haven’t used iterators a lot to use a `for` loop with a list of things to build up a result. Those can be turned into `fold()`s:\n\n```\nlet numbers = [1, 2, 3, 4, 5];\n\nlet mut result = 0;\n\n// for loop:\nfor i in &numbers {\n    result = result + i;\n}\n\n// fold:\nlet result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n// they're the same\nassert_eq!(result, result2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++let+mut+result+=+0;%0A++++%0A++++//+for+loop:%0A++++for+i+in+%26numbers+%7B%0A++++++++result+=+result+%2B+i;%0A++++%7D%0A++++%0A++++//+fold:%0A++++let+result2+=+numbers.iter().fold(0,+%7Cacc,+%26x%7C+acc+%2B+x);%0A++++%0A++++//+they%27re+the+same%0A++++assert_eq!(result,+result2);%0A%7D&edition=2021)\n\n1.51.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2620-2623)\n\nReduces the elements to a single one, by repeatedly applying a reducing operation.\n\nIf the iterator is empty, returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"); otherwise, returns the result of the reduction.\n\nThe reducing function is a closure with two arguments: an ‘accumulator’, and an element. For iterators with at least one element, this is the same as [`fold()`](about:blank/trait.Iterator.html#method.fold \"method std::iter::Iterator::fold\") with the first element of the iterator as the initial accumulator value, folding every subsequent element into it.\n\n##### [§](#example)Example\n\n```\nlet reduced: i32 = (1..10).reduce(|acc, e| acc + e).unwrap();\nassert_eq!(reduced, 45);\n\n// Which is equivalent to doing it with `fold`:\nlet folded: i32 = (1..10).fold(0, |acc, e| acc + e);\nassert_eq!(reduced, folded);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+reduced:+i32+=+(1..10).reduce(%7Cacc,+e%7C+acc+%2B+e).unwrap();%0A++++assert_eq!(reduced,+45);%0A++++%0A++++//+Which+is+equivalent+to+doing+it+with+%60fold%60:%0A++++let+folded:+i32+=+(1..10).fold(0,+%7Cacc,+e%7C+acc+%2B+e);%0A++++assert_eq!(reduced,+folded);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2692-2697)\n\n🔬This is a nightly-only experimental API. (`iterator_try_reduce` [#87053](https://github.com/rust-lang/rust/issues/87053))\n\nReduces the elements to a single one by repeatedly applying a reducing operation. If the closure returns a failure, the failure is propagated back to the caller immediately.\n\nThe return type of this method depends on the return type of the closure. If the closure returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>, E>`. If the closure returns `Option<Self::Item>`, then this function will return `Option<Option<Self::Item>>`.\n\nWhen called on an empty iterator, this function will return either `Some(None)` or `Ok(None)` depending on the type of the provided closure.\n\nFor iterators with at least one element, this is essentially the same as calling [`try_fold()`](about:blank/trait.Iterator.html#method.try_fold \"method std::iter::Iterator::try_fold\") with the first element of the iterator as the initial accumulator value.\n\n##### [§](#examples-39)Examples\n\nSafely calculate the sum of a series of numbers:\n\n```\n#![feature(iterator_try_reduce)]\n\nlet numbers: Vec<usize> = vec![10, 20, 5, 23, 0];\nlet sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\nassert_eq!(sum, Some(Some(58)));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers:+Vec%3Cusize%3E+=+vec!%5B10,+20,+5,+23,+0%5D;%0A++++let+sum+=+numbers.into_iter().try_reduce(%7Cx,+y%7C+x.checked_add(y));%0A++++assert_eq!(sum,+Some(Some(58)));%0A%7D&version=nightly&edition=2021)\n\nDetermine when a reduction short circuited:\n\n```\n#![feature(iterator_try_reduce)]\n\nlet numbers = vec![1, 2, 3, usize::MAX, 4, 5];\nlet sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\nassert_eq!(sum, None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers+=+vec!%5B1,+2,+3,+usize::MAX,+4,+5%5D;%0A++++let+sum+=+numbers.into_iter().try_reduce(%7Cx,+y%7C+x.checked_add(y));%0A++++assert_eq!(sum,+None);%0A%7D&version=nightly&edition=2021)\n\nDetermine when a reduction was not performed because there are no elements:\n\n```\n#![feature(iterator_try_reduce)]\n\nlet numbers: Vec<usize> = Vec::new();\nlet sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\nassert_eq!(sum, Some(None));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers:+Vec%3Cusize%3E+=+Vec::new();%0A++++let+sum+=+numbers.into_iter().try_reduce(%7Cx,+y%7C+x.checked_add(y));%0A++++assert_eq!(sum,+Some(None));%0A%7D&version=nightly&edition=2021)\n\nUse a [`Result`](../result/enum.Result.html \"enum std::result::Result\") instead of an [`Option`](../option/enum.Option.html \"enum std::option::Option\"):\n\n```\n#![feature(iterator_try_reduce)]\n\nlet numbers = vec![\"1\", \"2\", \"3\", \"4\", \"5\"];\nlet max: Result<Option<_>, <usize as std::str::FromStr>::Err> =\n    numbers.into_iter().try_reduce(|x, y| {\n        if x.parse::<usize>()? > y.parse::<usize>()? { Ok(x) } else { Ok(y) }\n    });\nassert_eq!(max, Ok(Some(\"5\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers+=+vec!%5B%221%22,+%222%22,+%223%22,+%224%22,+%225%22%5D;%0A++++let+max:+Result%3COption%3C_%3E,+%3Cusize+as+std::str::FromStr%3E::Err%3E+=%0A++++++++numbers.into_iter().try_reduce(%7Cx,+y%7C+%7B%0A++++++++++++if+x.parse::%3Cusize%3E()?+%3E+y.parse::%3Cusize%3E()?+%7B+Ok(x)+%7D+else+%7B+Ok(y)+%7D%0A++++++++%7D);%0A++++assert_eq!(max,+Ok(Some(%225%22)));%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2750-2753)\n\nTests if every element of the iterator matches a predicate.\n\n`all()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterator, and if they all return `true`, then so does `all()`. If any of them return `false`, it returns `false`.\n\n`all()` is short-circuiting; in other words, it will stop processing as soon as it finds a `false`, given that no matter what else happens, the result will also be `false`.\n\nAn empty iterator returns `true`.\n\n##### [§](#examples-40)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nassert!(a.iter().all(|&x| x > 0));\n\nassert!(!a.iter().all(|&x| x > 2));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert!(a.iter().all(%7C%26x%7C+x+%3E+0));%0A++++%0A++++assert!(!a.iter().all(%7C%26x%7C+x+%3E+2));%0A%7D&edition=2021)\n\nStopping at the first `false`:\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert!(!iter.all(|&x| x != 2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&3));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert!(!iter.all(%7C%26x%7C+x+!=+2));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%263));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2804-2807)\n\nTests if any element of the iterator matches a predicate.\n\n`any()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterator, and if any of them return `true`, then so does `any()`. If they all return `false`, it returns `false`.\n\n`any()` is short-circuiting; in other words, it will stop processing as soon as it finds a `true`, given that no matter what else happens, the result will also be `true`.\n\nAn empty iterator returns `false`.\n\n##### [§](#examples-41)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nassert!(a.iter().any(|&x| x > 0));\n\nassert!(!a.iter().any(|&x| x > 5));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert!(a.iter().any(%7C%26x%7C+x+%3E+0));%0A++++%0A++++assert!(!a.iter().any(%7C%26x%7C+x+%3E+5));%0A%7D&edition=2021)\n\nStopping at the first `true`:\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert!(iter.any(|&x| x != 2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&2));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert!(iter.any(%7C%26x%7C+x+!=+2));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%262));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2868-2871)\n\nSearches for an element of an iterator that satisfies a predicate.\n\n`find()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterator, and if any of them return `true`, then `find()` returns [`Some(element)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\"). If they all return `false`, it returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\n`find()` is short-circuiting; in other words, it will stop processing as soon as the closure returns `true`.\n\nBecause `find()` takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with `&&x`.\n\nIf you need the index of the element, see [`position()`](about:blank/trait.Iterator.html#method.position \"method std::iter::Iterator::position\").\n\n##### [§](#examples-42)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nassert_eq!(a.iter().find(|&&x| x == 2), Some(&2));\n\nassert_eq!(a.iter().find(|&&x| x == 5), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert_eq!(a.iter().find(%7C%26%26x%7C+x+==+2),+Some(%262));%0A++++%0A++++assert_eq!(a.iter().find(%7C%26%26x%7C+x+==+5),+None);%0A%7D&edition=2021)\n\nStopping at the first `true`:\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.find(|&&x| x == 2), Some(&2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&3));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.find(%7C%26%26x%7C+x+==+2),+Some(%262));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%263));%0A%7D&edition=2021)\n\nNote that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n\n1.30.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2900-2903)\n\nApplies function to the elements of iterator and returns the first non-none result.\n\n`iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n\n##### [§](#examples-43)Examples\n\n```\nlet a = [\"lol\", \"NaN\", \"2\", \"5\"];\n\nlet first_number = a.iter().find_map(|s| s.parse().ok());\n\nassert_eq!(first_number, Some(2));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%22lol%22,+%22NaN%22,+%222%22,+%225%22%5D;%0A++++%0A++++let+first_number+=+a.iter().find_map(%7Cs%7C+s.parse().ok());%0A++++%0A++++assert_eq!(first_number,+Some(2));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2959-2964)\n\n🔬This is a nightly-only experimental API. (`try_find` [#63178](https://github.com/rust-lang/rust/issues/63178))\n\nApplies function to the elements of iterator and returns the first true result or the first error.\n\nThe return type of this method depends on the return type of the closure. If you return `Result<bool, E>` from the closure, you’ll get a `Result<Option<Self::Item>, E>`. If you return `Option<bool>` from the closure, you’ll get an `Option<Option<Self::Item>>`.\n\n##### [§](#examples-44)Examples\n\n```\n#![feature(try_find)]\n\nlet a = [\"1\", \"2\", \"lol\", \"NaN\", \"5\"];\n\nlet is_my_num = |s: &str, search: i32| -> Result<bool, std::num::ParseIntError> {\n    Ok(s.parse::<i32>()?  == search)\n};\n\nlet result = a.iter().try_find(|&&s| is_my_num(s, 2));\nassert_eq!(result, Ok(Some(&\"2\")));\n\nlet result = a.iter().try_find(|&&s| is_my_num(s, 5));\nassert!(result.is_err());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(try_find)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B%221%22,+%222%22,+%22lol%22,+%22NaN%22,+%225%22%5D;%0A++++%0A++++let+is_my_num+=+%7Cs:+%26str,+search:+i32%7C+-%3E+Result%3Cbool,+std::num::ParseIntError%3E+%7B%0A++++++++Ok(s.parse::%3Ci32%3E()?++==+search)%0A++++%7D;%0A++++%0A++++let+result+=+a.iter().try_find(%7C%26%26s%7C+is_my_num(s,+2));%0A++++assert_eq!(result,+Ok(Some(%26%222%22)));%0A++++%0A++++let+result+=+a.iter().try_find(%7C%26%26s%7C+is_my_num(s,+5));%0A++++assert!(result.is_err());%0A%7D&version=nightly&edition=2021)\n\nThis also supports other types which implement [`Try`](../ops/trait.Try.html \"trait std::ops::Try\"), not just [`Result`](../result/enum.Result.html \"enum std::result::Result\").\n\n```\n#![feature(try_find)]\n\nuse std::num::NonZero;\n\nlet a = [3, 5, 7, 4, 9, 0, 11u32];\nlet result = a.iter().try_find(|&&x| NonZero::new(x).map(|y| y.is_power_of_two()));\nassert_eq!(result, Some(Some(&4)));\nlet result = a.iter().take(3).try_find(|&&x| NonZero::new(x).map(|y| y.is_power_of_two()));\nassert_eq!(result, Some(None));\nlet result = a.iter().rev().try_find(|&&x| NonZero::new(x).map(|y| y.is_power_of_two()));\nassert_eq!(result, None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(try_find)%5D%0A%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+a+=+%5B3,+5,+7,+4,+9,+0,+11u32%5D;%0A++++let+result+=+a.iter().try_find(%7C%26%26x%7C+NonZero::new(x).map(%7Cy%7C+y.is_power_of_two()));%0A++++assert_eq!(result,+Some(Some(%264)));%0A++++let+result+=+a.iter().take(3).try_find(%7C%26%26x%7C+NonZero::new(x).map(%7Cy%7C+y.is_power_of_two()));%0A++++assert_eq!(result,+Some(None));%0A++++let+result+=+a.iter().rev().try_find(%7C%26%26x%7C+NonZero::new(x).map(%7Cy%7C+y.is_power_of_two()));%0A++++assert_eq!(result,+None);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3042-3045)\n\nSearches for an element in an iterator, returning its index.\n\n`position()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterator, and if one of them returns `true`, then `position()` returns [`Some(index)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\"). If all of them return `false`, it returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\n`position()` is short-circuiting; in other words, it will stop processing as soon as it finds a `true`.\n\n##### [§](#overflow-behavior-2)Overflow Behavior\n\nThe method does no guarding against overflows, so if there are more than [`usize::MAX`](about:blank/primitive.usize.html#associatedconstant.MAX \"associated constant usize::MAX\") non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.\n\n##### [§](#panics-4)Panics\n\nThis function might panic if the iterator has more than `usize::MAX` non-matching elements.\n\n##### [§](#examples-45)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nassert_eq!(a.iter().position(|&x| x == 2), Some(1));\n\nassert_eq!(a.iter().position(|&x| x == 5), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert_eq!(a.iter().position(%7C%26x%7C+x+==+2),+Some(1));%0A++++%0A++++assert_eq!(a.iter().position(%7C%26x%7C+x+==+5),+None);%0A%7D&edition=2021)\n\nStopping at the first `true`:\n\n```\nlet a = [1, 2, 3, 4];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.position(|&x| x >= 2), Some(1));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&3));\n\n// The returned index depends on iterator state\nassert_eq!(iter.position(|&x| x == 4), Some(0));\n\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.position(%7C%26x%7C+x+%3E=+2),+Some(1));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++%0A++++//+The+returned+index+depends+on+iterator+state%0A++++assert_eq!(iter.position(%7C%26x%7C+x+==+4),+Some(0));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3107-3110)\n\nSearches for an element in an iterator from the right, returning its index.\n\n`rposition()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterator, starting from the end, and if one of them returns `true`, then `rposition()` returns [`Some(index)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\"). If all of them return `false`, it returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\n`rposition()` is short-circuiting; in other words, it will stop processing as soon as it finds a `true`.\n\n##### [§](#examples-46)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nassert_eq!(a.iter().rposition(|&x| x == 3), Some(2));\n\nassert_eq!(a.iter().rposition(|&x| x == 5), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert_eq!(a.iter().rposition(%7C%26x%7C+x+==+3),+Some(2));%0A++++%0A++++assert_eq!(a.iter().rposition(%7C%26x%7C+x+==+5),+None);%0A%7D&edition=2021)\n\nStopping at the first `true`:\n\n```\nlet a = [-1, 2, 3, 4];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.rposition(|&x| x >= 2), Some(3));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&-1));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+2,+3,+4%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.rposition(%7C%26x%7C+x+%3E=+2),+Some(3));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3157-3160)\n\nReturns the maximum element of an iterator.\n\nIf several elements are equally maximum, the last element is returned. If the iterator is empty, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned.\n\nNote that [`f32`](../primitive.f32.html \"primitive f32\")/[`f64`](../primitive.f64.html \"primitive f64\") doesn’t implement [`Ord`](../cmp/trait.Ord.html \"trait std::cmp::Ord\") due to NaN being incomparable. You can work around this by using [`Iterator::reduce`](about:blank/trait.Iterator.html#method.reduce \"method std::iter::Iterator::reduce\"):\n\n```\nassert_eq!(\n    [2.4, f32::NAN, 1.3]\n        .into_iter()\n        .reduce(f32::max)\n        .unwrap(),\n    2.4\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%0A++++++++%5B2.4,+f32::NAN,+1.3%5D%0A++++++++++++.into_iter()%0A++++++++++++.reduce(f32::max)%0A++++++++++++.unwrap(),%0A++++++++2.4%0A++++);%0A%7D&edition=2021)\n\n##### [§](#examples-47)Examples\n\n```\nlet a = [1, 2, 3];\nlet b: Vec<u32> = Vec::new();\n\nassert_eq!(a.iter().max(), Some(&3));\nassert_eq!(b.iter().max(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b:+Vec%3Cu32%3E+=+Vec::new();%0A++++%0A++++assert_eq!(a.iter().max(),+Some(%263));%0A++++assert_eq!(b.iter().max(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3194-3197)\n\nReturns the minimum element of an iterator.\n\nIf several elements are equally minimum, the first element is returned. If the iterator is empty, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned.\n\nNote that [`f32`](../primitive.f32.html \"primitive f32\")/[`f64`](../primitive.f64.html \"primitive f64\") doesn’t implement [`Ord`](../cmp/trait.Ord.html \"trait std::cmp::Ord\") due to NaN being incomparable. You can work around this by using [`Iterator::reduce`](about:blank/trait.Iterator.html#method.reduce \"method std::iter::Iterator::reduce\"):\n\n```\nassert_eq!(\n    [2.4, f32::NAN, 1.3]\n        .into_iter()\n        .reduce(f32::min)\n        .unwrap(),\n    1.3\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%0A++++++++%5B2.4,+f32::NAN,+1.3%5D%0A++++++++++++.into_iter()%0A++++++++++++.reduce(f32::min)%0A++++++++++++.unwrap(),%0A++++++++1.3%0A++++);%0A%7D&edition=2021)\n\n##### [§](#examples-48)Examples\n\n```\nlet a = [1, 2, 3];\nlet b: Vec<u32> = Vec::new();\n\nassert_eq!(a.iter().min(), Some(&1));\nassert_eq!(b.iter().min(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b:+Vec%3Cu32%3E+=+Vec::new();%0A++++%0A++++assert_eq!(a.iter().min(),+Some(%261));%0A++++assert_eq!(b.iter().min(),+None);%0A%7D&edition=2021)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3217-3220)\n\nReturns the element that gives the maximum value from the specified function.\n\nIf several elements are equally maximum, the last element is returned. If the iterator is empty, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned.\n\n##### [§](#examples-49)Examples\n\n```\nlet a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().max_by_key(%7Cx%7C+x.abs()).unwrap(),+-10);%0A%7D&edition=2021)\n\n1.15.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3251-3254)\n\nReturns the element that gives the maximum value with respect to the specified comparison function.\n\nIf several elements are equally maximum, the last element is returned. If the iterator is empty, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned.\n\n##### [§](#examples-50)Examples\n\n```\nlet a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().max_by(%7Cx,+y%7C+x.cmp(y)).unwrap(),+5);%0A%7D&edition=2021)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3279-3282)\n\nReturns the element that gives the minimum value from the specified function.\n\nIf several elements are equally minimum, the first element is returned. If the iterator is empty, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned.\n\n##### [§](#examples-51)Examples\n\n```\nlet a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().min_by_key(%7Cx%7C+x.abs()).unwrap(),+0);%0A%7D&edition=2021)\n\n1.15.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3313-3316)\n\nReturns the element that gives the minimum value with respect to the specified comparison function.\n\nIf several elements are equally minimum, the first element is returned. If the iterator is empty, [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\") is returned.\n\n##### [§](#examples-52)Examples\n\n```\nlet a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().min_by(%7Cx,+y%7C+x.cmp(y)).unwrap(),+-10);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3351-3353)\n\nReverses an iterator’s direction.\n\nUsually, iterators iterate from left to right. After using `rev()`, an iterator will instead iterate from right to left.\n\nThis is only possible if the iterator has an end, so `rev()` only works on [`DoubleEndedIterator`](trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\")s.\n\n##### [§](#examples-53)Examples\n\n```\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter().rev();\n\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&1));\n\nassert_eq!(iter.next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().rev();%0A++++%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++assert_eq!(iter.next(),+None);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3388-3392)\n\nConverts an iterator of pairs into a pair of containers.\n\n`unzip()` consumes an entire iterator of pairs, producing two collections: one from the left elements of the pairs, and one from the right elements.\n\nThis function is, in some sense, the opposite of [`zip`](about:blank/trait.Iterator.html#method.zip \"method std::iter::Iterator::zip\").\n\n##### [§](#examples-54)Examples\n\n```\nlet a = [(1, 2), (3, 4), (5, 6)];\n\nlet (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n\nassert_eq!(left, [1, 3, 5]);\nassert_eq!(right, [2, 4, 6]);\n\n// you can also unzip multiple nested tuples at once\nlet a = [(1, (2, 3)), (4, (5, 6))];\n\nlet (x, (y, z)): (Vec<_>, (Vec<_>, Vec<_>)) = a.iter().cloned().unzip();\nassert_eq!(x, [1, 4]);\nassert_eq!(y, [2, 5]);\nassert_eq!(z, [3, 6]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B(1,+2),+(3,+4),+(5,+6)%5D;%0A++++%0A++++let+(left,+right):+(Vec%3C_%3E,+Vec%3C_%3E)+=+a.iter().cloned().unzip();%0A++++%0A++++assert_eq!(left,+%5B1,+3,+5%5D);%0A++++assert_eq!(right,+%5B2,+4,+6%5D);%0A++++%0A++++//+you+can+also+unzip+multiple+nested+tuples+at+once%0A++++let+a+=+%5B(1,+(2,+3)),+(4,+(5,+6))%5D;%0A++++%0A++++let+(x,+(y,+z)):+(Vec%3C_%3E,+(Vec%3C_%3E,+Vec%3C_%3E))+=+a.iter().cloned().unzip();%0A++++assert_eq!(x,+%5B1,+4%5D);%0A++++assert_eq!(y,+%5B2,+5%5D);%0A++++assert_eq!(z,+%5B3,+6%5D);%0A%7D&edition=2021)\n\n1.36.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3419-3422)\n\nCreates an iterator which copies all of its elements.\n\nThis is useful when you have an iterator over `&T`, but you need an iterator over `T`.\n\n##### [§](#examples-55)Examples\n\n```\nlet a = [1, 2, 3];\n\nlet v_copied: Vec<_> = a.iter().copied().collect();\n\n// copied is the same as .map(|&x| x)\nlet v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\nassert_eq!(v_copied, vec![1, 2, 3]);\nassert_eq!(v_map, vec![1, 2, 3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+v_copied:+Vec%3C_%3E+=+a.iter().copied().collect();%0A++++%0A++++//+copied+is+the+same+as+.map(%7C%26x%7C+x)%0A++++let+v_map:+Vec%3C_%3E+=+a.iter().map(%7C%26x%7C+x).collect();%0A++++%0A++++assert_eq!(v_copied,+vec!%5B1,+2,+3%5D);%0A++++assert_eq!(v_map,+vec!%5B1,+2,+3%5D);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3467-3470)\n\nCreates an iterator which [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\")s all of its elements.\n\nThis is useful when you have an iterator over `&T`, but you need an iterator over `T`.\n\nThere is no guarantee whatsoever about the `clone` method actually being called _or_ optimized away. So code should not depend on either.\n\n##### [§](#examples-56)Examples\n\nBasic usage:\n\n```\nlet a = [1, 2, 3];\n\nlet v_cloned: Vec<_> = a.iter().cloned().collect();\n\n// cloned is the same as .map(|&x| x), for integers\nlet v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\nassert_eq!(v_cloned, vec![1, 2, 3]);\nassert_eq!(v_map, vec![1, 2, 3]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+v_cloned:+Vec%3C_%3E+=+a.iter().cloned().collect();%0A++++%0A++++//+cloned+is+the+same+as+.map(%7C%26x%7C+x),+for+integers%0A++++let+v_map:+Vec%3C_%3E+=+a.iter().map(%7C%26x%7C+x).collect();%0A++++%0A++++assert_eq!(v_cloned,+vec!%5B1,+2,+3%5D);%0A++++assert_eq!(v_map,+vec!%5B1,+2,+3%5D);%0A%7D&edition=2021)\n\nTo get the best performance, try to clone late:\n\n```\nlet a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];\n// don't do this:\nlet slower: Vec<_> = a.iter().cloned().filter(|s| s.len() == 1).collect();\nassert_eq!(&[vec![23]], &slower[..]);\n// instead call `cloned` late\nlet faster: Vec<_> = a.iter().filter(|s| s.len() == 1).cloned().collect();\nassert_eq!(&[vec![23]], &faster[..]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5Bvec!%5B0_u8,+1,+2%5D,+vec!%5B3,+4%5D,+vec!%5B23%5D%5D;%0A++++//+don%27t+do+this:%0A++++let+slower:+Vec%3C_%3E+=+a.iter().cloned().filter(%7Cs%7C+s.len()+==+1).collect();%0A++++assert_eq!(%26%5Bvec!%5B23%5D%5D,+%26slower%5B..%5D);%0A++++//+instead+call+%60cloned%60+late%0A++++let+faster:+Vec%3C_%3E+=+a.iter().filter(%7Cs%7C+s.len()+==+1).cloned().collect();%0A++++assert_eq!(%26%5Bvec!%5B23%5D%5D,+%26faster%5B..%5D);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3500-3502)\n\nRepeats an iterator endlessly.\n\nInstead of stopping at [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"), the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever. Note that in case the original iterator is empty, the resulting iterator will also be empty.\n\n##### [§](#examples-57)Examples\n\n```\nlet a = [1, 2, 3];\n\nlet mut it = a.iter().cycle();\n\nassert_eq!(it.next(), Some(&1));\nassert_eq!(it.next(), Some(&2));\nassert_eq!(it.next(), Some(&3));\nassert_eq!(it.next(), Some(&1));\nassert_eq!(it.next(), Some(&2));\nassert_eq!(it.next(), Some(&3));\nassert_eq!(it.next(), Some(&1));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+it+=+a.iter().cycle();%0A++++%0A++++assert_eq!(it.next(),+Some(%261));%0A++++assert_eq!(it.next(),+Some(%262));%0A++++assert_eq!(it.next(),+Some(%263));%0A++++assert_eq!(it.next(),+Some(%261));%0A++++assert_eq!(it.next(),+Some(%262));%0A++++assert_eq!(it.next(),+Some(%263));%0A++++assert_eq!(it.next(),+Some(%261));%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3544-3546)\n\n🔬This is a nightly-only experimental API. (`iter_array_chunks` [#100450](https://github.com/rust-lang/rust/issues/100450))\n\nReturns an iterator over `N` elements of the iterator at a time.\n\nThe chunks do not overlap. If `N` does not divide the length of the iterator, then the last up to `N-1` elements will be omitted and can be retrieved from the [`.into_remainder()`](about:blank/struct.ArrayChunks.html#method.into_remainder \"method std::iter::ArrayChunks::into_remainder\") function of the iterator.\n\n##### [§](#panics-5)Panics\n\nPanics if `N` is 0.\n\n##### [§](#examples-58)Examples\n\nBasic usage:\n\n```\n#![feature(iter_array_chunks)]\n\nlet mut iter = \"lorem\".chars().array_chunks();\nassert_eq!(iter.next(), Some(['l', 'o']));\nassert_eq!(iter.next(), Some(['r', 'e']));\nassert_eq!(iter.next(), None);\nassert_eq!(iter.into_remainder().unwrap().as_slice(), &['m']);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_array_chunks)%5D%0A%0Afn+main()+%7B%0A++++let+mut+iter+=+%22lorem%22.chars().array_chunks();%0A++++assert_eq!(iter.next(),+Some(%5B%27l%27,+%27o%27%5D));%0A++++assert_eq!(iter.next(),+Some(%5B%27r%27,+%27e%27%5D));%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.into_remainder().unwrap().as_slice(),+%26%5B%27m%27%5D);%0A%7D&version=nightly&edition=2021)\n\n```\n#![feature(iter_array_chunks)]\n\nlet data = [1, 1, 2, -2, 6, 0, 3, 1];\n//          ^-----^  ^------^\nfor [x, y, z] in data.iter().array_chunks() {\n    assert_eq!(x + y + z, 4);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_array_chunks)%5D%0A%0Afn+main()+%7B%0A++++let+data+=+%5B1,+1,+2,+-2,+6,+0,+3,+1%5D;%0A++++//++++++++++%5E-----%5E++%5E------%5E%0A++++for+%5Bx,+y,+z%5D+in+data.iter().array_chunks()+%7B%0A++++++++assert_eq!(x+%2B+y+%2B+z,+4);%0A++++%7D%0A%7D&version=nightly&edition=2021)\n\n1.11.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3576-3579)\n\nSums the elements of an iterator.\n\nTakes each element, adds them together, and returns the result.\n\nAn empty iterator returns the zero value of the type.\n\n`sum()` can be used to sum any type implementing [`Sum`](trait.Sum.html \"trait std::iter::Sum\"), including [`Option`](about:blank/option/enum.Option.html#method.sum \"associated function std::option::Option::sum\") and [`Result`](about:blank/result/enum.Result.html#method.sum \"associated function std::result::Result::sum\").\n\n##### [§](#panics-6)Panics\n\nWhen calling `sum()` and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.\n\n##### [§](#examples-59)Examples\n\n```\nlet a = [1, 2, 3];\nlet sum: i32 = a.iter().sum();\n\nassert_eq!(sum, 6);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+sum:+i32+=+a.iter().sum();%0A++++%0A++++assert_eq!(sum,+6);%0A%7D&edition=2021)\n\n1.11.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3609-3612)\n\nIterates over the entire iterator, multiplying all the elements\n\nAn empty iterator returns the one value of the type.\n\n`product()` can be used to multiply any type implementing [`Product`](trait.Product.html \"trait std::iter::Product\"), including [`Option`](about:blank/option/enum.Option.html#method.product \"associated function std::option::Option::product\") and [`Result`](about:blank/result/enum.Result.html#method.product \"associated function std::result::Result::product\").\n\n##### [§](#panics-7)Panics\n\nWhen calling `product()` and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.\n\n##### [§](#examples-60)Examples\n\n```\nfn factorial(n: u32) -> u32 {\n    (1..=n).product()\n}\nassert_eq!(factorial(0), 1);\nassert_eq!(factorial(1), 1);\nassert_eq!(factorial(5), 120);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+factorial(n:+u32)+-%3E+u32+%7B%0A++++++++(1..=n).product()%0A++++%7D%0A++++assert_eq!(factorial(0),+1);%0A++++assert_eq!(factorial(1),+1);%0A++++assert_eq!(factorial(5),+120);%0A%7D&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3631-3635)\n\n[Lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") compares the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") with those of another.\n\n##### [§](#examples-61)Examples\n\n```\nuse std::cmp::Ordering;\n\nassert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);\nassert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);\nassert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++assert_eq!(%5B1%5D.iter().cmp(%5B1%5D.iter()),+Ordering::Equal);%0A++++assert_eq!(%5B1%5D.iter().cmp(%5B1,+2%5D.iter()),+Ordering::Less);%0A++++assert_eq!(%5B1,+2%5D.iter().cmp(%5B1%5D.iter()),+Ordering::Greater);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3659-3663)\n\n🔬This is a nightly-only experimental API. (`iter_order_by` [#64295](https://github.com/rust-lang/rust/issues/64295))\n\n[Lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") compares the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") with those of another with respect to the specified comparison function.\n\n##### [§](#examples-62)Examples\n\n```\n#![feature(iter_order_by)]\n\nuse std::cmp::Ordering;\n\nlet xs = [1, 2, 3, 4];\nlet ys = [1, 4, 9, 16];\n\nassert_eq!(xs.iter().cmp_by(&ys, |&x, &y| x.cmp(&y)), Ordering::Less);\nassert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);\nassert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_order_by)%5D%0A%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+xs+=+%5B1,+2,+3,+4%5D;%0A++++let+ys+=+%5B1,+4,+9,+16%5D;%0A++++%0A++++assert_eq!(xs.iter().cmp_by(%26ys,+%7C%26x,+%26y%7C+x.cmp(%26y)),+Ordering::Less);%0A++++assert_eq!(xs.iter().cmp_by(%26ys,+%7C%26x,+%26y%7C+(x+*+x).cmp(%26y)),+Ordering::Equal);%0A++++assert_eq!(xs.iter().cmp_by(%26ys,+%7C%26x,+%26y%7C+(2+*+x).cmp(%26y)),+Ordering::Greater);%0A%7D&version=nightly&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3716-3720)\n\n[Lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") compares the [`PartialOrd`](../cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\") elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") with those of another. The comparison works like short-circuit evaluation, returning a result without comparing the remaining elements. As soon as an order can be determined, the evaluation stops and a result is returned.\n\n##### [§](#examples-63)Examples\n\n```\nuse std::cmp::Ordering;\n\nassert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\nassert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\nassert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++assert_eq!(%5B1.%5D.iter().partial_cmp(%5B1.%5D.iter()),+Some(Ordering::Equal));%0A++++assert_eq!(%5B1.%5D.iter().partial_cmp(%5B1.,+2.%5D.iter()),+Some(Ordering::Less));%0A++++assert_eq!(%5B1.,+2.%5D.iter().partial_cmp(%5B1.%5D.iter()),+Some(Ordering::Greater));%0A%7D&edition=2021)\n\nFor floating-point numbers, NaN does not have a total order and will result in `None` when compared:\n\n```\nassert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5Bf64::NAN%5D.iter().partial_cmp(%5B1.%5D.iter()),+None);%0A%7D&edition=2021)\n\nThe results are determined by the order of evaluation.\n\n```\nuse std::cmp::Ordering;\n\nassert_eq!([1.0, f64::NAN].iter().partial_cmp([2.0, f64::NAN].iter()), Some(Ordering::Less));\nassert_eq!([2.0, f64::NAN].iter().partial_cmp([1.0, f64::NAN].iter()), Some(Ordering::Greater));\nassert_eq!([f64::NAN, 1.0].iter().partial_cmp([f64::NAN, 2.0].iter()), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++assert_eq!(%5B1.0,+f64::NAN%5D.iter().partial_cmp(%5B2.0,+f64::NAN%5D.iter()),+Some(Ordering::Less));%0A++++assert_eq!(%5B2.0,+f64::NAN%5D.iter().partial_cmp(%5B1.0,+f64::NAN%5D.iter()),+Some(Ordering::Greater));%0A++++assert_eq!(%5Bf64::NAN,+1.0%5D.iter().partial_cmp(%5Bf64::NAN,+2.0%5D.iter()),+None);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3753-3757)\n\n🔬This is a nightly-only experimental API. (`iter_order_by` [#64295](https://github.com/rust-lang/rust/issues/64295))\n\n[Lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") compares the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") with those of another with respect to the specified comparison function.\n\n##### [§](#examples-64)Examples\n\n```\n#![feature(iter_order_by)]\n\nuse std::cmp::Ordering;\n\nlet xs = [1.0, 2.0, 3.0, 4.0];\nlet ys = [1.0, 4.0, 9.0, 16.0];\n\nassert_eq!(\n    xs.iter().partial_cmp_by(&ys, |&x, &y| x.partial_cmp(&y)),\n    Some(Ordering::Less)\n);\nassert_eq!(\n    xs.iter().partial_cmp_by(&ys, |&x, &y| (x * x).partial_cmp(&y)),\n    Some(Ordering::Equal)\n);\nassert_eq!(\n    xs.iter().partial_cmp_by(&ys, |&x, &y| (2.0 * x).partial_cmp(&y)),\n    Some(Ordering::Greater)\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_order_by)%5D%0A%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+xs+=+%5B1.0,+2.0,+3.0,+4.0%5D;%0A++++let+ys+=+%5B1.0,+4.0,+9.0,+16.0%5D;%0A++++%0A++++assert_eq!(%0A++++++++xs.iter().partial_cmp_by(%26ys,+%7C%26x,+%26y%7C+x.partial_cmp(%26y)),%0A++++++++Some(Ordering::Less)%0A++++);%0A++++assert_eq!(%0A++++++++xs.iter().partial_cmp_by(%26ys,+%7C%26x,+%26y%7C+(x+*+x).partial_cmp(%26y)),%0A++++++++Some(Ordering::Equal)%0A++++);%0A++++assert_eq!(%0A++++++++xs.iter().partial_cmp_by(%26ys,+%7C%26x,+%26y%7C+(2.0+*+x).partial_cmp(%26y)),%0A++++++++Some(Ordering::Greater)%0A++++);%0A%7D&version=nightly&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3787-3791)\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are equal to those of another.\n\n##### [§](#examples-65)Examples\n\n```\nassert_eq!([1].iter().eq([1].iter()), true);\nassert_eq!([1].iter().eq([1, 2].iter()), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().eq(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1%5D.iter().eq(%5B1,+2%5D.iter()),+false);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3811-3815)\n\n🔬This is a nightly-only experimental API. (`iter_order_by` [#64295](https://github.com/rust-lang/rust/issues/64295))\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are equal to those of another with respect to the specified equality function.\n\n##### [§](#examples-66)Examples\n\n```\n#![feature(iter_order_by)]\n\nlet xs = [1, 2, 3, 4];\nlet ys = [1, 4, 9, 16];\n\nassert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_order_by)%5D%0A%0Afn+main()+%7B%0A++++let+xs+=+%5B1,+2,+3,+4%5D;%0A++++let+ys+=+%5B1,+4,+9,+16%5D;%0A++++%0A++++assert!(xs.iter().eq_by(%26ys,+%7C%26x,+%26y%7C+x+*+x+==+y));%0A%7D&version=nightly&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3844-3848)\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are not equal to those of another.\n\n##### [§](#examples-67)Examples\n\n```\nassert_eq!([1].iter().ne([1].iter()), false);\nassert_eq!([1].iter().ne([1, 2].iter()), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().ne(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1%5D.iter().ne(%5B1,+2%5D.iter()),+true);%0A%7D&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3866-3870)\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are [lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") less than those of another.\n\n##### [§](#examples-68)Examples\n\n```\nassert_eq!([1].iter().lt([1].iter()), false);\nassert_eq!([1].iter().lt([1, 2].iter()), true);\nassert_eq!([1, 2].iter().lt([1].iter()), false);\nassert_eq!([1, 2].iter().lt([1, 2].iter()), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().lt(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1%5D.iter().lt(%5B1,+2%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().lt(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().lt(%5B1,+2%5D.iter()),+false);%0A%7D&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3888-3892)\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are [lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") less or equal to those of another.\n\n##### [§](#examples-69)Examples\n\n```\nassert_eq!([1].iter().le([1].iter()), true);\nassert_eq!([1].iter().le([1, 2].iter()), true);\nassert_eq!([1, 2].iter().le([1].iter()), false);\nassert_eq!([1, 2].iter().le([1, 2].iter()), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().le(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1%5D.iter().le(%5B1,+2%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().le(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().le(%5B1,+2%5D.iter()),+true);%0A%7D&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3910-3914)\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are [lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") greater than those of another.\n\n##### [§](#examples-70)Examples\n\n```\nassert_eq!([1].iter().gt([1].iter()), false);\nassert_eq!([1].iter().gt([1, 2].iter()), false);\nassert_eq!([1, 2].iter().gt([1].iter()), true);\nassert_eq!([1, 2].iter().gt([1, 2].iter()), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().gt(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1%5D.iter().gt(%5B1,+2%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().gt(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().gt(%5B1,+2%5D.iter()),+false);%0A%7D&edition=2021)\n\n1.5.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3932-3936)\n\nDetermines if the elements of this [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") are [lexicographically](about:blank/cmp/trait.Ord.html#lexicographical-comparison \"trait std::cmp::Ord\") greater than or equal to those of another.\n\n##### [§](#examples-71)Examples\n\n```\nassert_eq!([1].iter().ge([1].iter()), true);\nassert_eq!([1].iter().ge([1, 2].iter()), false);\nassert_eq!([1, 2].iter().ge([1].iter()), true);\nassert_eq!([1, 2].iter().ge([1, 2].iter()), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().ge(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1%5D.iter().ge(%5B1,+2%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().ge(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().ge(%5B1,+2%5D.iter()),+true);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3964-3967)\n\n🔬This is a nightly-only experimental API. (`is_sorted` [#53485](https://github.com/rust-lang/rust/issues/53485))\n\nChecks if the elements of this iterator are sorted.\n\nThat is, for each element `a` and its following element `b`, `a <= b` must hold. If the iterator yields exactly zero or one element, `true` is returned.\n\nNote that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition implies that this function returns `false` if any two consecutive items are not comparable.\n\n##### [§](#examples-72)Examples\n\n```\n#![feature(is_sorted)]\n\nassert!([1, 2, 2, 9].iter().is_sorted());\nassert!(![1, 3, 2, 4].iter().is_sorted());\nassert!([0].iter().is_sorted());\nassert!(std::iter::empty::<i32>().is_sorted());\nassert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(is_sorted)%5D%0A%0Afn+main()+%7B%0A++++assert!(%5B1,+2,+2,+9%5D.iter().is_sorted());%0A++++assert!(!%5B1,+3,+2,+4%5D.iter().is_sorted());%0A++++assert!(%5B0%5D.iter().is_sorted());%0A++++assert!(std::iter::empty::%3Ci32%3E().is_sorted());%0A++++assert!(!%5B0.0,+1.0,+f32::NAN%5D.iter().is_sorted());%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3993-3996)\n\n🔬This is a nightly-only experimental API. (`is_sorted` [#53485](https://github.com/rust-lang/rust/issues/53485))\n\nChecks if the elements of this iterator are sorted using the given comparator function.\n\nInstead of using `PartialOrd::partial_cmp`, this function uses the given `compare` function to determine whether two elements are to be considered in sorted order.\n\n##### [§](#examples-73)Examples\n\n```\n#![feature(is_sorted)]\n\nassert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a <= b));\nassert!(![1, 2, 2, 9].iter().is_sorted_by(|a, b| a < b));\n\nassert!([0].iter().is_sorted_by(|a, b| true));\nassert!([0].iter().is_sorted_by(|a, b| false));\n\nassert!(std::iter::empty::<i32>().is_sorted_by(|a, b| false));\nassert!(std::iter::empty::<i32>().is_sorted_by(|a, b| true));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(is_sorted)%5D%0A%0Afn+main()+%7B%0A++++assert!(%5B1,+2,+2,+9%5D.iter().is_sorted_by(%7Ca,+b%7C+a+%3C=+b));%0A++++assert!(!%5B1,+2,+2,+9%5D.iter().is_sorted_by(%7Ca,+b%7C+a+%3C+b));%0A++++%0A++++assert!(%5B0%5D.iter().is_sorted_by(%7Ca,+b%7C+true));%0A++++assert!(%5B0%5D.iter().is_sorted_by(%7Ca,+b%7C+false));%0A++++%0A++++assert!(std::iter::empty::%3Ci32%3E().is_sorted_by(%7Ca,+b%7C+false));%0A++++assert!(std::iter::empty::%3Ci32%3E().is_sorted_by(%7Ca,+b%7C+true));%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#4040-4044)\n\n🔬This is a nightly-only experimental API. (`is_sorted` [#53485](https://github.com/rust-lang/rust/issues/53485))\n\nChecks if the elements of this iterator are sorted using the given key extraction function.\n\nInstead of comparing the iterator’s elements directly, this function compares the keys of the elements, as determined by `f`. Apart from that, it’s equivalent to [`is_sorted`](about:blank/trait.Iterator.html#method.is_sorted \"method std::iter::Iterator::is_sorted\"); see its documentation for more information.\n\n##### [§](#examples-74)Examples\n\n```\n#![feature(is_sorted)]\n\nassert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\nassert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(is_sorted)%5D%0A%0Afn+main()+%7B%0A++++assert!(%5B%22c%22,+%22bb%22,+%22aaa%22%5D.iter().is_sorted_by_key(%7Cs%7C+s.len()));%0A++++assert!(!%5B-2i32,+-1,+0,+3%5D.iter().is_sorted_by_key(%7Cn%7C+n.abs()));%0A%7D&version=nightly&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A trait for dealing with iterators.\"><title>Iterator in std::iter - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc trait\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Iterator</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Iterator</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#required-associated-types\">Required Associated Types</a></h3><ul class=\"block\"><li><a href=\"#associatedtype.Item\">Item</a></li></ul><h3><a href=\"#required-methods\">Required Methods</a></h3><ul class=\"block\"><li><a href=\"#tymethod.next\">next</a></li></ul><h3><a href=\"#provided-methods\">Provided Methods</a></h3><ul class=\"block\"><li><a href=\"#method.advance_by\">advance_by</a></li><li><a href=\"#method.all\">all</a></li><li><a href=\"#method.any\">any</a></li><li><a href=\"#method.array_chunks\">array_chunks</a></li><li><a href=\"#method.by_ref\">by_ref</a></li><li><a href=\"#method.chain\">chain</a></li><li><a href=\"#method.cloned\">cloned</a></li><li><a href=\"#method.cmp\">cmp</a></li><li><a href=\"#method.cmp_by\">cmp_by</a></li><li><a href=\"#method.collect\">collect</a></li><li><a href=\"#method.collect_into\">collect_into</a></li><li><a href=\"#method.copied\">copied</a></li><li><a href=\"#method.count\">count</a></li><li><a href=\"#method.cycle\">cycle</a></li><li><a href=\"#method.enumerate\">enumerate</a></li><li><a href=\"#method.eq\">eq</a></li><li><a href=\"#method.eq_by\">eq_by</a></li><li><a href=\"#method.filter\">filter</a></li><li><a href=\"#method.filter_map\">filter_map</a></li><li><a href=\"#method.find\">find</a></li><li><a href=\"#method.find_map\">find_map</a></li><li><a href=\"#method.flat_map\">flat_map</a></li><li><a href=\"#method.flatten\">flatten</a></li><li><a href=\"#method.fold\">fold</a></li><li><a href=\"#method.for_each\">for_each</a></li><li><a href=\"#method.fuse\">fuse</a></li><li><a href=\"#method.ge\">ge</a></li><li><a href=\"#method.gt\">gt</a></li><li><a href=\"#method.inspect\">inspect</a></li><li><a href=\"#method.intersperse\">intersperse</a></li><li><a href=\"#method.intersperse_with\">intersperse_with</a></li><li><a href=\"#method.is_partitioned\">is_partitioned</a></li><li><a href=\"#method.is_sorted\">is_sorted</a></li><li><a href=\"#method.is_sorted_by\">is_sorted_by</a></li><li><a href=\"#method.is_sorted_by_key\">is_sorted_by_key</a></li><li><a href=\"#method.last\">last</a></li><li><a href=\"#method.le\">le</a></li><li><a href=\"#method.lt\">lt</a></li><li><a href=\"#method.map\">map</a></li><li><a href=\"#method.map_while\">map_while</a></li><li><a href=\"#method.map_windows\">map_windows</a></li><li><a href=\"#method.max\">max</a></li><li><a href=\"#method.max_by\">max_by</a></li><li><a href=\"#method.max_by_key\">max_by_key</a></li><li><a href=\"#method.min\">min</a></li><li><a href=\"#method.min_by\">min_by</a></li><li><a href=\"#method.min_by_key\">min_by_key</a></li><li><a href=\"#method.ne\">ne</a></li><li><a href=\"#method.next_chunk\">next_chunk</a></li><li><a href=\"#method.nth\">nth</a></li><li><a href=\"#method.partial_cmp\">partial_cmp</a></li><li><a href=\"#method.partial_cmp_by\">partial_cmp_by</a></li><li><a href=\"#method.partition\">partition</a></li><li><a href=\"#method.partition_in_place\">partition_in_place</a></li><li><a href=\"#method.peekable\">peekable</a></li><li><a href=\"#method.position\">position</a></li><li><a href=\"#method.product\">product</a></li><li><a href=\"#method.reduce\">reduce</a></li><li><a href=\"#method.rev\">rev</a></li><li><a href=\"#method.rposition\">rposition</a></li><li><a href=\"#method.scan\">scan</a></li><li><a href=\"#method.size_hint\">size_hint</a></li><li><a href=\"#method.skip\">skip</a></li><li><a href=\"#method.skip_while\">skip_while</a></li><li><a href=\"#method.step_by\">step_by</a></li><li><a href=\"#method.sum\">sum</a></li><li><a href=\"#method.take\">take</a></li><li><a href=\"#method.take_while\">take_while</a></li><li><a href=\"#method.try_collect\">try_collect</a></li><li><a href=\"#method.try_find\">try_find</a></li><li><a href=\"#method.try_fold\">try_fold</a></li><li><a href=\"#method.try_for_each\">try_for_each</a></li><li><a href=\"#method.try_reduce\">try_reduce</a></li><li><a href=\"#method.unzip\">unzip</a></li><li><a href=\"#method.zip\">zip</a></li></ul><h3><a href=\"#implementors\">Implementors</a></h3></section><h2><a href=\"index.html\">In std::iter</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.ArrayChunks.html\">ArrayChunks</a></li><li><a href=\"struct.ByRefSized.html\">ByRefSized</a></li><li><a href=\"struct.Chain.html\">Chain</a></li><li><a href=\"struct.Cloned.html\">Cloned</a></li><li><a href=\"struct.Copied.html\">Copied</a></li><li><a href=\"struct.Cycle.html\">Cycle</a></li><li><a href=\"struct.Empty.html\">Empty</a></li><li><a href=\"struct.Enumerate.html\">Enumerate</a></li><li><a href=\"struct.Filter.html\">Filter</a></li><li><a href=\"struct.FilterMap.html\">FilterMap</a></li><li><a href=\"struct.FlatMap.html\">FlatMap</a></li><li><a href=\"struct.Flatten.html\">Flatten</a></li><li><a href=\"struct.FromFn.html\">FromFn</a></li><li><a href=\"struct.Fuse.html\">Fuse</a></li><li><a href=\"struct.Inspect.html\">Inspect</a></li><li><a href=\"struct.Intersperse.html\">Intersperse</a></li><li><a href=\"struct.IntersperseWith.html\">IntersperseWith</a></li><li><a href=\"struct.Map.html\">Map</a></li><li><a href=\"struct.MapWhile.html\">MapWhile</a></li><li><a href=\"struct.MapWindows.html\">MapWindows</a></li><li><a href=\"struct.Once.html\">Once</a></li><li><a href=\"struct.OnceWith.html\">OnceWith</a></li><li><a href=\"struct.Peekable.html\">Peekable</a></li><li><a href=\"struct.Repeat.html\">Repeat</a></li><li><a href=\"struct.RepeatN.html\">RepeatN</a></li><li><a href=\"struct.RepeatWith.html\">RepeatWith</a></li><li><a href=\"struct.Rev.html\">Rev</a></li><li><a href=\"struct.Scan.html\">Scan</a></li><li><a href=\"struct.Skip.html\">Skip</a></li><li><a href=\"struct.SkipWhile.html\">SkipWhile</a></li><li><a href=\"struct.StepBy.html\">StepBy</a></li><li><a href=\"struct.Successors.html\">Successors</a></li><li><a href=\"struct.Take.html\">Take</a></li><li><a href=\"struct.TakeWhile.html\">TakeWhile</a></li><li><a href=\"struct.Zip.html\">Zip</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.DoubleEndedIterator.html\">DoubleEndedIterator</a></li><li><a href=\"trait.ExactSizeIterator.html\">ExactSizeIterator</a></li><li><a href=\"trait.Extend.html\">Extend</a></li><li><a href=\"trait.FromIterator.html\">FromIterator</a></li><li><a href=\"trait.FusedIterator.html\">FusedIterator</a></li><li><a href=\"trait.IntoIterator.html\">IntoIterator</a></li><li><a href=\"trait.Iterator.html\">Iterator</a></li><li><a href=\"trait.Product.html\">Product</a></li><li><a href=\"trait.Step.html\">Step</a></li><li><a href=\"trait.Sum.html\">Sum</a></li><li><a href=\"trait.TrustedLen.html\">TrustedLen</a></li><li><a href=\"trait.TrustedStep.html\">TrustedStep</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.chain.html\">chain</a></li><li><a href=\"fn.empty.html\">empty</a></li><li><a href=\"fn.from_coroutine.html\">from_coroutine</a></li><li><a href=\"fn.from_fn.html\">from_fn</a></li><li><a href=\"fn.once.html\">once</a></li><li><a href=\"fn.once_with.html\">once_with</a></li><li><a href=\"fn.repeat.html\">repeat</a></li><li><a href=\"fn.repeat_n.html\">repeat_n</a></li><li><a href=\"fn.repeat_with.html\">repeat_with</a></li><li><a href=\"fn.successors.html\">successors</a></li><li><a href=\"fn.zip.html\">zip</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Trait <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">iter</a>::<wbr><a class=\"trait\" href=\"#\">Iterator</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#44\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub trait Iterator {\n    type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a>;\n\n<details class=\"toggle type-contents-toggle\"><summary class=\"hideme\"><span>Show 76 methods</span></summary>    // Required method\n    fn <a href=\"#tymethod.next\" class=\"fn\">next</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;;\n\n    // Provided methods\n    fn <a href=\"#method.next_chunk\" class=\"fn\">next_chunk</a>&lt;const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(\n        &amp;mut self,\n    ) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;[Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>], <a class=\"struct\" href=\"../array/struct.IntoIter.html\" title=\"struct std::array::IntoIter\">IntoIter</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, N&gt;&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.size_hint\" class=\"fn\">size_hint</a>(&amp;self) -&gt; (<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;) { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.count\" class=\"fn\">count</a>(self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.last\" class=\"fn\">last</a>(self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.advance_by\" class=\"fn\">advance_by</a>(&amp;mut self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../num/struct.NonZero.html\" title=\"struct std::num::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;&gt; { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.nth\" class=\"fn\">nth</a>(&amp;mut self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.step_by\" class=\"fn\">step_by</a>(self, step: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.StepBy.html\" title=\"struct std::iter::StepBy\">StepBy</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"StepBy<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.chain\" class=\"fn\">chain</a>&lt;U&gt;(self, other: U) -&gt; <a class=\"struct\" href=\"struct.Chain.html\" title=\"struct std::iter::Chain\">Chain</a>&lt;Self, &lt;U as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type std::iter::IntoIterator::IntoIter\">IntoIter</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Chain<Self, <U as IntoIterator>::IntoIter>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.zip\" class=\"fn\">zip</a>&lt;U&gt;(self, other: U) -&gt; <a class=\"struct\" href=\"struct.Zip.html\" title=\"struct std::iter::Zip\">Zip</a>&lt;Self, &lt;U as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type std::iter::IntoIterator::IntoIter\">IntoIter</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Zip<Self, <U as IntoIterator>::IntoIter>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.intersperse\" class=\"fn\">intersperse</a>(self, separator: Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"struct\" href=\"struct.Intersperse.html\" title=\"struct std::iter::Intersperse\">Intersperse</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Intersperse<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.intersperse_with\" class=\"fn\">intersperse_with</a>&lt;G&gt;(self, separator: G) -&gt; <a class=\"struct\" href=\"struct.IntersperseWith.html\" title=\"struct std::iter::IntersperseWith\">IntersperseWith</a>&lt;Self, G&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntersperseWith<Self, G>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             G: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>() -&gt; Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.map\" class=\"fn\">map</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.Map.html\" title=\"struct std::iter::Map\">Map</a>&lt;Self, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Map<Self, F>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.for_each\" class=\"fn\">for_each</a>&lt;F&gt;(self, f: F)\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>)</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.filter\" class=\"fn\">filter</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.Filter.html\" title=\"struct std::iter::Filter\">Filter</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Filter<Self, P>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.filter_map\" class=\"fn\">filter_map</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.FilterMap.html\" title=\"struct std::iter::FilterMap\">FilterMap</a>&lt;Self, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"FilterMap<Self, F>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.enumerate\" class=\"fn\">enumerate</a>(self) -&gt; <a class=\"struct\" href=\"struct.Enumerate.html\" title=\"struct std::iter::Enumerate\">Enumerate</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Enumerate<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.peekable\" class=\"fn\">peekable</a>(self) -&gt; <a class=\"struct\" href=\"struct.Peekable.html\" title=\"struct std::iter::Peekable\">Peekable</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Peekable<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.skip_while\" class=\"fn\">skip_while</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.SkipWhile.html\" title=\"struct std::iter::SkipWhile\">SkipWhile</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SkipWhile<Self, P>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.take_while\" class=\"fn\">take_while</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.TakeWhile.html\" title=\"struct std::iter::TakeWhile\">TakeWhile</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"TakeWhile<Self, P>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.map_while\" class=\"fn\">map_while</a>&lt;B, P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.MapWhile.html\" title=\"struct std::iter::MapWhile\">MapWhile</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"MapWhile<Self, P>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.skip\" class=\"fn\">skip</a>(self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Skip.html\" title=\"struct std::iter::Skip\">Skip</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Skip<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.take\" class=\"fn\">take</a>(self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Take.html\" title=\"struct std::iter::Take\">Take</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Take<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.scan\" class=\"fn\">scan</a>&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; <a class=\"struct\" href=\"struct.Scan.html\" title=\"struct std::iter::Scan\">Scan</a>&lt;Self, St, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Scan<Self, St, F>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut St</a>, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.flat_map\" class=\"fn\">flat_map</a>&lt;U, F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.FlatMap.html\" title=\"struct std::iter::FlatMap\">FlatMap</a>&lt;Self, U, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"FlatMap<Self, U, F>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; U</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.flatten\" class=\"fn\">flatten</a>(self) -&gt; <a class=\"struct\" href=\"struct.Flatten.html\" title=\"struct std::iter::Flatten\">Flatten</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Flatten<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.map_windows\" class=\"fn\">map_windows</a>&lt;F, R, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.MapWindows.html\" title=\"struct std::iter::MapWindows\">MapWindows</a>&lt;Self, F, N&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"MapWindows<Self, F, N>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;[Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>]) -&gt; R</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.fuse\" class=\"fn\">fuse</a>(self) -&gt; <a class=\"struct\" href=\"struct.Fuse.html\" title=\"struct std::iter::Fuse\">Fuse</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Fuse<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.inspect\" class=\"fn\">inspect</a>&lt;F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.Inspect.html\" title=\"struct std::iter::Inspect\">Inspect</a>&lt;Self, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Inspect<Self, F>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>)</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.by_ref\" class=\"fn\">by_ref</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut Self</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.collect\" class=\"fn\">collect</a>&lt;B&gt;(self) -&gt; B\n       <span class=\"where\">where B: <a class=\"trait\" href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.try_collect\" class=\"fn\">try_collect</a>&lt;B&gt;(\n        &amp;mut self,\n    ) -&gt; &lt;&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a> as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a> as <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;B&gt;&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Residual.html#associatedtype.TryType\" title=\"type std::ops::Residual::TryType\">TryType</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>,\n             &lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a> as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a>: <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;B&gt;,\n             B: <a class=\"trait\" href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a> as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Output\" title=\"type std::ops::Try::Output\">Output</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.collect_into\" class=\"fn\">collect_into</a>&lt;E&gt;(self, collection: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut E</a>) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut E</a>\n       <span class=\"where\">where E: <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.partition\" class=\"fn\">partition</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.tuple.html\">(B, B)</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             B: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> + <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.partition_in_place\" class=\"fn\">partition_in_place</a>&lt;'a, T, P&gt;(self, predicate: P) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>\n       <span class=\"where\">where T: 'a,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut T</a>&gt;,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.is_partitioned\" class=\"fn\">is_partitioned</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.try_fold\" class=\"fn\">try_fold</a>&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(B, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n             R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = B&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.try_for_each\" class=\"fn\">try_for_each</a>&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n             R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = <a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.fold\" class=\"fn\">fold</a>&lt;B, F&gt;(self, init: B, f: F) -&gt; B\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(B, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.reduce\" class=\"fn\">reduce</a>&lt;F&gt;(self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.try_reduce\" class=\"fn\">try_reduce</a>&lt;F, R&gt;(\n        &amp;mut self,\n        f: F,\n    ) -&gt; &lt;&lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a> as <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Output\" title=\"type std::ops::Try::Output\">Output</a>&gt;&gt;&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Residual.html#associatedtype.TryType\" title=\"type std::ops::Residual::TryType\">TryType</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n             R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n             &lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a>: <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.all\" class=\"fn\">all</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.any\" class=\"fn\">any</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.find\" class=\"fn\">find</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.find_map\" class=\"fn\">find_map</a>&lt;B, F&gt;(&amp;mut self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.try_find\" class=\"fn\">try_find</a>&lt;F, R&gt;(\n        &amp;mut self,\n        f: F,\n    ) -&gt; &lt;&lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a> as <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;&gt;&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Residual.html#associatedtype.TryType\" title=\"type std::ops::Residual::TryType\">TryType</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n             R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>&gt;,\n             &lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a>: <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.position\" class=\"fn\">position</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.rposition\" class=\"fn\">rposition</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;\n       <span class=\"where\">where P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ExactSizeIterator.html\" title=\"trait std::iter::ExactSizeIterator\">ExactSizeIterator</a> + <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.max\" class=\"fn\">max</a>(self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.min\" class=\"fn\">min</a>(self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.max_by_key\" class=\"fn\">max_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where B: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.max_by\" class=\"fn\">max_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.min_by_key\" class=\"fn\">min_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where B: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.min_by\" class=\"fn\">min_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.rev\" class=\"fn\">rev</a>(self) -&gt; <a class=\"struct\" href=\"struct.Rev.html\" title=\"struct std::iter::Rev\">Rev</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Rev<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.unzip\" class=\"fn\">unzip</a>&lt;A, B, FromA, FromB&gt;(self) -&gt; <a class=\"primitive\" href=\"../primitive.tuple.html\">(FromA, FromB)</a>\n       <span class=\"where\">where FromA: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> + <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;A&gt;,\n             FromB: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> + <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;B&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.tuple.html\">(A, B)</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.copied\" class=\"fn\">copied</a>&lt;'a, T&gt;(self) -&gt; <a class=\"struct\" href=\"struct.Copied.html\" title=\"struct std::iter::Copied\">Copied</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Copied<Self>\">ⓘ</a>\n       <span class=\"where\">where T: 'a + <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.cloned\" class=\"fn\">cloned</a>&lt;'a, T&gt;(self) -&gt; <a class=\"struct\" href=\"struct.Cloned.html\" title=\"struct std::iter::Cloned\">Cloned</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Cloned<Self>\">ⓘ</a>\n       <span class=\"where\">where T: 'a + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.cycle\" class=\"fn\">cycle</a>(self) -&gt; <a class=\"struct\" href=\"struct.Cycle.html\" title=\"struct std::iter::Cycle\">Cycle</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Cycle<Self>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.array_chunks\" class=\"fn\">array_chunks</a>&lt;const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(self) -&gt; <a class=\"struct\" href=\"struct.ArrayChunks.html\" title=\"struct std::iter::ArrayChunks\">ArrayChunks</a>&lt;Self, N&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"ArrayChunks<Self, N>\">ⓘ</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.sum\" class=\"fn\">sum</a>&lt;S&gt;(self) -&gt; S\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             S: <a class=\"trait\" href=\"trait.Sum.html\" title=\"trait std::iter::Sum\">Sum</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.product\" class=\"fn\">product</a>&lt;P&gt;(self) -&gt; P\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             P: <a class=\"trait\" href=\"trait.Product.html\" title=\"trait std::iter::Product\">Product</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.cmp\" class=\"fn\">cmp</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.cmp_by\" class=\"fn\">cmp_by</a>&lt;I, F&gt;(self, other: I, cmp: F) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.partial_cmp\" class=\"fn\">partial_cmp</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.partial_cmp_by\" class=\"fn\">partial_cmp_by</a>&lt;I, F&gt;(self, other: I, partial_cmp: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.eq\" class=\"fn\">eq</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.eq_by\" class=\"fn\">eq_by</a>&lt;I, F&gt;(self, other: I, eq: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.ne\" class=\"fn\">ne</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.lt\" class=\"fn\">lt</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.le\" class=\"fn\">le</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.gt\" class=\"fn\">gt</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.ge\" class=\"fn\">ge</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n             Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.is_sorted\" class=\"fn\">is_sorted</a>(self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.is_sorted_by\" class=\"fn\">is_sorted_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></span> { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.is_sorted_by_key\" class=\"fn\">is_sorted_by_key</a>&lt;F, K&gt;(self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n             F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; K,\n             K: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a></span> { ... }\n</details>}</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A trait for dealing with iterators.</p>\n<p>This is the main iterator trait. For more about the concept of iterators\ngenerally, please see the <a href=\"index.html\" title=\"mod std::iter\">module-level documentation</a>. In particular, you\nmay want to know how to <a href=\"index.html#implementing-iterator\" title=\"mod std::iter\">implement <code>Iterator</code></a>.</p>\n</div></details><h2 id=\"required-associated-types\" class=\"section-header\">Required Associated Types<a href=\"#required-associated-types\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Item\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#48\">source</a></span><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a></h4></section></summary><div class=\"docblock\"><p>The type of the elements being iterated over.</p>\n</div></details></div><h2 id=\"required-methods\" class=\"section-header\">Required Methods<a href=\"#required-methods\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.next\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#80\">source</a></span><h4 class=\"code-header\">fn <a href=\"#tymethod.next\" class=\"fn\">next</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Advances the iterator and returns the next value.</p>\n<p>Returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> when iteration is finished. Individual iterator\nimplementations may choose to resume iteration, and so calling <code>next()</code>\nagain may or may not eventually start returning <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(Item)</code></a> again at some\npoint.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"comment\">// A call to next() returns the next value...\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>), iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>), iter.next());\n\n<span class=\"comment\">// ... and then None once it's over.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());\n\n<span class=\"comment\">// More calls may or may not return `None`. Here, they always will.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, iter.next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++//+A+call+to+next()+returns+the+next+value...%0A++++assert_eq!(Some(%261),+iter.next());%0A++++assert_eq!(Some(%262),+iter.next());%0A++++assert_eq!(Some(%263),+iter.next());%0A++++%0A++++//+...+and+then+None+once+it's+over.%0A++++assert_eq!(None,+iter.next());%0A++++%0A++++//+More+calls+may+or+may+not+return+%60None%60.+Here,+they+always+will.%0A++++assert_eq!(None,+iter.next());%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div><h2 id=\"provided-methods\" class=\"section-header\">Provided Methods<a href=\"#provided-methods\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.next_chunk\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#115-119\">source</a><h4 class=\"code-header\">fn <a href=\"#method.next_chunk\" class=\"fn\">next_chunk</a>&lt;const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;[Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>], <a class=\"struct\" href=\"../array/struct.IntoIter.html\" title=\"struct std::array::IntoIter\">IntoIter</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, N&gt;&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_next_chunk</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/98326\">#98326</a>)</span></div></span></summary><div class=\"docblock\"><p>Advances the iterator and returns an array containing the next <code>N</code> values.</p>\n<p>If there are not enough elements to fill the array then <code>Err</code> is returned\ncontaining an iterator over the remaining elements.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_next_chunk)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = <span class=\"string\">\"lorem\"</span>.chars();\n\n<span class=\"macro\">assert_eq!</span>(iter.next_chunk().unwrap(), [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>]);              <span class=\"comment\">// N is inferred as 2\n</span><span class=\"macro\">assert_eq!</span>(iter.next_chunk().unwrap(), [<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>]);         <span class=\"comment\">// N is inferred as 3\n</span><span class=\"macro\">assert_eq!</span>(iter.next_chunk::&lt;<span class=\"number\">4</span>&gt;().unwrap_err().as_slice(), <span class=\"kw-2\">&amp;</span>[]); <span class=\"comment\">// N is explicitly 4</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_next_chunk)%5D%0A%0Afn+main()+%7B%0A++++let+mut+iter+=+%22lorem%22.chars();%0A++++%0A++++assert_eq!(iter.next_chunk().unwrap(),+%5B'l',+'o'%5D);++++++++++++++//+N+is+inferred+as+2%0A++++assert_eq!(iter.next_chunk().unwrap(),+%5B'r',+'e',+'m'%5D);+++++++++//+N+is+inferred+as+3%0A++++assert_eq!(iter.next_chunk::%3C4%3E().unwrap_err().as_slice(),+%26%5B%5D);+//+N+is+explicitly+4%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Split a string and get the first three items.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_next_chunk)]\n\n</span><span class=\"kw\">let </span>quote = <span class=\"string\">\"not all those who wander are lost\"</span>;\n<span class=\"kw\">let </span>[first, second, third] = quote.split_whitespace().next_chunk().unwrap();\n<span class=\"macro\">assert_eq!</span>(first, <span class=\"string\">\"not\"</span>);\n<span class=\"macro\">assert_eq!</span>(second, <span class=\"string\">\"all\"</span>);\n<span class=\"macro\">assert_eq!</span>(third, <span class=\"string\">\"those\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_next_chunk)%5D%0A%0Afn+main()+%7B%0A++++let+quote+=+%22not+all+those+who+wander+are+lost%22;%0A++++let+%5Bfirst,+second,+third%5D+=+quote.split_whitespace().next_chunk().unwrap();%0A++++assert_eq!(first,+%22not%22);%0A++++assert_eq!(second,+%22all%22);%0A++++assert_eq!(third,+%22those%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.size_hint\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#193\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.size_hint\" class=\"fn\">size_hint</a>(&amp;self) -&gt; (<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;)</h4></section></summary><div class=\"docblock\"><p>Returns the bounds on the remaining length of the iterator.</p>\n<p>Specifically, <code>size_hint()</code> returns a tuple where the first element\nis the lower bound, and the second element is the upper bound.</p>\n<p>The second half of the tuple that is returned is an <code><a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"../primitive.usize.html\" title=\"primitive usize\">usize</a>&gt;</code>.\nA <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> here means that either there is no known upper bound, or the\nupper bound is larger than <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>.</p>\n<h5 id=\"implementation-notes\"><a class=\"doc-anchor\" href=\"#implementation-notes\">§</a>Implementation notes</h5>\n<p>It is not enforced that an iterator implementation yields the declared\nnumber of elements. A buggy iterator may yield less than the lower bound\nor more than the upper bound of elements.</p>\n<p><code>size_hint()</code> is primarily intended to be used for optimizations such as\nreserving space for the elements of the iterator, but must not be\ntrusted to e.g., omit bounds checks in unsafe code. An incorrect\nimplementation of <code>size_hint()</code> should not lead to memory safety\nviolations.</p>\n<p>That said, the implementation should provide a correct estimation,\nbecause otherwise it would be a violation of the trait’s protocol.</p>\n<p>The default implementation returns <code>(0, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\">None</a>)</code> which is correct for any\niterator.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">3</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>)), iter.size_hint());\n<span class=\"kw\">let _ </span>= iter.next();\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">2</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>)), iter.size_hint());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!((3,+Some(3)),+iter.size_hint());%0A++++let+_+=+iter.next();%0A++++assert_eq!((2,+Some(2)),+iter.size_hint());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A more complex example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// The even numbers in the range of zero to nine.\n</span><span class=\"kw\">let </span>iter = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).filter(|x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>);\n\n<span class=\"comment\">// We might iterate from zero to ten times. Knowing that it's five\n// exactly wouldn't be possible without executing filter().\n</span><span class=\"macro\">assert_eq!</span>((<span class=\"number\">0</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">10</span>)), iter.size_hint());\n\n<span class=\"comment\">// Let's add five more numbers with chain()\n</span><span class=\"kw\">let </span>iter = (<span class=\"number\">0</span>..<span class=\"number\">10</span>).filter(|x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>).chain(<span class=\"number\">15</span>..<span class=\"number\">20</span>);\n\n<span class=\"comment\">// now both bounds are increased by five\n</span><span class=\"macro\">assert_eq!</span>((<span class=\"number\">5</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">15</span>)), iter.size_hint());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+The+even+numbers+in+the+range+of+zero+to+nine.%0Afn+main()+%7B%0A++++let+iter+=+(0..10).filter(%7Cx%7C+x+%25+2+==+0);%0A++++%0A++++//+We+might+iterate+from+zero+to+ten+times.+Knowing+that+it's+five%0A++++//+exactly+wouldn't+be+possible+without+executing+filter().%0A++++assert_eq!((0,+Some(10)),+iter.size_hint());%0A++++%0A++++//+Let's+add+five+more+numbers+with+chain()%0A++++let+iter+=+(0..10).filter(%7Cx%7C+x+%25+2+==+0).chain(15..20);%0A++++%0A++++//+now+both+bounds+are+increased+by+five%0A++++assert_eq!((5,+Some(15)),+iter.size_hint());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Returning <code>None</code> for an upper bound:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// an infinite iterator has no upper bound\n// and the maximum possible lower bound\n</span><span class=\"kw\">let </span>iter = <span class=\"number\">0</span>..;\n\n<span class=\"macro\">assert_eq!</span>((usize::MAX, <span class=\"prelude-val\">None</span>), iter.size_hint());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+an+infinite+iterator+has+no+upper+bound%0A//+and+the+maximum+possible+lower+bound%0Afn+main()+%7B%0A++++let+iter+=+0..;%0A++++%0A++++assert_eq!((usize::MAX,+None),+iter.size_hint());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.count\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#229-231\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.count\" class=\"fn\">count</a>(self) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Consumes the iterator, counting the number of iterations and returning it.</p>\n<p>This method will call <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> repeatedly until <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is encountered,\nreturning the number of times it saw <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some</code></a>. Note that <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> has to be\ncalled at least once even if the iterator does not have any elements.</p>\n<h5 id=\"overflow-behavior\"><a class=\"doc-anchor\" href=\"#overflow-behavior\">§</a>Overflow Behavior</h5>\n<p>The method does no guarding against overflows, so counting elements of\nan iterator with more than <a href=\"../primitive.usize.html#associatedconstant.MAX\" title=\"associated constant usize::MAX\"><code>usize::MAX</code></a> elements either produces the\nwrong result or panics. If debug assertions are enabled, a panic is\nguaranteed.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function might panic if the iterator has more than <a href=\"../primitive.usize.html#associatedconstant.MAX\" title=\"associated constant usize::MAX\"><code>usize::MAX</code></a>\nelements.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"macro\">assert_eq!</span>(a.iter().count(), <span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n<span class=\"macro\">assert_eq!</span>(a.iter().count(), <span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().count(),+3);%0A++++%0A++++let+a+=+%5B1,+2,+3,+4,+5%5D;%0A++++assert_eq!(a.iter().count(),+5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.last\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#258-260\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.last\" class=\"fn\">last</a>(self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Consumes the iterator, returning the last element.</p>\n<p>This method will evaluate the iterator until it returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>. While\ndoing so, it keeps track of the current element. After <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is\nreturned, <code>last()</code> will then return the last element it saw.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"macro\">assert_eq!</span>(a.iter().last(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n\n<span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n<span class=\"macro\">assert_eq!</span>(a.iter().last(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().last(),+Some(%263));%0A++++%0A++++let+a+=+%5B1,+2,+3,+4,+5%5D;%0A++++assert_eq!(a.iter().last(),+Some(%265));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.advance_by\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#306\">source</a><h4 class=\"code-header\">fn <a href=\"#method.advance_by\" class=\"fn\">advance_by</a>(&amp;mut self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../num/struct.NonZero.html\" title=\"struct std::num::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_advance_by</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/77404\">#77404</a>)</span></div></span></summary><div class=\"docblock\"><p>Advances the iterator by <code>n</code> elements.</p>\n<p>This method will eagerly skip <code>n</code> elements by calling <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> up to <code>n</code>\ntimes until <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is encountered.</p>\n<p><code>advance_by(n)</code> will return <code>Ok(())</code> if the iterator successfully advances by\n<code>n</code> elements, or a <code>Err(NonZero&lt;usize&gt;)</code> with value <code>k</code> if <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is encountered,\nwhere <code>k</code> is remaining number of steps that could not be advanced because the iterator ran out.\nIf <code>self</code> is empty and <code>n</code> is non-zero, then this returns <code>Err(n)</code>.\nOtherwise, <code>k</code> is always less than <code>n</code>.</p>\n<p>Calling <code>advance_by(0)</code> can do meaningful work, for example <a href=\"struct.Flatten.html\" title=\"struct std::iter::Flatten\"><code>Flatten</code></a>\ncan advance its outer iterator until it finds an inner iterator that is not empty, which\nthen often allows it to return a more accurate <code>size_hint()</code> than in its initial state.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_advance_by)]\n\n</span><span class=\"kw\">use </span>std::num::NonZero;\n\n<span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert_eq!</span>(iter.advance_by(<span class=\"number\">2</span>), <span class=\"prelude-val\">Ok</span>(()));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.advance_by(<span class=\"number\">0</span>), <span class=\"prelude-val\">Ok</span>(()));\n<span class=\"macro\">assert_eq!</span>(iter.advance_by(<span class=\"number\">100</span>), <span class=\"prelude-val\">Err</span>(NonZero::new(<span class=\"number\">99</span>).unwrap())); <span class=\"comment\">// only `&amp;4` was skipped</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_advance_by)%5D%0A%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.advance_by(2),+Ok(()));%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.advance_by(0),+Ok(()));%0A++++assert_eq!(iter.advance_by(100),+Err(NonZero::new(99).unwrap()));+//+only+%60%264%60+was+skipped%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.nth\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#358\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.nth\" class=\"fn\">nth</a>(&amp;mut self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the <code>n</code>th element of the iterator.</p>\n<p>Like most indexing operations, the count starts from zero, so <code>nth(0)</code>\nreturns the first value, <code>nth(1)</code> the second, and so on.</p>\n<p>Note that all preceding elements, as well as the returned element, will be\nconsumed from the iterator. That means that the preceding elements will be\ndiscarded, and also that calling <code>nth(0)</code> multiple times on the same iterator\nwill return different elements.</p>\n<p><code>nth()</code> will return <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> if <code>n</code> is greater than or equal to the length of the\niterator.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"macro\">assert_eq!</span>(a.iter().nth(<span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().nth(1),+Some(%262));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Calling <code>nth()</code> multiple times doesn’t rewind the iterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert_eq!</span>(iter.nth(<span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.nth(<span class=\"number\">1</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.nth(1),+Some(%262));%0A++++assert_eq!(iter.nth(1),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Returning <code>None</code> if there are less than <code>n + 1</code> elements:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"macro\">assert_eq!</span>(a.iter().nth(<span class=\"number\">10</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++assert_eq!(a.iter().nth(10),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.step_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#409-411\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.step_by\" class=\"fn\">step_by</a>(self, step: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.StepBy.html\" title=\"struct std::iter::StepBy\">StepBy</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"StepBy<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator starting at the same point, but stepping by\nthe given amount at each iteration.</p>\n<p>Note 1: The first element of the iterator will always be returned,\nregardless of the step given.</p>\n<p>Note 2: The time at which ignored elements are pulled is not fixed.\n<code>StepBy</code> behaves like the sequence <code>self.next()</code>, <code>self.nth(step-1)</code>,\n<code>self.nth(step-1)</code>, …, but is also free to behave like the sequence\n<code>advance_n_and_return_first(&amp;mut self, step)</code>,\n<code>advance_n_and_return_first(&amp;mut self, step)</code>, …\nWhich way is used may change for some iterators for performance reasons.\nThe second way will advance the iterator earlier and may consume more items.</p>\n<p><code>advance_n_and_return_first</code> is the equivalent of:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>advance_n_and_return_first&lt;I&gt;(iter: <span class=\"kw-2\">&amp;mut </span>I, n: usize) -&gt; <span class=\"prelude-ty\">Option</span>&lt;I::Item&gt;\n<span class=\"kw\">where\n    </span>I: Iterator,\n{\n    <span class=\"kw\">let </span>next = iter.next();\n    <span class=\"kw\">if </span>n &gt; <span class=\"number\">1 </span>{\n        iter.nth(n - <span class=\"number\">2</span>);\n    }\n    next\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+advance_n_and_return_first%3CI%3E(iter:+%26mut+I,+n:+usize)+-%3E+Option%3CI::Item%3E%0A++++where%0A++++++++I:+Iterator,%0A++++%7B%0A++++++++let+next+=+iter.next();%0A++++++++if+n+%3E+1+%7B%0A++++++++++++iter.nth(n+-+2);%0A++++++++%7D%0A++++++++next%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>The method will panic if the given step is <code>0</code>.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().step_by(<span class=\"number\">2</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2,+3,+4,+5%5D;%0A++++let+mut+iter+=+a.iter().step_by(2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%264));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.chain\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#481-484\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.chain\" class=\"fn\">chain</a>&lt;U&gt;(self, other: U) -&gt; <a class=\"struct\" href=\"struct.Chain.html\" title=\"struct std::iter::Chain\">Chain</a>&lt;Self, &lt;U as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type std::iter::IntoIterator::IntoIter\">IntoIter</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Chain<Self, <U as IntoIterator>::IntoIter>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Takes two iterators and creates a new iterator over both in sequence.</p>\n<p><code>chain()</code> will return a new iterator which will first iterate over\nvalues from the first iterator and then over values from the second\niterator.</p>\n<p>In other words, it links two iterators together, in a chain. 🔗</p>\n<p><a href=\"fn.once.html\" title=\"fn std::iter::once\"><code>once</code></a> is commonly used to adapt a single value into a chain of\nother kinds of iteration.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>a2 = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a1.iter().chain(a2.iter());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">6</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a1+=+%5B1,+2,+3%5D;%0A++++let+a2+=+%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+a1.iter().chain(a2.iter());%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+Some(%264));%0A++++assert_eq!(iter.next(),+Some(%265));%0A++++assert_eq!(iter.next(),+Some(%266));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Since the argument to <code>chain()</code> uses <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>, we can pass\nanything that can be converted into an <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>, not just an\n<a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> itself. For example, slices (<code>&amp;[T]</code>) implement\n<a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>, and so can be passed to <code>chain()</code> directly:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s1 = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>s2 = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = s1.iter().chain(s2);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">6</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1+=+%26%5B1,+2,+3%5D;%0A++++let+s2+=+%26%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+s1.iter().chain(s2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+Some(%264));%0A++++assert_eq!(iter.next(),+Some(%265));%0A++++assert_eq!(iter.next(),+Some(%266));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If you work with Windows API, you may wish to convert <a href=\"../../std/ffi/struct.OsStr.html\"><code>OsStr</code></a> to <code>Vec&lt;u16&gt;</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[cfg(windows)]\n</span><span class=\"kw\">fn </span>os_str_to_utf16(s: <span class=\"kw-2\">&amp;</span>std::ffi::OsStr) -&gt; Vec&lt;u16&gt; {\n    <span class=\"kw\">use </span>std::os::windows::ffi::OsStrExt;\n    s.encode_wide().chain(std::iter::once(<span class=\"number\">0</span>)).collect()\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(windows)%5D%0A++++fn+os_str_to_utf16(s:+%26std::ffi::OsStr)+-%3E+Vec%3Cu16%3E+%7B%0A++++++++use+std::os::windows::ffi::OsStrExt;%0A++++++++s.encode_wide().chain(std::iter::once(0)).collect()%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.zip\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#600-603\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.zip\" class=\"fn\">zip</a>&lt;U&gt;(self, other: U) -&gt; <a class=\"struct\" href=\"struct.Zip.html\" title=\"struct std::iter::Zip\">Zip</a>&lt;Self, &lt;U as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type std::iter::IntoIterator::IntoIter\">IntoIter</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Zip<Self, <U as IntoIterator>::IntoIter>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,</div></h4></section></summary><div class=\"docblock\"><p>‘Zips up’ two iterators into a single iterator of pairs.</p>\n<p><code>zip()</code> returns a new iterator that will iterate over two other\niterators, returning a tuple where the first element comes from the\nfirst iterator, and the second element comes from the second iterator.</p>\n<p>In other words, it zips two iterators together, into a single one.</p>\n<p>If either iterator returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> from the zipped iterator\nwill return <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.\nIf the zipped iterator has no more elements to return then each further attempt to advance\nit will first try to advance the first iterator at most one time and if it still yielded an item\ntry to advance the second iterator at most one time.</p>\n<p>To ‘undo’ the result of zipping up two iterators, see <a href=\"trait.Iterator.html#method.unzip\" title=\"method std::iter::Iterator::unzip\"><code>unzip</code></a>.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>a2 = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a1.iter().zip(a2.iter());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">6</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a1+=+%5B1,+2,+3%5D;%0A++++let+a2+=+%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+a1.iter().zip(a2.iter());%0A++++%0A++++assert_eq!(iter.next(),+Some((%261,+%264)));%0A++++assert_eq!(iter.next(),+Some((%262,+%265)));%0A++++assert_eq!(iter.next(),+Some((%263,+%266)));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Since the argument to <code>zip()</code> uses <a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>, we can pass\nanything that can be converted into an <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a>, not just an\n<a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> itself. For example, slices (<code>&amp;[T]</code>) implement\n<a href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\"><code>IntoIterator</code></a>, and so can be passed to <code>zip()</code> directly:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s1 = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>s2 = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = s1.iter().zip(s2);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">6</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1+=+%26%5B1,+2,+3%5D;%0A++++let+s2+=+%26%5B4,+5,+6%5D;%0A++++%0A++++let+mut+iter+=+s1.iter().zip(s2);%0A++++%0A++++assert_eq!(iter.next(),+Some((%261,+%264)));%0A++++assert_eq!(iter.next(),+Some((%262,+%265)));%0A++++assert_eq!(iter.next(),+Some((%263,+%266)));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>zip()</code> is often used to zip an infinite iterator to a finite one.\nThis works because the finite iterator will eventually return <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>,\nending the zipper. Zipping with <code>(0..)</code> can look a lot like <a href=\"trait.Iterator.html#method.enumerate\" title=\"method std::iter::Iterator::enumerate\"><code>enumerate</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>enumerate: Vec&lt;<span class=\"kw\">_</span>&gt; = <span class=\"string\">\"foo\"</span>.chars().enumerate().collect();\n\n<span class=\"kw\">let </span>zipper: Vec&lt;<span class=\"kw\">_</span>&gt; = (<span class=\"number\">0</span>..).zip(<span class=\"string\">\"foo\"</span>.chars()).collect();\n\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">0</span>, <span class=\"string\">'f'</span>), enumerate[<span class=\"number\">0</span>]);\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">0</span>, <span class=\"string\">'f'</span>), zipper[<span class=\"number\">0</span>]);\n\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">1</span>, <span class=\"string\">'o'</span>), enumerate[<span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">1</span>, <span class=\"string\">'o'</span>), zipper[<span class=\"number\">1</span>]);\n\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">2</span>, <span class=\"string\">'o'</span>), enumerate[<span class=\"number\">2</span>]);\n<span class=\"macro\">assert_eq!</span>((<span class=\"number\">2</span>, <span class=\"string\">'o'</span>), zipper[<span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+enumerate:+Vec%3C_%3E+=+%22foo%22.chars().enumerate().collect();%0A++++%0A++++let+zipper:+Vec%3C_%3E+=+(0..).zip(%22foo%22.chars()).collect();%0A++++%0A++++assert_eq!((0,+'f'),+enumerate%5B0%5D);%0A++++assert_eq!((0,+'f'),+zipper%5B0%5D);%0A++++%0A++++assert_eq!((1,+'o'),+enumerate%5B1%5D);%0A++++assert_eq!((1,+'o'),+zipper%5B1%5D);%0A++++%0A++++assert_eq!((2,+'o'),+enumerate%5B2%5D);%0A++++assert_eq!((2,+'o'),+zipper%5B2%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If both iterators have roughly equivalent syntax, it may be more readable to use <a href=\"fn.zip.html\" title=\"fn std::iter::zip\"><code>zip</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::iter::zip;\n\n<span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>b = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>zipped = zip(\n    a.into_iter().map(|x| x * <span class=\"number\">2</span>).skip(<span class=\"number\">1</span>),\n    b.into_iter().map(|x| x * <span class=\"number\">2</span>).skip(<span class=\"number\">1</span>),\n);\n\n<span class=\"macro\">assert_eq!</span>(zipped.next(), <span class=\"prelude-val\">Some</span>((<span class=\"number\">4</span>, <span class=\"number\">6</span>)));\n<span class=\"macro\">assert_eq!</span>(zipped.next(), <span class=\"prelude-val\">Some</span>((<span class=\"number\">6</span>, <span class=\"number\">8</span>)));\n<span class=\"macro\">assert_eq!</span>(zipped.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::iter::zip;%0A++++%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b+=+%5B2,+3,+4%5D;%0A++++%0A++++let+mut+zipped+=+zip(%0A++++++++a.into_iter().map(%7Cx%7C+x+*+2).skip(1),%0A++++++++b.into_iter().map(%7Cx%7C+x+*+2).skip(1),%0A++++);%0A++++%0A++++assert_eq!(zipped.next(),+Some((4,+6)));%0A++++assert_eq!(zipped.next(),+Some((6,+8)));%0A++++assert_eq!(zipped.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>compared to:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>zipped = a\n    .into_iter()\n    .map(|x| x * <span class=\"number\">2</span>)\n    .skip(<span class=\"number\">1</span>)\n    .zip(b.into_iter().map(|x| x * <span class=\"number\">2</span>).skip(<span class=\"number\">1</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b+=+%5B2,+3,+4%5D;%0A++++%0A++++let+mut+zipped+=+a%0A++++++++.into_iter()%0A++++++++.map(%7Cx%7C+x+*+2)%0A++++++++.skip(1)%0A++++++++.zip(b.into_iter().map(%7Cx%7C+x+*+2).skip(1));%0A++++%0A++++assert_eq!(zipped.next(),+Some((4,+6)));%0A++++assert_eq!(zipped.next(),+Some((6,+8)));%0A++++assert_eq!(zipped.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.intersperse\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#643-646\">source</a><h4 class=\"code-header\">fn <a href=\"#method.intersperse\" class=\"fn\">intersperse</a>(self, separator: Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"struct\" href=\"struct.Intersperse.html\" title=\"struct std::iter::Intersperse\">Intersperse</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Intersperse<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_intersperse</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/79524\">#79524</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates a new iterator which places a copy of <code>separator</code> between adjacent\nitems of the original iterator.</p>\n<p>In case <code>separator</code> does not implement <a href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\"><code>Clone</code></a> or needs to be\ncomputed every time, use <a href=\"trait.Iterator.html#method.intersperse_with\" title=\"method std::iter::Iterator::intersperse_with\"><code>intersperse_with</code></a>.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_intersperse)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().intersperse(<span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>);\n<span class=\"macro\">assert_eq!</span>(a.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>));   <span class=\"comment\">// The first element from `a`.\n</span><span class=\"macro\">assert_eq!</span>(a.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>)); <span class=\"comment\">// The separator.\n</span><span class=\"macro\">assert_eq!</span>(a.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));   <span class=\"comment\">// The next element from `a`.\n</span><span class=\"macro\">assert_eq!</span>(a.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>)); <span class=\"comment\">// The separator.\n</span><span class=\"macro\">assert_eq!</span>(a.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));   <span class=\"comment\">// The last element from `a`.\n</span><span class=\"macro\">assert_eq!</span>(a.next(), <span class=\"prelude-val\">None</span>);       <span class=\"comment\">// The iterator is finished.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++let+mut+a+=+%5B0,+1,+2%5D.iter().intersperse(%26100);%0A++++assert_eq!(a.next(),+Some(%260));+++//+The+first+element+from+%60a%60.%0A++++assert_eq!(a.next(),+Some(%26100));+//+The+separator.%0A++++assert_eq!(a.next(),+Some(%261));+++//+The+next+element+from+%60a%60.%0A++++assert_eq!(a.next(),+Some(%26100));+//+The+separator.%0A++++assert_eq!(a.next(),+Some(%262));+++//+The+last+element+from+%60a%60.%0A++++assert_eq!(a.next(),+None);+++++++//+The+iterator+is+finished.%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p><code>intersperse</code> can be very useful to join an iterator’s items using a common element:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_intersperse)]\n\n</span><span class=\"kw\">let </span>hello = [<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"World\"</span>, <span class=\"string\">\"!\"</span>].iter().copied().intersperse(<span class=\"string\">\" \"</span>).collect::&lt;String&gt;();\n<span class=\"macro\">assert_eq!</span>(hello, <span class=\"string\">\"Hello World !\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++let+hello+=+%5B%22Hello%22,+%22World%22,+%22!%22%5D.iter().copied().intersperse(%22+%22).collect::%3CString%3E();%0A++++assert_eq!(hello,+%22Hello+World+!%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.intersperse_with\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#702-705\">source</a><h4 class=\"code-header\">fn <a href=\"#method.intersperse_with\" class=\"fn\">intersperse_with</a>&lt;G&gt;(self, separator: G) -&gt; <a class=\"struct\" href=\"struct.IntersperseWith.html\" title=\"struct std::iter::IntersperseWith\">IntersperseWith</a>&lt;Self, G&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntersperseWith<Self, G>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    G: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>() -&gt; Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_intersperse</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/79524\">#79524</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates a new iterator which places an item generated by <code>separator</code>\nbetween adjacent items of the original iterator.</p>\n<p>The closure will be called exactly once each time an item is placed\nbetween two adjacent items from the underlying iterator; specifically,\nthe closure is not called if the underlying iterator yields less than\ntwo items and after the last item is yielded.</p>\n<p>If the iterator’s item implements <a href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\"><code>Clone</code></a>, it may be easier to use\n<a href=\"trait.Iterator.html#method.intersperse\" title=\"method std::iter::Iterator::intersperse\"><code>intersperse</code></a>.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_intersperse)]\n\n#[derive(PartialEq, Debug)]\n</span><span class=\"kw\">struct </span>NotClone(usize);\n\n<span class=\"kw\">let </span>v = [NotClone(<span class=\"number\">0</span>), NotClone(<span class=\"number\">1</span>), NotClone(<span class=\"number\">2</span>)];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = v.into_iter().intersperse_with(|| NotClone(<span class=\"number\">99</span>));\n\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(NotClone(<span class=\"number\">0</span>)));  <span class=\"comment\">// The first element from `v`.\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(NotClone(<span class=\"number\">99</span>))); <span class=\"comment\">// The separator.\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(NotClone(<span class=\"number\">1</span>)));  <span class=\"comment\">// The next element from `v`.\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(NotClone(<span class=\"number\">99</span>))); <span class=\"comment\">// The separator.\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(NotClone(<span class=\"number\">2</span>)));  <span class=\"comment\">// The last element from `v`.\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">None</span>);               <span class=\"comment\">// The iterator is finished.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++%23%5Bderive(PartialEq,+Debug)%5D%0A++++struct+NotClone(usize);%0A++++%0A++++let+v+=+%5BNotClone(0),+NotClone(1),+NotClone(2)%5D;%0A++++let+mut+it+=+v.into_iter().intersperse_with(%7C%7C+NotClone(99));%0A++++%0A++++assert_eq!(it.next(),+Some(NotClone(0)));++//+The+first+element+from+%60v%60.%0A++++assert_eq!(it.next(),+Some(NotClone(99)));+//+The+separator.%0A++++assert_eq!(it.next(),+Some(NotClone(1)));++//+The+next+element+from+%60v%60.%0A++++assert_eq!(it.next(),+Some(NotClone(99)));+//+The+separator.%0A++++assert_eq!(it.next(),+Some(NotClone(2)));++//+The+last+element+from+%60v%60.%0A++++assert_eq!(it.next(),+None);+++++++++++++++//+The+iterator+is+finished.%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p><code>intersperse_with</code> can be used in situations where the separator needs\nto be computed:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_intersperse)]\n\n</span><span class=\"kw\">let </span>src = [<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"to\"</span>, <span class=\"string\">\"all\"</span>, <span class=\"string\">\"people\"</span>, <span class=\"string\">\"!!\"</span>].iter().copied();\n\n<span class=\"comment\">// The closure mutably borrows its context to generate an item.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>happy_emojis = [<span class=\"string\">\" ❤️ \"</span>, <span class=\"string\">\" 😀 \"</span>].iter().copied();\n<span class=\"kw\">let </span>separator = || happy_emojis.next().unwrap_or(<span class=\"string\">\" 🦀 \"</span>);\n\n<span class=\"kw\">let </span>result = src.intersperse_with(separator).collect::&lt;String&gt;();\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"string\">\"Hello ❤️ to 😀 all 🦀 people 🦀 !!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_intersperse)%5D%0A%0Afn+main()+%7B%0A++++let+src+=+%5B%22Hello%22,+%22to%22,+%22all%22,+%22people%22,+%22!!%22%5D.iter().copied();%0A++++%0A++++//+The+closure+mutably+borrows+its+context+to+generate+an+item.%0A++++let+mut+happy_emojis+=+%5B%22+%E2%9D%A4%EF%B8%8F+%22,+%22+%F0%9F%98%80+%22%5D.iter().copied();%0A++++let+separator+=+%7C%7C+happy_emojis.next().unwrap_or(%22+%F0%9F%A6%80+%22);%0A++++%0A++++let+result+=+src.intersperse_with(separator).collect::%3CString%3E();%0A++++assert_eq!(result,+%22Hello+%E2%9D%A4%EF%B8%8F+to+%F0%9F%98%80+all+%F0%9F%A6%80+people+%F0%9F%A6%80+!!%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.map\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#762-765\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.map\" class=\"fn\">map</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.Map.html\" title=\"struct std::iter::Map\">Map</a>&lt;Self, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Map<Self, F>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B,</div></h4></section></summary><div class=\"docblock\"><p>Takes a closure and creates an iterator which calls that closure on each\nelement.</p>\n<p><code>map()</code> transforms one iterator into another, by means of its argument:\nsomething that implements <a href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\"><code>FnMut</code></a>. It produces a new iterator which\ncalls this closure on each element of the original iterator.</p>\n<p>If you are good at thinking in types, you can think of <code>map()</code> like this:\nIf you have an iterator that gives you elements of some type <code>A</code>, and\nyou want an iterator of some other type <code>B</code>, you can use <code>map()</code>,\npassing a closure that takes an <code>A</code> and returns a <code>B</code>.</p>\n<p><code>map()</code> is conceptually similar to a <a href=\"../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\"><code>for</code></a> loop. However, as <code>map()</code> is\nlazy, it is best used when you’re already working with other iterators.\nIf you’re doing some sort of looping for a side effect, it’s considered\nmore idiomatic to use <a href=\"../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\"><code>for</code></a> than <code>map()</code>.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().map(|x| <span class=\"number\">2 </span>* x);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">6</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().map(%7Cx%7C+2+*+x);%0A++++%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+Some(6));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If you’re doing some sort of side effect, prefer <a href=\"../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\"><code>for</code></a> to <code>map()</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// don't do this:\n</span>(<span class=\"number\">0</span>..<span class=\"number\">5</span>).map(|x| <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>));\n\n<span class=\"comment\">// it won't even execute, as it is lazy. Rust will warn you about this.\n\n// Instead, use for:\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">5 </span>{\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0A//+don't+do+this:%0Afn+main()+%7B%0A++++(0..5).map(%7Cx%7C+println!(%22%7Bx%7D%22));%0A++++%0A++++//+it+won't+even+execute,+as+it+is+lazy.+Rust+will+warn+you+about+this.%0A++++%0A++++//+Instead,+use+for:%0A++++for+x+in+0..5+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.for_each\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#808-811\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.for_each\" class=\"fn\">for_each</a>&lt;F&gt;(self, f: F)<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>),</div></h4></section></summary><div class=\"docblock\"><p>Calls a closure on each element of an iterator.</p>\n<p>This is equivalent to using a <a href=\"../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\"><code>for</code></a> loop on the iterator, although\n<code>break</code> and <code>continue</code> are not possible from a closure. It’s generally\nmore idiomatic to use a <code>for</code> loop, but <code>for_each</code> may be more legible\nwhen processing items at the end of longer iterator chains. In some\ncases <code>for_each</code> may also be faster than a loop, because it will use\ninternal iteration on adapters like <code>Chain</code>.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::mpsc::channel;\n\n<span class=\"kw\">let </span>(tx, rx) = channel();\n(<span class=\"number\">0</span>..<span class=\"number\">5</span>).map(|x| x * <span class=\"number\">2 </span>+ <span class=\"number\">1</span>)\n      .for_each(<span class=\"kw\">move </span>|x| tx.send(x).unwrap());\n\n<span class=\"kw\">let </span>v: Vec&lt;<span class=\"kw\">_</span>&gt; = rx.iter().collect();\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++let+(tx,+rx)+=+channel();%0A++++(0..5).map(%7Cx%7C+x+*+2+%2B+1)%0A++++++++++.for_each(move+%7Cx%7C+tx.send(x).unwrap());%0A++++%0A++++let+v:+Vec%3C_%3E+=+rx.iter().collect();%0A++++assert_eq!(v,+vec!%5B1,+3,+5,+7,+9%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>For such a small example, a <code>for</code> loop may be cleaner, but <code>for_each</code>\nmight be preferable to keep a functional style with longer iterators:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>(<span class=\"number\">0</span>..<span class=\"number\">5</span>).flat_map(|x| x * <span class=\"number\">100 </span>.. x * <span class=\"number\">110</span>)\n      .enumerate()\n      .filter(|<span class=\"kw-2\">&amp;</span>(i, x)| (i + x) % <span class=\"number\">3 </span>== <span class=\"number\">0</span>)\n      .for_each(|(i, x)| <span class=\"macro\">println!</span>(<span class=\"string\">\"{i}:{x}\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++(0..5).flat_map(%7Cx%7C+x+*+100+..+x+*+110)%0A++++++++++.enumerate()%0A++++++++++.filter(%7C%26(i,+x)%7C+(i+%2B+x)+%25+3+==+0)%0A++++++++++.for_each(%7C(i,+x)%7C+println!(%22%7Bi%7D:%7Bx%7D%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.filter\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#884-887\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.filter\" class=\"fn\">filter</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.Filter.html\" title=\"struct std::iter::Filter\">Filter</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Filter<Self, P>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator which uses a closure to determine if an element\nshould be yielded.</p>\n<p>Given an element the closure must return <code>true</code> or <code>false</code>. The returned\niterator will yield only the elements for which the closure returns\ntrue.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">0i32</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().filter(|x| x.is_positive());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0i32,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7Cx%7C+x.is_positive());%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because the closure passed to <code>filter()</code> takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure is a double reference:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().filter(|x| <span class=\"kw-2\">**</span>x &gt; <span class=\"number\">1</span>); <span class=\"comment\">// need two *s!\n\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7Cx%7C+**x+%3E+1);+//+need+two+*s!%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It’s common to instead use destructuring on the argument to strip away\none:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().filter(|<span class=\"kw-2\">&amp;</span>x| <span class=\"kw-2\">*</span>x &gt; <span class=\"number\">1</span>); <span class=\"comment\">// both &amp; and *\n\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7C%26x%7C+*x+%3E+1);+//+both+%26+and+*%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>or both:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().filter(|&amp;&amp;x| x &gt; <span class=\"number\">1</span>); <span class=\"comment\">// two &amp;s\n\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter(%7C%26%26x%7C+x+%3E+1);+//+two+%26s%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>of these layers.</p>\n<p>Note that <code>iter.filter(f).next()</code> is equivalent to <code>iter.find(f)</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.filter_map\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#930-933\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.filter_map\" class=\"fn\">filter_map</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.FilterMap.html\" title=\"struct std::iter::FilterMap\">FilterMap</a>&lt;Self, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"FilterMap<Self, F>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that both filters and maps.</p>\n<p>The returned iterator yields only the <code>value</code>s for which the supplied\nclosure returns <code>Some(value)</code>.</p>\n<p><code>filter_map</code> can be used to make chains of <a href=\"trait.Iterator.html#method.filter\" title=\"method std::iter::Iterator::filter\"><code>filter</code></a> and <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a> more\nconcise. The example below shows how a <code>map().filter().map()</code> can be\nshortened to a single call to <code>filter_map</code>.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"two\"</span>, <span class=\"string\">\"NaN\"</span>, <span class=\"string\">\"four\"</span>, <span class=\"string\">\"5\"</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().filter_map(|s| s.parse().ok());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%221%22,+%22two%22,+%22NaN%22,+%22four%22,+%225%22%5D;%0A++++%0A++++let+mut+iter+=+a.iter().filter_map(%7Cs%7C+s.parse().ok());%0A++++%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(5));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Here’s the same example, but with <a href=\"trait.Iterator.html#method.filter\" title=\"method std::iter::Iterator::filter\"><code>filter</code></a> and <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"two\"</span>, <span class=\"string\">\"NaN\"</span>, <span class=\"string\">\"four\"</span>, <span class=\"string\">\"5\"</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%221%22,+%22two%22,+%22NaN%22,+%22four%22,+%225%22%5D;%0A++++let+mut+iter+=+a.iter().map(%7Cs%7C+s.parse()).filter(%7Cs%7C+s.is_ok()).map(%7Cs%7C+s.unwrap());%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(5));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.enumerate\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#978-980\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.enumerate\" class=\"fn\">enumerate</a>(self) -&gt; <a class=\"struct\" href=\"struct.Enumerate.html\" title=\"struct std::iter::Enumerate\">Enumerate</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Enumerate<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator which gives the current iteration count as well as\nthe next value.</p>\n<p>The iterator returned yields pairs <code>(i, val)</code>, where <code>i</code> is the\ncurrent index of iteration and <code>val</code> is the value returned by the\niterator.</p>\n<p><code>enumerate()</code> keeps its count as a <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>. If you want to count by a\ndifferent sized integer, the <a href=\"trait.Iterator.html#method.zip\" title=\"method std::iter::Iterator::zip\"><code>zip</code></a> function provides similar\nfunctionality.</p>\n<h5 id=\"overflow-behavior-1\"><a class=\"doc-anchor\" href=\"#overflow-behavior-1\">§</a>Overflow Behavior</h5>\n<p>The method does no guarding against overflows, so enumerating more than\n<a href=\"../primitive.usize.html#associatedconstant.MAX\" title=\"associated constant usize::MAX\"><code>usize::MAX</code></a> elements either produces the wrong result or panics. If\ndebug assertions are enabled, a panic is guaranteed.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">§</a>Panics</h5>\n<p>The returned iterator might panic if the to-be-returned index would\noverflow a <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a>.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().enumerate();\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"number\">0</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">'a'</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">'b'</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>((<span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">'c'</span>)));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B'a',+'b',+'c'%5D;%0A++++%0A++++let+mut+iter+=+a.iter().enumerate();%0A++++%0A++++assert_eq!(iter.next(),+Some((0,+%26'a')));%0A++++assert_eq!(iter.next(),+Some((1,+%26'b')));%0A++++assert_eq!(iter.next(),+Some((2,+%26'c')));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.peekable\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1050-1052\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.peekable\" class=\"fn\">peekable</a>(self) -&gt; <a class=\"struct\" href=\"struct.Peekable.html\" title=\"struct std::iter::Peekable\">Peekable</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Peekable<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator which can use the <a href=\"struct.Peekable.html#method.peek\" title=\"method std::iter::Peekable::peek\"><code>peek</code></a> and <a href=\"struct.Peekable.html#method.peek_mut\" title=\"method std::iter::Peekable::peek_mut\"><code>peek_mut</code></a> methods\nto look at the next element of the iterator without consuming it. See\ntheir documentation for more information.</p>\n<p>Note that the underlying iterator is still advanced when <a href=\"struct.Peekable.html#method.peek\" title=\"method std::iter::Peekable::peek\"><code>peek</code></a> or\n<a href=\"struct.Peekable.html#method.peek_mut\" title=\"method std::iter::Peekable::peek_mut\"><code>peek_mut</code></a> are called for the first time: In order to retrieve the\nnext element, <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> is called on the underlying iterator, hence any\nside effects (i.e. anything other than fetching the next value) of\nthe <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>next</code></a> method will occur.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>xs = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = xs.iter().peekable();\n\n<span class=\"comment\">// peek() lets us see into the future\n</span><span class=\"macro\">assert_eq!</span>(iter.peek(), <span class=\"prelude-val\">Some</span>(&amp;&amp;<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n\n<span class=\"comment\">// we can peek() multiple times, the iterator won't advance\n</span><span class=\"macro\">assert_eq!</span>(iter.peek(), <span class=\"prelude-val\">Some</span>(&amp;&amp;<span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.peek(), <span class=\"prelude-val\">Some</span>(&amp;&amp;<span class=\"number\">3</span>));\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n\n<span class=\"comment\">// after the iterator is finished, so is peek()\n</span><span class=\"macro\">assert_eq!</span>(iter.peek(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+xs+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+xs.iter().peekable();%0A++++%0A++++//+peek()+lets+us+see+into+the+future%0A++++assert_eq!(iter.peek(),+Some(%26%261));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++%0A++++//+we+can+peek()+multiple+times,+the+iterator+won't+advance%0A++++assert_eq!(iter.peek(),+Some(%26%263));%0A++++assert_eq!(iter.peek(),+Some(%26%263));%0A++++%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++%0A++++//+after+the+iterator+is+finished,+so+is+peek()%0A++++assert_eq!(iter.peek(),+None);%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <a href=\"struct.Peekable.html#method.peek_mut\" title=\"method std::iter::Peekable::peek_mut\"><code>peek_mut</code></a> to mutate the next item without advancing the\niterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>xs = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = xs.iter().peekable();\n\n<span class=\"comment\">// `peek_mut()` lets us see into the future\n</span><span class=\"macro\">assert_eq!</span>(iter.peek_mut(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut &amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.peek_mut(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut &amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">mut </span>p) = iter.peek_mut() {\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>p, <span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>);\n    <span class=\"comment\">// put a value into the iterator\n    </span><span class=\"kw-2\">*</span>p = <span class=\"kw-2\">&amp;</span><span class=\"number\">1000</span>;\n}\n\n<span class=\"comment\">// The value reappears as the iterator continues\n</span><span class=\"macro\">assert_eq!</span>(iter.collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), <span class=\"macro\">vec!</span>[<span class=\"kw-2\">&amp;</span><span class=\"number\">1000</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+xs+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+xs.iter().peekable();%0A++++%0A++++//+%60peek_mut()%60+lets+us+see+into+the+future%0A++++assert_eq!(iter.peek_mut(),+Some(%26mut+%261));%0A++++assert_eq!(iter.peek_mut(),+Some(%26mut+%261));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++if+let+Some(mut+p)+=+iter.peek_mut()+%7B%0A++++++++assert_eq!(*p,+%262);%0A++++++++//+put+a+value+into+the+iterator%0A++++++++*p+=+%261000;%0A++++%7D%0A++++%0A++++//+The+value+reappears+as+the+iterator+continues%0A++++assert_eq!(iter.collect::%3CVec%3C_%3E%3E(),+vec!%5B%261000,+%263%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.skip_while\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1116-1119\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.skip_while\" class=\"fn\">skip_while</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.SkipWhile.html\" title=\"struct std::iter::SkipWhile\">SkipWhile</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SkipWhile<Self, P>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that <a href=\"trait.Iterator.html#method.skip\" title=\"method std::iter::Iterator::skip\"><code>skip</code></a>s elements based on a predicate.</p>\n<p><code>skip_while()</code> takes a closure as an argument. It will call this\nclosure on each element of the iterator, and ignore elements\nuntil it returns <code>false</code>.</p>\n<p>After <code>false</code> is returned, <code>skip_while()</code>’s job is over, and the\nrest of the elements are yielded.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1i32</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().skip_while(|x| x.is_negative());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip_while(%7Cx%7C+x.is_negative());%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because the closure passed to <code>skip_while()</code> takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure argument is a double reference:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().skip_while(|x| <span class=\"kw-2\">**</span>x &lt; <span class=\"number\">0</span>); <span class=\"comment\">// need two *s!\n\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip_while(%7Cx%7C+**x+%3C+0);+//+need+two+*s!%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping after an initial <code>false</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().skip_while(|x| <span class=\"kw-2\">**</span>x &lt; <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n\n<span class=\"comment\">// while this would have been false, since we already got a false,\n// skip_while() isn't used any more\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>-<span class=\"number\">2</span>));\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1,+-2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip_while(%7Cx%7C+**x+%3C+0);%0A++++%0A++++assert_eq!(iter.next(),+Some(%260));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++//+while+this+would+have+been+false,+since+we+already+got+a+false,%0A++++//+skip_while()+isn't+used+any+more%0A++++assert_eq!(iter.next(),+Some(%26-2));%0A++++%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.take_while\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1198-1201\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.take_while\" class=\"fn\">take_while</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.TakeWhile.html\" title=\"struct std::iter::TakeWhile\">TakeWhile</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"TakeWhile<Self, P>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that yields elements based on a predicate.</p>\n<p><code>take_while()</code> takes a closure as an argument. It will call this\nclosure on each element of the iterator, and yield elements\nwhile it returns <code>true</code>.</p>\n<p>After <code>false</code> is returned, <code>take_while()</code>’s job is over, and the\nrest of the elements are ignored.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1i32</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().take_while(|x| x.is_negative());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>-<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take_while(%7Cx%7C+x.is_negative());%0A++++%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because the closure passed to <code>take_while()</code> takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure is a double reference:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().take_while(|x| <span class=\"kw-2\">**</span>x &lt; <span class=\"number\">0</span>); <span class=\"comment\">// need two *s!\n\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>-<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take_while(%7Cx%7C+**x+%3C+0);+//+need+two+*s!%0A++++%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping after an initial <code>false</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().take_while(|x| <span class=\"kw-2\">**</span>x &lt; <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>-<span class=\"number\">1</span>));\n\n<span class=\"comment\">// We have more elements that are less than zero, but since we already\n// got a false, take_while() isn't used any more\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+0,+1,+-2%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take_while(%7Cx%7C+**x+%3C+0);%0A++++%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A++++%0A++++//+We+have+more+elements+that+are+less+than+zero,+but+since+we+already%0A++++//+got+a+false,+take_while()+isn't+used+any+more%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because <code>take_while()</code> needs to look at the value in order to see if it\nshould be included or not, consuming iterators will see that it is\nremoved:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"kw\">let </span>result: Vec&lt;i32&gt; = iter.by_ref()\n                           .take_while(|n| <span class=\"kw-2\">**</span>n != <span class=\"number\">3</span>)\n                           .cloned()\n                           .collect();\n\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n\n<span class=\"kw\">let </span>result: Vec&lt;i32&gt; = iter.cloned().collect();\n\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">4</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++let+result:+Vec%3Ci32%3E+=+iter.by_ref()%0A+++++++++++++++++++++++++++++++.take_while(%7Cn%7C+**n+!=+3)%0A+++++++++++++++++++++++++++++++.cloned()%0A+++++++++++++++++++++++++++++++.collect();%0A++++%0A++++assert_eq!(result,+%26%5B1,+2%5D);%0A++++%0A++++let+result:+Vec%3Ci32%3E+=+iter.cloned().collect();%0A++++%0A++++assert_eq!(result,+%26%5B4%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The <code>3</code> is no longer there, because it was consumed in order to see if\nthe iteration should stop, but wasn’t placed back into the iterator.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.map_while\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.57.0\">1.57.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1287-1290\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.map_while\" class=\"fn\">map_while</a>&lt;B, P&gt;(self, predicate: P) -&gt; <a class=\"struct\" href=\"struct.MapWhile.html\" title=\"struct std::iter::MapWhile\">MapWhile</a>&lt;Self, P&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"MapWhile<Self, P>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that both yields elements based on a predicate and maps.</p>\n<p><code>map_while()</code> takes a closure as an argument. It will call this\nclosure on each element of the iterator, and yield elements\nwhile it returns <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(_)</code></a>.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1i32</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().map_while(|x| <span class=\"number\">16i32</span>.checked_div(<span class=\"kw-2\">*</span>x));\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(-<span class=\"number\">16</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+4,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter().map_while(%7Cx%7C+16i32.checked_div(*x));%0A++++%0A++++assert_eq!(iter.next(),+Some(-16));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Here’s the same example, but with <a href=\"trait.Iterator.html#method.take_while\" title=\"method std::iter::Iterator::take_while\"><code>take_while</code></a> and <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1i32</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter()\n                .map(|x| <span class=\"number\">16i32</span>.checked_div(<span class=\"kw-2\">*</span>x))\n                .take_while(|x| x.is_some())\n                .map(|x| x.unwrap());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(-<span class=\"number\">16</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1i32,+4,+0,+1%5D;%0A++++%0A++++let+mut+iter+=+a.iter()%0A++++++++++++++++++++.map(%7Cx%7C+16i32.checked_div(*x))%0A++++++++++++++++++++.take_while(%7Cx%7C+x.is_some())%0A++++++++++++++++++++.map(%7Cx%7C+x.unwrap());%0A++++%0A++++assert_eq!(iter.next(),+Some(-16));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping after an initial <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>];\n\n<span class=\"kw\">let </span>iter = a.iter().map_while(|x| u32::try_from(<span class=\"kw-2\">*</span>x).ok());\n<span class=\"kw\">let </span>vec = iter.collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n\n<span class=\"comment\">// We have more elements which could fit in u32 (4, 5), but `map_while` returned `None` for `-3`\n// (as the `predicate` returned `None`) and `collect` stops at the first `None` encountered.\n</span><span class=\"macro\">assert_eq!</span>(vec, <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0,+1,+2,+-3,+4,+5,+-6%5D;%0A++++%0A++++let+iter+=+a.iter().map_while(%7Cx%7C+u32::try_from(*x).ok());%0A++++let+vec+=+iter.collect::%3CVec%3C_%3E%3E();%0A++++%0A++++//+We+have+more+elements+which+could+fit+in+u32+(4,+5),+but+%60map_while%60+returned+%60None%60+for+%60-3%60%0A++++//+(as+the+%60predicate%60+returned+%60None%60)+and+%60collect%60+stops+at+the+first+%60None%60+encountered.%0A++++assert_eq!(vec,+vec!%5B0,+1,+2%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because <code>map_while()</code> needs to look at the value in order to see if it\nshould be included or not, consuming iterators will see that it is\nremoved:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"kw\">let </span>result: Vec&lt;u32&gt; = iter.by_ref()\n                           .map_while(|n| u32::try_from(<span class=\"kw-2\">*</span>n).ok())\n                           .collect();\n\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n\n<span class=\"kw\">let </span>result: Vec&lt;i32&gt; = iter.cloned().collect();\n\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">4</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+-3,+4%5D;%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++let+result:+Vec%3Cu32%3E+=+iter.by_ref()%0A+++++++++++++++++++++++++++++++.map_while(%7Cn%7C+u32::try_from(*n).ok())%0A+++++++++++++++++++++++++++++++.collect();%0A++++%0A++++assert_eq!(result,+%26%5B1,+2%5D);%0A++++%0A++++let+result:+Vec%3Ci32%3E+=+iter.cloned().collect();%0A++++%0A++++assert_eq!(result,+%26%5B4%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The <code>-3</code> is no longer there, because it was consumed in order to see if\nthe iteration should stop, but wasn’t placed back into the iterator.</p>\n<p>Note that unlike <a href=\"trait.Iterator.html#method.take_while\" title=\"method std::iter::Iterator::take_while\"><code>take_while</code></a> this iterator is <strong>not</strong> fused.\nIt is also not specified what this iterator returns after the first <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.\nIf you need fused iterator, use <a href=\"trait.Iterator.html#method.fuse\" title=\"method std::iter::Iterator::fuse\"><code>fuse</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.skip\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1317-1319\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.skip\" class=\"fn\">skip</a>(self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Skip.html\" title=\"struct std::iter::Skip\">Skip</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Skip<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that skips the first <code>n</code> elements.</p>\n<p><code>skip(n)</code> skips elements until <code>n</code> elements are skipped or the end of the\niterator is reached (whichever happens first). After that, all the remaining\nelements are yielded. In particular, if the original iterator is too short,\nthen the returned iterator is empty.</p>\n<p>Rather than overriding this method directly, instead override the <code>nth</code> method.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().skip(<span class=\"number\">2</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().skip(2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.take\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1371-1373\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.take\" class=\"fn\">take</a>(self, n: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Take.html\" title=\"struct std::iter::Take\">Take</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Take<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that yields the first <code>n</code> elements, or fewer\nif the underlying iterator ends sooner.</p>\n<p><code>take(n)</code> yields elements until <code>n</code> elements are yielded or the end of\nthe iterator is reached (whichever happens first).\nThe returned iterator is a prefix of length <code>n</code> if the original iterator\ncontains at least <code>n</code> elements, otherwise it contains all of the\n(fewer than <code>n</code>) elements of the original iterator.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().take(<span class=\"number\">2</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().take(2);%0A++++%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>take()</code> is often used with an infinite iterator, to make it finite:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = (<span class=\"number\">0</span>..).take(<span class=\"number\">3</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+(0..).take(3);%0A++++%0A++++assert_eq!(iter.next(),+Some(0));%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If less than <code>n</code> elements are available,\n<code>take</code> will limit itself to the size of the underlying iterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = v.into_iter().take(<span class=\"number\">5</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5B1,+2%5D;%0A++++let+mut+iter+=+v.into_iter().take(5);%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.scan\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1419-1422\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.scan\" class=\"fn\">scan</a>&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; <a class=\"struct\" href=\"struct.Scan.html\" title=\"struct std::iter::Scan\">Scan</a>&lt;Self, St, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Scan<Self, St, F>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut St</a>, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator adapter which, like <a href=\"trait.Iterator.html#method.fold\" title=\"method std::iter::Iterator::fold\"><code>fold</code></a>, holds internal state, but\nunlike <a href=\"trait.Iterator.html#method.fold\" title=\"method std::iter::Iterator::fold\"><code>fold</code></a>, produces a new iterator.</p>\n<p><code>scan()</code> takes two arguments: an initial value which seeds the internal\nstate, and a closure with two arguments, the first being a mutable\nreference to the internal state and the second an iterator element.\nThe closure can assign to the internal state to share state between\niterations.</p>\n<p>On iteration, the closure will be applied to each element of the\niterator and the return value from the closure, an <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>, is\nreturned by the <code>next</code> method. Thus the closure can return\n<code>Some(value)</code> to yield <code>value</code>, or <code>None</code> to end the iteration.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().scan(<span class=\"number\">1</span>, |state, <span class=\"kw-2\">&amp;</span>x| {\n    <span class=\"comment\">// each iteration, we'll multiply the state by the element ...\n    </span><span class=\"kw-2\">*</span>state = <span class=\"kw-2\">*</span>state * x;\n\n    <span class=\"comment\">// ... and terminate if the state exceeds 6\n    </span><span class=\"kw\">if </span><span class=\"kw-2\">*</span>state &gt; <span class=\"number\">6 </span>{\n        <span class=\"kw\">return </span><span class=\"prelude-val\">None</span>;\n    }\n    <span class=\"comment\">// ... else yield the negation of the state\n    </span><span class=\"prelude-val\">Some</span>(-<span class=\"kw-2\">*</span>state)\n});\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(-<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(-<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(-<span class=\"number\">6</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++%0A++++let+mut+iter+=+a.iter().scan(1,+%7Cstate,+%26x%7C+%7B%0A++++++++//+each+iteration,+we'll+multiply+the+state+by+the+element+...%0A++++++++*state+=+*state+*+x;%0A++++%0A++++++++//+...+and+terminate+if+the+state+exceeds+6%0A++++++++if+*state+%3E+6+%7B%0A++++++++++++return+None;%0A++++++++%7D%0A++++++++//+...+else+yield+the+negation+of+the+state%0A++++++++Some(-*state)%0A++++%7D);%0A++++%0A++++assert_eq!(iter.next(),+Some(-1));%0A++++assert_eq!(iter.next(),+Some(-2));%0A++++assert_eq!(iter.next(),+Some(-6));%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.flat_map\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1458-1462\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.flat_map\" class=\"fn\">flat_map</a>&lt;U, F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.FlatMap.html\" title=\"struct std::iter::FlatMap\">FlatMap</a>&lt;Self, U, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"FlatMap<Self, U, F>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; U,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that works like map, but flattens nested structure.</p>\n<p>The <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a> adapter is very useful, but only when the closure\nargument produces values. If it produces an iterator instead, there’s\nan extra layer of indirection. <code>flat_map()</code> will remove this extra layer\non its own.</p>\n<p>You can think of <code>flat_map(f)</code> as the semantic equivalent\nof <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a>ping, and then <a href=\"trait.Iterator.html#method.flatten\" title=\"method std::iter::Iterator::flatten\"><code>flatten</code></a>ing as in <code>map(f).flatten()</code>.</p>\n<p>Another way of thinking about <code>flat_map()</code>: <a href=\"trait.Iterator.html#method.map\" title=\"method std::iter::Iterator::map\"><code>map</code></a>’s closure returns\none item for each element, and <code>flat_map()</code>’s closure returns an\niterator for each element.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>words = [<span class=\"string\">\"alpha\"</span>, <span class=\"string\">\"beta\"</span>, <span class=\"string\">\"gamma\"</span>];\n\n<span class=\"comment\">// chars() returns an iterator\n</span><span class=\"kw\">let </span>merged: String = words.iter()\n                          .flat_map(|s| s.chars())\n                          .collect();\n<span class=\"macro\">assert_eq!</span>(merged, <span class=\"string\">\"alphabetagamma\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+words+=+%5B%22alpha%22,+%22beta%22,+%22gamma%22%5D;%0A++++%0A++++//+chars()+returns+an+iterator%0A++++let+merged:+String+=+words.iter()%0A++++++++++++++++++++++++++++++.flat_map(%7Cs%7C+s.chars())%0A++++++++++++++++++++++++++++++.collect();%0A++++assert_eq!(merged,+%22alphabetagamma%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.flatten\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.29.0\">1.29.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1543-1546\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.flatten\" class=\"fn\">flatten</a>(self) -&gt; <a class=\"struct\" href=\"struct.Flatten.html\" title=\"struct std::iter::Flatten\">Flatten</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Flatten<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator that flattens nested structure.</p>\n<p>This is useful when you have an iterator of iterators or an iterator of\nthings that can be turned into iterators and you want to remove one\nlevel of indirection.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>data = <span class=\"macro\">vec!</span>[<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"macro\">vec!</span>[<span class=\"number\">5</span>, <span class=\"number\">6</span>]];\n<span class=\"kw\">let </span>flattened = data.into_iter().flatten().collect::&lt;Vec&lt;u8&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(flattened, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+data+=+vec!%5Bvec!%5B1,+2,+3,+4%5D,+vec!%5B5,+6%5D%5D;%0A++++let+flattened+=+data.into_iter().flatten().collect::%3CVec%3Cu8%3E%3E();%0A++++assert_eq!(flattened,+%26%5B1,+2,+3,+4,+5,+6%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Mapping and then flattening:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>words = [<span class=\"string\">\"alpha\"</span>, <span class=\"string\">\"beta\"</span>, <span class=\"string\">\"gamma\"</span>];\n\n<span class=\"comment\">// chars() returns an iterator\n</span><span class=\"kw\">let </span>merged: String = words.iter()\n                          .map(|s| s.chars())\n                          .flatten()\n                          .collect();\n<span class=\"macro\">assert_eq!</span>(merged, <span class=\"string\">\"alphabetagamma\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+words+=+%5B%22alpha%22,+%22beta%22,+%22gamma%22%5D;%0A++++%0A++++//+chars()+returns+an+iterator%0A++++let+merged:+String+=+words.iter()%0A++++++++++++++++++++++++++++++.map(%7Cs%7C+s.chars())%0A++++++++++++++++++++++++++++++.flatten()%0A++++++++++++++++++++++++++++++.collect();%0A++++assert_eq!(merged,+%22alphabetagamma%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>You can also rewrite this in terms of <a href=\"trait.Iterator.html#method.flat_map\" title=\"method std::iter::Iterator::flat_map\"><code>flat_map()</code></a>, which is preferable\nin this case since it conveys intent more clearly:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>words = [<span class=\"string\">\"alpha\"</span>, <span class=\"string\">\"beta\"</span>, <span class=\"string\">\"gamma\"</span>];\n\n<span class=\"comment\">// chars() returns an iterator\n</span><span class=\"kw\">let </span>merged: String = words.iter()\n                          .flat_map(|s| s.chars())\n                          .collect();\n<span class=\"macro\">assert_eq!</span>(merged, <span class=\"string\">\"alphabetagamma\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+words+=+%5B%22alpha%22,+%22beta%22,+%22gamma%22%5D;%0A++++%0A++++//+chars()+returns+an+iterator%0A++++let+merged:+String+=+words.iter()%0A++++++++++++++++++++++++++++++.flat_map(%7Cs%7C+s.chars())%0A++++++++++++++++++++++++++++++.collect();%0A++++assert_eq!(merged,+%22alphabetagamma%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Flattening works on any <code>IntoIterator</code> type, including <code>Option</code> and <code>Result</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>options = <span class=\"macro\">vec!</span>[<span class=\"prelude-val\">Some</span>(<span class=\"number\">123</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">321</span>), <span class=\"prelude-val\">None</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">231</span>)];\n<span class=\"kw\">let </span>flattened_options: Vec&lt;<span class=\"kw\">_</span>&gt; = options.into_iter().flatten().collect();\n<span class=\"macro\">assert_eq!</span>(flattened_options, <span class=\"macro\">vec!</span>[<span class=\"number\">123</span>, <span class=\"number\">321</span>, <span class=\"number\">231</span>]);\n\n<span class=\"kw\">let </span>results = <span class=\"macro\">vec!</span>[<span class=\"prelude-val\">Ok</span>(<span class=\"number\">123</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">321</span>), <span class=\"prelude-val\">Err</span>(<span class=\"number\">456</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">231</span>)];\n<span class=\"kw\">let </span>flattened_results: Vec&lt;<span class=\"kw\">_</span>&gt; = results.into_iter().flatten().collect();\n<span class=\"macro\">assert_eq!</span>(flattened_results, <span class=\"macro\">vec!</span>[<span class=\"number\">123</span>, <span class=\"number\">321</span>, <span class=\"number\">231</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+options+=+vec!%5BSome(123),+Some(321),+None,+Some(231)%5D;%0A++++let+flattened_options:+Vec%3C_%3E+=+options.into_iter().flatten().collect();%0A++++assert_eq!(flattened_options,+vec!%5B123,+321,+231%5D);%0A++++%0A++++let+results+=+vec!%5BOk(123),+Ok(321),+Err(456),+Ok(231)%5D;%0A++++let+flattened_results:+Vec%3C_%3E+=+results.into_iter().flatten().collect();%0A++++assert_eq!(flattened_results,+vec!%5B123,+321,+231%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Flattening only removes one level of nesting at a time:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>d3 = [[[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]], [[<span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>]]];\n\n<span class=\"kw\">let </span>d2 = d3.iter().flatten().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(d2, [<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"kw-2\">&amp;</span>[<span class=\"number\">5</span>, <span class=\"number\">6</span>], <span class=\"kw-2\">&amp;</span>[<span class=\"number\">7</span>, <span class=\"number\">8</span>]]);\n\n<span class=\"kw\">let </span>d1 = d3.iter().flatten().flatten().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(d1, [<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">6</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">7</span>, <span class=\"kw-2\">&amp;</span><span class=\"number\">8</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+d3+=+%5B%5B%5B1,+2%5D,+%5B3,+4%5D%5D,+%5B%5B5,+6%5D,+%5B7,+8%5D%5D%5D;%0A++++%0A++++let+d2+=+d3.iter().flatten().collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(d2,+%5B%26%5B1,+2%5D,+%26%5B3,+4%5D,+%26%5B5,+6%5D,+%26%5B7,+8%5D%5D);%0A++++%0A++++let+d1+=+d3.iter().flatten().flatten().collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(d1,+%5B%261,+%262,+%263,+%264,+%265,+%266,+%267,+%268%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Here we see that <code>flatten()</code> does not perform a “deep” flatten.\nInstead, only one level of nesting is removed. That is, if you\n<code>flatten()</code> a three-dimensional array, the result will be\ntwo-dimensional and not one-dimensional. To get a one-dimensional\nstructure, you have to <code>flatten()</code> again.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.map_windows\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1700-1703\">source</a><h4 class=\"code-header\">fn <a href=\"#method.map_windows\" class=\"fn\">map_windows</a>&lt;F, R, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.MapWindows.html\" title=\"struct std::iter::MapWindows\">MapWindows</a>&lt;Self, F, N&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"MapWindows<Self, F, N>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;[Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>]) -&gt; R,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_map_windows</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/87155\">#87155</a>)</span></div></span></summary><div class=\"docblock\"><p>Calls the given function <code>f</code> for each contiguous window of size <code>N</code> over\n<code>self</code> and returns an iterator over the outputs of <code>f</code>. Like <a href=\"../primitive.slice.html#method.windows\" title=\"method slice::windows\"><code>slice::windows()</code></a>,\nthe windows during mapping overlap as well.</p>\n<p>In the following example, the closure is called three times with the\narguments <code>&amp;['a', 'b']</code>, <code>&amp;['b', 'c']</code> and <code>&amp;['c', 'd']</code> respectively.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_map_windows)]\n\n</span><span class=\"kw\">let </span>strings = <span class=\"string\">\"abcd\"</span>.chars()\n    .map_windows(|[x, y]| <span class=\"macro\">format!</span>(<span class=\"string\">\"{}+{}\"</span>, x, y))\n    .collect::&lt;Vec&lt;String&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(strings, <span class=\"macro\">vec!</span>[<span class=\"string\">\"a+b\"</span>, <span class=\"string\">\"b+c\"</span>, <span class=\"string\">\"c+d\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+strings+=+%22abcd%22.chars()%0A++++++++.map_windows(%7C%5Bx,+y%5D%7C+format!(%22%7B%7D%2B%7B%7D%22,+x,+y))%0A++++++++.collect::%3CVec%3CString%3E%3E();%0A++++%0A++++assert_eq!(strings,+vec!%5B%22a%2Bb%22,+%22b%2Bc%22,+%22c%2Bd%22%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Note that the const parameter <code>N</code> is usually inferred by the\ndestructured argument in the closure.</p>\n<p>The returned iterator yields 𝑘 − <code>N</code> + 1 items (where 𝑘 is the number of\nitems yielded by <code>self</code>). If 𝑘 is less than <code>N</code>, this method yields an\nempty iterator.</p>\n<p>The returned iterator implements <a href=\"trait.FusedIterator.html\" title=\"trait std::iter::FusedIterator\"><code>FusedIterator</code></a>, because once <code>self</code>\nreturns <code>None</code>, even if it returns a <code>Some(T)</code> again in the next iterations,\nwe cannot put it into a contiguous array buffer, and thus the returned iterator\nshould be fused.</p>\n<h5 id=\"panics-3\"><a class=\"doc-anchor\" href=\"#panics-3\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is 0. This check will most probably get changed to a\ncompile time error before this method gets stabilized.</p>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_map_windows)]\n\n</span><span class=\"kw\">let </span>iter = std::iter::repeat(<span class=\"number\">0</span>).map_windows(|<span class=\"kw-2\">&amp;</span>[]| ());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+iter+=+std::iter::repeat(0).map_windows(%7C%26%5B%5D%7C+());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">§</a>Examples</h5>\n<p>Building the sums of neighboring numbers.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_map_windows)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>].iter().map_windows(|<span class=\"kw-2\">&amp;</span>[a, b]| a + b);\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));  <span class=\"comment\">// 1 + 3\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">11</span>)); <span class=\"comment\">// 3 + 8\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">9</span>));  <span class=\"comment\">// 8 + 1\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+mut+it+=+%5B1,+3,+8,+1%5D.iter().map_windows(%7C%26%5Ba,+b%5D%7C+a+%2B+b);%0A++++assert_eq!(it.next(),+Some(4));++//+1+%2B+3%0A++++assert_eq!(it.next(),+Some(11));+//+3+%2B+8%0A++++assert_eq!(it.next(),+Some(9));++//+8+%2B+1%0A++++assert_eq!(it.next(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Since the elements in the following example implement <code>Copy</code>, we can\njust copy the array and get an iterator over the windows.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_map_windows)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = <span class=\"string\">\"ferris\"</span>.chars().map_windows(|w: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>; <span class=\"number\">3</span>]| <span class=\"kw-2\">*</span>w);\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>([<span class=\"string\">'f'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'r'</span>]));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>([<span class=\"string\">'e'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'r'</span>]));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>([<span class=\"string\">'r'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'i'</span>]));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>([<span class=\"string\">'r'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'s'</span>]));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+mut+it+=+%22ferris%22.chars().map_windows(%7Cw:+%26%5B_;+3%5D%7C+*w);%0A++++assert_eq!(it.next(),+Some(%5B'f',+'e',+'r'%5D));%0A++++assert_eq!(it.next(),+Some(%5B'e',+'r',+'r'%5D));%0A++++assert_eq!(it.next(),+Some(%5B'r',+'r',+'i'%5D));%0A++++assert_eq!(it.next(),+Some(%5B'r',+'i',+'s'%5D));%0A++++assert_eq!(it.next(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>You can also use this function to check the sortedness of an iterator.\nFor the simple case, rather use <a href=\"trait.Iterator.html#method.is_sorted\" title=\"method std::iter::Iterator::is_sorted\"><code>Iterator::is_sorted</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_map_windows)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = [<span class=\"number\">0.5</span>, <span class=\"number\">1.0</span>, <span class=\"number\">3.5</span>, <span class=\"number\">3.0</span>, <span class=\"number\">8.5</span>, <span class=\"number\">8.5</span>, f32::NAN].iter()\n    .map_windows(|[a, b]| a &lt;= b);\n\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"bool-val\">true</span>));  <span class=\"comment\">// 0.5 &lt;= 1.0\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"bool-val\">true</span>));  <span class=\"comment\">// 1.0 &lt;= 3.5\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"bool-val\">false</span>)); <span class=\"comment\">// 3.5 &lt;= 3.0\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"bool-val\">true</span>));  <span class=\"comment\">// 3.0 &lt;= 8.5\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"bool-val\">true</span>));  <span class=\"comment\">// 8.5 &lt;= 8.5\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"bool-val\">false</span>)); <span class=\"comment\">// 8.5 &lt;= NAN\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++let+mut+it+=+%5B0.5,+1.0,+3.5,+3.0,+8.5,+8.5,+f32::NAN%5D.iter()%0A++++++++.map_windows(%7C%5Ba,+b%5D%7C+a+%3C=+b);%0A++++%0A++++assert_eq!(it.next(),+Some(true));++//+0.5+%3C=+1.0%0A++++assert_eq!(it.next(),+Some(true));++//+1.0+%3C=+3.5%0A++++assert_eq!(it.next(),+Some(false));+//+3.5+%3C=+3.0%0A++++assert_eq!(it.next(),+Some(true));++//+3.0+%3C=+8.5%0A++++assert_eq!(it.next(),+Some(true));++//+8.5+%3C=+8.5%0A++++assert_eq!(it.next(),+Some(false));+//+8.5+%3C=+NAN%0A++++assert_eq!(it.next(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>For non-fused iterators, they are fused after <code>map_windows</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_map_windows)]\n\n#[derive(Default)]\n</span><span class=\"kw\">struct </span>NonFusedIterator {\n    state: i32,\n}\n\n<span class=\"kw\">impl </span>Iterator <span class=\"kw\">for </span>NonFusedIterator {\n    <span class=\"kw\">type </span>Item = i32;\n\n    <span class=\"kw\">fn </span>next(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"prelude-ty\">Option</span>&lt;i32&gt; {\n        <span class=\"kw\">let </span>val = <span class=\"self\">self</span>.state;\n        <span class=\"self\">self</span>.state = <span class=\"self\">self</span>.state + <span class=\"number\">1</span>;\n\n        <span class=\"comment\">// yields `0..5` first, then only even numbers since `6..`.\n        </span><span class=\"kw\">if </span>val &lt; <span class=\"number\">5 </span>|| val % <span class=\"number\">2 </span>== <span class=\"number\">0 </span>{\n            <span class=\"prelude-val\">Some</span>(val)\n        } <span class=\"kw\">else </span>{\n            <span class=\"prelude-val\">None\n        </span>}\n    }\n}\n\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = NonFusedIterator::default();\n\n<span class=\"comment\">// yields 0..5 first.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));\n<span class=\"comment\">// then we can see our iterator going back and forth\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">6</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">8</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// however, with `.map_windows()`, it is fused.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = NonFusedIterator::default()\n    .map_windows(|arr: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>; <span class=\"number\">2</span>]| <span class=\"kw-2\">*</span>arr);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>([<span class=\"number\">2</span>, <span class=\"number\">3</span>]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>([<span class=\"number\">3</span>, <span class=\"number\">4</span>]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// it will always return `None` after the first time.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_map_windows)%5D%0A%0Afn+main()+%7B%0A++++%23%5Bderive(Default)%5D%0A++++struct+NonFusedIterator+%7B%0A++++++++state:+i32,%0A++++%7D%0A++++%0A++++impl+Iterator+for+NonFusedIterator+%7B%0A++++++++type+Item+=+i32;%0A++++%0A++++++++fn+next(%26mut+self)+-%3E+Option%3Ci32%3E+%7B%0A++++++++++++let+val+=+self.state;%0A++++++++++++self.state+=+self.state+%2B+1;%0A++++%0A++++++++++++//+yields+%600..5%60+first,+then+only+even+numbers+since+%606..%60.%0A++++++++++++if+val+%3C+5+%7C%7C+val+%25+2+==+0+%7B%0A++++++++++++++++Some(val)%0A++++++++++++%7D+else+%7B%0A++++++++++++++++None%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++%0A++++let+mut+iter+=+NonFusedIterator::default();%0A++++%0A++++//+yields+0..5+first.%0A++++assert_eq!(iter.next(),+Some(0));%0A++++assert_eq!(iter.next(),+Some(1));%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+Some(3));%0A++++assert_eq!(iter.next(),+Some(4));%0A++++//+then+we+can+see+our+iterator+going+back+and+forth%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+Some(6));%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+Some(8));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+however,+with+%60.map_windows()%60,+it+is+fused.%0A++++let+mut+iter+=+NonFusedIterator::default()%0A++++++++.map_windows(%7Carr:+%26%5B_;+2%5D%7C+*arr);%0A++++%0A++++assert_eq!(iter.next(),+Some(%5B0,+1%5D));%0A++++assert_eq!(iter.next(),+Some(%5B1,+2%5D));%0A++++assert_eq!(iter.next(),+Some(%5B2,+3%5D));%0A++++assert_eq!(iter.next(),+Some(%5B3,+4%5D));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+it+will+always+return+%60None%60+after+the+first+time.%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fuse\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1767-1769\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.fuse\" class=\"fn\">fuse</a>(self) -&gt; <a class=\"struct\" href=\"struct.Fuse.html\" title=\"struct std::iter::Fuse\">Fuse</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Fuse<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator which ends after the first <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p>After an iterator returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, future calls may or may not yield\n<a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(T)</code></a> again. <code>fuse()</code> adapts an iterator, ensuring that after a\n<a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is given, it will always return <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> forever.</p>\n<p>Note that the <a href=\"struct.Fuse.html\" title=\"struct std::iter::Fuse\"><code>Fuse</code></a> wrapper is a no-op on iterators that implement\nthe <a href=\"trait.FusedIterator.html\" title=\"trait std::iter::FusedIterator\"><code>FusedIterator</code></a> trait. <code>fuse()</code> may therefore behave incorrectly\nif the <a href=\"trait.FusedIterator.html\" title=\"trait std::iter::FusedIterator\"><code>FusedIterator</code></a> trait is improperly implemented.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// an iterator which alternates between Some and None\n</span><span class=\"kw\">struct </span>Alternate {\n    state: i32,\n}\n\n<span class=\"kw\">impl </span>Iterator <span class=\"kw\">for </span>Alternate {\n    <span class=\"kw\">type </span>Item = i32;\n\n    <span class=\"kw\">fn </span>next(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"prelude-ty\">Option</span>&lt;i32&gt; {\n        <span class=\"kw\">let </span>val = <span class=\"self\">self</span>.state;\n        <span class=\"self\">self</span>.state = <span class=\"self\">self</span>.state + <span class=\"number\">1</span>;\n\n        <span class=\"comment\">// if it's even, Some(i32), else None\n        </span><span class=\"kw\">if </span>val % <span class=\"number\">2 </span>== <span class=\"number\">0 </span>{\n            <span class=\"prelude-val\">Some</span>(val)\n        } <span class=\"kw\">else </span>{\n            <span class=\"prelude-val\">None\n        </span>}\n    }\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = Alternate { state: <span class=\"number\">0 </span>};\n\n<span class=\"comment\">// we can see our iterator going back and forth\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// however, once we fuse it...\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = iter.fuse();\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// it will always return `None` after the first time.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+an+iterator+which+alternates+between+Some+and+None%0Afn+main()+%7B%0A++++struct+Alternate+%7B%0A++++++++state:+i32,%0A++++%7D%0A++++%0A++++impl+Iterator+for+Alternate+%7B%0A++++++++type+Item+=+i32;%0A++++%0A++++++++fn+next(%26mut+self)+-%3E+Option%3Ci32%3E+%7B%0A++++++++++++let+val+=+self.state;%0A++++++++++++self.state+=+self.state+%2B+1;%0A++++%0A++++++++++++//+if+it's+even,+Some(i32),+else+None%0A++++++++++++if+val+%25+2+==+0+%7B%0A++++++++++++++++Some(val)%0A++++++++++++%7D+else+%7B%0A++++++++++++++++None%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+mut+iter+=+Alternate+%7B+state:+0+%7D;%0A++++%0A++++//+we+can+see+our+iterator+going+back+and+forth%0A++++assert_eq!(iter.next(),+Some(0));%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+Some(2));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+however,+once+we+fuse+it...%0A++++let+mut+iter+=+iter.fuse();%0A++++%0A++++assert_eq!(iter.next(),+Some(4));%0A++++assert_eq!(iter.next(),+None);%0A++++%0A++++//+it+will+always+return+%60None%60+after+the+first+time.%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.inspect\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1852-1855\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.inspect\" class=\"fn\">inspect</a>&lt;F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"struct.Inspect.html\" title=\"struct std::iter::Inspect\">Inspect</a>&lt;Self, F&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Inspect<Self, F>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>),</div></h4></section></summary><div class=\"docblock\"><p>Does something with each element of an iterator, passing the value on.</p>\n<p>When using iterators, you’ll often chain several of them together.\nWhile working on such code, you might want to check out what’s\nhappening at various parts in the pipeline. To do that, insert\na call to <code>inspect()</code>.</p>\n<p>It’s more common for <code>inspect()</code> to be used as a debugging tool than to\nexist in your final code, but applications may find it useful in certain\nsituations when errors need to be logged before being discarded.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"comment\">// this iterator sequence is complex.\n</span><span class=\"kw\">let </span>sum = a.iter()\n    .cloned()\n    .filter(|x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>)\n    .fold(<span class=\"number\">0</span>, |sum, i| sum + i);\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{sum}\"</span>);\n\n<span class=\"comment\">// let's add some inspect() calls to investigate what's happening\n</span><span class=\"kw\">let </span>sum = a.iter()\n    .cloned()\n    .inspect(|x| <span class=\"macro\">println!</span>(<span class=\"string\">\"about to filter: {x}\"</span>))\n    .filter(|x| x % <span class=\"number\">2 </span>== <span class=\"number\">0</span>)\n    .inspect(|x| <span class=\"macro\">println!</span>(<span class=\"string\">\"made it through filter: {x}\"</span>))\n    .fold(<span class=\"number\">0</span>, |sum, i| sum + i);\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{sum}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+4,+2,+3%5D;%0A++++%0A++++//+this+iterator+sequence+is+complex.%0A++++let+sum+=+a.iter()%0A++++++++.cloned()%0A++++++++.filter(%7Cx%7C+x+%25+2+==+0)%0A++++++++.fold(0,+%7Csum,+i%7C+sum+%2B+i);%0A++++%0A++++println!(%22%7Bsum%7D%22);%0A++++%0A++++//+let's+add+some+inspect()+calls+to+investigate+what's+happening%0A++++let+sum+=+a.iter()%0A++++++++.cloned()%0A++++++++.inspect(%7Cx%7C+println!(%22about+to+filter:+%7Bx%7D%22))%0A++++++++.filter(%7Cx%7C+x+%25+2+==+0)%0A++++++++.inspect(%7Cx%7C+println!(%22made+it+through+filter:+%7Bx%7D%22))%0A++++++++.fold(0,+%7Csum,+i%7C+sum+%2B+i);%0A++++%0A++++println!(%22%7Bsum%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will print:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>6\nabout to filter: 1\nabout to filter: 4\nmade it through filter: 4\nabout to filter: 2\nmade it through filter: 2\nabout to filter: 3\n6\n</code></pre></div>\n<p>Logging errors before discarding them:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>lines = [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"a\"</span>];\n\n<span class=\"kw\">let </span>sum: i32 = lines\n    .iter()\n    .map(|line| line.parse::&lt;i32&gt;())\n    .inspect(|num| {\n        <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(<span class=\"kw-2\">ref </span>e) = <span class=\"kw-2\">*</span>num {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Parsing error: {e}\"</span>);\n        }\n    })\n    .filter_map(Result::ok)\n    .sum();\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Sum: {sum}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+lines+=+%5B%221%22,+%222%22,+%22a%22%5D;%0A++++%0A++++let+sum:+i32+=+lines%0A++++++++.iter()%0A++++++++.map(%7Cline%7C+line.parse::%3Ci32%3E())%0A++++++++.inspect(%7Cnum%7C+%7B%0A++++++++++++if+let+Err(ref+e)+=+*num+%7B%0A++++++++++++++++println!(%22Parsing+error:+%7Be%7D%22);%0A++++++++++++%7D%0A++++++++%7D)%0A++++++++.filter_map(Result::ok)%0A++++++++.sum();%0A++++%0A++++println!(%22Sum:+%7Bsum%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will print:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>Parsing error: invalid digit found in string\nSum: 3\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.by_ref\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#1881-1883\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.by_ref\" class=\"fn\">by_ref</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut Self</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Borrows an iterator, rather than consuming it.</p>\n<p>This is useful to allow applying iterator adapters while still\nretaining ownership of the original iterator.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>words = [<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>, <span class=\"string\">\"of\"</span>, <span class=\"string\">\"Rust\"</span>].into_iter();\n\n<span class=\"comment\">// Take the first two words.\n</span><span class=\"kw\">let </span>hello_world: Vec&lt;<span class=\"kw\">_</span>&gt; = words.by_ref().take(<span class=\"number\">2</span>).collect();\n<span class=\"macro\">assert_eq!</span>(hello_world, <span class=\"macro\">vec!</span>[<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>]);\n\n<span class=\"comment\">// Collect the rest of the words.\n// We can only do this because we used `by_ref` earlier.\n</span><span class=\"kw\">let </span>of_rust: Vec&lt;<span class=\"kw\">_</span>&gt; = words.collect();\n<span class=\"macro\">assert_eq!</span>(of_rust, <span class=\"macro\">vec!</span>[<span class=\"string\">\"of\"</span>, <span class=\"string\">\"Rust\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+words+=+%5B%22hello%22,+%22world%22,+%22of%22,+%22Rust%22%5D.into_iter();%0A++++%0A++++//+Take+the+first+two+words.%0A++++let+hello_world:+Vec%3C_%3E+=+words.by_ref().take(2).collect();%0A++++assert_eq!(hello_world,+vec!%5B%22hello%22,+%22world%22%5D);%0A++++%0A++++//+Collect+the+rest+of+the+words.%0A++++//+We+can+only+do+this+because+we+used+%60by_ref%60+earlier.%0A++++let+of_rust:+Vec%3C_%3E+=+words.collect();%0A++++assert_eq!(of_rust,+vec!%5B%22of%22,+%22Rust%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.collect\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2001-2003\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.collect\" class=\"fn\">collect</a>&lt;B&gt;(self) -&gt; B<div class=\"where\">where\n    B: <a class=\"trait\" href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Transforms an iterator into a collection.</p>\n<p><code>collect()</code> can take anything iterable, and turn it into a relevant\ncollection. This is one of the more powerful methods in the standard\nlibrary, used in a variety of contexts.</p>\n<p>The most basic pattern in which <code>collect()</code> is used is to turn one\ncollection into another. You take a collection, call <a href=\"trait.Iterator.html#tymethod.next\" title=\"method std::iter::Iterator::next\"><code>iter</code></a> on it,\ndo a bunch of transformations, and then <code>collect()</code> at the end.</p>\n<p><code>collect()</code> can also create instances of types that are not typical\ncollections. For example, a <a href=\"../../std/string/struct.String.html\"><code>String</code></a> can be built from <a href=\"../primitive.char.html\" title=\"primitive char\"><code>char</code></a>s,\nand an iterator of <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> items can be collected\ninto <code>Result&lt;Collection&lt;T&gt;, E&gt;</code>. See the examples below for more.</p>\n<p>Because <code>collect()</code> is so general, it can cause problems with type\ninference. As such, <code>collect()</code> is one of the few times you’ll see\nthe syntax affectionately known as the ‘turbofish’: <code>::&lt;&gt;</code>. This\nhelps the inference algorithm understand specifically which collection\nyou’re trying to collect into.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>doubled: Vec&lt;i32&gt; = a.iter()\n                         .map(|<span class=\"kw-2\">&amp;</span>x| x * <span class=\"number\">2</span>)\n                         .collect();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>], doubled);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled:+Vec%3Ci32%3E+=+a.iter()%0A+++++++++++++++++++++++++++++.map(%7C%26x%7C+x+*+2)%0A+++++++++++++++++++++++++++++.collect();%0A++++%0A++++assert_eq!(vec!%5B2,+4,+6%5D,+doubled);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that we needed the <code>: Vec&lt;i32&gt;</code> on the left-hand side. This is because\nwe could collect into, for example, a <a href=\"../../std/collections/struct.VecDeque.html\"><code>VecDeque&lt;T&gt;</code></a> instead:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::VecDeque;\n\n<span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>doubled: VecDeque&lt;i32&gt; = a.iter().map(|<span class=\"kw-2\">&amp;</span>x| x * <span class=\"number\">2</span>).collect();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, doubled[<span class=\"number\">0</span>]);\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">4</span>, doubled[<span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">6</span>, doubled[<span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::VecDeque;%0A++++%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled:+VecDeque%3Ci32%3E+=+a.iter().map(%7C%26x%7C+x+*+2).collect();%0A++++%0A++++assert_eq!(2,+doubled%5B0%5D);%0A++++assert_eq!(4,+doubled%5B1%5D);%0A++++assert_eq!(6,+doubled%5B2%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using the ‘turbofish’ instead of annotating <code>doubled</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>doubled = a.iter().map(|x| x * <span class=\"number\">2</span>).collect::&lt;Vec&lt;i32&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>], doubled);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled+=+a.iter().map(%7Cx%7C+x+*+2).collect::%3CVec%3Ci32%3E%3E();%0A++++%0A++++assert_eq!(vec!%5B2,+4,+6%5D,+doubled);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because <code>collect()</code> only cares about what you’re collecting into, you can\nstill use a partial type hint, <code>_</code>, with the turbofish:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>doubled = a.iter().map(|x| x * <span class=\"number\">2</span>).collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>], doubled);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+doubled+=+a.iter().map(%7Cx%7C+x+*+2).collect::%3CVec%3C_%3E%3E();%0A++++%0A++++assert_eq!(vec!%5B2,+4,+6%5D,+doubled);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Using <code>collect()</code> to make a <a href=\"../../std/string/struct.String.html\"><code>String</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>chars = [<span class=\"string\">'g'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'k'</span>, <span class=\"string\">'k'</span>, <span class=\"string\">'n'</span>];\n\n<span class=\"kw\">let </span>hello: String = chars.iter()\n    .map(|<span class=\"kw-2\">&amp;</span>x| x <span class=\"kw\">as </span>u8)\n    .map(|x| (x + <span class=\"number\">1</span>) <span class=\"kw\">as </span>char)\n    .collect();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello\"</span>, hello);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+chars+=+%5B'g',+'d',+'k',+'k',+'n'%5D;%0A++++%0A++++let+hello:+String+=+chars.iter()%0A++++++++.map(%7C%26x%7C+x+as+u8)%0A++++++++.map(%7Cx%7C+(x+%2B+1)+as+char)%0A++++++++.collect();%0A++++%0A++++assert_eq!(%22hello%22,+hello);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If you have a list of <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>s, you can use <code>collect()</code> to\nsee if any of them failed:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>results = [<span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"nope\"</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>), <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"bad\"</span>)];\n\n<span class=\"kw\">let </span>result: <span class=\"prelude-ty\">Result</span>&lt;Vec&lt;<span class=\"kw\">_</span>&gt;, <span class=\"kw-2\">&amp;</span>str&gt; = results.iter().cloned().collect();\n\n<span class=\"comment\">// gives us the first error\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Err</span>(<span class=\"string\">\"nope\"</span>), result);\n\n<span class=\"kw\">let </span>results = [<span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>)];\n\n<span class=\"kw\">let </span>result: <span class=\"prelude-ty\">Result</span>&lt;Vec&lt;<span class=\"kw\">_</span>&gt;, <span class=\"kw-2\">&amp;</span>str&gt; = results.iter().cloned().collect();\n\n<span class=\"comment\">// gives us the list of answers\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Ok</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">3</span>]), result);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+results+=+%5BOk(1),+Err(%22nope%22),+Ok(3),+Err(%22bad%22)%5D;%0A++++%0A++++let+result:+Result%3CVec%3C_%3E,+%26str%3E+=+results.iter().cloned().collect();%0A++++%0A++++//+gives+us+the+first+error%0A++++assert_eq!(Err(%22nope%22),+result);%0A++++%0A++++let+results+=+%5BOk(1),+Ok(3)%5D;%0A++++%0A++++let+result:+Result%3CVec%3C_%3E,+%26str%3E+=+results.iter().cloned().collect();%0A++++%0A++++//+gives+us+the+list+of+answers%0A++++assert_eq!(Ok(vec!%5B1,+3%5D),+result);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_collect\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2080-2085\">source</a><h4 class=\"code-header\">fn <a href=\"#method.try_collect\" class=\"fn\">try_collect</a>&lt;B&gt;(\n    &amp;mut self,\n) -&gt; &lt;&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a> as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a> as <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;B&gt;&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Residual.html#associatedtype.TryType\" title=\"type std::ops::Residual::TryType\">TryType</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>,\n    &lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a> as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a>: <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;B&gt;,\n    B: <a class=\"trait\" href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a> as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Output\" title=\"type std::ops::Try::Output\">Output</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iterator_try_collect</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/94047\">#94047</a>)</span></div></span></summary><div class=\"docblock\"><p>Fallibly transforms an iterator into a collection, short circuiting if\na failure is encountered.</p>\n<p><code>try_collect()</code> is a variation of <a href=\"trait.Iterator.html#method.collect\" title=\"method std::iter::Iterator::collect\"><code>collect()</code></a> that allows fallible\nconversions during collection. Its main use case is simplifying conversions from\niterators yielding <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> into <code>Option&lt;Collection&lt;T&gt;&gt;</code>, or similarly for other <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>Try</code></a>\ntypes (e.g. <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>).</p>\n<p>Importantly, <code>try_collect()</code> doesn’t require that the outer <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>Try</code></a> type also implements <a href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\"><code>FromIterator</code></a>;\nonly the inner type produced on <code>Try::Output</code> must implement it. Concretely,\nthis means that collecting into <code>ControlFlow&lt;_, Vec&lt;i32&gt;&gt;</code> is valid because <code>Vec&lt;i32&gt;</code> implements\n<a href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\"><code>FromIterator</code></a>, even though <a href=\"../ops/enum.ControlFlow.html\" title=\"enum std::ops::ControlFlow\"><code>ControlFlow</code></a> doesn’t.</p>\n<p>Also, if a failure is encountered during <code>try_collect()</code>, the iterator is still valid and\nmay continue to be used, in which case it will continue iterating starting after the element that\ntriggered the failure. See the last example below for an example of how this works.</p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">§</a>Examples</h5>\n<p>Successfully collecting an iterator of <code>Option&lt;i32&gt;</code> into <code>Option&lt;Vec&lt;i32&gt;&gt;</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_collect)]\n\n</span><span class=\"kw\">let </span>u = <span class=\"macro\">vec!</span>[<span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>)];\n<span class=\"kw\">let </span>v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"prelude-val\">Some</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++let+u+=+vec!%5BSome(1),+Some(2),+Some(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+Some(vec!%5B1,+2,+3%5D));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Failing to collect in the same way:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_collect)]\n\n</span><span class=\"kw\">let </span>u = <span class=\"macro\">vec!</span>[<span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">None</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>)];\n<span class=\"kw\">let </span>v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++let+u+=+vec!%5BSome(1),+Some(2),+None,+Some(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>A similar example, but with <code>Result</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_collect)]\n\n</span><span class=\"kw\">let </span>u: Vec&lt;<span class=\"prelude-ty\">Result</span>&lt;i32, ()&gt;&gt; = <span class=\"macro\">vec!</span>[<span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>)];\n<span class=\"kw\">let </span>v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"prelude-val\">Ok</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));\n\n<span class=\"kw\">let </span>u = <span class=\"macro\">vec!</span>[<span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Err</span>(()), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>)];\n<span class=\"kw\">let </span>v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"prelude-val\">Err</span>(()));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++let+u:+Vec%3CResult%3Ci32,+()%3E%3E+=+vec!%5BOk(1),+Ok(2),+Ok(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+Ok(vec!%5B1,+2,+3%5D));%0A++++%0A++++let+u+=+vec!%5BOk(1),+Ok(2),+Err(()),+Ok(3)%5D;%0A++++let+v+=+u.into_iter().try_collect::%3CVec%3Ci32%3E%3E();%0A++++assert_eq!(v,+Err(()));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Finally, even <a href=\"../ops/enum.ControlFlow.html\" title=\"enum std::ops::ControlFlow\"><code>ControlFlow</code></a> works, despite the fact that it\ndoesn’t implement <a href=\"trait.FromIterator.html\" title=\"trait std::iter::FromIterator\"><code>FromIterator</code></a>. Note also that the iterator can\ncontinue to be used, even if a failure is encountered:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_collect)]\n\n</span><span class=\"kw\">use </span>core::ops::ControlFlow::{Break, Continue};\n\n<span class=\"kw\">let </span>u = [Continue(<span class=\"number\">1</span>), Continue(<span class=\"number\">2</span>), Break(<span class=\"number\">3</span>), Continue(<span class=\"number\">4</span>), Continue(<span class=\"number\">5</span>)];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = u.into_iter();\n\n<span class=\"kw\">let </span>v = it.try_collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(v, Break(<span class=\"number\">3</span>));\n\n<span class=\"kw\">let </span>v = it.try_collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(v, Continue(<span class=\"macro\">vec!</span>[<span class=\"number\">4</span>, <span class=\"number\">5</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_collect)%5D%0A%0Afn+main()+%7B%0A++++use+core::ops::ControlFlow::%7BBreak,+Continue%7D;%0A++++%0A++++let+u+=+%5BContinue(1),+Continue(2),+Break(3),+Continue(4),+Continue(5)%5D;%0A++++let+mut+it+=+u.into_iter();%0A++++%0A++++let+v+=+it.try_collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(v,+Break(3));%0A++++%0A++++let+v+=+it.try_collect::%3CVec%3C_%3E%3E();%0A++++assert_eq!(v,+Continue(vec!%5B4,+5%5D));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.collect_into\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2154-2156\">source</a><h4 class=\"code-header\">fn <a href=\"#method.collect_into\" class=\"fn\">collect_into</a>&lt;E&gt;(self, collection: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut E</a>) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut E</a><div class=\"where\">where\n    E: <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_collect_into</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/94780\">#94780</a>)</span></div></span></summary><div class=\"docblock\"><p>Collects all the items from an iterator into a collection.</p>\n<p>This method consumes the iterator and adds all its items to the\npassed collection. The collection is then returned, so the call chain\ncan be continued.</p>\n<p>This is useful when you already have a collection and want to add\nthe iterator items to it.</p>\n<p>This method is a convenience method to call <a href=\"trait.Extend.html\">Extend::extend</a>,\nbut instead of being called on a collection, it’s called on an iterator.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_collect_into)]\n\n</span><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec: Vec::&lt;i32&gt; = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>];\n\na.iter().map(|<span class=\"kw-2\">&amp;</span>x| x * <span class=\"number\">2</span>).collect_into(<span class=\"kw-2\">&amp;mut </span>vec);\na.iter().map(|<span class=\"kw-2\">&amp;</span>x| x * <span class=\"number\">10</span>).collect_into(<span class=\"kw-2\">&amp;mut </span>vec);\n\n<span class=\"macro\">assert_eq!</span>(vec, <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_collect_into)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+vec:+Vec::%3Ci32%3E+=+vec!%5B0,+1%5D;%0A++++%0A++++a.iter().map(%7C%26x%7C+x+*+2).collect_into(%26mut+vec);%0A++++a.iter().map(%7C%26x%7C+x+*+10).collect_into(%26mut+vec);%0A++++%0A++++assert_eq!(vec,+vec!%5B0,+1,+2,+4,+6,+10,+20,+30%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p><code>Vec</code> can have a manual set capacity to avoid reallocating it:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_collect_into)]\n\n</span><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec: Vec::&lt;i32&gt; = Vec::with_capacity(<span class=\"number\">6</span>);\n\na.iter().map(|<span class=\"kw-2\">&amp;</span>x| x * <span class=\"number\">2</span>).collect_into(<span class=\"kw-2\">&amp;mut </span>vec);\na.iter().map(|<span class=\"kw-2\">&amp;</span>x| x * <span class=\"number\">10</span>).collect_into(<span class=\"kw-2\">&amp;mut </span>vec);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">6</span>, vec.capacity());\n<span class=\"macro\">assert_eq!</span>(vec, <span class=\"macro\">vec!</span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_collect_into)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+vec:+Vec::%3Ci32%3E+=+Vec::with_capacity(6);%0A++++%0A++++a.iter().map(%7C%26x%7C+x+*+2).collect_into(%26mut+vec);%0A++++a.iter().map(%7C%26x%7C+x+*+10).collect_into(%26mut+vec);%0A++++%0A++++assert_eq!(6,+vec.capacity());%0A++++assert_eq!(vec,+vec!%5B2,+4,+6,+10,+20,+30%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>The returned mutable reference can be used to continue the call chain:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_collect_into)]\n\n</span><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec: Vec::&lt;i32&gt; = Vec::with_capacity(<span class=\"number\">6</span>);\n\n<span class=\"kw\">let </span>count = a.iter().collect_into(<span class=\"kw-2\">&amp;mut </span>vec).iter().count();\n\n<span class=\"macro\">assert_eq!</span>(count, vec.len());\n<span class=\"macro\">assert_eq!</span>(vec, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n\n<span class=\"kw\">let </span>count = a.iter().collect_into(<span class=\"kw-2\">&amp;mut </span>vec).iter().count();\n\n<span class=\"macro\">assert_eq!</span>(count, vec.len());\n<span class=\"macro\">assert_eq!</span>(vec, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_collect_into)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+mut+vec:+Vec::%3Ci32%3E+=+Vec::with_capacity(6);%0A++++%0A++++let+count+=+a.iter().collect_into(%26mut+vec).iter().count();%0A++++%0A++++assert_eq!(count,+vec.len());%0A++++assert_eq!(vec,+vec!%5B1,+2,+3%5D);%0A++++%0A++++let+count+=+a.iter().collect_into(%26mut+vec).iter().count();%0A++++%0A++++assert_eq!(count,+vec.len());%0A++++assert_eq!(vec,+vec!%5B1,+2,+3,+1,+2,+3%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partition\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2187-2191\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.partition\" class=\"fn\">partition</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.tuple.html\">(B, B)</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    B: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> + <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Consumes an iterator, creating two collections from it.</p>\n<p>The predicate passed to <code>partition()</code> can return <code>true</code>, or <code>false</code>.\n<code>partition()</code> returns a pair, all of the elements for which it returned\n<code>true</code>, and all of the elements for which it returned <code>false</code>.</p>\n<p>See also <a href=\"trait.Iterator.html#method.is_partitioned\" title=\"method std::iter::Iterator::is_partitioned\"><code>is_partitioned()</code></a> and <a href=\"trait.Iterator.html#method.partition_in_place\" title=\"method std::iter::Iterator::partition_in_place\"><code>partition_in_place()</code></a>.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>(even, odd): (Vec&lt;<span class=\"kw\">_</span>&gt;, Vec&lt;<span class=\"kw\">_</span>&gt;) = a\n    .into_iter()\n    .partition(|n| n % <span class=\"number\">2 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(even, <span class=\"macro\">vec!</span>[<span class=\"number\">2</span>]);\n<span class=\"macro\">assert_eq!</span>(odd, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+(even,+odd):+(Vec%3C_%3E,+Vec%3C_%3E)+=+a%0A++++++++.into_iter()%0A++++++++.partition(%7Cn%7C+n+%25+2+==+0);%0A++++%0A++++assert_eq!(even,+vec!%5B2%5D);%0A++++assert_eq!(odd,+vec!%5B1,+3%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partition_in_place\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2250-2253\">source</a><h4 class=\"code-header\">fn <a href=\"#method.partition_in_place\" class=\"fn\">partition_in_place</a>&lt;'a, T, P&gt;(self, predicate: P) -&gt; <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a><div class=\"where\">where\n    T: 'a,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut T</a>&gt;,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_partition_in_place</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/62543\">#62543</a>)</span></div></span></summary><div class=\"docblock\"><p>Reorders the elements of this iterator <em>in-place</em> according to the given predicate,\nsuch that all those that return <code>true</code> precede all those that return <code>false</code>.\nReturns the number of <code>true</code> elements found.</p>\n<p>The relative order of partitioned items is not maintained.</p>\n<h5 id=\"current-implementation\"><a class=\"doc-anchor\" href=\"#current-implementation\">§</a>Current implementation</h5>\n<p>The current algorithm tries to find the first element for which the predicate evaluates\nto false and the last element for which it evaluates to true, and repeatedly swaps them.</p>\n<p>Time complexity: <em>O</em>(<em>n</em>)</p>\n<p>See also <a href=\"trait.Iterator.html#method.is_partitioned\" title=\"method std::iter::Iterator::is_partitioned\"><code>is_partitioned()</code></a> and <a href=\"trait.Iterator.html#method.partition\" title=\"method std::iter::Iterator::partition\"><code>partition()</code></a>.</p>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_partition_in_place)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];\n\n<span class=\"comment\">// Partition in-place between evens and odds\n</span><span class=\"kw\">let </span>i = a.iter_mut().partition_in_place(|<span class=\"kw-2\">&amp;</span>n| n % <span class=\"number\">2 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(i, <span class=\"number\">3</span>);\n<span class=\"macro\">assert!</span>(a[..i].iter().all(|<span class=\"kw-2\">&amp;</span>n| n % <span class=\"number\">2 </span>== <span class=\"number\">0</span>)); <span class=\"comment\">// evens\n</span><span class=\"macro\">assert!</span>(a[i..].iter().all(|<span class=\"kw-2\">&amp;</span>n| n % <span class=\"number\">2 </span>== <span class=\"number\">1</span>)); <span class=\"comment\">// odds</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_partition_in_place)%5D%0A%0Afn+main()+%7B%0A++++let+mut+a+=+%5B1,+2,+3,+4,+5,+6,+7%5D;%0A++++%0A++++//+Partition+in-place+between+evens+and+odds%0A++++let+i+=+a.iter_mut().partition_in_place(%7C%26n%7C+n+%25+2+==+0);%0A++++%0A++++assert_eq!(i,+3);%0A++++assert!(a%5B..i%5D.iter().all(%7C%26n%7C+n+%25+2+==+0));+//+evens%0A++++assert!(a%5Bi..%5D.iter().all(%7C%26n%7C+n+%25+2+==+1));+//+odds%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_partitioned\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2308-2311\">source</a><h4 class=\"code-header\">fn <a href=\"#method.is_partitioned\" class=\"fn\">is_partitioned</a>&lt;P&gt;(self, predicate: P) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_is_partitioned</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/62544\">#62544</a>)</span></div></span></summary><div class=\"docblock\"><p>Checks if the elements of this iterator are partitioned according to the given predicate,\nsuch that all those that return <code>true</code> precede all those that return <code>false</code>.</p>\n<p>See also <a href=\"trait.Iterator.html#method.partition\" title=\"method std::iter::Iterator::partition\"><code>partition()</code></a> and <a href=\"trait.Iterator.html#method.partition_in_place\" title=\"method std::iter::Iterator::partition_in_place\"><code>partition_in_place()</code></a>.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_is_partitioned)]\n\n</span><span class=\"macro\">assert!</span>(<span class=\"string\">\"Iterator\"</span>.chars().is_partitioned(char::is_uppercase));\n<span class=\"macro\">assert!</span>(!<span class=\"string\">\"IntoIterator\"</span>.chars().is_partitioned(char::is_uppercase));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_is_partitioned)%5D%0A%0Afn+main()+%7B%0A++++assert!(%22Iterator%22.chars().is_partitioned(char::is_uppercase));%0A++++assert!(!%22IntoIterator%22.chars().is_partitioned(char::is_uppercase));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_fold\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2403-2407\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.try_fold\" class=\"fn\">try_fold</a>&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(B, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n    R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = B&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator method that applies a function as long as it returns\nsuccessfully, producing a single, final value.</p>\n<p><code>try_fold()</code> takes two arguments: an initial value, and a closure with\ntwo arguments: an ‘accumulator’, and an element. The closure either\nreturns successfully, with the value that the accumulator should have\nfor the next iteration, or it returns failure, with an error value that\nis propagated back to the caller immediately (short-circuiting).</p>\n<p>The initial value is the value the accumulator will have on the first\ncall. If applying the closure succeeded against every element of the\niterator, <code>try_fold()</code> returns the final accumulator as success.</p>\n<p>Folding is useful whenever you have a collection of something, and want\nto produce a single value from it.</p>\n<h5 id=\"note-to-implementors\"><a class=\"doc-anchor\" href=\"#note-to-implementors\">§</a>Note to Implementors</h5>\n<p>Several of the other (forward) methods have default implementations in\nterms of this one, so try to implement this explicitly if it can\ndo something better than the default <code>for</code> loop implementation.</p>\n<p>In particular, try to have this call <code>try_fold()</code> on the internal parts\nfrom which this iterator is composed. If multiple calls are needed,\nthe <code>?</code> operator may be convenient for chaining the accumulator value\nalong, but beware any invariants that need to be upheld before those\nearly returns. This is a <code>&amp;mut self</code> method, so iteration needs to be\nresumable after hitting an error here.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"comment\">// the checked sum of all of the elements of the array\n</span><span class=\"kw\">let </span>sum = a.iter().try_fold(<span class=\"number\">0i8</span>, |acc, <span class=\"kw-2\">&amp;</span>x| acc.checked_add(x));\n\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"prelude-val\">Some</span>(<span class=\"number\">6</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++//+the+checked+sum+of+all+of+the+elements+of+the+array%0A++++let+sum+=+a.iter().try_fold(0i8,+%7Cacc,+%26x%7C+acc.checked_add(x));%0A++++%0A++++assert_eq!(sum,+Some(6));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Short-circuiting:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">100</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = a.iter();\n\n<span class=\"comment\">// This sum overflows when adding the 100 element\n</span><span class=\"kw\">let </span>sum = it.try_fold(<span class=\"number\">0i8</span>, |acc, <span class=\"kw-2\">&amp;</span>x| acc.checked_add(x));\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"prelude-val\">None</span>);\n\n<span class=\"comment\">// Because it short-circuited, the remaining elements are still\n// available through the iterator.\n</span><span class=\"macro\">assert_eq!</span>(it.len(), <span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">40</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B10,+20,+30,+100,+40,+50%5D;%0A++++let+mut+it+=+a.iter();%0A++++%0A++++//+This+sum+overflows+when+adding+the+100+element%0A++++let+sum+=+it.try_fold(0i8,+%7Cacc,+%26x%7C+acc.checked_add(x));%0A++++assert_eq!(sum,+None);%0A++++%0A++++//+Because+it+short-circuited,+the+remaining+elements+are+still%0A++++//+available+through+the+iterator.%0A++++assert_eq!(it.len(),+2);%0A++++assert_eq!(it.next(),+Some(%2640));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>While you cannot <code>break</code> from a closure, the <a href=\"../ops/enum.ControlFlow.html\" title=\"enum std::ops::ControlFlow\"><code>ControlFlow</code></a> type allows\na similar idea:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::ops::ControlFlow;\n\n<span class=\"kw\">let </span>triangular = (<span class=\"number\">1</span>..<span class=\"number\">30</span>).try_fold(<span class=\"number\">0_i8</span>, |prev, x| {\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(next) = prev.checked_add(x) {\n        ControlFlow::Continue(next)\n    } <span class=\"kw\">else </span>{\n        ControlFlow::Break(prev)\n    }\n});\n<span class=\"macro\">assert_eq!</span>(triangular, ControlFlow::Break(<span class=\"number\">120</span>));\n\n<span class=\"kw\">let </span>triangular = (<span class=\"number\">1</span>..<span class=\"number\">30</span>).try_fold(<span class=\"number\">0_u64</span>, |prev, x| {\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(next) = prev.checked_add(x) {\n        ControlFlow::Continue(next)\n    } <span class=\"kw\">else </span>{\n        ControlFlow::Break(prev)\n    }\n});\n<span class=\"macro\">assert_eq!</span>(triangular, ControlFlow::Continue(<span class=\"number\">435</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ops::ControlFlow;%0A++++%0A++++let+triangular+=+(1..30).try_fold(0_i8,+%7Cprev,+x%7C+%7B%0A++++++++if+let+Some(next)+=+prev.checked_add(x)+%7B%0A++++++++++++ControlFlow::Continue(next)%0A++++++++%7D+else+%7B%0A++++++++++++ControlFlow::Break(prev)%0A++++++++%7D%0A++++%7D);%0A++++assert_eq!(triangular,+ControlFlow::Break(120));%0A++++%0A++++let+triangular+=+(1..30).try_fold(0_u64,+%7Cprev,+x%7C+%7B%0A++++++++if+let+Some(next)+=+prev.checked_add(x)+%7B%0A++++++++++++ControlFlow::Continue(next)%0A++++++++%7D+else+%7B%0A++++++++++++ControlFlow::Break(prev)%0A++++++++%7D%0A++++%7D);%0A++++assert_eq!(triangular,+ControlFlow::Continue(435));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_for_each\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2462-2466\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.try_for_each\" class=\"fn\">try_for_each</a>&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n    R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = <a class=\"primitive\" href=\"../primitive.unit.html\">()</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>An iterator method that applies a fallible function to each item in the\niterator, stopping at the first error and returning that error.</p>\n<p>This can also be thought of as the fallible form of <a href=\"trait.Iterator.html#method.for_each\" title=\"method std::iter::Iterator::for_each\"><code>for_each()</code></a>\nor as the stateless version of <a href=\"trait.Iterator.html#method.try_fold\" title=\"method std::iter::Iterator::try_fold\"><code>try_fold()</code></a>.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::rename;\n<span class=\"kw\">use </span>std::io::{stdout, Write};\n<span class=\"kw\">use </span>std::path::Path;\n\n<span class=\"kw\">let </span>data = [<span class=\"string\">\"no_tea.txt\"</span>, <span class=\"string\">\"stale_bread.json\"</span>, <span class=\"string\">\"torrential_rain.png\"</span>];\n\n<span class=\"kw\">let </span>res = data.iter().try_for_each(|x| <span class=\"macro\">writeln!</span>(stdout(), <span class=\"string\">\"{x}\"</span>));\n<span class=\"macro\">assert!</span>(res.is_ok());\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = data.iter().cloned();\n<span class=\"kw\">let </span>res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(<span class=\"string\">\"old\"</span>)));\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"comment\">// It short-circuited, so the remaining items are still in the iterator:\n</span><span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"stale_bread.json\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::rename;%0A++++use+std::io::%7Bstdout,+Write%7D;%0A++++use+std::path::Path;%0A++++%0A++++let+data+=+%5B%22no_tea.txt%22,+%22stale_bread.json%22,+%22torrential_rain.png%22%5D;%0A++++%0A++++let+res+=+data.iter().try_for_each(%7Cx%7C+writeln!(stdout(),+%22%7Bx%7D%22));%0A++++assert!(res.is_ok());%0A++++%0A++++let+mut+it+=+data.iter().cloned();%0A++++let+res+=+it.try_for_each(%7Cx%7C+rename(x,+Path::new(x).with_extension(%22old%22)));%0A++++assert!(res.is_err());%0A++++//+It+short-circuited,+so+the+remaining+items+are+still+in+the+iterator:%0A++++assert_eq!(it.next(),+Some(%22stale_bread.json%22));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The <a href=\"../ops/enum.ControlFlow.html\" title=\"enum std::ops::ControlFlow\"><code>ControlFlow</code></a> type can be used with this method for the situations\nin which you’d use <code>break</code> and <code>continue</code> in a normal loop:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::ops::ControlFlow;\n\n<span class=\"kw\">let </span>r = (<span class=\"number\">2</span>..<span class=\"number\">100</span>).try_for_each(|x| {\n    <span class=\"kw\">if </span><span class=\"number\">323 </span>% x == <span class=\"number\">0 </span>{\n        <span class=\"kw\">return </span>ControlFlow::Break(x)\n    }\n\n    ControlFlow::Continue(())\n});\n<span class=\"macro\">assert_eq!</span>(r, ControlFlow::Break(<span class=\"number\">17</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ops::ControlFlow;%0A++++%0A++++let+r+=+(2..100).try_for_each(%7Cx%7C+%7B%0A++++++++if+323+%25+x+==+0+%7B%0A++++++++++++return+ControlFlow::Break(x)%0A++++++++%7D%0A++++%0A++++++++ControlFlow::Continue(())%0A++++%7D);%0A++++assert_eq!(r,+ControlFlow::Break(17));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fold\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2582-2585\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.fold\" class=\"fn\">fold</a>&lt;B, F&gt;(self, init: B, f: F) -&gt; B<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(B, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B,</div></h4></section></summary><div class=\"docblock\"><p>Folds every element into an accumulator by applying an operation,\nreturning the final result.</p>\n<p><code>fold()</code> takes two arguments: an initial value, and a closure with two\narguments: an ‘accumulator’, and an element. The closure returns the value that\nthe accumulator should have for the next iteration.</p>\n<p>The initial value is the value the accumulator will have on the first\ncall.</p>\n<p>After applying this closure to every element of the iterator, <code>fold()</code>\nreturns the accumulator.</p>\n<p>This operation is sometimes called ‘reduce’ or ‘inject’.</p>\n<p>Folding is useful whenever you have a collection of something, and want\nto produce a single value from it.</p>\n<p>Note: <code>fold()</code>, and similar methods that traverse the entire iterator,\nmight not terminate for infinite iterators, even on traits for which a\nresult is determinable in finite time.</p>\n<p>Note: <a href=\"trait.Iterator.html#method.reduce\" title=\"method std::iter::Iterator::reduce\"><code>reduce()</code></a> can be used to use the first element as the initial\nvalue, if the accumulator type and item type is the same.</p>\n<p>Note: <code>fold()</code> combines elements in a <em>left-associative</em> fashion. For associative\noperators like <code>+</code>, the order the elements are combined in is not important, but for non-associative\noperators like <code>-</code> the order will affect the final result.\nFor a <em>right-associative</em> version of <code>fold()</code>, see <a href=\"trait.DoubleEndedIterator.html#method.rfold\" title=\"method std::iter::DoubleEndedIterator::rfold\"><code>DoubleEndedIterator::rfold()</code></a>.</p>\n<h5 id=\"note-to-implementors-1\"><a class=\"doc-anchor\" href=\"#note-to-implementors-1\">§</a>Note to Implementors</h5>\n<p>Several of the other (forward) methods have default implementations in\nterms of this one, so try to implement this explicitly if it can\ndo something better than the default <code>for</code> loop implementation.</p>\n<p>In particular, try to have this call <code>fold()</code> on the internal parts\nfrom which this iterator is composed.</p>\n<h5 id=\"examples-38\"><a class=\"doc-anchor\" href=\"#examples-38\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"comment\">// the sum of all of the elements of the array\n</span><span class=\"kw\">let </span>sum = a.iter().fold(<span class=\"number\">0</span>, |acc, x| acc + x);\n\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"number\">6</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++//+the+sum+of+all+of+the+elements+of+the+array%0A++++let+sum+=+a.iter().fold(0,+%7Cacc,+x%7C+acc+%2B+x);%0A++++%0A++++assert_eq!(sum,+6);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Let’s walk through each step of the iteration here:</p>\n<div><table><thead><tr><th>element</th><th>acc</th><th>x</th><th>result</th></tr></thead><tbody>\n<tr><td></td><td>0</td><td></td><td></td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>1</td></tr>\n<tr><td>2</td><td>1</td><td>2</td><td>3</td></tr>\n<tr><td>3</td><td>3</td><td>3</td><td>6</td></tr>\n</tbody></table>\n</div>\n<p>And so, our final result, <code>6</code>.</p>\n<p>This example demonstrates the left-associative nature of <code>fold()</code>:\nit builds a string, starting with an initial value\nand continuing with each element from the front until the back:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n<span class=\"kw\">let </span>zero = <span class=\"string\">\"0\"</span>.to_string();\n\n<span class=\"kw\">let </span>result = numbers.iter().fold(zero, |acc, <span class=\"kw-2\">&amp;</span>x| {\n    <span class=\"macro\">format!</span>(<span class=\"string\">\"({acc} + {x})\"</span>)\n});\n\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"string\">\"(((((0 + 1) + 2) + 3) + 4) + 5)\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++let+zero+=+%220%22.to_string();%0A++++%0A++++let+result+=+numbers.iter().fold(zero,+%7Cacc,+%26x%7C+%7B%0A++++++++format!(%22(%7Bacc%7D+%2B+%7Bx%7D)%22)%0A++++%7D);%0A++++%0A++++assert_eq!(result,+%22(((((0+%2B+1)+%2B+2)+%2B+3)+%2B+4)+%2B+5)%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It’s common for people who haven’t used iterators a lot to\nuse a <code>for</code> loop with a list of things to build up a result. Those\ncan be turned into <code>fold()</code>s:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>result = <span class=\"number\">0</span>;\n\n<span class=\"comment\">// for loop:\n</span><span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>numbers {\n    result = result + i;\n}\n\n<span class=\"comment\">// fold:\n</span><span class=\"kw\">let </span>result2 = numbers.iter().fold(<span class=\"number\">0</span>, |acc, <span class=\"kw-2\">&amp;</span>x| acc + x);\n\n<span class=\"comment\">// they're the same\n</span><span class=\"macro\">assert_eq!</span>(result, result2);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+numbers+=+%5B1,+2,+3,+4,+5%5D;%0A++++%0A++++let+mut+result+=+0;%0A++++%0A++++//+for+loop:%0A++++for+i+in+%26numbers+%7B%0A++++++++result+=+result+%2B+i;%0A++++%7D%0A++++%0A++++//+fold:%0A++++let+result2+=+numbers.iter().fold(0,+%7Cacc,+%26x%7C+acc+%2B+x);%0A++++%0A++++//+they're+the+same%0A++++assert_eq!(result,+result2);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.reduce\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2620-2623\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.reduce\" class=\"fn\">reduce</a>&lt;F&gt;(self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>,</div></h4></section></summary><div class=\"docblock\"><p>Reduces the elements to a single one, by repeatedly applying a reducing\noperation.</p>\n<p>If the iterator is empty, returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>; otherwise, returns the\nresult of the reduction.</p>\n<p>The reducing function is a closure with two arguments: an ‘accumulator’, and an element.\nFor iterators with at least one element, this is the same as <a href=\"trait.Iterator.html#method.fold\" title=\"method std::iter::Iterator::fold\"><code>fold()</code></a>\nwith the first element of the iterator as the initial accumulator value, folding\nevery subsequent element into it.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>reduced: i32 = (<span class=\"number\">1</span>..<span class=\"number\">10</span>).reduce(|acc, e| acc + e).unwrap();\n<span class=\"macro\">assert_eq!</span>(reduced, <span class=\"number\">45</span>);\n\n<span class=\"comment\">// Which is equivalent to doing it with `fold`:\n</span><span class=\"kw\">let </span>folded: i32 = (<span class=\"number\">1</span>..<span class=\"number\">10</span>).fold(<span class=\"number\">0</span>, |acc, e| acc + e);\n<span class=\"macro\">assert_eq!</span>(reduced, folded);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+reduced:+i32+=+(1..10).reduce(%7Cacc,+e%7C+acc+%2B+e).unwrap();%0A++++assert_eq!(reduced,+45);%0A++++%0A++++//+Which+is+equivalent+to+doing+it+with+%60fold%60:%0A++++let+folded:+i32+=+(1..10).fold(0,+%7Cacc,+e%7C+acc+%2B+e);%0A++++assert_eq!(reduced,+folded);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_reduce\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2692-2697\">source</a><h4 class=\"code-header\">fn <a href=\"#method.try_reduce\" class=\"fn\">try_reduce</a>&lt;F, R&gt;(\n    &amp;mut self,\n    f: F,\n) -&gt; &lt;&lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a> as <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Output\" title=\"type std::ops::Try::Output\">Output</a>&gt;&gt;&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Residual.html#associatedtype.TryType\" title=\"type std::ops::Residual::TryType\">TryType</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n    R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n    &lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a>: <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iterator_try_reduce</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/87053\">#87053</a>)</span></div></span></summary><div class=\"docblock\"><p>Reduces the elements to a single one by repeatedly applying a reducing operation. If the\nclosure returns a failure, the failure is propagated back to the caller immediately.</p>\n<p>The return type of this method depends on the return type of the closure. If the closure\nreturns <code>Result&lt;Self::Item, E&gt;</code>, then this function will return <code>Result&lt;Option&lt;Self::Item&gt;, E&gt;</code>. If the closure returns <code>Option&lt;Self::Item&gt;</code>, then this function will return\n<code>Option&lt;Option&lt;Self::Item&gt;&gt;</code>.</p>\n<p>When called on an empty iterator, this function will return either <code>Some(None)</code> or\n<code>Ok(None)</code> depending on the type of the provided closure.</p>\n<p>For iterators with at least one element, this is essentially the same as calling\n<a href=\"trait.Iterator.html#method.try_fold\" title=\"method std::iter::Iterator::try_fold\"><code>try_fold()</code></a> with the first element of the iterator as the initial accumulator value.</p>\n<h5 id=\"examples-39\"><a class=\"doc-anchor\" href=\"#examples-39\">§</a>Examples</h5>\n<p>Safely calculate the sum of a series of numbers:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_reduce)]\n\n</span><span class=\"kw\">let </span>numbers: Vec&lt;usize&gt; = <span class=\"macro\">vec!</span>[<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span>sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"prelude-val\">Some</span>(<span class=\"prelude-val\">Some</span>(<span class=\"number\">58</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers:+Vec%3Cusize%3E+=+vec!%5B10,+20,+5,+23,+0%5D;%0A++++let+sum+=+numbers.into_iter().try_reduce(%7Cx,+y%7C+x.checked_add(y));%0A++++assert_eq!(sum,+Some(Some(58)));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Determine when a reduction short circuited:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_reduce)]\n\n</span><span class=\"kw\">let </span>numbers = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, usize::MAX, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n<span class=\"kw\">let </span>sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers+=+vec!%5B1,+2,+3,+usize::MAX,+4,+5%5D;%0A++++let+sum+=+numbers.into_iter().try_reduce(%7Cx,+y%7C+x.checked_add(y));%0A++++assert_eq!(sum,+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Determine when a reduction was not performed because there are no elements:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_reduce)]\n\n</span><span class=\"kw\">let </span>numbers: Vec&lt;usize&gt; = Vec::new();\n<span class=\"kw\">let </span>sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"prelude-val\">Some</span>(<span class=\"prelude-val\">None</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers:+Vec%3Cusize%3E+=+Vec::new();%0A++++let+sum+=+numbers.into_iter().try_reduce(%7Cx,+y%7C+x.checked_add(y));%0A++++assert_eq!(sum,+Some(None));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>Use a <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> instead of an <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iterator_try_reduce)]\n\n</span><span class=\"kw\">let </span>numbers = <span class=\"macro\">vec!</span>[<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"5\"</span>];\n<span class=\"kw\">let </span>max: <span class=\"prelude-ty\">Result</span>&lt;<span class=\"prelude-ty\">Option</span>&lt;<span class=\"kw\">_</span>&gt;, &lt;usize <span class=\"kw\">as </span>std::str::FromStr&gt;::Err&gt; =\n    numbers.into_iter().try_reduce(|x, y| {\n        <span class=\"kw\">if </span>x.parse::&lt;usize&gt;()<span class=\"question-mark\">? </span>&gt; y.parse::&lt;usize&gt;()<span class=\"question-mark\">? </span>{ <span class=\"prelude-val\">Ok</span>(x) } <span class=\"kw\">else </span>{ <span class=\"prelude-val\">Ok</span>(y) }\n    });\n<span class=\"macro\">assert_eq!</span>(max, <span class=\"prelude-val\">Ok</span>(<span class=\"prelude-val\">Some</span>(<span class=\"string\">\"5\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iterator_try_reduce)%5D%0A%0Afn+main()+%7B%0A++++let+numbers+=+vec!%5B%221%22,+%222%22,+%223%22,+%224%22,+%225%22%5D;%0A++++let+max:+Result%3COption%3C_%3E,+%3Cusize+as+std::str::FromStr%3E::Err%3E+=%0A++++++++numbers.into_iter().try_reduce(%7Cx,+y%7C+%7B%0A++++++++++++if+x.parse::%3Cusize%3E()?+%3E+y.parse::%3Cusize%3E()?+%7B+Ok(x)+%7D+else+%7B+Ok(y)+%7D%0A++++++++%7D);%0A++++assert_eq!(max,+Ok(Some(%225%22)));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.all\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2750-2753\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.all\" class=\"fn\">all</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Tests if every element of the iterator matches a predicate.</p>\n<p><code>all()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies\nthis closure to each element of the iterator, and if they all return\n<code>true</code>, then so does <code>all()</code>. If any of them return <code>false</code>, it\nreturns <code>false</code>.</p>\n<p><code>all()</code> is short-circuiting; in other words, it will stop processing\nas soon as it finds a <code>false</code>, given that no matter what else happens,\nthe result will also be <code>false</code>.</p>\n<p>An empty iterator returns <code>true</code>.</p>\n<h5 id=\"examples-40\"><a class=\"doc-anchor\" href=\"#examples-40\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"macro\">assert!</span>(a.iter().all(|<span class=\"kw-2\">&amp;</span>x| x &gt; <span class=\"number\">0</span>));\n\n<span class=\"macro\">assert!</span>(!a.iter().all(|<span class=\"kw-2\">&amp;</span>x| x &gt; <span class=\"number\">2</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert!(a.iter().all(%7C%26x%7C+x+%3E+0));%0A++++%0A++++assert!(!a.iter().all(%7C%26x%7C+x+%3E+2));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping at the first <code>false</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert!</span>(!iter.all(|<span class=\"kw-2\">&amp;</span>x| x != <span class=\"number\">2</span>));\n\n<span class=\"comment\">// we can still use `iter`, as there are more elements.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert!(!iter.all(%7C%26x%7C+x+!=+2));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%263));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.any\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2804-2807\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.any\" class=\"fn\">any</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Tests if any element of the iterator matches a predicate.</p>\n<p><code>any()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies\nthis closure to each element of the iterator, and if any of them return\n<code>true</code>, then so does <code>any()</code>. If they all return <code>false</code>, it\nreturns <code>false</code>.</p>\n<p><code>any()</code> is short-circuiting; in other words, it will stop processing\nas soon as it finds a <code>true</code>, given that no matter what else happens,\nthe result will also be <code>true</code>.</p>\n<p>An empty iterator returns <code>false</code>.</p>\n<h5 id=\"examples-41\"><a class=\"doc-anchor\" href=\"#examples-41\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"macro\">assert!</span>(a.iter().any(|<span class=\"kw-2\">&amp;</span>x| x &gt; <span class=\"number\">0</span>));\n\n<span class=\"macro\">assert!</span>(!a.iter().any(|<span class=\"kw-2\">&amp;</span>x| x &gt; <span class=\"number\">5</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert!(a.iter().any(%7C%26x%7C+x+%3E+0));%0A++++%0A++++assert!(!a.iter().any(%7C%26x%7C+x+%3E+5));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping at the first <code>true</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert!</span>(iter.any(|<span class=\"kw-2\">&amp;</span>x| x != <span class=\"number\">2</span>));\n\n<span class=\"comment\">// we can still use `iter`, as there are more elements.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert!(iter.any(%7C%26x%7C+x+!=+2));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%262));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.find\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2868-2871\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.find\" class=\"fn\">find</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Searches for an element of an iterator that satisfies a predicate.</p>\n<p><code>find()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies\nthis closure to each element of the iterator, and if any of them return\n<code>true</code>, then <code>find()</code> returns <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(element)</code></a>. If they all return\n<code>false</code>, it returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p><code>find()</code> is short-circuiting; in other words, it will stop processing\nas soon as the closure returns <code>true</code>.</p>\n<p>Because <code>find()</code> takes a reference, and many iterators iterate over\nreferences, this leads to a possibly confusing situation where the\nargument is a double reference. You can see this effect in the\nexamples below, with <code>&amp;&amp;x</code>.</p>\n<p>If you need the index of the element, see <a href=\"trait.Iterator.html#method.position\" title=\"method std::iter::Iterator::position\"><code>position()</code></a>.</p>\n<h5 id=\"examples-42\"><a class=\"doc-anchor\" href=\"#examples-42\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"macro\">assert_eq!</span>(a.iter().find(|&amp;&amp;x| x == <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n\n<span class=\"macro\">assert_eq!</span>(a.iter().find(|&amp;&amp;x| x == <span class=\"number\">5</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert_eq!(a.iter().find(%7C%26%26x%7C+x+==+2),+Some(%262));%0A++++%0A++++assert_eq!(a.iter().find(%7C%26%26x%7C+x+==+5),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping at the first <code>true</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert_eq!</span>(iter.find(|&amp;&amp;x| x == <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n\n<span class=\"comment\">// we can still use `iter`, as there are more elements.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.find(%7C%26%26x%7C+x+==+2),+Some(%262));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%263));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that <code>iter.find(f)</code> is equivalent to <code>iter.filter(f).next()</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.find_map\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2900-2903\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.find_map\" class=\"fn\">find_map</a>&lt;B, F&gt;(&amp;mut self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Applies function to the elements of iterator and returns\nthe first non-none result.</p>\n<p><code>iter.find_map(f)</code> is equivalent to <code>iter.filter_map(f).next()</code>.</p>\n<h5 id=\"examples-43\"><a class=\"doc-anchor\" href=\"#examples-43\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"string\">\"lol\"</span>, <span class=\"string\">\"NaN\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"5\"</span>];\n\n<span class=\"kw\">let </span>first_number = a.iter().find_map(|s| s.parse().ok());\n\n<span class=\"macro\">assert_eq!</span>(first_number, <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B%22lol%22,+%22NaN%22,+%222%22,+%225%22%5D;%0A++++%0A++++let+first_number+=+a.iter().find_map(%7Cs%7C+s.parse().ok());%0A++++%0A++++assert_eq!(first_number,+Some(2));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_find\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#2959-2964\">source</a><h4 class=\"code-header\">fn <a href=\"#method.try_find\" class=\"fn\">try_find</a>&lt;F, R&gt;(\n    &amp;mut self,\n    f: F,\n) -&gt; &lt;&lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a> as <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;&gt;&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Residual.html#associatedtype.TryType\" title=\"type std::ops::Residual::TryType\">TryType</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; R,\n    R: <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&lt;Output = <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>&gt;,\n    &lt;R as <a class=\"trait\" href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\">Try</a>&gt;::<a class=\"associatedtype\" href=\"../ops/trait.Try.html#associatedtype.Residual\" title=\"type std::ops::Try::Residual\">Residual</a>: <a class=\"trait\" href=\"../ops/trait.Residual.html\" title=\"trait std::ops::Residual\">Residual</a>&lt;<a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>try_find</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/63178\">#63178</a>)</span></div></span></summary><div class=\"docblock\"><p>Applies function to the elements of iterator and returns\nthe first true result or the first error.</p>\n<p>The return type of this method depends on the return type of the closure.\nIf you return <code>Result&lt;bool, E&gt;</code> from the closure, you’ll get a <code>Result&lt;Option&lt;Self::Item&gt;, E&gt;</code>.\nIf you return <code>Option&lt;bool&gt;</code> from the closure, you’ll get an <code>Option&lt;Option&lt;Self::Item&gt;&gt;</code>.</p>\n<h5 id=\"examples-44\"><a class=\"doc-anchor\" href=\"#examples-44\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(try_find)]\n\n</span><span class=\"kw\">let </span>a = [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"lol\"</span>, <span class=\"string\">\"NaN\"</span>, <span class=\"string\">\"5\"</span>];\n\n<span class=\"kw\">let </span>is_my_num = |s: <span class=\"kw-2\">&amp;</span>str, search: i32| -&gt; <span class=\"prelude-ty\">Result</span>&lt;bool, std::num::ParseIntError&gt; {\n    <span class=\"prelude-val\">Ok</span>(s.parse::&lt;i32&gt;()<span class=\"question-mark\">?  </span>== search)\n};\n\n<span class=\"kw\">let </span>result = a.iter().try_find(|&amp;&amp;s| is_my_num(s, <span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"prelude-val\">Ok</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"string\">\"2\"</span>)));\n\n<span class=\"kw\">let </span>result = a.iter().try_find(|&amp;&amp;s| is_my_num(s, <span class=\"number\">5</span>));\n<span class=\"macro\">assert!</span>(result.is_err());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(try_find)%5D%0A%0Afn+main()+%7B%0A++++let+a+=+%5B%221%22,+%222%22,+%22lol%22,+%22NaN%22,+%225%22%5D;%0A++++%0A++++let+is_my_num+=+%7Cs:+%26str,+search:+i32%7C+-%3E+Result%3Cbool,+std::num::ParseIntError%3E+%7B%0A++++++++Ok(s.parse::%3Ci32%3E()?++==+search)%0A++++%7D;%0A++++%0A++++let+result+=+a.iter().try_find(%7C%26%26s%7C+is_my_num(s,+2));%0A++++assert_eq!(result,+Ok(Some(%26%222%22)));%0A++++%0A++++let+result+=+a.iter().try_find(%7C%26%26s%7C+is_my_num(s,+5));%0A++++assert!(result.is_err());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>This also supports other types which implement <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>Try</code></a>, not just <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(try_find)]\n\n</span><span class=\"kw\">use </span>std::num::NonZero;\n\n<span class=\"kw\">let </span>a = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">11u32</span>];\n<span class=\"kw\">let </span>result = a.iter().try_find(|&amp;&amp;x| NonZero::new(x).map(|y| y.is_power_of_two()));\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"prelude-val\">Some</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>)));\n<span class=\"kw\">let </span>result = a.iter().take(<span class=\"number\">3</span>).try_find(|&amp;&amp;x| NonZero::new(x).map(|y| y.is_power_of_two()));\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"prelude-val\">Some</span>(<span class=\"prelude-val\">None</span>));\n<span class=\"kw\">let </span>result = a.iter().rev().try_find(|&amp;&amp;x| NonZero::new(x).map(|y| y.is_power_of_two()));\n<span class=\"macro\">assert_eq!</span>(result, <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(try_find)%5D%0A%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+a+=+%5B3,+5,+7,+4,+9,+0,+11u32%5D;%0A++++let+result+=+a.iter().try_find(%7C%26%26x%7C+NonZero::new(x).map(%7Cy%7C+y.is_power_of_two()));%0A++++assert_eq!(result,+Some(Some(%264)));%0A++++let+result+=+a.iter().take(3).try_find(%7C%26%26x%7C+NonZero::new(x).map(%7Cy%7C+y.is_power_of_two()));%0A++++assert_eq!(result,+Some(None));%0A++++let+result+=+a.iter().rev().try_find(%7C%26%26x%7C+NonZero::new(x).map(%7Cy%7C+y.is_power_of_two()));%0A++++assert_eq!(result,+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.position\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3042-3045\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.position\" class=\"fn\">position</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Searches for an element in an iterator, returning its index.</p>\n<p><code>position()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies\nthis closure to each element of the iterator, and if one of them\nreturns <code>true</code>, then <code>position()</code> returns <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(index)</code></a>. If all of\nthem return <code>false</code>, it returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p><code>position()</code> is short-circuiting; in other words, it will stop\nprocessing as soon as it finds a <code>true</code>.</p>\n<h5 id=\"overflow-behavior-2\"><a class=\"doc-anchor\" href=\"#overflow-behavior-2\">§</a>Overflow Behavior</h5>\n<p>The method does no guarding against overflows, so if there are more\nthan <a href=\"../primitive.usize.html#associatedconstant.MAX\" title=\"associated constant usize::MAX\"><code>usize::MAX</code></a> non-matching elements, it either produces the wrong\nresult or panics. If debug assertions are enabled, a panic is\nguaranteed.</p>\n<h5 id=\"panics-4\"><a class=\"doc-anchor\" href=\"#panics-4\">§</a>Panics</h5>\n<p>This function might panic if the iterator has more than <code>usize::MAX</code>\nnon-matching elements.</p>\n<h5 id=\"examples-45\"><a class=\"doc-anchor\" href=\"#examples-45\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"macro\">assert_eq!</span>(a.iter().position(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n\n<span class=\"macro\">assert_eq!</span>(a.iter().position(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">5</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert_eq!(a.iter().position(%7C%26x%7C+x+==+2),+Some(1));%0A++++%0A++++assert_eq!(a.iter().position(%7C%26x%7C+x+==+5),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping at the first <code>true</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert_eq!</span>(iter.position(|<span class=\"kw-2\">&amp;</span>x| x &gt;= <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n\n<span class=\"comment\">// we can still use `iter`, as there are more elements.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n\n<span class=\"comment\">// The returned index depends on iterator state\n</span><span class=\"macro\">assert_eq!</span>(iter.position(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">4</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>));\n</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3,+4%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.position(%7C%26x%7C+x+%3E=+2),+Some(1));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++%0A++++//+The+returned+index+depends+on+iterator+state%0A++++assert_eq!(iter.position(%7C%26x%7C+x+==+4),+Some(0));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rposition\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3107-3110\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.rposition\" class=\"fn\">rposition</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ExactSizeIterator.html\" title=\"trait std::iter::ExactSizeIterator\">ExactSizeIterator</a> + <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a>,</div></h4></section></summary><div class=\"docblock\"><p>Searches for an element in an iterator from the right, returning its\nindex.</p>\n<p><code>rposition()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies\nthis closure to each element of the iterator, starting from the end,\nand if one of them returns <code>true</code>, then <code>rposition()</code> returns\n<a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(index)</code></a>. If all of them return <code>false</code>, it returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p><code>rposition()</code> is short-circuiting; in other words, it will stop\nprocessing as soon as it finds a <code>true</code>.</p>\n<h5 id=\"examples-46\"><a class=\"doc-anchor\" href=\"#examples-46\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"macro\">assert_eq!</span>(a.iter().rposition(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">3</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n\n<span class=\"macro\">assert_eq!</span>(a.iter().rposition(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">5</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++assert_eq!(a.iter().rposition(%7C%26x%7C+x+==+3),+Some(2));%0A++++%0A++++assert_eq!(a.iter().rposition(%7C%26x%7C+x+==+5),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Stopping at the first <code>true</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter();\n\n<span class=\"macro\">assert_eq!</span>(iter.rposition(|<span class=\"kw-2\">&amp;</span>x| x &gt;= <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>));\n\n<span class=\"comment\">// we can still use `iter`, as there are more elements.\n</span><span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>-<span class=\"number\">1</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-1,+2,+3,+4%5D;%0A++++%0A++++let+mut+iter+=+a.iter();%0A++++%0A++++assert_eq!(iter.rposition(%7C%26x%7C+x+%3E=+2),+Some(3));%0A++++%0A++++//+we+can+still+use+%60iter%60,+as+there+are+more+elements.%0A++++assert_eq!(iter.next(),+Some(%26-1));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3157-3160\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.max\" class=\"fn\">max</a>(self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the maximum element of an iterator.</p>\n<p>If several elements are equally maximum, the last element is\nreturned. If the iterator is empty, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.</p>\n<p>Note that <a href=\"../primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a>/<a href=\"../primitive.f64.html\" title=\"primitive f64\"><code>f64</code></a> doesn’t implement <a href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a> due to NaN being\nincomparable. You can work around this by using <a href=\"trait.Iterator.html#method.reduce\" title=\"method std::iter::Iterator::reduce\"><code>Iterator::reduce</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(\n    [<span class=\"number\">2.4</span>, f32::NAN, <span class=\"number\">1.3</span>]\n        .into_iter()\n        .reduce(f32::max)\n        .unwrap(),\n    <span class=\"number\">2.4\n</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%0A++++++++%5B2.4,+f32::NAN,+1.3%5D%0A++++++++++++.into_iter()%0A++++++++++++.reduce(f32::max)%0A++++++++++++.unwrap(),%0A++++++++2.4%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"examples-47\"><a class=\"doc-anchor\" href=\"#examples-47\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>b: Vec&lt;u32&gt; = Vec::new();\n\n<span class=\"macro\">assert_eq!</span>(a.iter().max(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(b.iter().max(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b:+Vec%3Cu32%3E+=+Vec::new();%0A++++%0A++++assert_eq!(a.iter().max(),+Some(%263));%0A++++assert_eq!(b.iter().max(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3194-3197\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.min\" class=\"fn\">min</a>(self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the minimum element of an iterator.</p>\n<p>If several elements are equally minimum, the first element is returned.\nIf the iterator is empty, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.</p>\n<p>Note that <a href=\"../primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a>/<a href=\"../primitive.f64.html\" title=\"primitive f64\"><code>f64</code></a> doesn’t implement <a href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a> due to NaN being\nincomparable. You can work around this by using <a href=\"trait.Iterator.html#method.reduce\" title=\"method std::iter::Iterator::reduce\"><code>Iterator::reduce</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(\n    [<span class=\"number\">2.4</span>, f32::NAN, <span class=\"number\">1.3</span>]\n        .into_iter()\n        .reduce(f32::min)\n        .unwrap(),\n    <span class=\"number\">1.3\n</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%0A++++++++%5B2.4,+f32::NAN,+1.3%5D%0A++++++++++++.into_iter()%0A++++++++++++.reduce(f32::min)%0A++++++++++++.unwrap(),%0A++++++++1.3%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"examples-48\"><a class=\"doc-anchor\" href=\"#examples-48\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>b: Vec&lt;u32&gt; = Vec::new();\n\n<span class=\"macro\">assert_eq!</span>(a.iter().min(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(b.iter().min(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+b:+Vec%3Cu32%3E+=+Vec::new();%0A++++%0A++++assert_eq!(a.iter().min(),+Some(%261));%0A++++assert_eq!(b.iter().min(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3217-3220\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.max_by_key\" class=\"fn\">max_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    B: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B,</div></h4></section></summary><div class=\"docblock\"><p>Returns the element that gives the maximum value from the\nspecified function.</p>\n<p>If several elements are equally maximum, the last element is\nreturned. If the iterator is empty, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.</p>\n<h5 id=\"examples-49\"><a class=\"doc-anchor\" href=\"#examples-49\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">3_i32</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, -<span class=\"number\">10</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>a.iter().max_by_key(|x| x.abs()).unwrap(), -<span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().max_by_key(%7Cx%7C+x.abs()).unwrap(),+-10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3251-3254\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.max_by\" class=\"fn\">max_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the element that gives the maximum value with respect to the\nspecified comparison function.</p>\n<p>If several elements are equally maximum, the last element is\nreturned. If the iterator is empty, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.</p>\n<h5 id=\"examples-50\"><a class=\"doc-anchor\" href=\"#examples-50\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">3_i32</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, -<span class=\"number\">10</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>a.iter().max_by(|x, y| x.cmp(y)).unwrap(), <span class=\"number\">5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().max_by(%7Cx,+y%7C+x.cmp(y)).unwrap(),+5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3279-3282\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.min_by_key\" class=\"fn\">min_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    B: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B,</div></h4></section></summary><div class=\"docblock\"><p>Returns the element that gives the minimum value from the\nspecified function.</p>\n<p>If several elements are equally minimum, the first element is\nreturned. If the iterator is empty, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.</p>\n<h5 id=\"examples-51\"><a class=\"doc-anchor\" href=\"#examples-51\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">3_i32</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, -<span class=\"number\">10</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>a.iter().min_by_key(|x| x.abs()).unwrap(), <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().min_by_key(%7Cx%7C+x.abs()).unwrap(),+0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3313-3316\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.min_by\" class=\"fn\">min_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the element that gives the minimum value with respect to the\nspecified comparison function.</p>\n<p>If several elements are equally minimum, the first element is\nreturned. If the iterator is empty, <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a> is returned.</p>\n<h5 id=\"examples-52\"><a class=\"doc-anchor\" href=\"#examples-52\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [-<span class=\"number\">3_i32</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, -<span class=\"number\">10</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -<span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B-3_i32,+0,+1,+5,+-10%5D;%0A++++assert_eq!(*a.iter().min_by(%7Cx,+y%7C+x.cmp(y)).unwrap(),+-10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rev\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3351-3353\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.rev\" class=\"fn\">rev</a>(self) -&gt; <a class=\"struct\" href=\"struct.Rev.html\" title=\"struct std::iter::Rev\">Rev</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Rev<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a>,</div></h4></section></summary><div class=\"docblock\"><p>Reverses an iterator’s direction.</p>\n<p>Usually, iterators iterate from left to right. After using <code>rev()</code>,\nan iterator will instead iterate from right to left.</p>\n<p>This is only possible if the iterator has an end, so <code>rev()</code> only\nworks on <a href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\"><code>DoubleEndedIterator</code></a>s.</p>\n<h5 id=\"examples-53\"><a class=\"doc-anchor\" href=\"#examples-53\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = a.iter().rev();\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+iter+=+a.iter().rev();%0A++++%0A++++assert_eq!(iter.next(),+Some(%263));%0A++++assert_eq!(iter.next(),+Some(%262));%0A++++assert_eq!(iter.next(),+Some(%261));%0A++++%0A++++assert_eq!(iter.next(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.unzip\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3388-3392\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.unzip\" class=\"fn\">unzip</a>&lt;A, B, FromA, FromB&gt;(self) -&gt; <a class=\"primitive\" href=\"../primitive.tuple.html\">(FromA, FromB)</a><div class=\"where\">where\n    FromA: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> + <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;A&gt;,\n    FromB: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> + <a class=\"trait\" href=\"trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;B&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.tuple.html\">(A, B)</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Converts an iterator of pairs into a pair of containers.</p>\n<p><code>unzip()</code> consumes an entire iterator of pairs, producing two\ncollections: one from the left elements of the pairs, and one\nfrom the right elements.</p>\n<p>This function is, in some sense, the opposite of <a href=\"trait.Iterator.html#method.zip\" title=\"method std::iter::Iterator::zip\"><code>zip</code></a>.</p>\n<h5 id=\"examples-54\"><a class=\"doc-anchor\" href=\"#examples-54\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [(<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>), (<span class=\"number\">5</span>, <span class=\"number\">6</span>)];\n\n<span class=\"kw\">let </span>(left, right): (Vec&lt;<span class=\"kw\">_</span>&gt;, Vec&lt;<span class=\"kw\">_</span>&gt;) = a.iter().cloned().unzip();\n\n<span class=\"macro\">assert_eq!</span>(left, [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>]);\n<span class=\"macro\">assert_eq!</span>(right, [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]);\n\n<span class=\"comment\">// you can also unzip multiple nested tuples at once\n</span><span class=\"kw\">let </span>a = [(<span class=\"number\">1</span>, (<span class=\"number\">2</span>, <span class=\"number\">3</span>)), (<span class=\"number\">4</span>, (<span class=\"number\">5</span>, <span class=\"number\">6</span>))];\n\n<span class=\"kw\">let </span>(x, (y, z)): (Vec&lt;<span class=\"kw\">_</span>&gt;, (Vec&lt;<span class=\"kw\">_</span>&gt;, Vec&lt;<span class=\"kw\">_</span>&gt;)) = a.iter().cloned().unzip();\n<span class=\"macro\">assert_eq!</span>(x, [<span class=\"number\">1</span>, <span class=\"number\">4</span>]);\n<span class=\"macro\">assert_eq!</span>(y, [<span class=\"number\">2</span>, <span class=\"number\">5</span>]);\n<span class=\"macro\">assert_eq!</span>(z, [<span class=\"number\">3</span>, <span class=\"number\">6</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B(1,+2),+(3,+4),+(5,+6)%5D;%0A++++%0A++++let+(left,+right):+(Vec%3C_%3E,+Vec%3C_%3E)+=+a.iter().cloned().unzip();%0A++++%0A++++assert_eq!(left,+%5B1,+3,+5%5D);%0A++++assert_eq!(right,+%5B2,+4,+6%5D);%0A++++%0A++++//+you+can+also+unzip+multiple+nested+tuples+at+once%0A++++let+a+=+%5B(1,+(2,+3)),+(4,+(5,+6))%5D;%0A++++%0A++++let+(x,+(y,+z)):+(Vec%3C_%3E,+(Vec%3C_%3E,+Vec%3C_%3E))+=+a.iter().cloned().unzip();%0A++++assert_eq!(x,+%5B1,+4%5D);%0A++++assert_eq!(y,+%5B2,+5%5D);%0A++++assert_eq!(z,+%5B3,+6%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.copied\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3419-3422\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.copied\" class=\"fn\">copied</a>&lt;'a, T&gt;(self) -&gt; <a class=\"struct\" href=\"struct.Copied.html\" title=\"struct std::iter::Copied\">Copied</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Copied<Self>\">ⓘ</a><div class=\"where\">where\n    T: 'a + <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator which copies all of its elements.</p>\n<p>This is useful when you have an iterator over <code>&amp;T</code>, but you need an\niterator over <code>T</code>.</p>\n<h5 id=\"examples-55\"><a class=\"doc-anchor\" href=\"#examples-55\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>v_copied: Vec&lt;<span class=\"kw\">_</span>&gt; = a.iter().copied().collect();\n\n<span class=\"comment\">// copied is the same as .map(|&amp;x| x)\n</span><span class=\"kw\">let </span>v_map: Vec&lt;<span class=\"kw\">_</span>&gt; = a.iter().map(|<span class=\"kw-2\">&amp;</span>x| x).collect();\n\n<span class=\"macro\">assert_eq!</span>(v_copied, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"macro\">assert_eq!</span>(v_map, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+v_copied:+Vec%3C_%3E+=+a.iter().copied().collect();%0A++++%0A++++//+copied+is+the+same+as+.map(%7C%26x%7C+x)%0A++++let+v_map:+Vec%3C_%3E+=+a.iter().map(%7C%26x%7C+x).collect();%0A++++%0A++++assert_eq!(v_copied,+vec!%5B1,+2,+3%5D);%0A++++assert_eq!(v_map,+vec!%5B1,+2,+3%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cloned\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3467-3470\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.cloned\" class=\"fn\">cloned</a>&lt;'a, T&gt;(self) -&gt; <a class=\"struct\" href=\"struct.Cloned.html\" title=\"struct std::iter::Cloned\">Cloned</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Cloned<Self>\">ⓘ</a><div class=\"where\">where\n    T: 'a + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Creates an iterator which <a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a>s all of its elements.</p>\n<p>This is useful when you have an iterator over <code>&amp;T</code>, but you need an\niterator over <code>T</code>.</p>\n<p>There is no guarantee whatsoever about the <code>clone</code> method actually\nbeing called <em>or</em> optimized away. So code should not depend on\neither.</p>\n<h5 id=\"examples-56\"><a class=\"doc-anchor\" href=\"#examples-56\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>v_cloned: Vec&lt;<span class=\"kw\">_</span>&gt; = a.iter().cloned().collect();\n\n<span class=\"comment\">// cloned is the same as .map(|&amp;x| x), for integers\n</span><span class=\"kw\">let </span>v_map: Vec&lt;<span class=\"kw\">_</span>&gt; = a.iter().map(|<span class=\"kw-2\">&amp;</span>x| x).collect();\n\n<span class=\"macro\">assert_eq!</span>(v_cloned, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"macro\">assert_eq!</span>(v_map, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+v_cloned:+Vec%3C_%3E+=+a.iter().cloned().collect();%0A++++%0A++++//+cloned+is+the+same+as+.map(%7C%26x%7C+x),+for+integers%0A++++let+v_map:+Vec%3C_%3E+=+a.iter().map(%7C%26x%7C+x).collect();%0A++++%0A++++assert_eq!(v_cloned,+vec!%5B1,+2,+3%5D);%0A++++assert_eq!(v_map,+vec!%5B1,+2,+3%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>To get the best performance, try to clone late:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"macro\">vec!</span>[<span class=\"number\">0_u8</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"macro\">vec!</span>[<span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"macro\">vec!</span>[<span class=\"number\">23</span>]];\n<span class=\"comment\">// don't do this:\n</span><span class=\"kw\">let </span>slower: Vec&lt;<span class=\"kw\">_</span>&gt; = a.iter().cloned().filter(|s| s.len() == <span class=\"number\">1</span>).collect();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"macro\">vec!</span>[<span class=\"number\">23</span>]], <span class=\"kw-2\">&amp;</span>slower[..]);\n<span class=\"comment\">// instead call `cloned` late\n</span><span class=\"kw\">let </span>faster: Vec&lt;<span class=\"kw\">_</span>&gt; = a.iter().filter(|s| s.len() == <span class=\"number\">1</span>).cloned().collect();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"macro\">vec!</span>[<span class=\"number\">23</span>]], <span class=\"kw-2\">&amp;</span>faster[..]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5Bvec!%5B0_u8,+1,+2%5D,+vec!%5B3,+4%5D,+vec!%5B23%5D%5D;%0A++++//+don't+do+this:%0A++++let+slower:+Vec%3C_%3E+=+a.iter().cloned().filter(%7Cs%7C+s.len()+==+1).collect();%0A++++assert_eq!(%26%5Bvec!%5B23%5D%5D,+%26slower%5B..%5D);%0A++++//+instead+call+%60cloned%60+late%0A++++let+faster:+Vec%3C_%3E+=+a.iter().filter(%7Cs%7C+s.len()+==+1).cloned().collect();%0A++++assert_eq!(%26%5Bvec!%5B23%5D%5D,+%26faster%5B..%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cycle\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3500-3502\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.cycle\" class=\"fn\">cycle</a>(self) -&gt; <a class=\"struct\" href=\"struct.Cycle.html\" title=\"struct std::iter::Cycle\">Cycle</a>&lt;Self&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Cycle<Self>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Repeats an iterator endlessly.</p>\n<p>Instead of stopping at <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, the iterator will instead start again,\nfrom the beginning. After iterating again, it will start at the\nbeginning again. And again. And again. Forever. Note that in case the\noriginal iterator is empty, the resulting iterator will also be empty.</p>\n<h5 id=\"examples-57\"><a class=\"doc-anchor\" href=\"#examples-57\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = a.iter().cycle();\n\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++%0A++++let+mut+it+=+a.iter().cycle();%0A++++%0A++++assert_eq!(it.next(),+Some(%261));%0A++++assert_eq!(it.next(),+Some(%262));%0A++++assert_eq!(it.next(),+Some(%263));%0A++++assert_eq!(it.next(),+Some(%261));%0A++++assert_eq!(it.next(),+Some(%262));%0A++++assert_eq!(it.next(),+Some(%263));%0A++++assert_eq!(it.next(),+Some(%261));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.array_chunks\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3544-3546\">source</a><h4 class=\"code-header\">fn <a href=\"#method.array_chunks\" class=\"fn\">array_chunks</a>&lt;const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;(self) -&gt; <a class=\"struct\" href=\"struct.ArrayChunks.html\" title=\"struct std::iter::ArrayChunks\">ArrayChunks</a>&lt;Self, N&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"ArrayChunks<Self, N>\">ⓘ</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_array_chunks</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/100450\">#100450</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns an iterator over <code>N</code> elements of the iterator at a time.</p>\n<p>The chunks do not overlap. If <code>N</code> does not divide the length of the\niterator, then the last up to <code>N-1</code> elements will be omitted and can be\nretrieved from the <a href=\"struct.ArrayChunks.html#method.into_remainder\" title=\"method std::iter::ArrayChunks::into_remainder\"><code>.into_remainder()</code></a>\nfunction of the iterator.</p>\n<h5 id=\"panics-5\"><a class=\"doc-anchor\" href=\"#panics-5\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is 0.</p>\n<h5 id=\"examples-58\"><a class=\"doc-anchor\" href=\"#examples-58\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_array_chunks)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = <span class=\"string\">\"lorem\"</span>.chars().array_chunks();\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>([<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>([<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(iter.into_remainder().unwrap().as_slice(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'m'</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_array_chunks)%5D%0A%0Afn+main()+%7B%0A++++let+mut+iter+=+%22lorem%22.chars().array_chunks();%0A++++assert_eq!(iter.next(),+Some(%5B'l',+'o'%5D));%0A++++assert_eq!(iter.next(),+Some(%5B'r',+'e'%5D));%0A++++assert_eq!(iter.next(),+None);%0A++++assert_eq!(iter.into_remainder().unwrap().as_slice(),+%26%5B'm'%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_array_chunks)]\n\n</span><span class=\"kw\">let </span>data = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>];\n<span class=\"comment\">//          ^-----^  ^------^\n</span><span class=\"kw\">for </span>[x, y, z] <span class=\"kw\">in </span>data.iter().array_chunks() {\n    <span class=\"macro\">assert_eq!</span>(x + y + z, <span class=\"number\">4</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_array_chunks)%5D%0A%0Afn+main()+%7B%0A++++let+data+=+%5B1,+1,+2,+-2,+6,+0,+3,+1%5D;%0A++++//++++++++++%5E-----%5E++%5E------%5E%0A++++for+%5Bx,+y,+z%5D+in+data.iter().array_chunks()+%7B%0A++++++++assert_eq!(x+%2B+y+%2B+z,+4);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sum\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.11.0\">1.11.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3576-3579\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.sum\" class=\"fn\">sum</a>&lt;S&gt;(self) -&gt; S<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    S: <a class=\"trait\" href=\"trait.Sum.html\" title=\"trait std::iter::Sum\">Sum</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Sums the elements of an iterator.</p>\n<p>Takes each element, adds them together, and returns the result.</p>\n<p>An empty iterator returns the zero value of the type.</p>\n<p><code>sum()</code> can be used to sum any type implementing <a href=\"trait.Sum.html\" title=\"trait std::iter::Sum\"><code>Sum</code></a>,\nincluding <a href=\"../option/enum.Option.html#method.sum\" title=\"associated function std::option::Option::sum\"><code>Option</code></a> and <a href=\"../result/enum.Result.html#method.sum\" title=\"associated function std::result::Result::sum\"><code>Result</code></a>.</p>\n<h5 id=\"panics-6\"><a class=\"doc-anchor\" href=\"#panics-6\">§</a>Panics</h5>\n<p>When calling <code>sum()</code> and a primitive integer type is being returned, this\nmethod will panic if the computation overflows and debug assertions are\nenabled.</p>\n<h5 id=\"examples-59\"><a class=\"doc-anchor\" href=\"#examples-59\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>sum: i32 = a.iter().sum();\n\n<span class=\"macro\">assert_eq!</span>(sum, <span class=\"number\">6</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B1,+2,+3%5D;%0A++++let+sum:+i32+=+a.iter().sum();%0A++++%0A++++assert_eq!(sum,+6);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.product\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.11.0\">1.11.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3609-3612\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.product\" class=\"fn\">product</a>&lt;P&gt;(self) -&gt; P<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    P: <a class=\"trait\" href=\"trait.Product.html\" title=\"trait std::iter::Product\">Product</a>&lt;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Iterates over the entire iterator, multiplying all the elements</p>\n<p>An empty iterator returns the one value of the type.</p>\n<p><code>product()</code> can be used to multiply any type implementing <a href=\"trait.Product.html\" title=\"trait std::iter::Product\"><code>Product</code></a>,\nincluding <a href=\"../option/enum.Option.html#method.product\" title=\"associated function std::option::Option::product\"><code>Option</code></a> and <a href=\"../result/enum.Result.html#method.product\" title=\"associated function std::result::Result::product\"><code>Result</code></a>.</p>\n<h5 id=\"panics-7\"><a class=\"doc-anchor\" href=\"#panics-7\">§</a>Panics</h5>\n<p>When calling <code>product()</code> and a primitive integer type is being returned,\nmethod will panic if the computation overflows and debug assertions are\nenabled.</p>\n<h5 id=\"examples-60\"><a class=\"doc-anchor\" href=\"#examples-60\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>factorial(n: u32) -&gt; u32 {\n    (<span class=\"number\">1</span>..=n).product()\n}\n<span class=\"macro\">assert_eq!</span>(factorial(<span class=\"number\">0</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(factorial(<span class=\"number\">1</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(factorial(<span class=\"number\">5</span>), <span class=\"number\">120</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+factorial(n:+u32)+-%3E+u32+%7B%0A++++++++(1..=n).product()%0A++++%7D%0A++++assert_eq!(factorial(0),+1);%0A++++assert_eq!(factorial(1),+1);%0A++++assert_eq!(factorial(5),+120);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3631-3635\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.cmp\" class=\"fn\">cmp</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p><a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">Lexicographically</a> compares the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> with those\nof another.</p>\n<h5 id=\"examples-61\"><a class=\"doc-anchor\" href=\"#examples-61\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().cmp([<span class=\"number\">1</span>].iter()), Ordering::Equal);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().cmp([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), Ordering::Less);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().cmp([<span class=\"number\">1</span>].iter()), Ordering::Greater);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++assert_eq!(%5B1%5D.iter().cmp(%5B1%5D.iter()),+Ordering::Equal);%0A++++assert_eq!(%5B1%5D.iter().cmp(%5B1,+2%5D.iter()),+Ordering::Less);%0A++++assert_eq!(%5B1,+2%5D.iter().cmp(%5B1%5D.iter()),+Ordering::Greater);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp_by\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3659-3663\">source</a><h4 class=\"code-header\">fn <a href=\"#method.cmp_by\" class=\"fn\">cmp_by</a>&lt;I, F&gt;(self, other: I, cmp: F) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/64295\">#64295</a>)</span></div></span></summary><div class=\"docblock\"><p><a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">Lexicographically</a> compares the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> with those\nof another with respect to the specified comparison function.</p>\n<h5 id=\"examples-62\"><a class=\"doc-anchor\" href=\"#examples-62\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_order_by)]\n\n</span><span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>xs = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span>ys = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>];\n\n<span class=\"macro\">assert_eq!</span>(xs.iter().cmp_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| x.cmp(<span class=\"kw-2\">&amp;</span>y)), Ordering::Less);\n<span class=\"macro\">assert_eq!</span>(xs.iter().cmp_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| (x * x).cmp(<span class=\"kw-2\">&amp;</span>y)), Ordering::Equal);\n<span class=\"macro\">assert_eq!</span>(xs.iter().cmp_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| (<span class=\"number\">2 </span>* x).cmp(<span class=\"kw-2\">&amp;</span>y)), Ordering::Greater);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_order_by)%5D%0A%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+xs+=+%5B1,+2,+3,+4%5D;%0A++++let+ys+=+%5B1,+4,+9,+16%5D;%0A++++%0A++++assert_eq!(xs.iter().cmp_by(%26ys,+%7C%26x,+%26y%7C+x.cmp(%26y)),+Ordering::Less);%0A++++assert_eq!(xs.iter().cmp_by(%26ys,+%7C%26x,+%26y%7C+(x+*+x).cmp(%26y)),+Ordering::Equal);%0A++++assert_eq!(xs.iter().cmp_by(%26ys,+%7C%26x,+%26y%7C+(2+*+x).cmp(%26y)),+Ordering::Greater);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3716-3720\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.partial_cmp\" class=\"fn\">partial_cmp</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p><a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">Lexicographically</a> compares the <a href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a> elements of\nthis <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> with those of another. The comparison works like short-circuit\nevaluation, returning a result without comparing the remaining elements.\nAs soon as an order can be determined, the evaluation stops and a result is returned.</p>\n<h5 id=\"examples-63\"><a class=\"doc-anchor\" href=\"#examples-63\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1.</span>].iter().partial_cmp([<span class=\"number\">1.</span>].iter()), <span class=\"prelude-val\">Some</span>(Ordering::Equal));\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1.</span>].iter().partial_cmp([<span class=\"number\">1.</span>, <span class=\"number\">2.</span>].iter()), <span class=\"prelude-val\">Some</span>(Ordering::Less));\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1.</span>, <span class=\"number\">2.</span>].iter().partial_cmp([<span class=\"number\">1.</span>].iter()), <span class=\"prelude-val\">Some</span>(Ordering::Greater));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++assert_eq!(%5B1.%5D.iter().partial_cmp(%5B1.%5D.iter()),+Some(Ordering::Equal));%0A++++assert_eq!(%5B1.%5D.iter().partial_cmp(%5B1.,+2.%5D.iter()),+Some(Ordering::Less));%0A++++assert_eq!(%5B1.,+2.%5D.iter().partial_cmp(%5B1.%5D.iter()),+Some(Ordering::Greater));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>For floating-point numbers, NaN does not have a total order and will result\nin <code>None</code> when compared:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([f64::NAN].iter().partial_cmp([<span class=\"number\">1.</span>].iter()), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5Bf64::NAN%5D.iter().partial_cmp(%5B1.%5D.iter()),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The results are determined by the order of evaluation.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1.0</span>, f64::NAN].iter().partial_cmp([<span class=\"number\">2.0</span>, f64::NAN].iter()), <span class=\"prelude-val\">Some</span>(Ordering::Less));\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">2.0</span>, f64::NAN].iter().partial_cmp([<span class=\"number\">1.0</span>, f64::NAN].iter()), <span class=\"prelude-val\">Some</span>(Ordering::Greater));\n<span class=\"macro\">assert_eq!</span>([f64::NAN, <span class=\"number\">1.0</span>].iter().partial_cmp([f64::NAN, <span class=\"number\">2.0</span>].iter()), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++assert_eq!(%5B1.0,+f64::NAN%5D.iter().partial_cmp(%5B2.0,+f64::NAN%5D.iter()),+Some(Ordering::Less));%0A++++assert_eq!(%5B2.0,+f64::NAN%5D.iter().partial_cmp(%5B1.0,+f64::NAN%5D.iter()),+Some(Ordering::Greater));%0A++++assert_eq!(%5Bf64::NAN,+1.0%5D.iter().partial_cmp(%5Bf64::NAN,+2.0%5D.iter()),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp_by\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3753-3757\">source</a><h4 class=\"code-header\">fn <a href=\"#method.partial_cmp_by\" class=\"fn\">partial_cmp_by</a>&lt;I, F&gt;(self, other: I, partial_cmp: F) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/64295\">#64295</a>)</span></div></span></summary><div class=\"docblock\"><p><a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">Lexicographically</a> compares the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> with those\nof another with respect to the specified comparison function.</p>\n<h5 id=\"examples-64\"><a class=\"doc-anchor\" href=\"#examples-64\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_order_by)]\n\n</span><span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>xs = [<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>];\n<span class=\"kw\">let </span>ys = [<span class=\"number\">1.0</span>, <span class=\"number\">4.0</span>, <span class=\"number\">9.0</span>, <span class=\"number\">16.0</span>];\n\n<span class=\"macro\">assert_eq!</span>(\n    xs.iter().partial_cmp_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| x.partial_cmp(<span class=\"kw-2\">&amp;</span>y)),\n    <span class=\"prelude-val\">Some</span>(Ordering::Less)\n);\n<span class=\"macro\">assert_eq!</span>(\n    xs.iter().partial_cmp_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| (x * x).partial_cmp(<span class=\"kw-2\">&amp;</span>y)),\n    <span class=\"prelude-val\">Some</span>(Ordering::Equal)\n);\n<span class=\"macro\">assert_eq!</span>(\n    xs.iter().partial_cmp_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| (<span class=\"number\">2.0 </span>* x).partial_cmp(<span class=\"kw-2\">&amp;</span>y)),\n    <span class=\"prelude-val\">Some</span>(Ordering::Greater)\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_order_by)%5D%0A%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++%0A++++let+xs+=+%5B1.0,+2.0,+3.0,+4.0%5D;%0A++++let+ys+=+%5B1.0,+4.0,+9.0,+16.0%5D;%0A++++%0A++++assert_eq!(%0A++++++++xs.iter().partial_cmp_by(%26ys,+%7C%26x,+%26y%7C+x.partial_cmp(%26y)),%0A++++++++Some(Ordering::Less)%0A++++);%0A++++assert_eq!(%0A++++++++xs.iter().partial_cmp_by(%26ys,+%7C%26x,+%26y%7C+(x+*+x).partial_cmp(%26y)),%0A++++++++Some(Ordering::Equal)%0A++++);%0A++++assert_eq!(%0A++++++++xs.iter().partial_cmp_by(%26ys,+%7C%26x,+%26y%7C+(2.0+*+x).partial_cmp(%26y)),%0A++++++++Some(Ordering::Greater)%0A++++);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3787-3791\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.eq\" class=\"fn\">eq</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are equal to those of\nanother.</p>\n<h5 id=\"examples-65\"><a class=\"doc-anchor\" href=\"#examples-65\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().eq([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().eq([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().eq(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1%5D.iter().eq(%5B1,+2%5D.iter()),+false);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq_by\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3811-3815\">source</a><h4 class=\"code-header\">fn <a href=\"#method.eq_by\" class=\"fn\">eq_by</a>&lt;I, F&gt;(self, other: I, eq: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/64295\">#64295</a>)</span></div></span></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are equal to those of\nanother with respect to the specified equality function.</p>\n<h5 id=\"examples-66\"><a class=\"doc-anchor\" href=\"#examples-66\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(iter_order_by)]\n\n</span><span class=\"kw\">let </span>xs = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span>ys = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>];\n\n<span class=\"macro\">assert!</span>(xs.iter().eq_by(<span class=\"kw-2\">&amp;</span>ys, |<span class=\"kw-2\">&amp;</span>x, <span class=\"kw-2\">&amp;</span>y| x * x == y));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(iter_order_by)%5D%0A%0Afn+main()+%7B%0A++++let+xs+=+%5B1,+2,+3,+4%5D;%0A++++let+ys+=+%5B1,+4,+9,+16%5D;%0A++++%0A++++assert!(xs.iter().eq_by(%26ys,+%7C%26x,+%26y%7C+x+*+x+==+y));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3844-3848\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.ne\" class=\"fn\">ne</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are not equal to those of\nanother.</p>\n<h5 id=\"examples-67\"><a class=\"doc-anchor\" href=\"#examples-67\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().ne([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().ne([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().ne(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1%5D.iter().ne(%5B1,+2%5D.iter()),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3866-3870\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.lt\" class=\"fn\">lt</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are <a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">lexicographically</a>\nless than those of another.</p>\n<h5 id=\"examples-68\"><a class=\"doc-anchor\" href=\"#examples-68\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().lt([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().lt([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().lt([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().lt([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().lt(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1%5D.iter().lt(%5B1,+2%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().lt(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().lt(%5B1,+2%5D.iter()),+false);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3888-3892\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.le\" class=\"fn\">le</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are <a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">lexicographically</a>\nless or equal to those of another.</p>\n<h5 id=\"examples-69\"><a class=\"doc-anchor\" href=\"#examples-69\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().le([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().le([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().le([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().le([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().le(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1%5D.iter().le(%5B1,+2%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().le(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().le(%5B1,+2%5D.iter()),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3910-3914\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.gt\" class=\"fn\">gt</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are <a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">lexicographically</a>\ngreater than those of another.</p>\n<h5 id=\"examples-70\"><a class=\"doc-anchor\" href=\"#examples-70\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().gt([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().gt([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().gt([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().gt([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().gt(%5B1%5D.iter()),+false);%0A++++assert_eq!(%5B1%5D.iter().gt(%5B1,+2%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().gt(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().gt(%5B1,+2%5D.iter()),+false);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3932-3936\">source</a></span><h4 class=\"code-header\">fn <a href=\"#method.ge\" class=\"fn\">ge</a>&lt;I&gt;(self, other: I) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;&lt;I as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a>&gt;,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Determines if the elements of this <a href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\"><code>Iterator</code></a> are <a href=\"../cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait std::cmp::Ord\">lexicographically</a>\ngreater than or equal to those of another.</p>\n<h5 id=\"examples-71\"><a class=\"doc-anchor\" href=\"#examples-71\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().ge([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>].iter().ge([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().ge([<span class=\"number\">1</span>].iter()), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter().ge([<span class=\"number\">1</span>, <span class=\"number\">2</span>].iter()), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%5B1%5D.iter().ge(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1%5D.iter().ge(%5B1,+2%5D.iter()),+false);%0A++++assert_eq!(%5B1,+2%5D.iter().ge(%5B1%5D.iter()),+true);%0A++++assert_eq!(%5B1,+2%5D.iter().ge(%5B1,+2%5D.iter()),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_sorted\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3964-3967\">source</a><h4 class=\"code-header\">fn <a href=\"#method.is_sorted\" class=\"fn\">is_sorted</a>(self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>is_sorted</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/53485\">#53485</a>)</span></div></span></summary><div class=\"docblock\"><p>Checks if the elements of this iterator are sorted.</p>\n<p>That is, for each element <code>a</code> and its following element <code>b</code>, <code>a &lt;= b</code> must hold. If the\niterator yields exactly zero or one element, <code>true</code> is returned.</p>\n<p>Note that if <code>Self::Item</code> is only <code>PartialOrd</code>, but not <code>Ord</code>, the above definition\nimplies that this function returns <code>false</code> if any two consecutive items are not\ncomparable.</p>\n<h5 id=\"examples-72\"><a class=\"doc-anchor\" href=\"#examples-72\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(is_sorted)]\n\n</span><span class=\"macro\">assert!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>].iter().is_sorted());\n<span class=\"macro\">assert!</span>(![<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>].iter().is_sorted());\n<span class=\"macro\">assert!</span>([<span class=\"number\">0</span>].iter().is_sorted());\n<span class=\"macro\">assert!</span>(std::iter::empty::&lt;i32&gt;().is_sorted());\n<span class=\"macro\">assert!</span>(![<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, f32::NAN].iter().is_sorted());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(is_sorted)%5D%0A%0Afn+main()+%7B%0A++++assert!(%5B1,+2,+2,+9%5D.iter().is_sorted());%0A++++assert!(!%5B1,+3,+2,+4%5D.iter().is_sorted());%0A++++assert!(%5B0%5D.iter().is_sorted());%0A++++assert!(std::iter::empty::%3Ci32%3E().is_sorted());%0A++++assert!(!%5B0.0,+1.0,+f32::NAN%5D.iter().is_sorted());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_sorted_by\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#3993-3996\">source</a><h4 class=\"code-header\">fn <a href=\"#method.is_sorted_by\" class=\"fn\">is_sorted_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &amp;Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>is_sorted</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/53485\">#53485</a>)</span></div></span></summary><div class=\"docblock\"><p>Checks if the elements of this iterator are sorted using the given comparator function.</p>\n<p>Instead of using <code>PartialOrd::partial_cmp</code>, this function uses the given <code>compare</code>\nfunction to determine whether two elements are to be considered in sorted order.</p>\n<h5 id=\"examples-73\"><a class=\"doc-anchor\" href=\"#examples-73\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(is_sorted)]\n\n</span><span class=\"macro\">assert!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>].iter().is_sorted_by(|a, b| a &lt;= b));\n<span class=\"macro\">assert!</span>(![<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>].iter().is_sorted_by(|a, b| a &lt; b));\n\n<span class=\"macro\">assert!</span>([<span class=\"number\">0</span>].iter().is_sorted_by(|a, b| <span class=\"bool-val\">true</span>));\n<span class=\"macro\">assert!</span>([<span class=\"number\">0</span>].iter().is_sorted_by(|a, b| <span class=\"bool-val\">false</span>));\n\n<span class=\"macro\">assert!</span>(std::iter::empty::&lt;i32&gt;().is_sorted_by(|a, b| <span class=\"bool-val\">false</span>));\n<span class=\"macro\">assert!</span>(std::iter::empty::&lt;i32&gt;().is_sorted_by(|a, b| <span class=\"bool-val\">true</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(is_sorted)%5D%0A%0Afn+main()+%7B%0A++++assert!(%5B1,+2,+2,+9%5D.iter().is_sorted_by(%7Ca,+b%7C+a+%3C=+b));%0A++++assert!(!%5B1,+2,+2,+9%5D.iter().is_sorted_by(%7Ca,+b%7C+a+%3C+b));%0A++++%0A++++assert!(%5B0%5D.iter().is_sorted_by(%7Ca,+b%7C+true));%0A++++assert!(%5B0%5D.iter().is_sorted_by(%7Ca,+b%7C+false));%0A++++%0A++++assert!(std::iter::empty::%3Ci32%3E().is_sorted_by(%7Ca,+b%7C+false));%0A++++assert!(std::iter::empty::%3Ci32%3E().is_sorted_by(%7Ca,+b%7C+true));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_sorted_by_key\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#4040-4044\">source</a><h4 class=\"code-header\">fn <a href=\"#method.is_sorted_by_key\" class=\"fn\">is_sorted_by_key</a>&lt;F, K&gt;(self, f: F) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(Self::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>is_sorted</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/53485\">#53485</a>)</span></div></span></summary><div class=\"docblock\"><p>Checks if the elements of this iterator are sorted using the given key extraction\nfunction.</p>\n<p>Instead of comparing the iterator’s elements directly, this function compares the keys of\nthe elements, as determined by <code>f</code>. Apart from that, it’s equivalent to <a href=\"trait.Iterator.html#method.is_sorted\" title=\"method std::iter::Iterator::is_sorted\"><code>is_sorted</code></a>; see\nits documentation for more information.</p>\n<h5 id=\"examples-74\"><a class=\"doc-anchor\" href=\"#examples-74\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(is_sorted)]\n\n</span><span class=\"macro\">assert!</span>([<span class=\"string\">\"c\"</span>, <span class=\"string\">\"bb\"</span>, <span class=\"string\">\"aaa\"</span>].iter().is_sorted_by_key(|s| s.len()));\n<span class=\"macro\">assert!</span>(![-<span class=\"number\">2i32</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>].iter().is_sorted_by_key(|n| n.abs()));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(is_sorted)%5D%0A%0Afn+main()+%7B%0A++++assert!(%5B%22c%22,+%22bb%22,+%22aaa%22%5D.iter().is_sorted_by_key(%7Cs%7C+s.len()));%0A++++assert!(!%5B-2i32,+-1,+0,+3%5D.iter().is_sorted_by_key(%7Cn%7C+n.abs()));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div><h2 id=\"implementors\" class=\"section-header\">Implementors<a href=\"#implementors\" class=\"anchor\">§</a></h2><div id=\"implementors-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeDefault\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ascii.rs.html#115\">source</a></span><a href=\"#impl-Iterator-for-EscapeDefault\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::ascii::<a class=\"struct\" href=\"../ascii/struct.EscapeDefault.html\" title=\"struct std::ascii::EscapeDefault\">EscapeDefault</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeDebug\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/char/mod.rs.html#329\">source</a></span><a href=\"#impl-Iterator-for-EscapeDebug\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::char::<a class=\"struct\" href=\"../char/struct.EscapeDebug.html\" title=\"struct std::char::EscapeDebug\">EscapeDebug</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-2\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeDefault-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/char/mod.rs.html#238\">source</a></span><a href=\"#impl-Iterator-for-EscapeDefault-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::char::<a class=\"struct\" href=\"../char/struct.EscapeDefault.html\" title=\"struct std::char::EscapeDefault\">EscapeDefault</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-3\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-3\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeUnicode\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/char/mod.rs.html#162\">source</a></span><a href=\"#impl-Iterator-for-EscapeUnicode\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::char::<a class=\"struct\" href=\"../char/struct.EscapeUnicode.html\" title=\"struct std::char::EscapeUnicode\">EscapeUnicode</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-4\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-4\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ToLowercase\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/char/mod.rs.html#478-486\">source</a></span><a href=\"#impl-Iterator-for-ToLowercase\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../char/struct.ToLowercase.html\" title=\"struct std::char::ToLowercase\">ToLowercase</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-5\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-5\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ToUppercase\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/char/mod.rs.html#488-496\">source</a></span><a href=\"#impl-Iterator-for-ToUppercase\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../char/struct.ToUppercase.html\" title=\"struct std::char::ToUppercase\">ToUppercase</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-6\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-6\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Args\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/env.rs.html#879-887\">source</a></span><a href=\"#impl-Iterator-for-Args\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../env/struct.Args.html\" title=\"struct std::env::Args\">Args</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-7\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-7\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ArgsOs\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/env.rs.html#921-929\">source</a></span><a href=\"#impl-Iterator-for-ArgsOs\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../env/struct.ArgsOs.html\" title=\"struct std::env::ArgsOs\">ArgsOs</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-8\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-8\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Vars\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/env.rs.html#168-176\">source</a></span><a href=\"#impl-Iterator-for-Vars\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../env/struct.Vars.html\" title=\"struct std::env::Vars\">Vars</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-9\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-9\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-VarsOs\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/env.rs.html#187-195\">source</a></span><a href=\"#impl-Iterator-for-VarsOs\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../env/struct.VarsOs.html\" title=\"struct std::env::VarsOs\">VarsOs</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-10\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-10\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>, <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ReadDir\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/fs.rs.html#1809-1815\">source</a></span><a href=\"#impl-Iterator-for-ReadDir\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../fs/struct.ReadDir.html\" title=\"struct std::fs::ReadDir\">ReadDir</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-11\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-11\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../fs/struct.DirEntry.html\" title=\"struct std::fs::DirEntry\">DirEntry</a>, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIncoming\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/net/tcp.rs.html#1037-1042\">source</a><a href=\"#impl-Iterator-for-IntoIncoming\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../net/struct.IntoIncoming.html\" title=\"struct std::net::IntoIncoming\">IntoIncoming</a></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-12\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-12\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../net/struct.TcpStream.html\" title=\"struct std::net::TcpStream\">TcpStream</a>, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Bytes%3C'_%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#282\">source</a></span><a href=\"#impl-Iterator-for-Bytes%3C'_%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.Bytes.html\" title=\"struct std::str::Bytes\">Bytes</a>&lt;'_&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-13\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-13\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Drain%3C'_%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#3010\">source</a></span><a href=\"#impl-Iterator-for-Drain%3C'_%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::string::<a class=\"struct\" href=\"../string/struct.Drain.html\" title=\"struct std::string::Drain\">Drain</a>&lt;'_&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-14\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-14\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Bytes%3C'_%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ffi/c_str.rs.html#798\">source</a><a href=\"#impl-Iterator-for-Bytes%3C'_%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for core::ffi::c_str::<a class=\"struct\" href=\"https://doc.rust-lang.org/1.80.0/core/ffi/c_str/struct.Bytes.html\" title=\"struct core::ffi::c_str::Bytes\">Bytes</a>&lt;'_&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-15\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-15\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitPaths%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/env.rs.html#508-516\">source</a></span><a href=\"#impl-Iterator-for-SplitPaths%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../env/struct.SplitPaths.html\" title=\"struct std::env::SplitPaths\">SplitPaths</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-16\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-16\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Incoming%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/net/tcp.rs.html#1026-1031\">source</a></span><a href=\"#impl-Iterator-for-Incoming%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::net::<a class=\"struct\" href=\"../net/struct.Incoming.html\" title=\"struct std::net::Incoming\">Incoming</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-17\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-17\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../net/struct.TcpStream.html\" title=\"struct std::net::TcpStream\">TcpStream</a>, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Incoming%3C'a%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../src/std/os/unix/net/listener.rs.html#412-422\">source</a></span><a href=\"#impl-Iterator-for-Incoming%3C'a%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::os::unix::net::<a class=\"struct\" href=\"../os/unix/net/struct.Incoming.html\" title=\"struct std::os::unix::net::Incoming\">Incoming</a>&lt;'a&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Unix</strong> only.</div></span></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-18\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-18\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../os/unix/net/struct.UnixStream.html\" title=\"struct std::os::unix::net::UnixStream\">UnixStream</a>, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Messages%3C'a%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/os/unix/net/ancillary.rs.html#537-568\">source</a><a href=\"#impl-Iterator-for-Messages%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../os/unix/net/struct.Messages.html\" title=\"struct std::os::unix::net::Messages\">Messages</a>&lt;'a&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>(Android or Linux) and Unix</strong> only.</div></span></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-19\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-19\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"enum\" href=\"../os/unix/net/enum.AncillaryData.html\" title=\"enum std::os::unix::net::AncillaryData\">AncillaryData</a>&lt;'a&gt;, <a class=\"enum\" href=\"../os/unix/net/enum.AncillaryError.html\" title=\"enum std::os::unix::net::AncillaryError\">AncillaryError</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ScmCredentials%3C'a%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/os/unix/net/ancillary.rs.html#438-444\">source</a><a href=\"#impl-Iterator-for-ScmCredentials%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../os/unix/net/struct.ScmCredentials.html\" title=\"struct std::os::unix::net::ScmCredentials\">ScmCredentials</a>&lt;'a&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>(Android or Linux) and Unix</strong> only.</div></span></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-20\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-20\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../os/unix/net/struct.SocketCred.html\" title=\"struct std::os::unix::net::SocketCred\">SocketCred</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ScmRights%3C'a%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/os/unix/net/ancillary.rs.html#397-403\">source</a><a href=\"#impl-Iterator-for-ScmRights%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../os/unix/net/struct.ScmRights.html\" title=\"struct std::os::unix::net::ScmRights\">ScmRights</a>&lt;'a&gt;</h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>(Android or Linux) and Unix</strong> only.</div></span></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-21\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-21\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.i32.html\">i32</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EncodeWide%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sys_common/wtf8.rs.html#982-1012\">source</a></span><a href=\"#impl-Iterator-for-EncodeWide%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../os/windows/ffi/struct.EncodeWide.html\" title=\"struct std::os::windows::ffi::EncodeWide\">EncodeWide</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-22\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-22\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Ancestors%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#1093-1102\">source</a></span><a href=\"#impl-Iterator-for-Ancestors%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../path/struct.Ancestors.html\" title=\"struct std::path::Ancestors\">Ancestors</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-23\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-23\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Components%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#887-937\">source</a></span><a href=\"#impl-Iterator-for-Components%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../path/struct.Components.html\" title=\"struct std::path::Components\">Components</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-24\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-24\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../path/enum.Component.html\" title=\"enum std::path::Component\">Component</a>&lt;'a&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#866-873\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::path::<a class=\"struct\" href=\"../path/struct.Iter.html\" title=\"struct std::path::Iter\">Iter</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-25\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-25\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-CommandArgs%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.57.0\">1.57.0</span> · <a class=\"src\" href=\"../../src/std/process.rs.html#1237-1245\">source</a></span><a href=\"#impl-Iterator-for-CommandArgs%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../process/struct.CommandArgs.html\" title=\"struct std::process::CommandArgs\">CommandArgs</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-26\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-26\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-CommandEnvs%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.57.0\">1.57.0</span> · <a class=\"src\" href=\"../../src/std/sys_common/process.rs.html#116-124\">source</a></span><a href=\"#impl-Iterator-for-CommandEnvs%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../process/struct.CommandEnvs.html\" title=\"struct std::process::CommandEnvs\">CommandEnvs</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-27\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-27\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (&amp;'a <a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>, <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;&amp;'a <a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt;)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeAscii%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0\">1.60.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/ascii.rs.html#207\">source</a></span><a href=\"#impl-Iterator-for-EscapeAscii%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.EscapeAscii.html\" title=\"struct std::slice::EscapeAscii\">EscapeAscii</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-28\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-28\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-CharIndices%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#184\">source</a></span><a href=\"#impl-Iterator-for-CharIndices%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.CharIndices.html\" title=\"struct std::str::CharIndices\">CharIndices</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-29\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-29\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"../primitive.char.html\">char</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Chars%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#38\">source</a></span><a href=\"#impl-Iterator-for-Chars%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.Chars.html\" title=\"struct std::str::Chars\">Chars</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-30\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-30\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EncodeUtf16%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1496\">source</a></span><a href=\"#impl-Iterator-for-EncodeUtf16%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.EncodeUtf16.html\" title=\"struct std::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-31\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-31\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeDebug%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1604\">source</a></span><a href=\"#impl-Iterator-for-EscapeDebug%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.EscapeDebug.html\" title=\"struct std::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-32\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-32\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeDefault%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1604\">source</a></span><a href=\"#impl-Iterator-for-EscapeDefault%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.EscapeDefault.html\" title=\"struct std::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-33\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-33\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-EscapeUnicode%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1604\">source</a></span><a href=\"#impl-Iterator-for-EscapeUnicode%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.EscapeUnicode.html\" title=\"struct std::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-34\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-34\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.char.html\">char</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Lines%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1160\">source</a></span><a href=\"#impl-Iterator-for-Lines%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.Lines.html\" title=\"struct std::str::Lines\">Lines</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-35\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-35\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-LinesAny%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1227\">source</a></span><a href=\"#impl-Iterator-for-LinesAny%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.LinesAny.html\" title=\"struct std::str::LinesAny\">LinesAny</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-36\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-36\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitAsciiWhitespace%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1352\">source</a></span><a href=\"#impl-Iterator-for-SplitAsciiWhitespace%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.SplitAsciiWhitespace.html\" title=\"struct std::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-37\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-37\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitWhitespace%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.1.0\">1.1.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1296\">source</a></span><a href=\"#impl-Iterator-for-SplitWhitespace%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.SplitWhitespace.html\" title=\"struct std::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-38\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-38\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Utf8Chunks%3C'a%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.79.0\">1.79.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/lossy.rs.html#190\">source</a></span><a href=\"#impl-Iterator-for-Utf8Chunks%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.Utf8Chunks.html\" title=\"struct std::str::Utf8Chunks\">Utf8Chunks</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-39\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-39\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../str/struct.Utf8Chunk.html\" title=\"struct std::str::Utf8Chunk\">Utf8Chunk</a>&lt;'a&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Source%3C'a%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/error.rs.html#1016\">source</a><a href=\"#impl-Iterator-for-Source%3C'a%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.80.0/core/error/struct.Source.html\" title=\"struct core::error::Source\">Source</a>&lt;'a&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-40\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-40\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a (dyn <a class=\"trait\" href=\"../error/trait.Error.html\" title=\"trait std::error::Error\">Error</a> + 'static)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/option.rs.html#2247\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::option::<a class=\"struct\" href=\"../option/struct.Iter.html\" title=\"struct std::option::Iter\">Iter</a>&lt;'a, A&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-41\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-41\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a A</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/option.rs.html#2297\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::option::<a class=\"struct\" href=\"../option/struct.IterMut.html\" title=\"struct std::option::IterMut\">IterMut</a>&lt;'a, A&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-42\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-42\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut A</a></h4></section></div></details><section id=\"impl-Iterator-for-%26Box%3C%5BI%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2132\">source</a></span><a href=\"#impl-Iterator-for-%26Box%3C%5BI%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, I, A&gt; !<a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for &amp;'a <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[I]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><div class=\"docblock\"><p>This implementation is required to make sure that the <code>&amp;Box&lt;[I]&gt;: IntoIterator</code>\nimplementation doesn’t overlap with <code>IntoIterator for T where T: Iterator</code> blanket.</p>\n</div><section id=\"impl-Iterator-for-%26mut+Box%3C%5BI%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2137\">source</a></span><a href=\"#impl-Iterator-for-%26mut+Box%3C%5BI%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, I, A&gt; !<a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for &amp;'a mut <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[I]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><div class=\"docblock\"><p>This implementation is required to make sure that the <code>&amp;mut Box&lt;[I]&gt;: IntoIterator</code>\nimplementation doesn’t overlap with <code>IntoIterator for T where T: Iterator</code> blanket.</p>\n</div><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Cloned%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.1.0\">1.1.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/cloned.rs.html#33-36\">source</a></span><a href=\"#impl-Iterator-for-Cloned%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, I, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Cloned.html\" title=\"struct std::iter::Cloned\">Cloned</a>&lt;I&gt;<div class=\"where\">where\n    T: 'a + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-43\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-43\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Copied%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/copied.rs.html#40-43\">source</a></span><a href=\"#impl-Iterator-for-Copied%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, I, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Copied.html\" title=\"struct std::iter::Copied\">Copied</a>&lt;I&gt;<div class=\"where\">where\n    T: 'a + <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-44\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-44\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Drain%3C'a,+K%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1583-1602\">source</a></span><a href=\"#impl-Iterator-for-Drain%3C'a,+K%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.Drain.html\" title=\"struct std::collections::hash_set::Drain\">Drain</a>&lt;'a, K&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-45\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-45\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = K</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+K%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1499-1522\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+K%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.Iter.html\" title=\"struct std::collections::hash_set::Iter\">Iter</a>&lt;'a, K&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-46\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-46\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1495\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.Iter.html\" title=\"struct std::collections::btree_map::Iter\">Iter</a>&lt;'a, K, V&gt;<div class=\"where\">where\n    K: 'a,\n    V: 'a,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-47\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-47\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a V</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1570\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.IterMut.html\" title=\"struct std::collections::btree_map::IterMut\">IterMut</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-48\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-48\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut V</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Keys%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1749\">source</a></span><a href=\"#impl-Iterator-for-Keys%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.Keys.html\" title=\"struct std::collections::btree_map::Keys\">Keys</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-49\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-49\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Range%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1979\">source</a></span><a href=\"#impl-Iterator-for-Range%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.Range.html\" title=\"struct std::collections::btree_map::Range\">Range</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-50\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-50\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a V</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RangeMut%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2187\">source</a></span><a href=\"#impl-Iterator-for-RangeMut%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../collections/btree_map/struct.RangeMut.html\" title=\"struct std::collections::btree_map::RangeMut\">RangeMut</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-51\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-51\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut V</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Values%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1818\">source</a></span><a href=\"#impl-Iterator-for-Values%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.Values.html\" title=\"struct std::collections::btree_map::Values\">Values</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-52\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-52\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a V</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ValuesMut%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2020\">source</a></span><a href=\"#impl-Iterator-for-ValuesMut%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.ValuesMut.html\" title=\"struct std::collections::btree_map::ValuesMut\">ValuesMut</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-53\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-53\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut V</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Drain%3C'a,+K,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2549-2568\">source</a></span><a href=\"#impl-Iterator-for-Drain%3C'a,+K,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.Drain.html\" title=\"struct std::collections::hash_map::Drain\">Drain</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-54\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-54\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.tuple.html\">(K, V)</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+K,+V%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2229-2252\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+K,+V%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.Iter.html\" title=\"struct std::collections::hash_map::Iter\">Iter</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-55\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-55\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a V</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+K,+V%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2265-2288\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+K,+V%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.IterMut.html\" title=\"struct std::collections::hash_map::IterMut\">IterMut</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-56\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-56\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut V</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Keys%3C'a,+K,+V%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2353-2376\">source</a></span><a href=\"#impl-Iterator-for-Keys%3C'a,+K,+V%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.Keys.html\" title=\"struct std::collections::hash_map::Keys\">Keys</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-57\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-57\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a K</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Values%3C'a,+K,+V%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2388-2411\">source</a></span><a href=\"#impl-Iterator-for-Values%3C'a,+K,+V%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.Values.html\" title=\"struct std::collections::hash_map::Values\">Values</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-58\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-58\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a V</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ValuesMut%3C'a,+K,+V%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2423-2446\">source</a></span><a href=\"#impl-Iterator-for-ValuesMut%3C'a,+K,+V%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.ValuesMut.html\" title=\"struct std::collections::hash_map::ValuesMut\">ValuesMut</a>&lt;'a, K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-59\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-59\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut V</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-MatchIndices%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1073-1089\">source</a></span><a href=\"#impl-Iterator-for-MatchIndices%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.MatchIndices.html\" title=\"struct std::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-60\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-60\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Matches%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1130-1146\">source</a></span><a href=\"#impl-Iterator-for-Matches%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.Matches.html\" title=\"struct std::str::Matches\">Matches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-61\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-61\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RMatchIndices%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1073-1089\">source</a></span><a href=\"#impl-Iterator-for-RMatchIndices%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.RMatchIndices.html\" title=\"struct std::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-62\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-62\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RMatches%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1130-1146\">source</a></span><a href=\"#impl-Iterator-for-RMatches%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.RMatches.html\" title=\"struct std::str::RMatches\">RMatches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-63\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-63\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplit%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#781-797\">source</a></span><a href=\"#impl-Iterator-for-RSplit%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.RSplit.html\" title=\"struct std::str::RSplit\">RSplit</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-64\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-64\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplitN%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#972-988\">source</a></span><a href=\"#impl-Iterator-for-RSplitN%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.RSplitN.html\" title=\"struct std::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-65\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-65\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplitTerminator%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#845-861\">source</a></span><a href=\"#impl-Iterator-for-RSplitTerminator%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.RSplitTerminator.html\" title=\"struct std::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"../str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"../str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-66\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-66\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Split%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#781-797\">source</a></span><a href=\"#impl-Iterator-for-Split%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.Split.html\" title=\"struct std::str::Split\">Split</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-67\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-67\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitInclusive%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#1415\">source</a></span><a href=\"#impl-Iterator-for-SplitInclusive%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.SplitInclusive.html\" title=\"struct std::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-68\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-68\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitN%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#972-988\">source</a></span><a href=\"#impl-Iterator-for-SplitN%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::str::<a class=\"struct\" href=\"../str/struct.SplitN.html\" title=\"struct std::str::SplitN\">SplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-69\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-69\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitTerminator%3C'a,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/str/iter.rs.html#845-861\">source</a></span><a href=\"#impl-Iterator-for-SplitTerminator%3C'a,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../str/struct.SplitTerminator.html\" title=\"struct std::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-70\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-70\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1452\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::binary_heap::<a class=\"struct\" href=\"../collections/binary_heap/struct.Iter.html\" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-71\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-71\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1466\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.Iter.html\" title=\"struct std::collections::btree_set::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-72\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-72\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Range%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1579\">source</a></span><a href=\"#impl-Iterator-for-Range%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.Range.html\" title=\"struct std::collections::btree_set::Range\">Range</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-73\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-73\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SymmetricDifference%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1703\">source</a></span><a href=\"#impl-Iterator-for-SymmetricDifference%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.SymmetricDifference.html\" title=\"struct std::collections::btree_set::SymmetricDifference\">SymmetricDifference</a>&lt;'a, T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-74\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-74\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Union%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1798\">source</a></span><a href=\"#impl-Iterator-for-Union%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.Union.html\" title=\"struct std::collections::btree_set::Union\">Union</a>&lt;'a, T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-75\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-75\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E-2\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/linked_list.rs.html#1190\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E-2\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::linked_list::<a class=\"struct\" href=\"../collections/linked_list/struct.Iter.html\" title=\"struct std::collections::linked_list::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-76\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-76\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/linked_list.rs.html#1258\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::linked_list::<a class=\"struct\" href=\"../collections/linked_list/struct.IterMut.html\" title=\"struct std::collections::linked_list::IterMut\">IterMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-77\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-77\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E-3\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/vec_deque/iter.rs.html#40\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E-3\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::vec_deque::<a class=\"struct\" href=\"../collections/vec_deque/struct.Iter.html\" title=\"struct std::collections::vec_deque::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-78\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-78\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+T%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/vec_deque/iter_mut.rs.html#32\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+T%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::vec_deque::<a class=\"struct\" href=\"../collections/vec_deque/struct.IterMut.html\" title=\"struct std::collections::vec_deque::IterMut\">IterMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-79\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-79\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E-4\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/result.rs.html#1784\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E-4\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::result::<a class=\"struct\" href=\"../result/struct.Iter.html\" title=\"struct std::result::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-80\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-80\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+T%3E-2\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/result.rs.html#1833\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+T%3E-2\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::result::<a class=\"struct\" href=\"../result/struct.IterMut.html\" title=\"struct std::result::IterMut\">IterMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-81\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-81\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Chunks%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1480\">source</a></span><a href=\"#impl-Iterator-for-Chunks%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.Chunks.html\" title=\"struct std::slice::Chunks\">Chunks</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-82\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-82\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ChunksExact%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1880\">source</a></span><a href=\"#impl-Iterator-for-ChunksExact%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunksExact.html\" title=\"struct std::slice::ChunksExact\">ChunksExact</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-83\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-83\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ChunksExactMut%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2038\">source</a></span><a href=\"#impl-Iterator-for-ChunksExactMut%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunksExactMut.html\" title=\"struct std::slice::ChunksExactMut\">ChunksExactMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-84\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-84\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ChunksMut%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1662\">source</a></span><a href=\"#impl-Iterator-for-ChunksMut%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunksMut.html\" title=\"struct std::slice::ChunksMut\">ChunksMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-85\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-85\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E-5\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#136-144\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E-5\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.Iter.html\" title=\"struct std::slice::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-86\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-86\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IterMut%3C'a,+T%3E-3\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#370\">source</a></span><a href=\"#impl-Iterator-for-IterMut%3C'a,+T%3E-3\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.IterMut.html\" title=\"struct std::slice::IterMut\">IterMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-87\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-87\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a mut T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RChunks%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2558\">source</a></span><a href=\"#impl-Iterator-for-RChunks%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunks.html\" title=\"struct std::slice::RChunks\">RChunks</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-88\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-88\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RChunksExact%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2952\">source</a></span><a href=\"#impl-Iterator-for-RChunksExact%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunksExact.html\" title=\"struct std::slice::RChunksExact\">RChunksExact</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-89\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-89\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RChunksExactMut%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#3112\">source</a></span><a href=\"#impl-Iterator-for-RChunksExactMut%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunksExactMut.html\" title=\"struct std::slice::RChunksExactMut\">RChunksExactMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-90\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-90\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RChunksMut%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2730\">source</a></span><a href=\"#impl-Iterator-for-RChunksMut%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RChunksMut.html\" title=\"struct std::slice::RChunksMut\">RChunksMut</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-91\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-91\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Windows%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1332\">source</a></span><a href=\"#impl-Iterator-for-Windows%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.Windows.html\" title=\"struct std::slice::Windows\">Windows</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-92\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-92\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Iter%3C'a,+T%3E-6\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mpsc/mod.rs.html#1044-1050\">source</a></span><a href=\"#impl-Iterator-for-Iter%3C'a,+T%3E-6\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::sync::mpsc::<a class=\"struct\" href=\"../sync/mpsc/struct.Iter.html\" title=\"struct std::sync::mpsc::Iter\">Iter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-93\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-93\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-TryIter%3C'a,+T%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.15.0\">1.15.0</span> · <a class=\"src\" href=\"../../src/std/sync/mpsc/mod.rs.html#1053-1059\">source</a></span><a href=\"#impl-Iterator-for-TryIter%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../sync/mpsc/struct.TryIter.html\" title=\"struct std::sync::mpsc::TryIter\">TryIter</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-94\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-94\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Difference%3C'a,+T,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1647\">source</a></span><a href=\"#impl-Iterator-for-Difference%3C'a,+T,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.Difference.html\" title=\"struct std::collections::btree_set::Difference\">Difference</a>&lt;'a, T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-95\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-95\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Intersection%3C'a,+T,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1748\">source</a></span><a href=\"#impl-Iterator-for-Intersection%3C'a,+T,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.Intersection.html\" title=\"struct std::collections::btree_set::Intersection\">Intersection</a>&lt;'a, T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-96\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-96\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1297-1299\">source</a><a href=\"#impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, F, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.ExtractIf.html\" title=\"struct std::collections::btree_set::ExtractIf\">ExtractIf</a>&lt;'_, T, F, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    F: 'a + <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-97\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-97\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ChunkBy%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#3276-3278\">source</a></span><a href=\"#impl-Iterator-for-ChunkBy%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunkBy.html\" title=\"struct std::slice::ChunkBy\">ChunkBy</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    T: 'a,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-98\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-98\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ChunkByMut%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#3363-3365\">source</a></span><a href=\"#impl-Iterator-for-ChunkByMut%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ChunkByMut.html\" title=\"struct std::slice::ChunkByMut\">ChunkByMut</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    T: 'a,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-99\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-99\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplit%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#963-965\">source</a></span><a href=\"#impl-Iterator-for-RSplit%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.RSplit.html\" title=\"struct std::slice::RSplit\">RSplit</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-100\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-100\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplitMut%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1060-1062\">source</a></span><a href=\"#impl-Iterator-for-RSplitMut%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RSplitMut.html\" title=\"struct std::slice::RSplitMut\">RSplitMut</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-101\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-101\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplitN%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1291\">source</a></span><a href=\"#impl-Iterator-for-RSplitN%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.RSplitN.html\" title=\"struct std::slice::RSplitN\">RSplitN</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-102\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-102\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RSplitNMut%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1293\">source</a></span><a href=\"#impl-Iterator-for-RSplitNMut%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.RSplitNMut.html\" title=\"struct std::slice::RSplitNMut\">RSplitNMut</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-103\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-103\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Split%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#451-453\">source</a></span><a href=\"#impl-Iterator-for-Split%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.Split.html\" title=\"struct std::slice::Split\">Split</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-104\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-104\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitInclusive%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#592-594\">source</a></span><a href=\"#impl-Iterator-for-SplitInclusive%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.SplitInclusive.html\" title=\"struct std::slice::SplitInclusive\">SplitInclusive</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-105\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-105\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitInclusiveMut%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#831-833\">source</a></span><a href=\"#impl-Iterator-for-SplitInclusiveMut%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.SplitInclusiveMut.html\" title=\"struct std::slice::SplitInclusiveMut\">SplitInclusiveMut</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-106\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-106\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitMut%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#713-715\">source</a></span><a href=\"#impl-Iterator-for-SplitMut%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.SplitMut.html\" title=\"struct std::slice::SplitMut\">SplitMut</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-107\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-107\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitN%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1290\">source</a></span><a href=\"#impl-Iterator-for-SplitN%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.SplitN.html\" title=\"struct std::slice::SplitN\">SplitN</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-108\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-108\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SplitNMut%3C'a,+T,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#1292\">source</a></span><a href=\"#impl-Iterator-for-SplitNMut%3C'a,+T,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.SplitNMut.html\" title=\"struct std::slice::SplitNMut\">SplitNMut</a>&lt;'a, T, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-109\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-109\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Difference%3C'a,+T,+S%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1720-1751\">source</a></span><a href=\"#impl-Iterator-for-Difference%3C'a,+T,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, S&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.Difference.html\" title=\"struct std::collections::hash_set::Difference\">Difference</a>&lt;'a, T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a>,\n    S: <a class=\"trait\" href=\"../hash/trait.BuildHasher.html\" title=\"trait std::hash::BuildHasher\">BuildHasher</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-110\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-110\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Intersection%3C'a,+T,+S%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1659-1690\">source</a></span><a href=\"#impl-Iterator-for-Intersection%3C'a,+T,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, S&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.Intersection.html\" title=\"struct std::collections::hash_set::Intersection\">Intersection</a>&lt;'a, T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a>,\n    S: <a class=\"trait\" href=\"../hash/trait.BuildHasher.html\" title=\"trait std::hash::BuildHasher\">BuildHasher</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-111\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-111\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SymmetricDifference%3C'a,+T,+S%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1781-1804\">source</a></span><a href=\"#impl-Iterator-for-SymmetricDifference%3C'a,+T,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, S&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.SymmetricDifference.html\" title=\"struct std::collections::hash_set::SymmetricDifference\">SymmetricDifference</a>&lt;'a, T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a>,\n    S: <a class=\"trait\" href=\"../hash/trait.BuildHasher.html\" title=\"trait std::hash::BuildHasher\">BuildHasher</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-112\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-112\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Union%3C'a,+T,+S%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1853-1880\">source</a></span><a href=\"#impl-Iterator-for-Union%3C'a,+T,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, S&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.Union.html\" title=\"struct std::collections::hash_set::Union\">Union</a>&lt;'a, T, S&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a>,\n    S: <a class=\"trait\" href=\"../hash/trait.BuildHasher.html\" title=\"trait std::hash::BuildHasher\">BuildHasher</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-113\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-113\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;'a T</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ArrayChunks%3C'a,+T,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2328\">source</a><a href=\"#impl-Iterator-for-ArrayChunks%3C'a,+T,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::slice::<a class=\"struct\" href=\"../slice/struct.ArrayChunks.html\" title=\"struct std::slice::ArrayChunks\">ArrayChunks</a>&lt;'a, T, N&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-114\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-114\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ArrayChunksMut%3C'a,+T,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2446\">source</a><a href=\"#impl-Iterator-for-ArrayChunksMut%3C'a,+T,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ArrayChunksMut.html\" title=\"struct std::slice::ArrayChunksMut\">ArrayChunksMut</a>&lt;'a, T, N&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-115\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-115\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a mut <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ArrayWindows%3C'a,+T,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#2189\">source</a><a href=\"#impl-Iterator-for-ArrayWindows%3C'a,+T,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../slice/struct.ArrayWindows.html\" title=\"struct std::slice::ArrayWindows\">ArrayWindows</a>&lt;'a, T, N&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-116\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-116\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Range%3CA%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#839\">source</a></span><a href=\"#impl-Iterator-for-Range%3CA%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::ops::<a class=\"struct\" href=\"../ops/struct.Range.html\" title=\"struct std::ops::Range\">Range</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-117\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-117\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RangeFrom%3CA%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#1007\">source</a></span><a href=\"#impl-Iterator-for-RangeFrom%3CA%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../ops/struct.RangeFrom.html\" title=\"struct std::ops::RangeFrom\">RangeFrom</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-118\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-118\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RangeInclusive%3CA%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#1243\">source</a></span><a href=\"#impl-Iterator-for-RangeInclusive%3CA%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../ops/struct.RangeInclusive.html\" title=\"struct std::ops::RangeInclusive\">RangeInclusive</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-119\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-119\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CA%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/option.rs.html#2338\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CA%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::option::<a class=\"struct\" href=\"../option/struct.IntoIter.html\" title=\"struct std::option::IntoIter\">IntoIter</a>&lt;A&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-120\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-120\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Repeat%3CA%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/repeat.rs.html#70\">source</a></span><a href=\"#impl-Iterator-for-Repeat%3CA%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Repeat.html\" title=\"struct std::iter::Repeat\">Repeat</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-121\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-121\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RepeatN%3CA%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/repeat_n.rs.html#112\">source</a><a href=\"#impl-Iterator-for-RepeatN%3CA%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.RepeatN.html\" title=\"struct std::iter::RepeatN\">RepeatN</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-122\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-122\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Chain%3CA,+B%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/chain.rs.html#75-78\">source</a></span><a href=\"#impl-Iterator-for-Chain%3CA,+B%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A, B&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Chain.html\" title=\"struct std::iter::Chain\">Chain</a>&lt;A, B&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    B: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = &lt;A as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-123\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-123\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;A as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Zip%3CA,+B%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/zip.rs.html#76-79\">source</a></span><a href=\"#impl-Iterator-for-Zip%3CA,+B%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A, B&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Zip.html\" title=\"struct std::iter::Zip\">Zip</a>&lt;A, B&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    B: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-124\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-124\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (&lt;A as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>, &lt;B as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-OnceWith%3CF%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/once_with.rs.html#88\">source</a></span><a href=\"#impl-Iterator-for-OnceWith%3CF%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.OnceWith.html\" title=\"struct std::iter::OnceWith\">OnceWith</a>&lt;F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>() -&gt; A,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-125\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-125\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-RepeatWith%3CF%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/repeat_with.rs.html#88\">source</a></span><a href=\"#impl-Iterator-for-RepeatWith%3CF%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.RepeatWith.html\" title=\"struct std::iter::RepeatWith\">RepeatWith</a>&lt;F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>() -&gt; A,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-126\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-126\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-FilterMap%3CI,+F%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/filter_map.rs.html#56-58\">source</a></span><a href=\"#impl-Iterator-for-FilterMap%3CI,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B, I, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FilterMap.html\" title=\"struct std::iter::FilterMap\">FilterMap</a>&lt;I, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-127\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-127\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = B</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Map%3CI,+F%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/map.rs.html#100-102\">source</a></span><a href=\"#impl-Iterator-for-Map%3CI,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B, I, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Map.html\" title=\"struct std::iter::Map\">Map</a>&lt;I, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; B,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-128\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-128\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = B</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-MapWhile%3CI,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.57.0\">1.57.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/map_while.rs.html#35-37\">source</a></span><a href=\"#impl-Iterator-for-MapWhile%3CI,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B, I, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.MapWhile.html\" title=\"struct std::iter::MapWhile\">MapWhile</a>&lt;I, P&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-129\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-129\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = B</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Scan%3CI,+St,+F%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/scan.rs.html#36-39\">source</a></span><a href=\"#impl-Iterator-for-Scan%3CI,+St,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B, I, St, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Scan.html\" title=\"struct std::iter::Scan\">Scan</a>&lt;I, St, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut St</a>, &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;B&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-130\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-130\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = B</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Lines%3CB%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#3176-3195\">source</a></span><a href=\"#impl-Iterator-for-Lines%3CB%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B: <a class=\"trait\" href=\"../io/trait.BufRead.html\" title=\"trait std::io::BufRead\">BufRead</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::io::<a class=\"struct\" href=\"../io/struct.Lines.html\" title=\"struct std::io::Lines\">Lines</a>&lt;B&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-131\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-131\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a>, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Split%3CB%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#3144-3160\">source</a></span><a href=\"#impl-Iterator-for-Split%3CB%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B: <a class=\"trait\" href=\"../io/trait.BufRead.html\" title=\"trait std::io::BufRead\">BufRead</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::io::<a class=\"struct\" href=\"../io/struct.Split.html\" title=\"struct std::io::Split\">Split</a>&lt;B&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-132\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-132\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-%26mut+I\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/iterator.rs.html#4105\">source</a></span><a href=\"#impl-Iterator-for-%26mut+I\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut I</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-133\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-133\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-DecodeUtf16%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/char/decode.rs.html#40\">source</a></span><a href=\"#impl-Iterator-for-DecodeUtf16%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../char/struct.DecodeUtf16.html\" title=\"struct std::char::DecodeUtf16\">DecodeUtf16</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-134\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-134\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.char.html\">char</a>, <a class=\"struct\" href=\"../char/struct.DecodeUtf16Error.html\" title=\"struct std::char::DecodeUtf16Error\">DecodeUtf16Error</a>&gt;</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ByRefSized%3C'_,+I%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/by_ref_sized.rs.html#16\">source</a><a href=\"#impl-Iterator-for-ByRefSized%3C'_,+I%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.ByRefSized.html\" title=\"struct std::iter::ByRefSized\">ByRefSized</a>&lt;'_, I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-135\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-135\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Cycle%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/cycle.rs.html#26-28\">source</a></span><a href=\"#impl-Iterator-for-Cycle%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Cycle.html\" title=\"struct std::iter::Cycle\">Cycle</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-136\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-136\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Enumerate%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/enumerate.rs.html#30-32\">source</a></span><a href=\"#impl-Iterator-for-Enumerate%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Enumerate.html\" title=\"struct std::iter::Enumerate\">Enumerate</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-137\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-137\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>, &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>)</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Fuse%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/fuse.rs.html#42-44\">source</a></span><a href=\"#impl-Iterator-for-Fuse%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Fuse.html\" title=\"struct std::iter::Fuse\">Fuse</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-138\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-138\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Intersperse%3CI%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/intersperse.rs.html#38-41\">source</a><a href=\"#impl-Iterator-for-Intersperse%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Intersperse.html\" title=\"struct std::iter::Intersperse\">Intersperse</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-139\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-139\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Peekable%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/peekable.rs.html#33\">source</a></span><a href=\"#impl-Iterator-for-Peekable%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Peekable.html\" title=\"struct std::iter::Peekable\">Peekable</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-140\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-140\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Rev%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/rev.rs.html#26-28\">source</a></span><a href=\"#impl-Iterator-for-Rev%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Rev.html\" title=\"struct std::iter::Rev\">Rev</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.DoubleEndedIterator.html\" title=\"trait std::iter::DoubleEndedIterator\">DoubleEndedIterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-141\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-141\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Skip%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/skip.rs.html#33-35\">source</a></span><a href=\"#impl-Iterator-for-Skip%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Skip.html\" title=\"struct std::iter::Skip\">Skip</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-142\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-142\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-StepBy%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/step_by.rs.html#53-55\">source</a></span><a href=\"#impl-Iterator-for-StepBy%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.StepBy.html\" title=\"struct std::iter::StepBy\">StepBy</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-143\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-143\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Take%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/take.rs.html#31-33\">source</a></span><a href=\"#impl-Iterator-for-Take%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Take.html\" title=\"struct std::iter::Take\">Take</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-144\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-144\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><section id=\"impl-Iterator-for-Box%3C%5BI%5D,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2127\">source</a></span><a href=\"#impl-Iterator-for-Box%3C%5BI%5D,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, A&gt; !<a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[I]</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><div class=\"docblock\"><p>This implementation is required to make sure that the <code>Box&lt;[I]&gt;: IntoIterator</code>\nimplementation doesn’t overlap with <code>IntoIterator for T where T: Iterator</code> blanket.</p>\n</div><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Box%3CI,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#1994\">source</a></span><a href=\"#impl-Iterator-for-Box%3CI,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;I, A&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-145\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-145\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Splice%3C'_,+I,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/vec/splice.rs.html#31\">source</a></span><a href=\"#impl-Iterator-for-Splice%3C'_,+I,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../vec/struct.Splice.html\" title=\"struct std::vec::Splice\">Splice</a>&lt;'_, I, A&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-146\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-146\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Inspect%3CI,+F%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/inspect.rs.html#69-71\">source</a></span><a href=\"#impl-Iterator-for-Inspect%3CI,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Inspect.html\" title=\"struct std::iter::Inspect\">Inspect</a>&lt;I, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>),</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-147\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-147\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-MapWindows%3CI,+F,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/map_windows.rs.html#240-243\">source</a><a href=\"#impl-Iterator-for-MapWindows%3CI,+F,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, F, R, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.MapWindows.html\" title=\"struct std::iter::MapWindows\">MapWindows</a>&lt;I, F, N&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;[&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>]) -&gt; R,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-148\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-148\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = R</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntersperseWith%3CI,+G%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/intersperse.rs.html#154-157\">source</a><a href=\"#impl-Iterator-for-IntersperseWith%3CI,+G%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, G&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IntersperseWith.html\" title=\"struct std::iter::IntersperseWith\">IntersperseWith</a>&lt;I, G&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    G: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>() -&gt; &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-149\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-149\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Filter%3CI,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/filter.rs.html#52-54\">source</a></span><a href=\"#impl-Iterator-for-Filter%3CI,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Filter.html\" title=\"struct std::iter::Filter\">Filter</a>&lt;I, P&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-150\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-150\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-SkipWhile%3CI,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/skip_while.rs.html#36-38\">source</a></span><a href=\"#impl-Iterator-for-SkipWhile%3CI,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SkipWhile.html\" title=\"struct std::iter::SkipWhile\">SkipWhile</a>&lt;I, P&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-151\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-151\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-TakeWhile%3CI,+P%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/take_while.rs.html#36-38\">source</a></span><a href=\"#impl-Iterator-for-TakeWhile%3CI,+P%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, P&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TakeWhile.html\" title=\"struct std::iter::TakeWhile\">TakeWhile</a>&lt;I, P&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    P: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&amp;&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-152\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-152\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Flatten%3CI%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.29.0\">1.29.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/flatten.rs.html#289-292\">source</a></span><a href=\"#impl-Iterator-for-Flatten%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, U&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Flatten.html\" title=\"struct std::iter::Flatten\">Flatten</a>&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    &lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;IntoIter = U, Item = &lt;U as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>&gt;,\n    U: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-153\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-153\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;U as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-FlatMap%3CI,+U,+F%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/flatten.rs.html#58-60\">source</a></span><a href=\"#impl-Iterator-for-FlatMap%3CI,+U,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, U, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FlatMap.html\" title=\"struct std::iter::FlatMap\">FlatMap</a>&lt;I, U, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,\n    U: <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>) -&gt; U,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-154\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-154\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;U as <a class=\"trait\" href=\"trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.IntoIterator.html#associatedtype.Item\" title=\"type std::iter::IntoIterator::Item\">Item</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ArrayChunks%3CI,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/adapters/array_chunks.rs.html#58-60\">source</a><a href=\"#impl-Iterator-for-ArrayChunks%3CI,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::iter::<a class=\"struct\" href=\"struct.ArrayChunks.html\" title=\"struct std::iter::ArrayChunks\">ArrayChunks</a>&lt;I, N&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-155\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-155\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = [&lt;I as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type std::iter::Iterator::Item\">Item</a>; <a class=\"primitive\" href=\"../primitive.array.html\">N</a>]</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CK%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/set.rs.html#1541-1564\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CK%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.IntoIter.html\" title=\"struct std::collections::hash_set::IntoIter\">IntoIter</a>&lt;K&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-156\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-156\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = K</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ExtractIf%3C'_,+K,+F%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/collections/hash/set.rs.html#1621-1635\">source</a><a href=\"#impl-Iterator-for-ExtractIf%3C'_,+K,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_set::<a class=\"struct\" href=\"../collections/hash_set/struct.ExtractIf.html\" title=\"struct std::collections::hash_set::ExtractIf\">ExtractIf</a>&lt;'_, K, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;K</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-157\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-157\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = K</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CK,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2311-2334\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CK,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.IntoIter.html\" title=\"struct std::collections::hash_map::IntoIter\">IntoIter</a>&lt;K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-158\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-158\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.tuple.html\">(K, V)</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoKeys%3CK,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.54.0\">1.54.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2465-2488\">source</a></span><a href=\"#impl-Iterator-for-IntoKeys%3CK,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.IntoKeys.html\" title=\"struct std::collections::hash_map::IntoKeys\">IntoKeys</a>&lt;K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-159\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-159\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = K</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoValues%3CK,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.54.0\">1.54.0</span> · <a class=\"src\" href=\"../../src/std/collections/hash/map.rs.html#2507-2530\">source</a></span><a href=\"#impl-Iterator-for-IntoValues%3CK,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.IntoValues.html\" title=\"struct std::collections::hash_map::IntoValues\">IntoValues</a>&lt;K, V&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-160\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-160\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = V</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1717\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CK,+V,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.IntoIter.html\" title=\"struct std::collections::btree_map::IntoIter\">IntoIter</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-161\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-161\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.tuple.html\">(K, V)</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoKeys%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.54.0\">1.54.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2054\">source</a></span><a href=\"#impl-Iterator-for-IntoKeys%3CK,+V,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.IntoKeys.html\" title=\"struct std::collections::btree_map::IntoKeys\">IntoKeys</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-162\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-162\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = K</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoValues%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.54.0\">1.54.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2119\">source</a></span><a href=\"#impl-Iterator-for-IntoValues%3CK,+V,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.IntoValues.html\" title=\"struct std::collections::btree_map::IntoValues\">IntoValues</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-163\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-163\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = V</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ExtractIf%3C'_,+K,+V,+F%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/collections/hash/map.rs.html#2591-2605\">source</a><a href=\"#impl-Iterator-for-ExtractIf%3C'_,+K,+V,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::hash_map::<a class=\"struct\" href=\"../collections/hash_map/struct.ExtractIf.html\" title=\"struct std::collections::hash_map::ExtractIf\">ExtractIf</a>&lt;'_, K, V, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut V</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-164\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-164\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.tuple.html\">(K, V)</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ExtractIf%3C'_,+K,+V,+F,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1916-1918\">source</a><a href=\"#impl-Iterator-for-ExtractIf%3C'_,+K,+V,+F,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, F, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_map::<a class=\"struct\" href=\"../collections/btree_map/struct.ExtractIf.html\" title=\"struct std::collections::btree_map::ExtractIf\">ExtractIf</a>&lt;'_, K, V, F, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut V</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-165\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-165\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../primitive.tuple.html\">(K, V)</a></h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Bytes%3CR%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#3019-3032\">source</a></span><a href=\"#impl-Iterator-for-Bytes%3CR%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;R: <a class=\"trait\" href=\"../io/trait.Read.html\" title=\"trait std::io::Read\">Read</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::io::<a class=\"struct\" href=\"../io/struct.Bytes.html\" title=\"struct std::io::Bytes\">Bytes</a>&lt;R&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-166\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-166\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>, <a class=\"struct\" href=\"../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;</h4></section></div></details><section id=\"impl-Iterator-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/slice/iter.rs.html#20\">source</a></span><a href=\"#impl-Iterator-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; !<a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h3></section><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/result.rs.html#1879\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::result::<a class=\"struct\" href=\"../result/struct.IntoIter.html\" title=\"struct std::result::IntoIter\">IntoIter</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-167\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-167\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.1.0\">1.1.0</span> · <a class=\"src\" href=\"../../src/std/sync/mpsc/mod.rs.html#1072-1077\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::sync::mpsc::<a class=\"struct\" href=\"../sync/mpsc/struct.IntoIter.html\" title=\"struct std::sync::mpsc::IntoIter\">IntoIter</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-168\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-168\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Empty%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/empty.rs.html#41\">source</a></span><a href=\"#impl-Iterator-for-Empty%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Empty.html\" title=\"struct std::iter::Empty\">Empty</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-169\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-169\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Once%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/once.rs.html#70\">source</a></span><a href=\"#impl-Iterator-for-Once%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Once.html\" title=\"struct std::iter::Once\">Once</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-170\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-170\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Drain%3C'_,+T,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1666\">source</a></span><a href=\"#impl-Iterator-for-Drain%3C'_,+T,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::binary_heap::<a class=\"struct\" href=\"../collections/binary_heap/struct.Drain.html\" title=\"struct std::collections::binary_heap::Drain\">Drain</a>&lt;'_, T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-171\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-171\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-DrainSorted%3C'_,+T,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1743\">source</a><a href=\"#impl-Iterator-for-DrainSorted%3C'_,+T,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../collections/binary_heap/struct.DrainSorted.html\" title=\"struct std::collections::binary_heap::DrainSorted\">DrainSorted</a>&lt;'_, T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-172\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-172\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1520\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::binary_heap::<a class=\"struct\" href=\"../collections/binary_heap/struct.IntoIter.html\" title=\"struct std::collections::binary_heap::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-173\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-173\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIterSorted%3CT,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/binary_heap/mod.rs.html#1617\">source</a><a href=\"#impl-Iterator-for-IntoIterSorted%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../collections/binary_heap/struct.IntoIterSorted.html\" title=\"struct std::collections::binary_heap::IntoIterSorted\">IntoIterSorted</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-174\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-174\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT,+A%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/set.rs.html#1512\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT,+A%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::btree_set::<a class=\"struct\" href=\"../collections/btree_set/struct.IntoIter.html\" title=\"struct std::collections::btree_set::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-175\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-175\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT,+A%3E-2\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/linked_list.rs.html#1973\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT,+A%3E-2\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::linked_list::<a class=\"struct\" href=\"../collections/linked_list/struct.IntoIter.html\" title=\"struct std::collections::linked_list::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-176\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-176\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Drain%3C'_,+T,+A%3E-1\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/vec_deque/drain.rs.html#237\">source</a></span><a href=\"#impl-Iterator-for-Drain%3C'_,+T,+A%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::vec_deque::<a class=\"struct\" href=\"../collections/vec_deque/struct.Drain.html\" title=\"struct std::collections::vec_deque::Drain\">Drain</a>&lt;'_, T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-177\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-177\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT,+A%3E-3\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/vec_deque/into_iter.rs.html#42\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT,+A%3E-3\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::vec_deque::<a class=\"struct\" href=\"../collections/vec_deque/struct.IntoIter.html\" title=\"struct std::collections::vec_deque::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-178\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-178\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Drain%3C'_,+T,+A%3E-2\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/vec/drain.rs.html#152\">source</a></span><a href=\"#impl-Iterator-for-Drain%3C'_,+T,+A%3E-2\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::vec::<a class=\"struct\" href=\"../vec/struct.Drain.html\" title=\"struct std::vec::Drain\">Drain</a>&lt;'_, T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-179\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-179\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT,+A%3E-4\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/vec/into_iter.rs.html#198\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT,+A%3E-4\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::vec::<a class=\"struct\" href=\"../vec/struct.IntoIter.html\" title=\"struct std::vec::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-180\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-180\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-FromFn%3CF%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/from_fn.rs.html#61-63\">source</a></span><a href=\"#impl-Iterator-for-FromFn%3CF%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FromFn.html\" title=\"struct std::iter::FromFn\">FromFn</a>&lt;F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>() -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-181\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-181\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-Successors%3CT,+F%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/sources/successors.rs.html#39-41\">source</a></span><a href=\"#impl-Iterator-for-Successors%3CT,+F%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, F&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Successors.html\" title=\"struct std::iter::Successors\">Successors</a>&lt;T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-182\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-182\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/linked_list.rs.html#1934-1936\">source</a><a href=\"#impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, F, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::collections::linked_list::<a class=\"struct\" href=\"../collections/linked_list/struct.ExtractIf.html\" title=\"struct std::collections::linked_list::ExtractIf\">ExtractIf</a>&lt;'_, T, F, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-183\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-183\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E-2\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/vec/extract_if.rs.html#55-57\">source</a><a href=\"#impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E-2\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, F, A&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::vec::<a class=\"struct\" href=\"../vec/struct.ExtractIf.html\" title=\"struct std::vec::ExtractIf\">ExtractIf</a>&lt;'_, T, F, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    F: <a class=\"trait\" href=\"../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a>,</div></h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-184\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-184\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Iterator-for-IntoIter%3CT,+N%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0\">1.40.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/array/iter.rs.html#237\">source</a></span><a href=\"#impl-Iterator-for-IntoIter%3CT,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for std::array::<a class=\"struct\" href=\"../array/struct.IntoIter.html\" title=\"struct std::array::IntoIter\">IntoIter</a>&lt;T, N&gt;</h3></section></summary><div class=\"impl-items\"><section id=\"associatedtype.Item-185\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-185\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></div></details><div id=\"impl-Iterator-189\" class=\"impl\"><a href=\"#impl-Iterator-189\" class=\"anchor\"></a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.80.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../proc_macro/token_stream/struct.IntoIter.html\" title=\"struct proc_macro::token_stream::IntoIter\">IntoIter</a></h3></div></div><script src=\"../../trait.impl/core/iter/traits/iterator/trait.Iterator.js\" data-ignore-extern-crates=\"alloc,core\" async=\"\"></script><script type=\"text/json\" id=\"notable-traits-data\">{\"ArrayChunks<Self, N>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.ArrayChunks.html\\\" title=\\\"struct std::iter::ArrayChunks\\\">ArrayChunks</a>&lt;I, N&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, const N: <a class=\\\"primitive\\\" href=\\\"../primitive.usize.html\\\">usize</a>&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.ArrayChunks.html\\\" title=\\\"struct std::iter::ArrayChunks\\\">ArrayChunks</a>&lt;I, N&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = [&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>; <a class=\\\"primitive\\\" href=\\\"../primitive.array.html\\\">N</a>];</div>\",\"Chain<Self, <U as IntoIterator>::IntoIter>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Chain.html\\\" title=\\\"struct std::iter::Chain\\\">Chain</a>&lt;A, B&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;A, B&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Chain.html\\\" title=\\\"struct std::iter::Chain\\\">Chain</a>&lt;A, B&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    B: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&lt;Item = &lt;A as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;A as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Cloned<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Cloned.html\\\" title=\\\"struct std::iter::Cloned\\\">Cloned</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, I, T&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Cloned.html\\\" title=\\\"struct std::iter::Cloned\\\">Cloned</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    T: 'a + <a class=\\\"trait\\\" href=\\\"../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a>,\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&lt;Item = <a class=\\\"primitive\\\" href=\\\"../primitive.reference.html\\\">&amp;'a T</a>&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = T;</div>\",\"Copied<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Copied.html\\\" title=\\\"struct std::iter::Copied\\\">Copied</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, I, T&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Copied.html\\\" title=\\\"struct std::iter::Copied\\\">Copied</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    T: 'a + <a class=\\\"trait\\\" href=\\\"../marker/trait.Copy.html\\\" title=\\\"trait std::marker::Copy\\\">Copy</a>,\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&lt;Item = <a class=\\\"primitive\\\" href=\\\"../primitive.reference.html\\\">&amp;'a T</a>&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = T;</div>\",\"Cycle<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Cycle.html\\\" title=\\\"struct std::iter::Cycle\\\">Cycle</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Cycle.html\\\" title=\\\"struct std::iter::Cycle\\\">Cycle</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a> + <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Enumerate<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Enumerate.html\\\" title=\\\"struct std::iter::Enumerate\\\">Enumerate</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Enumerate.html\\\" title=\\\"struct std::iter::Enumerate\\\">Enumerate</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../primitive.usize.html\\\">usize</a>, &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>);</div>\",\"Filter<Self, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Filter.html\\\" title=\\\"struct std::iter::Filter\\\">Filter</a>&lt;I, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, P&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Filter.html\\\" title=\\\"struct std::iter::Filter\\\">Filter</a>&lt;I, P&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    P: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&amp;&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; <a class=\\\"primitive\\\" href=\\\"../primitive.bool.html\\\">bool</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"FilterMap<Self, F>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.FilterMap.html\\\" title=\\\"struct std::iter::FilterMap\\\">FilterMap</a>&lt;I, F&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;B, I, F&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.FilterMap.html\\\" title=\\\"struct std::iter::FilterMap\\\">FilterMap</a>&lt;I, F&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; <a class=\\\"enum\\\" href=\\\"../option/enum.Option.html\\\" title=\\\"enum std::option::Option\\\">Option</a>&lt;B&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = B;</div>\",\"FlatMap<Self, U, F>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.FlatMap.html\\\" title=\\\"struct std::iter::FlatMap\\\">FlatMap</a>&lt;I, U, F&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, U, F&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.FlatMap.html\\\" title=\\\"struct std::iter::FlatMap\\\">FlatMap</a>&lt;I, U, F&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    U: <a class=\\\"trait\\\" href=\\\"trait.IntoIterator.html\\\" title=\\\"trait std::iter::IntoIterator\\\">IntoIterator</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; U,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;U as <a class=\\\"trait\\\" href=\\\"trait.IntoIterator.html\\\" title=\\\"trait std::iter::IntoIterator\\\">IntoIterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.IntoIterator.html#associatedtype.Item\\\" title=\\\"type std::iter::IntoIterator::Item\\\">Item</a>;</div>\",\"Flatten<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Flatten.html\\\" title=\\\"struct std::iter::Flatten\\\">Flatten</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, U&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Flatten.html\\\" title=\\\"struct std::iter::Flatten\\\">Flatten</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>: <a class=\\\"trait\\\" href=\\\"trait.IntoIterator.html\\\" title=\\\"trait std::iter::IntoIterator\\\">IntoIterator</a>&lt;IntoIter = U, Item = &lt;U as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>&gt;,\\n    U: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;U as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Fuse<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Fuse.html\\\" title=\\\"struct std::iter::Fuse\\\">Fuse</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Fuse.html\\\" title=\\\"struct std::iter::Fuse\\\">Fuse</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Inspect<Self, F>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Inspect.html\\\" title=\\\"struct std::iter::Inspect\\\">Inspect</a>&lt;I, F&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, F&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Inspect.html\\\" title=\\\"struct std::iter::Inspect\\\">Inspect</a>&lt;I, F&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&amp;&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>),</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Intersperse<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Intersperse.html\\\" title=\\\"struct std::iter::Intersperse\\\">Intersperse</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Intersperse.html\\\" title=\\\"struct std::iter::Intersperse\\\">Intersperse</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>: <a class=\\\"trait\\\" href=\\\"../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"IntersperseWith<Self, G>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.IntersperseWith.html\\\" title=\\\"struct std::iter::IntersperseWith\\\">IntersperseWith</a>&lt;I, G&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, G&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.IntersperseWith.html\\\" title=\\\"struct std::iter::IntersperseWith\\\">IntersperseWith</a>&lt;I, G&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    G: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>() -&gt; &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Map<Self, F>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Map.html\\\" title=\\\"struct std::iter::Map\\\">Map</a>&lt;I, F&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;B, I, F&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Map.html\\\" title=\\\"struct std::iter::Map\\\">Map</a>&lt;I, F&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; B,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = B;</div>\",\"MapWhile<Self, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.MapWhile.html\\\" title=\\\"struct std::iter::MapWhile\\\">MapWhile</a>&lt;I, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;B, I, P&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.MapWhile.html\\\" title=\\\"struct std::iter::MapWhile\\\">MapWhile</a>&lt;I, P&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    P: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; <a class=\\\"enum\\\" href=\\\"../option/enum.Option.html\\\" title=\\\"enum std::option::Option\\\">Option</a>&lt;B&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = B;</div>\",\"MapWindows<Self, F, N>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.MapWindows.html\\\" title=\\\"struct std::iter::MapWindows\\\">MapWindows</a>&lt;I, F, N&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, F, R, const N: <a class=\\\"primitive\\\" href=\\\"../primitive.usize.html\\\">usize</a>&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.MapWindows.html\\\" title=\\\"struct std::iter::MapWindows\\\">MapWindows</a>&lt;I, F, N&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&amp;[&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>; <a class=\\\"primitive\\\" href=\\\"../primitive.array.html\\\">N</a>]) -&gt; R,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = R;</div>\",\"Peekable<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Peekable.html\\\" title=\\\"struct std::iter::Peekable\\\">Peekable</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Peekable.html\\\" title=\\\"struct std::iter::Peekable\\\">Peekable</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Rev<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Rev.html\\\" title=\\\"struct std::iter::Rev\\\">Rev</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Rev.html\\\" title=\\\"struct std::iter::Rev\\\">Rev</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.DoubleEndedIterator.html\\\" title=\\\"trait std::iter::DoubleEndedIterator\\\">DoubleEndedIterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Scan<Self, St, F>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Scan.html\\\" title=\\\"struct std::iter::Scan\\\">Scan</a>&lt;I, St, F&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;B, I, St, F&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Scan.html\\\" title=\\\"struct std::iter::Scan\\\">Scan</a>&lt;I, St, F&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(<a class=\\\"primitive\\\" href=\\\"../primitive.reference.html\\\">&amp;mut St</a>, &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; <a class=\\\"enum\\\" href=\\\"../option/enum.Option.html\\\" title=\\\"enum std::option::Option\\\">Option</a>&lt;B&gt;,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = B;</div>\",\"Skip<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Skip.html\\\" title=\\\"struct std::iter::Skip\\\">Skip</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Skip.html\\\" title=\\\"struct std::iter::Skip\\\">Skip</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"SkipWhile<Self, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.SkipWhile.html\\\" title=\\\"struct std::iter::SkipWhile\\\">SkipWhile</a>&lt;I, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, P&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.SkipWhile.html\\\" title=\\\"struct std::iter::SkipWhile\\\">SkipWhile</a>&lt;I, P&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    P: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&amp;&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; <a class=\\\"primitive\\\" href=\\\"../primitive.bool.html\\\">bool</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"StepBy<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.StepBy.html\\\" title=\\\"struct std::iter::StepBy\\\">StepBy</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.StepBy.html\\\" title=\\\"struct std::iter::StepBy\\\">StepBy</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Take<Self>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Take.html\\\" title=\\\"struct std::iter::Take\\\">Take</a>&lt;I&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Take.html\\\" title=\\\"struct std::iter::Take\\\">Take</a>&lt;I&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"TakeWhile<Self, P>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.TakeWhile.html\\\" title=\\\"struct std::iter::TakeWhile\\\">TakeWhile</a>&lt;I, P&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;I, P&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.TakeWhile.html\\\" title=\\\"struct std::iter::TakeWhile\\\">TakeWhile</a>&lt;I, P&gt;<div class=\\\"where\\\">where\\n    I: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    P: <a class=\\\"trait\\\" href=\\\"../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(&amp;&lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>) -&gt; <a class=\\\"primitive\\\" href=\\\"../primitive.bool.html\\\">bool</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = &lt;I as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>;</div>\",\"Zip<Self, <U as IntoIterator>::IntoIter>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Zip.html\\\" title=\\\"struct std::iter::Zip\\\">Zip</a>&lt;A, B&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;A, B&gt; <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Zip.html\\\" title=\\\"struct std::iter::Zip\\\">Zip</a>&lt;A, B&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,\\n    B: <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (&lt;A as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>, &lt;B as <a class=\\\"trait\\\" href=\\\"trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a>&gt;::<a class=\\\"associatedtype\\\" href=\\\"trait.Iterator.html#associatedtype.Item\\\" title=\\\"type std::iter::Iterator::Item\\\">Item</a>);</div>\"}</script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:49.083Z"
}