{
	"title": "Developing the Library’s Functionality with Test Driven Development - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch12-04-testing-the-librarys-functionality.html",
	"markdown": "# Developing the Library’s Functionality with Test Driven Development\n\nNow that we’ve extracted the logic into _src/lib.rs_ and left the argument collecting and error handling in _src/main.rs_, it’s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line.\n\nIn this section, we’ll add the searching logic to the `minigrep` program using the test-driven development (TDD) process with the following steps:\n\n1.  Write a test that fails and run it to make sure it fails for the reason you expect.\n2.  Write or modify just enough code to make the new test pass.\n3.  Refactor the code you just added or changed and make sure the tests continue to pass.\n4.  Repeat from step 1!\n\nThough it’s just one of many ways to write software, TDD can help drive code design. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.\n\nWe’ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We’ll add this functionality in a function called `search`.\n\n### [Writing a Failing Test](#writing-a-failing-test)\n\nBecause we don’t need them anymore, let’s remove the `println!` statements from _src/lib.rs_ and _src/main.rs_ that we used to check the program’s behavior. Then, in _src/lib.rs_, add a `tests` module with a test function, as we did in [Chapter 11](about:blank/ch11-01-writing-tests.html#the-anatomy-of-a-test-function). The test function specifies the behavior we want the `search` function to have: it will take a query and the text to search, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won’t compile yet.\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\nListing 12-15: Creating a failing test for the `search` function we wish we had\n\nThis test searches for the string `\"duct\"`. The text we’re searching is three lines, only one of which contains `\"duct\"` (Note that the backslash after the opening double quote tells Rust not to put a newline character at the beginning of the contents of this string literal). We assert that the value returned from the `search` function contains only the line we expect.\n\nWe aren’t yet able to run this test and watch it fail because the test doesn’t even compile: the `search` function doesn’t exist yet! In accordance with TDD principles, we’ll add just enough code to get the test to compile and run by adding a definition of the `search` function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn’t match a vector containing the line `\"safe, fast, productive.\"`\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    Ok(())\n}\n\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    vec![]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\nListing 12-16: Defining just enough of the `search` function so our test will compile\n\nNotice that we need to define an explicit lifetime `'a` in the signature of `search` and use that lifetime with the `contents` argument and the return value. Recall in [Chapter 10](ch10-03-lifetime-syntax.html) that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument `contents` (rather than the argument `query`).\n\nIn other words, we tell Rust that the data returned by the `search` function will live as long as the data passed into the `search` function in the `contents` argument. This is important! The data referenced _by_ a slice needs to be valid for the reference to be valid; if the compiler assumes we’re making string slices of `query` rather than `contents`, it will do its safety checking incorrectly.\n\nIf we forget the lifetime annotations and try to compile this function, we’ll get this error:\n\n```console\n$ cargo build\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nerror[E0106]: missing lifetime specifier\n  --> src/lib.rs:28:51\n   |\n28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {\n   |                      ----            ----         ^ expected named lifetime parameter\n   |\n   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`\nhelp: consider introducing a named lifetime parameter\n   |\n28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {\n   |              ++++         ++                 ++              ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `minigrep` (lib) due to 1 previous error\n\n```\n\nRust can’t possibly know which of the two arguments we need, so we need to tell it explicitly. Because `contents` is the argument that contains all of our text and we want to return the parts of that text that match, we know `contents` is the argument that should be connected to the return value using the lifetime syntax.\n\nOther programming languages don’t require you to connect arguments to return values in the signature, but this practice will get easier over time. You might want to compare this example with the [“Validating References with Lifetimes”](about:blank/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes) section in Chapter 10.\n\nNow let’s run the test:\n\n```console\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... FAILED\n\nfailures:\n\n---- tests::one_result stdout ----\nthread 'tests::one_result' panicked at src/lib.rs:44:9:\nassertion `left == right` failed\n  left: [\"safe, fast, productive.\"]\n right: []\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::one_result\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nGreat, the test fails, exactly as we expected. Let’s get the test to pass!\n\n### [Writing Code to Pass the Test](#writing-code-to-pass-the-test)\n\nCurrently, our test is failing because we always return an empty vector. To fix that and implement `search`, our program needs to follow these steps:\n\n-   Iterate through each line of the contents.\n-   Check whether the line contains our query string.\n-   If it does, add it to the list of values we’re returning.\n-   If it doesn’t, do nothing.\n-   Return the list of results that match.\n\nLet’s work through each step, starting with iterating through lines.\n\n#### [Iterating Through Lines with the `lines` Method](#iterating-through-lines-with-the-lines-method)\n\nRust has a helpful method to handle line-by-line iteration of strings, conveniently named `lines`, that works as shown in Listing 12-17. Note this won’t compile yet.\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    Ok(())\n}\n\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    for line in contents.lines() {\n        // do something with line\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\nListing 12-17: Iterating through each line in `contents`\n\nThe `lines` method returns an iterator. We’ll talk about iterators in depth in [Chapter 13](ch13-02-iterators.html), but recall that you saw this way of using an iterator in [Listing 3-5](about:blank/ch03-05-control-flow.html#looping-through-a-collection-with-for), where we used a `for` loop with an iterator to run some code on each item in a collection.\n\n#### [Searching Each Line for the Query](#searching-each-line-for-the-query)\n\nNext, we’ll check whether the current line contains our query string. Fortunately, strings have a helpful method named `contains` that does this for us! Add a call to the `contains` method in the `search` function, as shown in Listing 12-18. Note this still won’t compile yet.\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    Ok(())\n}\n\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    for line in contents.lines() {\n        if line.contains(query) {\n            // do something with line\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\nListing 12-18: Adding functionality to see whether the line contains the string in `query`\n\nAt the moment, we’re building up functionality. To get it to compile, we need to return a value from the body as we indicated we would in the function signature.\n\n#### [Storing Matching Lines](#storing-matching-lines)\n\nTo finish this function, we need a way to store the matching lines that we want to return. For that, we can make a mutable vector before the `for` loop and call the `push` method to store a `line` in the vector. After the `for` loop, we return the vector, as shown in Listing 12-19.\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    Ok(())\n}\n\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\nListing 12-19: Storing the lines that match so we can return them\n\nNow the `search` function should return only the lines that contain `query`, and our test should pass. Let’s run the test:\n\n```console\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nOur test passed, so we know it works!\n\nAt this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn’t too bad, but it doesn’t take advantage of some useful features of iterators. We’ll return to this example in [Chapter 13](ch13-02-iterators.html), where we’ll explore iterators in detail, and look at how to improve it.\n\n#### [Using the `search` Function in the `run` Function](#using-the-search-function-in-the-run-function)\n\nNow that the `search` function is working and tested, we need to call `search` from our `run` function. We need to pass the `config.query` value and the `contents` that `run` reads from the file to the `search` function. Then `run` will print each line returned from `search`:\n\nFilename: src/lib.rs\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    for line in search(&config.query, &contents) {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\nWe’re still using a `for` loop to return each line from `search` and print it.\n\nNow the entire program should work! Let’s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, “frog”:\n\n```console\n$ cargo run -- frog poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/minigrep frog poem.txt`\nHow public, like a frog\n\n```\n\nCool! Now let’s try a word that will match multiple lines, like “body”:\n\n```console\n$ cargo run -- body poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep body poem.txt`\nI'm nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n\n```\n\nAnd finally, let’s make sure that we don’t get any lines when we search for a word that isn’t anywhere in the poem, such as “monomorphization”:\n\n```console\n$ cargo run -- monomorphization poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep monomorphization poem.txt`\n\n```\n\nExcellent! We’ve built our own mini version of a classic tool and learned a lot about how to structure applications. We’ve also learned a bit about file input and output, lifetimes, testing, and command line parsing.\n\nTo round out this project, we’ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you’re writing command line programs.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Developing the Library’s Functionality with Test Driven Development - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"developing-the-librarys-functionality-with-test-driven-development\"><a class=\"header\" href=\"#developing-the-librarys-functionality-with-test-driven-development\">Developing the Library’s Functionality with Test-Driven Development</a></h2>\n<p>Now that we’ve extracted the logic into <em>src/lib.rs</em> and left the argument\ncollecting and error handling in <em>src/main.rs</em>, it’s much easier to write tests\nfor the core functionality of our code. We can call functions directly with\nvarious arguments and check return values without having to call our binary\nfrom the command line.</p>\n<p>In this section, we’ll add the searching logic to the <code class=\"hljs\">minigrep</code> program\nusing the test-driven development (TDD) process with the following steps:</p>\n<ol>\n<li>Write a test that fails and run it to make sure it fails for the reason you\nexpect.</li>\n<li>Write or modify just enough code to make the new test pass.</li>\n<li>Refactor the code you just added or changed and make sure the tests\ncontinue to pass.</li>\n<li>Repeat from step 1!</li>\n</ol>\n<p>Though it’s just one of many ways to write software, TDD can help drive code\ndesign. Writing the test before you write the code that makes the test pass\nhelps to maintain high test coverage throughout the process.</p>\n<p>We’ll test drive the implementation of the functionality that will actually do\nthe searching for the query string in the file contents and produce a list of\nlines that match the query. We’ll add this functionality in a function called\n<code class=\"hljs\">search</code>.</p>\n<h3 id=\"writing-a-failing-test\"><a class=\"header\" href=\"#writing-a-failing-test\">Writing a Failing Test</a></h3>\n<p>Because we don’t need them anymore, let’s remove the <code class=\"hljs\">println!</code> statements from\n<em>src/lib.rs</em> and <em>src/main.rs</em> that we used to check the program’s behavior.\nThen, in <em>src/lib.rs</em>, add a <code class=\"hljs\">tests</code> module with a test function, as we did in\n<a href=\"ch11-01-writing-tests.html#the-anatomy-of-a-test-function\">Chapter 11</a><!-- ignore -->. The test function specifies the\nbehavior we want the <code class=\"hljs\">search</code> function to have: it will take a query and the\ntext to search, and it will return only the lines from the text that contain\nthe query. Listing 12-15 shows this test, which won’t compile yet.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">one_result</span></span>() {\n        <span class=\"hljs-keyword\">let</span> query = <span class=\"hljs-string\">\"duct\"</span>;\n        <span class=\"hljs-keyword\">let</span> contents = <span class=\"hljs-string\">\"\\\nRust:\nsafe, fast, productive.\nPick three.\"</span>;\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"safe, fast, productive.\"</span>], search(query, contents));\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 12-15: Creating a failing test for the <code class=\"hljs\">search</code>\nfunction we wish we had</span></p>\n<p>This test searches for the string <code class=\"hljs\">\"duct\"</code>. The text we’re searching is three\nlines, only one of which contains <code class=\"hljs\">\"duct\"</code> (Note that the backslash after the\nopening double quote tells Rust not to put a newline character at the beginning\nof the contents of this string literal). We assert that the value returned from\nthe <code class=\"hljs\">search</code> function contains only the line we expect.</p>\n<p>We aren’t yet able to run this test and watch it fail because the test doesn’t\neven compile: the <code class=\"hljs\">search</code> function doesn’t exist yet! In accordance with TDD\nprinciples, we’ll add just enough code to get the test to compile and run by\nadding a definition of the <code class=\"hljs\">search</code> function that always returns an empty\nvector, as shown in Listing 12-16. Then the test should compile and fail\nbecause an empty vector doesn’t match a vector containing the line <code class=\"hljs\">\"safe, fast, productive.\"</code></p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">search</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(query: &amp;<span class=\"hljs-built_in\">str</span>, contents: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">Vec</span>&lt;&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>&gt; {\n    <span class=\"hljs-built_in\">vec!</span>[]\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">one_result</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = <span class=\"hljs-string\">\"duct\"</span>;\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> contents = <span class=\"hljs-string\">\"\\\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Rust:\n</span></span><span class=\"boring\"><span class=\"hljs-string\">safe, fast, productive.\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Pick three.\"</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"safe, fast, productive.\"</span>], search(query, contents));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-16: Defining just enough of the <code class=\"hljs\">search</code>\nfunction so our test will compile</span></p>\n<p>Notice that we need to define an explicit lifetime <code class=\"hljs\">'a</code> in the signature of\n<code class=\"hljs\">search</code> and use that lifetime with the <code class=\"hljs\">contents</code> argument and the return\nvalue. Recall in <a href=\"ch10-03-lifetime-syntax.html\">Chapter 10</a><!-- ignore --> that the lifetime\nparameters specify which argument lifetime is connected to the lifetime of the\nreturn value. In this case, we indicate that the returned vector should contain\nstring slices that reference slices of the argument <code class=\"hljs\">contents</code> (rather than the\nargument <code class=\"hljs\">query</code>).</p>\n<p>In other words, we tell Rust that the data returned by the <code class=\"hljs\">search</code> function\nwill live as long as the data passed into the <code class=\"hljs\">search</code> function in the\n<code class=\"hljs\">contents</code> argument. This is important! The data referenced <em>by</em> a slice needs\nto be valid for the reference to be valid; if the compiler assumes we’re making\nstring slices of <code class=\"hljs\">query</code> rather than <code class=\"hljs\">contents</code>, it will do its safety checking\nincorrectly.</p>\n<p>If we forget the lifetime annotations and try to compile this function, we’ll\nget this error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo build</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nerror[E0106]: missing lifetime specifier\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/lib.rs:28:51</span>\n   |\n28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {\n   |                      ----            ----         ^ expected named lifetime parameter\n   |\n   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`\nhelp: consider introducing a named lifetime parameter\n   |\n28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {\n   |              ++++         ++                 ++              ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `minigrep` (lib) due to 1 previous error\n</code></pre>\n<p>Rust can’t possibly know which of the two arguments we need, so we need to tell\nit explicitly. Because <code class=\"hljs\">contents</code> is the argument that contains all of our text\nand we want to return the parts of that text that match, we know <code class=\"hljs\">contents</code> is\nthe argument that should be connected to the return value using the lifetime\nsyntax.</p>\n<p>Other programming languages don’t require you to connect arguments to return\nvalues in the signature, but this practice will get easier over time. You might\nwant to compare this example with the <a href=\"ch10-03-lifetime-syntax.html#validating-references-with-lifetimes\">“Validating References with\nLifetimes”</a><!-- ignore --> section in\nChapter 10.</p>\n<p>Now let’s run the test:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... FAILED\n\nfailures:\n\n---- tests::one_result stdout ----\nthread 'tests::one_result' panicked at src/lib.rs:44:9:\nassertion `left == right` failed\n  left: [\"safe, fast, productive.\"]\n right: []\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::one_result\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>Great, the test fails, exactly as we expected. Let’s get the test to pass!</p>\n<h3 id=\"writing-code-to-pass-the-test\"><a class=\"header\" href=\"#writing-code-to-pass-the-test\">Writing Code to Pass the Test</a></h3>\n<p>Currently, our test is failing because we always return an empty vector. To fix\nthat and implement <code class=\"hljs\">search</code>, our program needs to follow these steps:</p>\n<ul>\n<li>Iterate through each line of the contents.</li>\n<li>Check whether the line contains our query string.</li>\n<li>If it does, add it to the list of values we’re returning.</li>\n<li>If it doesn’t, do nothing.</li>\n<li>Return the list of results that match.</li>\n</ul>\n<p>Let’s work through each step, starting with iterating through lines.</p>\n<h4 id=\"iterating-through-lines-with-the-lines-method\"><a class=\"header\" href=\"#iterating-through-lines-with-the-lines-method\">Iterating Through Lines with the <code>lines</code> Method</a></h4>\n<p>Rust has a helpful method to handle line-by-line iteration of strings,\nconveniently named <code class=\"hljs\">lines</code>, that works as shown in Listing 12-17. Note this\nwon’t compile yet.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">search</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(query: &amp;<span class=\"hljs-built_in\">str</span>, contents: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">Vec</span>&lt;&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>&gt; {\n    <span class=\"hljs-keyword\">for</span> line <span class=\"hljs-keyword\">in</span> contents.lines() {\n        <span class=\"hljs-comment\">// do something with line</span>\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">one_result</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = <span class=\"hljs-string\">\"duct\"</span>;\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> contents = <span class=\"hljs-string\">\"\\\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Rust:\n</span></span><span class=\"boring\"><span class=\"hljs-string\">safe, fast, productive.\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Pick three.\"</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"safe, fast, productive.\"</span>], search(query, contents));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-17: Iterating through each line in <code class=\"hljs\">contents</code>\n</span></p>\n<p>The <code class=\"hljs\">lines</code> method returns an iterator. We’ll talk about iterators in depth in\n<a href=\"ch13-02-iterators.html\">Chapter 13</a><!-- ignore -->, but recall that you saw this way\nof using an iterator in <a href=\"ch03-05-control-flow.html#looping-through-a-collection-with-for\">Listing 3-5</a><!-- ignore -->, where we used a\n<code class=\"hljs\">for</code> loop with an iterator to run some code on each item in a collection.</p>\n<h4 id=\"searching-each-line-for-the-query\"><a class=\"header\" href=\"#searching-each-line-for-the-query\">Searching Each Line for the Query</a></h4>\n<p>Next, we’ll check whether the current line contains our query string.\nFortunately, strings have a helpful method named <code class=\"hljs\">contains</code> that does this for\nus! Add a call to the <code class=\"hljs\">contains</code> method in the <code class=\"hljs\">search</code> function, as shown in\nListing 12-18. Note this still won’t compile yet.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">search</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(query: &amp;<span class=\"hljs-built_in\">str</span>, contents: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">Vec</span>&lt;&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>&gt; {\n    <span class=\"hljs-keyword\">for</span> line <span class=\"hljs-keyword\">in</span> contents.lines() {\n        <span class=\"hljs-keyword\">if</span> line.contains(query) {\n            <span class=\"hljs-comment\">// do something with line</span>\n        }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">one_result</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = <span class=\"hljs-string\">\"duct\"</span>;\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> contents = <span class=\"hljs-string\">\"\\\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Rust:\n</span></span><span class=\"boring\"><span class=\"hljs-string\">safe, fast, productive.\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Pick three.\"</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"safe, fast, productive.\"</span>], search(query, contents));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-18: Adding functionality to see whether the\nline contains the string in <code class=\"hljs\">query</code></span></p>\n<p>At the moment, we’re building up functionality. To get it to compile, we need\nto return a value from the body as we indicated we would in the function\nsignature.</p>\n<h4 id=\"storing-matching-lines\"><a class=\"header\" href=\"#storing-matching-lines\">Storing Matching Lines</a></h4>\n<p>To finish this function, we need a way to store the matching lines that we want\nto return. For that, we can make a mutable vector before the <code class=\"hljs\">for</code> loop and\ncall the <code class=\"hljs\">push</code> method to store a <code class=\"hljs\">line</code> in the vector. After the <code class=\"hljs\">for</code> loop,\nwe return the vector, as shown in Listing 12-19.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-literal\">Ok</span>(())\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">search</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(query: &amp;<span class=\"hljs-built_in\">str</span>, contents: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">Vec</span>&lt;&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> results = <span class=\"hljs-built_in\">Vec</span>::new();\n\n    <span class=\"hljs-keyword\">for</span> line <span class=\"hljs-keyword\">in</span> contents.lines() {\n        <span class=\"hljs-keyword\">if</span> line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">one_result</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = <span class=\"hljs-string\">\"duct\"</span>;\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> contents = <span class=\"hljs-string\">\"\\\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Rust:\n</span></span><span class=\"boring\"><span class=\"hljs-string\">safe, fast, productive.\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Pick three.\"</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"safe, fast, productive.\"</span>], search(query, contents));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 12-19: Storing the lines that match so we can\nreturn them</span></p>\n<p>Now the <code class=\"hljs\">search</code> function should return only the lines that contain <code class=\"hljs\">query</code>,\nand our test should pass. Let’s run the test:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p>Our test passed, so we know it works!</p>\n<p>At this point, we could consider opportunities for refactoring the\nimplementation of the search function while keeping the tests passing to\nmaintain the same functionality. The code in the search function isn’t too bad,\nbut it doesn’t take advantage of some useful features of iterators. We’ll\nreturn to this example in <a href=\"ch13-02-iterators.html\">Chapter 13</a><!-- ignore -->, where\nwe’ll explore iterators in detail, and look at how to improve it.</p>\n<h4 id=\"using-the-search-function-in-the-run-function\"><a class=\"header\" href=\"#using-the-search-function-in-the-run-function\">Using the <code>search</code> Function in the <code>run</code> Function</a></h4>\n<p>Now that the <code class=\"hljs\">search</code> function is working and tested, we need to call <code class=\"hljs\">search</code>\nfrom our <code class=\"hljs\">run</code> function. We need to pass the <code class=\"hljs\">config.query</code> value and the\n<code class=\"hljs\">contents</code> that <code class=\"hljs\">run</code> reads from the file to the <code class=\"hljs\">search</code> function. Then <code class=\"hljs\">run</code>\nwill print each line returned from <code class=\"hljs\">search</code>:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::error::Error;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::fs;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Config</span></span> {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> query: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> file_path: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Config {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build</span></span>(args: &amp;[<span class=\"hljs-built_in\">String</span>]) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;Config, &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> args.len() &lt; <span class=\"hljs-number\">3</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"not enough arguments\"</span>);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = args[<span class=\"hljs-number\">1</span>].clone();\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> file_path = args[<span class=\"hljs-number\">2</span>].clone();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-literal\">Ok</span>(Config { query, file_path })\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run</span></span>(config: Config) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Error&gt;&gt; {\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(config.file_path)?;\n\n    <span class=\"hljs-keyword\">for</span> line <span class=\"hljs-keyword\">in</span> search(&amp;config.query, &amp;contents) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{line}\"</span>);\n    }\n\n    <span class=\"hljs-literal\">Ok</span>(())\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">search</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(query: &amp;<span class=\"hljs-built_in\">str</span>, contents: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">Vec</span>&lt;&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> results = <span class=\"hljs-built_in\">Vec</span>::new();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">for</span> line <span class=\"hljs-keyword\">in</span> contents.lines() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">if</span> line.contains(query) {\n</span><span class=\"boring\">            results.push(line);\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    results\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">one_result</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> query = <span class=\"hljs-string\">\"duct\"</span>;\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> contents = <span class=\"hljs-string\">\"\\\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Rust:\n</span></span><span class=\"boring\"><span class=\"hljs-string\">safe, fast, productive.\n</span></span><span class=\"boring\"><span class=\"hljs-string\">Pick three.\"</span>;\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"safe, fast, productive.\"</span>], search(query, contents));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>We’re still using a <code class=\"hljs\">for</code> loop to return each line from <code class=\"hljs\">search</code> and print it.</p>\n<p>Now the entire program should work! Let’s try it out, first with a word that\nshould return exactly one line from the Emily Dickinson poem, “frog”:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run -- frog poem.txt</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/minigrep frog poem.txt`\nHow public, like a frog\n</code></pre>\n<p>Cool! Now let’s try a word that will match multiple lines, like “body”:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run -- body poem.txt</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep body poem.txt`\nI'm nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n</code></pre>\n<p>And finally, let’s make sure that we don’t get any lines when we search for a\nword that isn’t anywhere in the poem, such as “monomorphization”:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run -- monomorphization poem.txt</span>\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep monomorphization poem.txt`\n</code></pre>\n<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot\nabout how to structure applications. We’ve also learned a bit about file input\nand output, lifetimes, testing, and command line parsing.</p>\n<p>To round out this project, we’ll briefly demonstrate how to work with\nenvironment variables and how to print to standard error, both of which are\nuseful when you’re writing command line programs.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch12-03-improving-error-handling-and-modularity.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch12-05-working-with-environment-variables.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch12-03-improving-error-handling-and-modularity.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch12-05-working-with-environment-variables.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:25.385Z"
}