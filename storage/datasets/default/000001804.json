{
	"title": "The Rust Edition Guide",
	"url": "https://doc.rust-lang.org/stable/edition-guide/print.html",
	"markdown": "# The Rust Edition Guide\n\n## [Introduction](#introduction)\n\nWelcome to The Rust Edition Guide! \"Editions\" are Rust's way of introducing changes into the language that would not otherwise be backwards compatible.\n\nIn this guide, we'll discuss:\n\n-   What editions are\n-   Which changes are contained in each edition\n-   How to migrate your code from one edition to another\n\n## [What are Editions?](#what-are-editions)\n\nIn May 2015, the [release of Rust 1.0](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html) established \"[stability without stagnation](https://blog.rust-lang.org/2014/10/30/Stability.html)\" as a core Rust axiom. Since then, Rust has committed to a pivotal rule: once a feature is [released through stable](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html), contributors will continue to support that feature for all future releases.\n\nHowever, there are times when it's useful to make backwards-incompatible changes to the language. A common example is the introduction of a new keyword. For instance, early versions of Rust didn't feature the `async` and `await` keywords.\n\nIf Rust had suddenly introduced these new keywords, some code would have broken: `let async = 1;` would no longer work.\n\nRust uses **editions** to solve this problem. When there are backwards-incompatible changes, they are pushed into the next edition. Since editions are opt-in, existing crates won't use the changes unless they explicitly migrate into the new edition. For example, the latest version of Rust doesn't treat `async` as a keyword unless edition 2018 or later is chosen.\n\nEach crate chooses its edition [within its `Cargo.toml` file](https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field). When creating a new crate with Cargo, it will automatically select the newest stable edition.\n\n## [Editions do not split the ecosystem](#editions-do-not-split-the-ecosystem)\n\nWhen creating editions, there is one most consequential rule: crates in one edition **must** seamlessly interoperate with those compiled with other editions.\n\nIn other words, each crate can decide when to migrate to a new edition independently. This decision is 'private' - it won't affect other crates in the ecosystem.\n\nFor Rust, this required compatibility implies some limits on the kinds of changes that can be featured in an edition. As a result, changes found in new Rust editions tend to be 'skin deep'. All Rust code - regardless of edition - will ultimately compile down to the same internal representation within the compiler.\n\n## [Edition migration is easy and largely automated](#edition-migration-is-easy-and-largely-automated)\n\nRust aims to make upgrading to a new edition an easy process. When a new edition releases, crate authors may use [automatic migration tooling within `cargo`](https://doc.rust-lang.org/cargo/commands/cargo-fix.html) to migrate. Cargo will then make minor changes to the code to make it compatible with the new version.\n\nFor example, when migrating to Rust 2018, anything named `async` will now use the equivalent [raw identifier syntax](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html): `r#async`.\n\nCargo's automatic migrations aren't perfect: there may still be corner cases where manual changes are required. It aims to avoid changes to semantics that could affect the correctness or performance of the code.\n\n## [What this guide covers](#what-this-guide-covers)\n\nIn addition to tooling, this Rust Edition Guide also covers the changes that are part of each edition. It describes each change and links to additional details, if available. It also covers corner cases or tricky details crate authors should be aware of.\n\nCrate authors should find:\n\n-   An overview of editions\n-   A migration guide for specific editions\n-   A quick troubleshooting reference when automated tooling isn't working.\n\n## [Creating a new project](#creating-a-new-project)\n\nA new project created with Cargo is configured to use the latest edition by default:\n\n```console\n$ cargo new foo\n     Created binary (application) `foo` project\n$ cat foo/Cargo.toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n\n```\n\nThat `edition = \"2021\"` setting configures your package to be built using the Rust 2021 edition. No further configuration needed!\n\nYou can use the `--edition <YEAR>` option of `cargo new` to create the project using some specific edition. For example, creating a new project to use the Rust 2018 edition could be done like this:\n\n```console\n$ cargo new --edition 2018 foo\n     Created binary (application) `foo` project\n$ cat foo/Cargo.toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\n\n```\n\nDon't worry about accidentally using an invalid year for the edition; the `cargo new` invocation will not accept an invalid edition year value:\n\n```console\n$ cargo new --edition 2019 foo\nerror: \"2019\" isn't a valid value for '--edition <YEAR>'\n        [possible values: 2015, 2018, 2021]\n\n        Did you mean \"2018\"?\n\nFor more information try --help\n\n```\n\nYou can change the value of the `edition` key by simply editing the `Cargo.toml` file. For example, to cause your package to be built using the Rust 2015 edition, you would set the key as in the following example:\n\n```toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2015\"\n\n[dependencies]\n\n```\n\n## [Transitioning an existing project to a new edition](#transitioning-an-existing-project-to-a-new-edition)\n\nRust includes tooling to automatically transition a project from one edition to the next. It will update your source code so that it is compatible with the next edition. Briefly, the steps to update to the next edition are:\n\n1.  Run `cargo fix --edition`\n2.  Edit `Cargo.toml` and set the `edition` field to the next edition, for example `edition = \"2021\"`\n3.  Run `cargo build` or `cargo test` to verify the fixes worked.\n\nThe following sections dig into the details of these steps, and some of the issues you may encounter along the way.\n\n> It's our intention that the migration to new editions is as smooth an experience as possible. If it's difficult for you to upgrade to the latest edition, we consider that a bug. If you run into problems with this process, please [file a bug report](https://github.com/rust-lang/rust/issues/new/choose). Thank you!\n\n## [Starting the migration](#starting-the-migration)\n\nAs an example, let's take a look at transitioning from the 2015 edition to the 2018 edition. The steps are essentially the same when transitioning to other editions like 2021.\n\nImagine we have a crate that has this code in `src/lib.rs`:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Foo {\n    fn foo(&self, i32);\n}\n}\n```\n\nThis code uses an anonymous parameter, that `i32`. This is [not supported in Rust 2018](editions/../rust-2018/trait-system/no-anon-params.html), and so this would fail to compile. Let's get this code up to date!\n\n## [Updating your code to be compatible with the new edition](#updating-your-code-to-be-compatible-with-the-new-edition)\n\nYour code may or may not use features that are incompatible with the new edition. In order to help transition to the next edition, Cargo includes the [`cargo fix`](editions/../../cargo/commands/cargo-fix.html) subcommand to automatically update your source code. To start, let's run it:\n\n```console\ncargo fix --edition\n\n```\n\nThis will check your code, and automatically fix any issues that it can. Let's look at `src/lib.rs` again:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Foo {\n    fn foo(&self, _: i32);\n}\n}\n```\n\nIt's re-written our code to introduce a parameter name for that `i32` value. In this case, since it had no name, `cargo fix` will replace it with `_`, which is conventional for unused variables.\n\n`cargo fix` can't always fix your code automatically. If `cargo fix` can't fix something, it will print the warning that it cannot fix to the console. If you see one of these warnings, you'll have to update your code manually. See the [Advanced migration strategies](editions/advanced-migrations.html) chapter for more on working with the migration process, and read the chapters in this guide which explain which changes are needed. If you have problems, please seek help at the [user's forums](https://users.rust-lang.org/).\n\n## [Enabling the new edition to use new features](#enabling-the-new-edition-to-use-new-features)\n\nIn order to use some new features, you must explicitly opt in to the new edition. Once you're ready to continue, change your `Cargo.toml` to add the new `edition` key/value pair. For example:\n\n```toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n```\n\nIf there's no `edition` key, Cargo will default to Rust 2015. But in this case, we've chosen `2018`, and so our code will compile with Rust 2018!\n\nThe next step is to test your project on the new edition. Run your project tests to verify that everything still works, such as running [`cargo test`](editions/../../cargo/commands/cargo-test.html). If new warnings are issued, you may want to consider running `cargo fix` again (without the `--edition` flag) to apply any suggestions given by the compiler.\n\nCongrats! Your code is now valid in both Rust 2015 and Rust 2018!\n\n## [Migrating to an unstable edition](#migrating-to-an-unstable-edition)\n\nAfter an edition is released, there is roughly a three year window before the next edition. During that window, new features may be added to the next edition, which will only be available on the [nightly channel](editions/../../book/appendix-07-nightly-rust.html). If you want to help test those new features before they are stabilized, you can use the nightly channel to try them out.\n\nThe steps are roughly similar to the stable channel:\n\n1.  Install the most recent nightly: `rustup update nightly`.\n2.  Run `cargo +nightly fix --edition`.\n3.  Edit `Cargo.toml` and place `cargo-features = [\"edition2024\"]` at the top (above `[package]`), and change the edition field to say `edition = \"2024\"`.\n4.  Run `cargo +nightly check` to verify it now works in the new edition.\n\n> **⚠ Caution**: Features implemented in the next edition may not have automatic migrations implemented with `cargo fix`, and the features themselves may not be finished. When possible, this guide should contain information about which features are implemented on nightly along with more information about their status. A few months before the edition is stabilized, all of the new features should be fully implemented, and the [Rust Blog](https://blog.rust-lang.org/) will announce a call for testing.\n\n## [Advanced migration strategies](#advanced-migration-strategies)\n\n## [How migrations work](#how-migrations-work)\n\n[`cargo fix --edition`](editions/../../cargo/commands/cargo-fix.html) works by running the equivalent of [`cargo check`](editions/../../cargo/commands/cargo-check.html) on your project with special [lints](editions/../../rustc/lints/index.html) enabled which will detect code that may not compile in the next edition. These lints include instructions on how to modify the code to make it compatible on both the current and the next edition. `cargo fix` applies these changes to the source code, and then runs `cargo check` again to verify that the fixes work. If the fixes fail, then it will back out the changes and display a warning.\n\nChanging the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code. If the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing `Cargo.toml` to use the next edition.\n\nThe lints that `cargo fix --edition` apply are part of a [lint group](editions/../../rustc/lints/groups.html). For example, when migrating from 2018 to 2021, Cargo uses the `rust-2021-compatibility` group of lints to fix the code. Check the [Partial migration](about:blank/editions/advanced-migrations.html#partial-migration-with-broken-code) section below for tips on using individual lints to help with migration.\n\n`cargo fix` may run `cargo check` multiple times. For example, after applying one set of fixes, this may trigger new warnings which require further fixes. Cargo repeats this until no new warnings are generated.\n\n## [Migrating multiple configurations](#migrating-multiple-configurations)\n\n`cargo fix` can only work with a single configuration at a time. If you use [Cargo features](editions/../../cargo/reference/features.html) or [conditional compilation](editions/../../reference/conditional-compilation.html), then you may need to run `cargo fix` multiple times with different flags.\n\nFor example, if you have code that uses `#[cfg]` attributes to include different code for different platforms, you may need to run `cargo fix` with the `--target` option to fix for different targets. This may require moving your code between machines if you don't have cross-compiling available.\n\nSimilarly, if you have conditions on Cargo features, like `#[cfg(feature = \"my-optional-thing\")]`, it is recommended to use the `--all-features` flag to allow `cargo fix` to migrate all the code behind those feature gates. If you want to migrate feature code individually, you can use the `--features` flag to migrate one at a time.\n\n## [Migrating a large project or workspace](#migrating-a-large-project-or-workspace)\n\nYou can migrate a large project incrementally to make the process easier if you run into problems.\n\nIn a [Cargo workspace](editions/../../cargo/reference/workspaces.html), each package defines its own edition, so the process naturally involves migrating one package at a time.\n\nWithin a [Cargo package](about:blank/cargo/reference/manifest.html#the-package-section), you can either migrate the entire package at once, or migrate individual [Cargo targets](editions/../../cargo/reference/cargo-targets.html) one at a time. For example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with `cargo fix --edition` to migrate just that one target. By default, `cargo fix` uses `--all-targets`.\n\nFor even more advanced cases, you can specify the edition for each individual target in `Cargo.toml` like this:\n\n```toml\n[[bin]]\nname = \"my-binary\"\nedition = \"2018\"\n\n```\n\nThis usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.\n\n## [Partial migration with broken code](#partial-migration-with-broken-code)\n\nSometimes the fixes suggested by the compiler may fail to work. When this happens, Cargo will report a warning indicating what happened and what the error was. However, by default it will automatically back out the changes it made. It can be helpful to keep the code in the broken state and manually resolve the issue. Some of the fixes may have been correct, and the broken fix may be _mostly_ correct, but just need minor tweaking.\n\nIn this situation, use the `--broken-code` option with `cargo fix` to tell Cargo not to back out the changes. Then, you can go manually inspect the error and investigate what is needed to fix it.\n\nAnother option to incrementally migrate a project is to apply individual fixes separately, one at a time. You can do this by adding the individual lints as warnings, and then either running `cargo fix` (without the `--edition` flag) or using your editor or IDE to apply its suggestions if it supports \"Quick Fixes\".\n\nFor example, the 2018 edition uses the [`keyword-idents`](about:blank/rustc/lints/listing/allowed-by-default.html#keyword-idents) lint to fix any conflicting keywords. You can add `#![warn(keyword_idents)]` to the top of each crate (like at the top of `src/lib.rs` or `src/main.rs`). Then, running `cargo fix` will apply just the suggestions for that lint.\n\nYou can see the list of lints enabled for each edition in the [lint group](editions/../../rustc/lints/groups.html) page, or run the `rustc -Whelp` command.\n\n## [Migrating macros](#migrating-macros)\n\nSome macros may require manual work to fix them for the next edition. For example, `cargo fix --edition` may not be able to automatically fix a macro that generates syntax that does not work in the next edition.\n\nThis may be a problem for both [proc macros](editions/../../reference/procedural-macros.html) and `macro_rules`\\-style macros. `macro_rules` macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot. Proc macros in general cannot be automatically fixed at all.\n\nFor example, if we migrate a crate containing this (contrived) macro `foo` from 2015 to 2018, `foo` would not be automatically fixed.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[macro_export]\nmacro_rules! foo {\n    () => {\n        let dyn = 1;\n        println!(\"it is {}\", dyn);\n    };\n}\n}\n```\n\nWhen this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below). In 2015, `dyn` is a normal identifier and can be used without restriction.\n\nHowever, in 2018, `dyn` is no longer a valid identifier. When using `cargo fix --edition` to migrate to 2018, Cargo won't display any warnings or errors at all. However, `foo` won't work when called from any crate.\n\nIf you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax. You may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere. If you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.\n\n### [Macro hygiene](#macro-hygiene)\n\nMacros use a system called \"edition hygiene\" where the tokens within a macro are marked with which edition they come from. This allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.\n\nLet's take a closer look at the example above that defines a `macro_rules` macro using `dyn` as an identifier. If that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where `dyn` is a keyword and that would normally be a syntax error. The `let dyn = 1;` tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded. The parser looks at the edition of the tokens to know how to interpret it.\n\nThe problem arises when changing the edition to 2018 in the crate where it is defined. Now, those tokens are tagged with the 2018 edition, and those will fail to parse. However, since we never called the macro from our crate, `cargo fix --edition` never had a chance to inspect the macro and fix it.\n\n## [Documentation tests](#documentation-tests)\n\nAt this time, `cargo fix` is not able to update [documentation tests](editions/../../rustdoc/documentation-tests.html). After updating the edition in `Cargo.toml`, you should run `cargo test` to ensure everything still passes. If your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.\n\nIn rare cases, you can manually set the edition for each test. For example, you can use the [`edition2018` annotation](about:blank/rustdoc/documentation-tests.html#attributes) on the triple backticks to tell `rustdoc` which edition to use.\n\n## [Generated code](#generated-code)\n\nAnother area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see [Code generation](about:blank/cargo/reference/build-script-examples.html#code-generation) for an example). In this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.\n\n## [Migrating non-Cargo projects](#migrating-non-cargo-projects)\n\nIf your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition. You can enable the migration lints as described above by enabling the appropriate [lint group](editions/../../rustc/lints/groups.html). For example, you can use the `#![warn(rust_2021_compatibility)]` attribute or the `-Wrust-2021-compatibility` or `--force-warns=rust-2021-compatibility` [CLI flag](about:blank/rustc/lints/levels.html#via-compiler-flag).\n\nThe next step is to apply those lints to your code. There are several options here:\n\n-   Manually read the warnings and apply the suggestions recommended by the compiler.\n-   Use an editor or IDE that supports automatically applying suggestions. For example, [Visual Studio Code](https://code.visualstudio.com/) with the [Rust Analyzer extension](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer) has the ability to use the \"Quick Fix\" links to automatically apply suggestions. Many other editors and IDEs have similar functionality.\n-   Write a migration tool using the [`rustfix`](https://crates.io/crates/rustfix) library. This is the library that Cargo uses internally to take the [JSON messages](editions/../../rustc/json.html) from the compiler and modify the source code. Check the [`examples` directory](https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples) for examples of how to use the library.\n\n## [Writing idiomatic code in a new edition](#writing-idiomatic-code-in-a-new-edition)\n\nEditions are not only about new features and removing old ones. In any programming language, idioms change over time, and Rust is no exception. While old code will continue to compile, it might be written with different idioms today.\n\nFor example, in Rust 2015, external crates must be listed with `extern crate` like this:\n\n```rust\n// src/lib.rs\nextern crate rand;\n```\n\nIn Rust 2018, it is [no longer necessary](about:blank/rust-2018/path-changes.html#no-more-extern-crate) to include these items.\n\n`cargo fix` has the `--edition-idioms` option to automatically transition some of these idioms to the new syntax.\n\n> **Warning**: The current _\"idiom lints\"_ are known to have some problems. They may make incorrect suggestions which may fail to compile. The current lints are:\n> \n> -   Edition 2018:\n>     -   [`unused-extern-crates`](about:blank/rustc/lints/listing/allowed-by-default.html#unused-extern-crates)\n>     -   [`explicit-outlives-requirements`](about:blank/rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements)\n> -   Edition 2021 does not have any idiom lints.\n> \n> The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs! If you run into problems, you can try the `--broken-code` option [described above](about:blank/editions/advanced-migrations.html#partial-migration-with-broken-code) to make as much progress as possible, and then resolve the remaining issues manually.\n\nWith that out of the way, we can instruct Cargo to fix our code snippet with:\n\n```console\ncargo fix --edition-idioms\n\n```\n\nAfterwards, the line with `extern crate rand;` in `src/lib.rs` will be removed.\n\nWe're now more idiomatic, and we didn't have to fix our code manually!\n\n## [Rust 2015](#rust-2015)\n\nRust 2015 has a theme of \"stability\". It commenced with the release of 1.0, and is the \"default edition\". The edition system was conceived in late 2017, but Rust 1.0 was released in May of 2015. As such, 2015 is the edition that you get when you don't specify any particular edition, for backwards compatibility reasons.\n\n\"Stability\" is the theme of Rust 2015 because 1.0 marked a huge change in Rust development. Previous to Rust 1.0, Rust was changing on a daily basis. This made it very difficult to write large software in Rust, and made it difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed to backwards compatibility, ensuring a solid foundation for people to build projects on top of.\n\nSince it's the default edition, there's no way to port your code to Rust 2015; it just _is_. You'll be transitioning _away_ from 2015, but never really _to_ 2015. As such, there's not much else to say about it!\n\n## [Rust 2018](#rust-2018)\n\n| Info |  |\n| --- | --- |\n| RFC | [#2052](https://rust-lang.github.io/rfcs/2052-epochs.html), which also proposed the Edition system |\n| Release version | [1.31.0](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html) |\n\nThe edition system was created for the release of Rust 2018. The release of the Rust 2018 edition coincided with a number of other features all coordinated around the theme of _productivity_. The majority of those features were backwards compatible and are now available on all editions; however, some of those changes required the edition mechanism (most notably the [module system changes](rust-2018/path-changes.html)).\n\n## [Path and module system changes](#path-and-module-system-changes)\n\n![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)\n\n## [Summary](#summary)\n\n-   Paths in `use` declarations now work the same as other paths.\n-   Paths starting with `::` must now be followed with an external crate.\n-   Paths in `pub(in path)` visibility modifiers must now start with `crate`, `self`, or `super`.\n\n## [Motivation](#motivation)\n\nThe module system is often one of the hardest things for people new to Rust. Everyone has their own things that take time to master, of course, but there's a root cause for why it's so confusing to many: while there are simple and consistent rules defining the module system, their consequences can feel inconsistent, counterintuitive and mysterious.\n\nAs such, the 2018 edition of Rust introduces a few new module system features, but they end up _simplifying_ the module system, to make it more clear as to what is going on.\n\nHere's a brief summary:\n\n-   `extern crate` is no longer needed in 99% of circumstances.\n-   The `crate` keyword refers to the current crate.\n-   Paths may start with a crate name, even within submodules.\n-   Paths starting with `::` must reference an external crate.\n-   A `foo.rs` and `foo/` subdirectory may coexist; `mod.rs` is no longer needed when placing submodules in a subdirectory.\n-   Paths in `use` declarations work the same as other paths.\n\nThese may seem like arbitrary new rules when put this way, but the mental model is now significantly simplified overall. Read on for more details!\n\n## [More details](#more-details)\n\nLet's talk about each new feature in turn.\n\n### [No more `extern crate`](#no-more-extern-crate)\n\nThis one is quite straightforward: you no longer need to write `extern crate` to import a crate into your project. Before:\n\n```rust\n// Rust 2015\n\nextern crate futures;\n\nmod submodule {\n    use futures::Future;\n}\n```\n\nAfter:\n\n```rust\n// Rust 2018\n\nmod submodule {\n    use futures::Future;\n}\n```\n\nNow, to add a new crate to your project, you can add it to your `Cargo.toml`, and then there is no step two. If you're not using Cargo, you already had to pass `--extern` flags to give `rustc` the location of external crates, so you'd just keep doing what you were doing there as well.\n\n> One small note here: `cargo fix` will not currently automate this change. We may have it do this for you in the future.\n\n#### [An exception](#an-exception)\n\nThere's one exception to this rule, and that's the \"sysroot\" crates. These are the crates distributed with Rust itself.\n\nUsually these are only needed in very specialized situations. Starting in 1.41, `rustc` accepts the `--extern=CRATE_NAME` flag which automatically adds the given crate name in a way similar to `extern crate`. Build tools may use this to inject sysroot crates into the crate's prelude. Cargo does not have a general way to express this, though it uses it for `proc_macro` crates.\n\nSome examples of needing to explicitly import sysroot crates are:\n\n-   [`std`](rust-2018/../../std/index.html): Usually this is not necessary, because `std` is automatically imported unless the crate is marked with [`#![no_std]`](about:blank/reference/names/preludes.html#the-no_std-attribute).\n-   [`core`](rust-2018/../../core/index.html): Usually this is not necessary, because `core` is automatically imported, unless the crate is marked with [`#![no_core]`](https://github.com/rust-lang/rust/issues/29639). For example, some of the internal crates used by the standard library itself need this.\n-   [`proc_macro`](rust-2018/../../proc_macro/index.html): This is automatically imported by Cargo if it is a proc-macro crate starting in 1.42. `extern crate proc_macro;` would be needed if you want to support older releases, or if using another build tool that does not pass the appropriate `--extern` flags to `rustc`.\n-   [`alloc`](rust-2018/../../alloc/index.html): Items in the `alloc` crate are usually accessed via re-exports in the `std` crate. If you are working with a `no_std` crate that supports allocation, then you may need to explicitly import `alloc`.\n-   [`test`](rust-2018/../../test/index.html): This is only available on the [nightly channel](rust-2018/../../book/appendix-07-nightly-rust.html), and is usually only used for the unstable benchmark support.\n\n#### [Macros](#macros)\n\nOne other use for `extern crate` was to import macros; that's no longer needed. Macros may be imported with `use` like any other item. For example, the following use of `extern crate`:\n\n```rust\n#[macro_use]\nextern crate bar;\n\nfn main() {\n    baz!();\n}\n```\n\nCan be changed to something like the following:\n\n```rust\nuse bar::baz;\n\nfn main() {\n    baz!();\n}\n```\n\n#### [Renaming crates](#renaming-crates)\n\nIf you've been using `as` to rename your crate like this:\n\n```rust\nextern crate futures as f;\n\nuse f::Future;\n```\n\nthen removing the `extern crate` line on its own won't work. You'll need to do this:\n\n```rust\nuse futures as f;\n\nuse self::f::Future;\n```\n\nThis change will need to happen in any module that uses `f`.\n\n### [The `crate` keyword refers to the current crate](#the-crate-keyword-refers-to-the-current-crate)\n\nIn `use` declarations and in other code, you can refer to the root of the current crate with the `crate::` prefix. For instance, `crate::foo::bar` will always refer to the name `bar` inside the module `foo`, from anywhere else in the same crate.\n\nThe prefix `::` previously referred to either the crate root or an external crate; it now unambiguously refers to an external crate. For instance, `::foo::bar` always refers to the name `bar` inside the external crate `foo`.\n\n### [Extern crate paths](#extern-crate-paths)\n\nPreviously, using an external crate in a module without a `use` import required a leading `::` on the path.\n\n```rust\n// Rust 2015\n\nextern crate chrono;\n\nfn foo() {\n    // this works in the crate root\n    let x = chrono::Utc::now();\n}\n\nmod submodule {\n    fn function() {\n        // but in a submodule it requires a leading :: if not imported with `use`\n        let x = ::chrono::Utc::now();\n    }\n}\n```\n\nNow, extern crate names are in scope in the entire crate, including submodules.\n\n```rust\n// Rust 2018\n\nfn foo() {\n    // this works in the crate root\n    let x = chrono::Utc::now();\n}\n\nmod submodule {\n    fn function() {\n        // crates may be referenced directly, even in submodules\n        let x = chrono::Utc::now();\n    }\n}\n```\n\nIf you have a local module or item with the same name as an external crate, a path begining with that name will be taken to refer to the local module or item. To explicitly refer to the external crate, use the `::name` form.\n\n### [No more `mod.rs`](#no-more-modrs)\n\nIn Rust 2015, if you have a submodule:\n\n```rust\n// This `mod` declaration looks for the `foo` module in\n// `foo.rs` or `foo/mod.rs`.\nmod foo;\n```\n\nIt can live in `foo.rs` or `foo/mod.rs`. If it has submodules of its own, it _must_ be `foo/mod.rs`. So a `bar` submodule of `foo` would live at `foo/bar.rs`.\n\nIn Rust 2018 the restriction that a module with submodules must be named `mod.rs` is lifted. `foo.rs` can just be `foo.rs`, and the submodule is still `foo/bar.rs`. This eliminates the special name, and if you have a bunch of files open in your editor, you can clearly see their names, instead of having a bunch of tabs named `mod.rs`.\n\n| Rust 2015 | Rust 2018 |\n| --- | --- |\n| \n```\n.\n├── lib.rs\n└── foo/\n    ├── mod.rs\n    └── bar.rs\n```\n\n | \n```\n.\n├── lib.rs\n├── foo.rs\n└── foo/\n    └── bar.rs\n\n```\n\n |\n\n### [`use` paths](#use-paths)\n\n![Minimum Rust version: 1.32](https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg)\n\nRust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust 2015, paths work differently in `use` declarations than they do elsewhere. In particular, paths in `use` declarations would always start from the crate root, while paths in other code implicitly started from the current scope. Those differences didn't have any effect in the top-level module, which meant that everything would seem straightforward until working on a project large enough to have submodules.\n\nIn Rust 2018, paths in `use` declarations and in other code work the same way, both in the top-level module and in any submodule. You can use a relative path from the current scope, a path starting from an external crate name, or a path starting with `::`, `crate`, `super`, or `self`.\n\nCode that looked like this:\n\n```rust\n// Rust 2015\n\nextern crate futures;\n\nuse futures::Future;\n\nmod foo {\n    pub struct Bar;\n}\n\nuse foo::Bar;\n\nfn my_poll() -> futures::Poll { ... }\n\nenum SomeEnum {\n    V1(usize),\n    V2(String),\n}\n\nfn func() {\n    let five = std::sync::Arc::new(5);\n    use SomeEnum::*;\n    match ... {\n        V1(i) => { ... }\n        V2(s) => { ... }\n    }\n}\n```\n\nwill look exactly the same in Rust 2018, except that you can delete the `extern crate` line:\n\n```rust\n// Rust 2018\n\nuse futures::Future;\n\nmod foo {\n    pub struct Bar;\n}\n\nuse foo::Bar;\n\nfn my_poll() -> futures::Poll { ... }\n\nenum SomeEnum {\n    V1(usize),\n    V2(String),\n}\n\nfn func() {\n    let five = std::sync::Arc::new(5);\n    use SomeEnum::*;\n    match ... {\n        V1(i) => { ... }\n        V2(s) => { ... }\n    }\n}\n```\n\nThe same code will also work completely unmodified in a submodule:\n\n```rust\n// Rust 2018\n\nmod submodule {\n    use futures::Future;\n\n    mod foo {\n        pub struct Bar;\n    }\n\n    use foo::Bar;\n\n    fn my_poll() -> futures::Poll { ... }\n\n    enum SomeEnum {\n        V1(usize),\n        V2(String),\n    }\n\n    fn func() {\n        let five = std::sync::Arc::new(5);\n        use SomeEnum::*;\n        match ... {\n            V1(i) => { ... }\n            V2(s) => { ... }\n        }\n    }\n}\n```\n\nThis makes it easy to move code around in a project, and avoids introducing additional complexity to multi-module projects.\n\n## [Anonymous trait function parameters deprecated](#anonymous-trait-function-parameters-deprecated)\n\n![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)\n\n## [Summary](#summary-1)\n\n-   [Trait function parameters](https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns) may use any irrefutable pattern when the function has a body.\n\n## [Details](#details)\n\nIn accordance with RFC [#1685](https://github.com/rust-lang/rfcs/pull/1685), parameters in trait method declarations are no longer allowed to be anonymous.\n\nFor example, in the 2015 edition, this was allowed:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Foo {\n    fn foo(&self, u8);\n}\n}\n```\n\nIn the 2018 edition, all parameters must be given an argument name (even if it's just `_`):\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Foo {\n    fn foo(&self, baz: u8);\n}\n}\n```\n\n## [New keywords](#new-keywords)\n\n![Minimum Rust version: 1.27](https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg)\n\n## [Summary](#summary-2)\n\n-   `dyn` is a [strict keyword](https://doc.rust-lang.org/reference/keywords.html#strict-keywords), in 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html#weak-keywords).\n-   `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html#strict-keywords).\n-   `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html#reserved-keywords).\n\n## [Motivation](#motivation-1)\n\n### [`dyn Trait` for trait objects](#dyn-trait-for-trait-objects)\n\nThe `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n-   `Box<Trait>` becomes `Box<dyn Trait>`\n-   `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`\n\nAnd so on. In code:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Trait {}\n\nimpl Trait for i32 {}\n\n// old\nfn function1() -> Box<Trait> {\nunimplemented!()\n}\n\n// new\nfn function2() -> Box<dyn Trait> {\nunimplemented!()\n}\n}\n```\n\nThat's it!\n\n#### [Why?](#why)\n\nUsing just the trait name for trait objects turned out to be a bad decision. The current syntax is often ambiguous and confusing, even to veterans, and favors a feature that is not more frequently used than its alternatives, is sometimes slower, and often cannot be used at all when its alternatives can.\n\nFurthermore, with `impl Trait` arriving, \"`impl Trait` vs `dyn Trait`\" is much more symmetric, and therefore a bit nicer, than \"`impl Trait` vs `Trait`\". `impl Trait` is explained [here](rust-2018/../../rust-by-example/trait/impl_trait.html).\n\nIn the new edition, you should therefore prefer `dyn Trait` to just `Trait` where you need a trait object.\n\n### [`async` and `await`](#async-and-await)\n\nThese keywords are reserved to implement the async-await feature of Rust, which was ultimately [released to stable in 1.39.0](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html).\n\n### [`try` keyword](#try-keyword)\n\nThe `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))\n\n## [Method dispatch for raw pointers to inference variables](#method-dispatch-for-raw-pointers-to-inference-variables)\n\n## [Summary](#summary-3)\n\n-   The [`tyvar_behind_raw_pointer`](https://github.com/rust-lang/rust/issues/46906) lint is now a hard error.\n\n## [Details](#details-1)\n\nSee Rust issue [#46906](https://github.com/rust-lang/rust/issues/46906) for details.\n\n## [Cargo changes](#cargo-changes)\n\n## [Summary](#summary-4)\n\n-   If there is a target definition in a `Cargo.toml` manifest, it no longer automatically disables automatic discovery of other targets.\n-   Target paths of the form `src/{target_name}.rs` are no longer inferred for targets where the `path` field is not set.\n-   `cargo install` for the current directory is no longer allowed, you must specify `cargo install --path .` to install the current package.\n\n## [Rust 2021](#rust-2021)\n\n| Info |  |\n| --- | --- |\n| RFC | [#3085](https://github.com/rust-lang/rfcs/pull/3085) |\n| Release version | 1.56.0 |\n\nThe Rust 2021 Edition contains several changes that bring new capabilities and more consistency to the language, and opens up room for expansion in the future. The following chapters dive into the details of each change, and they include guidance on migrating your existing code.\n\n## [Additions to the prelude](#additions-to-the-prelude)\n\n## [Summary](#summary-5)\n\n-   The `TryInto`, `TryFrom` and `FromIterator` traits are now part of the prelude.\n-   This might make calls to trait methods ambiguous which could make some code fail to compile.\n\n## [Details](#details-2)\n\nThe [prelude of the standard library](https://doc.rust-lang.org/stable/std/prelude/index.html) is the module containing everything that is automatically imported in every module. It contains commonly used items such as `Option`, `Vec`, `drop`, and `Clone`.\n\nThe Rust compiler prioritizes any manually imported items over those from the prelude, to make sure additions to the prelude will not break any existing code. For example, if you have a crate or module called `example` containing a `pub struct Option;`, then `use example::*;` will make `Option` unambiguously refer to the one from `example`; not the one from the standard library.\n\nHowever, adding a _trait_ to the prelude can break existing code in a subtle way. For example, a call to `x.try_into()` which comes from a `MyTryInto` trait might fail to compile if `std`'s `TryInto` is also imported, because the call to `try_into` is now ambiguous and could come from either trait. This is the reason we haven't added `TryInto` to the prelude yet, since there is a lot of code that would break this way.\n\nAs a solution, Rust 2021 will use a new prelude. It's identical to the current one, except for three new additions:\n\n-   [`std::convert::TryInto`](https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html)\n-   [`std::convert::TryFrom`](https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html)\n-   [`std::iter::FromIterator`](https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html)\n\nThe tracking issue [can be found here](https://github.com/rust-lang/rust/issues/85684).\n\n## [Migration](#migration)\n\nAs a part of the 2021 edition a migration lint, `rust_2021_prelude_collisions`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.\n\nIn order to migrate your code to be Rust 2021 Edition compatible, run:\n\n```sh\ncargo fix --edition\n\n```\n\nThe lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.\n\nIf you'd like to migrate your code manually or better understand what `cargo fix` is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.\n\n### [Migration needed](#migration-needed)\n\n#### [Conflicting trait methods](#conflicting-trait-methods)\n\nWhen two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:\n\n```rust\ntrait MyTrait<A> {\n  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  \n  fn from_iter(x: Option<A>);\n}\n\nimpl<T> MyTrait<()> for Vec<T> {\n  fn from_iter(_: Option<()>) {}\n}\n\nfn main() {\n  // Vec<T> implements both `std::iter::FromIterator` and `MyTrait` \n  // If both traits are in scope (as would be the case in Rust 2021),\n  // then it becomes ambiguous which `from_iter` method to call\n  <Vec<i32>>::from_iter(None);\n}\n```\n\nWe can fix this by using fully qualified syntax:\n\n```rust\nfn main() {\n  // Now it is clear which trait method we're referring to\n  <Vec<i32> as MyTrait<()>>::from_iter(None);\n}\n```\n\n#### [Inherent methods on `dyn Trait` objects](#inherent-methods-on-dyn-trait-objects)\n\nSome users invoke methods on a `dyn Trait` value where the method name overlaps with a new prelude trait:\n\n```rust\n#![allow(unused)]\nfn main() {\nmod submodule {\n  pub trait MyTrait {\n    // This has the same name as `TryInto::try_into`\n    fn try_into(&self) -> Result<u32, ()>;\n  }\n}\n\n// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`\nfn bar(f: Box<dyn submodule::MyTrait>) {\n  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),\n  // then it becomes ambiguous which `try_into` method to call\n  f.try_into();\n}\n}\n```\n\nUnlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works as long as there is no trait in scope with a conflicting method name. When the `TryInto` trait is in scope (which is the case in Rust 2021), this causes an ambiguity. Should the call be to `MyTrait::try_into` or `std::convert::TryInto::try_into`?\n\nIn these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that the `dyn Trait` method is chosen, versus the methods from the prelude trait. For example, turning `f.try_into()` above into `(&*f).try_into()` ensures that we're calling `try_into` on the `dyn MyTrait` which can only refer to the `MyTrait::try_into` method.\n\n### [No migration needed](#no-migration-needed)\n\n#### [Inherent methods](#inherent-methods)\n\nMany types define their own inherent methods with the same name as a trait method. For instance, below the struct `MyStruct` implements `from_iter` which shares the same name with the method from the trait `FromIterator` found in the standard library:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::iter::IntoIterator;\n\nstruct MyStruct {\n  data: Vec<u32>\n}\n\nimpl MyStruct {\n  // This has the same name as `std::iter::FromIterator::from_iter`\n  fn from_iter(iter: impl IntoIterator<Item = u32>) -> Self {\n    Self {\n      data: iter.into_iter().collect()\n    }\n  }\n}\n\nimpl std::iter::FromIterator<u32> for MyStruct {\n    fn from_iter<I: IntoIterator<Item = u32>>(iter: I) -> Self {\n      Self {\n        data: iter.into_iter().collect()\n      }\n    }\n}\n}\n```\n\nInherent methods always take precedent over trait methods so there's no need for any migration.\n\n### [Implementation Reference](#implementation-reference)\n\nThe lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:\n\n-   Is the call a [fully-qualified call](https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls) or does it use [dot-call method syntax](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)?\n    -   This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. `<Type as Trait>::method`)\n-   Is this an [inherent method](https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations) or [a trait method](https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations)?\n    -   Inherent methods that take `self` will take priority over `TryInto::try_into` as inherent methods take priority over trait methods, but inherent methods that take `&self` or `&mut self` won't take priority due to requiring a auto-reference (while `TryInto::try_into` does not, as it takes `self`)\n-   Is the origin of this method from `core`/`std`? (As the traits can't have a collision with themselves)\n-   Does the given type implement the trait it could have a collision against?\n-   Is the method being called via dynamic dispatch? (i.e. is the `self` type `dyn Trait`)\n    -   If so, trait imports don't affect resolution, and no migration lint needs to occur\n\n## [Default Cargo feature resolver](#default-cargo-feature-resolver)\n\n## [Summary](#summary-6)\n\n-   `edition = \"2021\"` implies `resolver = \"2\"` in `Cargo.toml`.\n\n## [Details](#details-3)\n\nSince Rust 1.51.0, Cargo has opt-in support for a [new feature resolver](about:blank/cargo/reference/resolver.html#feature-resolver-version-2) which can be activated with `resolver = \"2\"` in `Cargo.toml`.\n\nStarting in Rust 2021, this will be the default. That is, writing `edition = \"2021\"` in `Cargo.toml` will imply `resolver = \"2\"`.\n\nThe resolver is a global setting for a [workspace](rust-2021/../../cargo/reference/workspaces.html), and the setting is ignored in dependencies. The setting is only honored for the top-level package of the workspace. If you are using a [virtual workspace](about:blank/cargo/reference/workspaces.html#virtual-workspace), you will still need to explicitly set the [`resolver` field](about:blank/cargo/reference/resolver.html#resolver-versions) in the `[workspace]` definition if you want to opt-in to the new resolver.\n\nThe new feature resolver no longer merges all requested features for crates that are depended on in multiple ways. See [the announcement of Rust 1.51](https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver) for details.\n\n## [Migration](#migration-1)\n\nThere are no automated migration tools for updating for the new resolver. For most projects, there are usually few or no changes as a result of updating.\n\nWhen updating with `cargo fix --edition`, Cargo will display a report if the new resolver will build dependencies with different features. It may look something like this:\n\n> note: Switching to Edition 2021 will enable the use of the version 2 feature resolver in Cargo. This may cause some dependencies to be built with fewer features enabled than previously. More information about the resolver changes may be found at [https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html](https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html)  \n> When building the following dependencies, the given features will no longer be used:\n> \n> ```text\n>   bstr v0.2.16: default, lazy_static, regex-automata, unicode\n>   libz-sys v1.1.3 (as host dependency): libc\n> \n> ```\n\nThis lets you know that certain dependencies will no longer be built with the given features.\n\n### [Build failures](#build-failures)\n\nThere may be some circumstances where your project may not build correctly after the change. If a dependency declaration in one package assumes that certain features are enabled in another, and those features are now disabled, it may fail to compile.\n\nFor example, let's say we have a dependency like this:\n\n```toml\n# Cargo.toml\n\n[dependencies]\nbstr = { version = \"0.2.16\", default-features = false }\n# ...\n\n```\n\nAnd somewhere in our dependency tree, another package has this:\n\n```toml\n# Another package's Cargo.toml\n\n[build-dependencies]\nbstr = \"0.2.16\"\n\n```\n\nIn our package, we've been using the [`words_with_breaks`](https://docs.rs/bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks) method from `bstr`, which requires `bstr`'s \"unicode\" feature to be enabled. This has historically worked because Cargo unified the features of `bstr` between the two packages. However, after updating to Rust 2021, the new resolver will build `bstr` twice, once with the default features (as a build dependency), and once with no features (as our normal dependency). Since `bstr` is now being built without the \"unicode\" feature, the `words_with_breaks` method doesn't exist, and the build will fail with an error that the method is missing.\n\nThe solution here is to ensure that the dependency is declared with the features you are actually using. For example:\n\n```toml\n[dependencies]\nbstr = { version = \"0.2.16\", default-features = false, features = [\"unicode\"] }\n\n```\n\nIn some cases, this may be a problem with a third-party dependency that you don't have direct control over. You can consider submitting a patch to that project to try to declare the correct set of features for the problematic dependency. Alternatively, you can add features to any dependency from within your own `Cargo.toml` file. For example, if the `bstr` example given above was declared in some third-party dependency, you can just copy the correct dependency declaration into your own project. The features will be unified, as long as they match the unification rules of the new resolver. Those are:\n\n-   Features enabled on platform-specific dependencies for targets not currently being built are ignored.\n-   Build-dependencies and proc-macros do not share features with normal dependencies.\n-   Dev-dependencies do not activate features unless building a target that needs them (like tests or examples).\n\nA real-world example is using [`diesel`](https://crates.io/crates/diesel) and [`diesel_migrations`](https://crates.io/crates/diesel_migrations). These packages provide database support, and the database is selected using a feature, like this:\n\n```toml\n[dependencies]\ndiesel = { version = \"1.4.7\", features = [\"postgres\"] }\ndiesel_migrations = \"1.4.0\"\n\n```\n\nThe problem is that `diesel_migrations` has an internal proc-macro which itself depends on `diesel`, and the proc-macro assumes its own copy of `diesel` has the same features enabled as the rest of the dependency graph. After updating to the new resolver, it fails to build because now there are two copies of `diesel`, and the one built for the proc-macro is missing the \"postgres\" feature.\n\nA solution here is to add `diesel` as a build-dependency with the required features, for example:\n\n```toml\n[build-dependencies]\ndiesel = { version = \"1.4.7\", features = [\"postgres\"] }\n\n```\n\nThis causes Cargo to add \"postgres\" as a feature for host dependencies (proc-macros and build-dependencies). Now, the `diesel_migrations` proc-macro will get the \"postgres\" feature enabled, and it will build correctly.\n\nThe 2.0 release of `diesel` (currently in development) does not have this problem as it has been restructured to not have this dependency requirement.\n\n### [Exploring features](#exploring-features)\n\nThe [`cargo tree`](rust-2021/../../cargo/commands/cargo-tree.html) command has had substantial improvements to help with the migration to the new resolver. `cargo tree` can be used to explore the dependency graph, and to see which features are being enabled, and importantly _why_ they are being enabled.\n\nOne option is to use the `--duplicates` flag (`-d` for short), which will tell you when a package is being built multiple times. Taking the `bstr` example from earlier, we might see:\n\n```console\n> cargo tree -d\nbstr v0.2.16\n└── foo v0.1.0 (/MyProjects/foo)\n\nbstr v0.2.16\n[build-dependencies]\n└── bar v0.1.0\n    └── foo v0.1.0 (/MyProjects/foo)\n\n\n```\n\nThis output tells us that `bstr` is built twice, and shows the chain of dependencies that led to its inclusion in both cases.\n\nYou can print which features each package is using with the `-f` flag, like this:\n\n```console\ncargo tree -f '{p} {f}'\n\n```\n\nThis tells Cargo to change the \"format\" of the output, where it will print both the package and the enabled features.\n\nYou can also use the `-e` flag to tell it which \"edges\" to display. For example, `cargo tree -e features` will show in-between each dependency which features are being added by each dependency. This option becomes more useful with the `-i` flag which can be used to \"invert\" the tree. This allows you to see how features _flow_ into a given dependency. For example, let's say the dependency graph is large, and we're not quite sure who is depending on `bstr`, the following command will show that:\n\n```console\n> cargo tree -e features -i bstr\nbstr v0.2.16\n├── bstr feature \"default\"\n│   [build-dependencies]\n│   └── bar v0.1.0\n│       └── bar feature \"default\"\n│           └── foo v0.1.0 (/MyProjects/foo)\n├── bstr feature \"lazy_static\"\n│   └── bstr feature \"unicode\"\n│       └── bstr feature \"default\" (*)\n├── bstr feature \"regex-automata\"\n│   └── bstr feature \"unicode\" (*)\n├── bstr feature \"std\"\n│   └── bstr feature \"default\" (*)\n└── bstr feature \"unicode\" (*)\n\n```\n\nThis snippet of output shows that the project `foo` depends on `bar` with the \"default\" feature. Then, `bar` depends on `bstr` as a build-dependency with the \"default\" feature. We can further see that `bstr`'s \"default\" feature enables \"unicode\" (among other features).\n\n## [IntoIterator for arrays](#intoiterator-for-arrays)\n\n## [Summary](#summary-7)\n\n-   Arrays implement `IntoIterator` in _all_ editions.\n-   Calls to `IntoIterator::into_iter` are _hidden_ in Rust 2015 and Rust 2018 when using method call syntax (i.e., `array.into_iter()`). So, `array.into_iter()` still resolves to `(&array).into_iter()` as it has before.\n-   `array.into_iter()` changes meaning to be the call to `IntoIterator::into_iter` in Rust 2021.\n\n## [Details](#details-4)\n\nUntil Rust 1.53, only _references_ to arrays implement `IntoIterator`. This means you can iterate over `&[1, 2, 3]` and `&mut [1, 2, 3]`, but not over `[1, 2, 3]` directly.\n\n```rust\nfor &e in &[1, 2, 3] {} // Ok :)\n\nfor e in [1, 2, 3] {} // Error :(\n```\n\nThis has been [a long-standing issue](https://github.com/rust-lang/rust/issues/25725), but the solution is not as simple as it seems. Just [adding the trait implementation](https://github.com/rust-lang/rust/pull/65819) would break existing code. `array.into_iter()` already compiles today because that implicitly calls `(&array).into_iter()` due to [how method call syntax works](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator). Adding the trait implementation would change the meaning.\n\nUsually this type of breakage (adding a trait implementation) is categorized as 'minor' and acceptable. But in this case there is too much code that would be broken by it.\n\nIt has been suggested many times to \"only implement `IntoIterator` for arrays in Rust 2021\". However, this is simply not possible. You can't have a trait implementation exist in one edition and not in another, since editions can be mixed.\n\nInstead, the trait implementation was added in _all_ editions (starting in Rust 1.53.0) but with a small hack to avoid breakage until Rust 2021. In Rust 2015 and 2018 code, the compiler will still resolve `array.into_iter()` to `(&array).into_iter()` like before, as if the trait implementation does not exist. This _only_ applies to the `.into_iter()` method call syntax. It does not affect any other syntax such as `for e in [1, 2, 3]`, `iter.zip([1, 2, 3])` or `IntoIterator::into_iter([1, 2, 3])`. Those will start to work in _all_ editions.\n\nWhile it's a shame that this required a small hack to avoid breakage, this solution keeps the difference between the editions to an absolute minimum.\n\n## [Migration](#migration-2)\n\nA lint, `array_into_iter`, gets triggered whenever there is some call to `into_iter()` that will change meaning in Rust 2021. The `array_into_iter` lint has already been a warning by default on all editions since the 1.41 release (with several enhancements made in 1.55). If your code is already warning free, then it should already be ready to go for Rust 2021!\n\nYou can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by running:\n\n```sh\ncargo fix --edition\n\n```\n\nBecause the difference between editions is small, the migration to Rust 2021 is fairly straight-forward.\n\nFor method calls of `into_iter` on arrays, the elements being implemented will change from references to owned values.\n\nFor example:\n\n```rust\nfn main() {\n  let array = [1u8, 2, 3];\n  for x in array.into_iter() {\n    // x is a `&u8` in Rust 2015 and Rust 2018\n    // x is a `u8` in Rust 2021\n  }\n}\n```\n\nThe most straightforward way to migrate in Rust 2021, is by keeping the exact behavior from previous editions by calling `iter()` which also iterates over owned arrays by reference:\n\n```rust\nfn main() {\n  let array = [1u8, 2, 3];\n  for x in array.iter() { // <- This line changed\n    // x is a `&u8` in all editions\n  }\n}\n```\n\n### [Optional migration](#optional-migration)\n\nIf you are using fully qualified method syntax (i.e., `IntoIterator::into_iter(array)`) in a previous edition, this can be upgraded to method call syntax (i.e., `array.into_iter()`).\n\n## [Disjoint capture in closures](#disjoint-capture-in-closures)\n\n## [Summary](#summary-8)\n\n-   `|| a.x + 1` now captures only `a.x` instead of `a`.\n-   This can cause things to be dropped at different times or affect whether closures implement traits like `Send` or `Clone`.\n    -   If possible changes are detected, `cargo fix` will insert statements like `let _ = &a` to force a closure to capture the entire variable.\n\n## [Details](#details-5)\n\n[Closures](https://doc.rust-lang.org/book/ch13-01-closures.html) automatically capture anything that you refer to from within their body. For example, `|| a + 1` automatically captures a reference to `a` from the surrounding context.\n\nIn Rust 2018 and before, closures capture entire variables, even if the closure only uses one field. For example, `|| a.x + 1` captures a reference to `a` and not just `a.x`. Capturing `a` in its entirety prevents mutation or moves from other fields of `a`, so that code like this does not compile:\n\n```rust\nlet a = SomeStruct::new();\ndrop(a.x); // Move out of one field of the struct\nprintln!(\"{}\", a.y); // Ok: Still use another field of the struct\nlet c = || println!(\"{}\", a.y); // Error: Tries to capture all of `a`\nc();\n```\n\nStarting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.\n\nDisjoint capture was proposed as part of [RFC 2229](https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md) and the RFC contains details about the motivation.\n\n## [Migration](#migration-3)\n\nAs a part of the 2021 edition a migration lint, `rust_2021_incompatible_closure_captures`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.\n\nIn order to migrate your code to be Rust 2021 Edition compatible, run:\n\n```sh\ncargo fix --edition\n\n```\n\nBelow is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail or you would like to better understand how the migration works.\n\nChanging the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:\n\n-   changes to drop order, or when destructors run ([details](about:blank/rust-2021/disjoint-capture-in-closures.html#drop-order));\n-   changes to which traits a closure implements ([details](about:blank/rust-2021/disjoint-capture-in-closures.html#trait-implementations)).\n\nWhenever any of the scenarios below are detected, `cargo fix` will insert a \"dummy let\" into your closure to force it to capture the entire variable:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = (vec![22], vec![23]);\nlet c = move || {\n    // \"Dummy let\" that forces `x` to be captured in its entirety\n    let _ = &x;\n\n    // Otherwise, only `x.0` would be captured here\n    println!(\"{:?}\", x.0);\n};\n}\n```\n\nThis is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.\n\n### [Wild Card Patterns](#wild-card-patterns)\n\nClosures now only capture data that needs to be read, which means the following closures will not capture `x`:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 10;\nlet c = || {\n    let _ = x; // no-op\n};\n\nlet c = || match x {\n    _ => println!(\"Hello World!\")\n};\n}\n```\n\nThe `let _ = x` statement here is a no-op, since the `_` pattern completely ignores the right-hand side, and `x` is a reference to a place in memory (in this case, a variable).\n\nThis change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the \"drop order\" change below.\n\n**Subtle:** There are other similar expressions, such as the \"dummy lets\" `let _ = &x` that we insert, which are not no-ops. This is because the right-hand side (`&x`) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).\n\n### [Drop Order](#drop-order)\n\nWhen a closure takes ownership of a value from a variable `t`, that value is then dropped when the closure is dropped, and not when the variable `t` goes out of scope:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn move_value<T>(_: T){}\n{\n    let t = (vec![0], vec![0]);\n\n    {\n        let c = || move_value(t); // t is moved here\n    } // c is dropped, which drops the tuple `t` as well\n} // t goes out of scope here\n}\n```\n\nThe above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of _part_ of a variable, there can be differences:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn move_value<T>(_: T){}\n{\n    let t = (vec![0], vec![0]);\n\n    {\n        let c = || {\n            // In Rust 2018, captures all of `t`.\n            // In Rust 2021, captures only `t.0`\n            move_value(t.0);\n        };\n\n        // In Rust 2018, `c` (and `t`) are both dropped when we\n        // exit this block.\n        //\n        // In Rust 2021, `c` and `t.0` are both dropped when we\n        // exit this block.\n    }\n\n// In Rust 2018, the value from `t` has been moved and is\n// not dropped.\n//\n// In Rust 2021, the value from `t.0` has been moved, but `t.1`\n// remains, so it will be dropped here.\n}\n}\n```\n\nIn most cases, dropping values at different times just affects when memory is freed and is not important. However, some `Drop` impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy `let` to force the entire variable to be captured.\n\n### [Trait implementations](#trait-implementations)\n\nClosures automatically implement the following traits based on what values they capture:\n\n-   [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html): if all captured values are `Clone`.\n-   [Auto traits](https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits) like [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html), and [`UnwindSafe`](https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html): if all captured values implement the given trait.\n\nIn Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then \"dummy lets\" are inserted.\n\nFor instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement `Send`/`Sync` auto trait for the wrapper. The closure that is passed to `thread::spawn` uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is `Send`/`Sync`, the code is considered safe and therefore compiles successfully.\n\nWith disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally `Send`/`Sync` defeating the purpose of the wrapper.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::thread;\n\nstruct Ptr(*mut i32);\nunsafe impl Send for Ptr {}\n\n\nlet mut x = 5;\nlet px = Ptr(&mut x as *mut i32);\n\nlet c = thread::spawn(move || {\n    unsafe {\n        *(px.0) += 10;\n    }\n}); // Closure captured px.0 which is not Send\n}\n```\n\n## [Panic macro consistency](#panic-macro-consistency)\n\n## [Summary](#summary-9)\n\n-   `panic!(..)` now always uses `format_args!(..)`, just like `println!()`.\n-   `panic!(\"{\")` is no longer accepted, without escaping the `{` as `{{`.\n-   `panic!(x)` is no longer accepted if `x` is not a string literal.\n    -   Use `std::panic::panic_any(x)` to panic with a non-string payload.\n    -   Or use `panic!(\"{}\", x)` to use `x`'s `Display` implementation.\n-   The same applies to `assert!(expr, ..)`.\n\n## [Details](#details-6)\n\nThe `panic!()` macro is one of Rust's most well known macros. However, it has [some subtle surprises](https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md) that we can't just change due to backwards compatibility.\n\n```rust\n// Rust 2018\npanic!(\"{}\", 1); // Ok, panics with the message \"1\"\npanic!(\"{}\"); // Ok, panics with the message \"{}\"\n```\n\nThe `panic!()` macro only uses string formatting when it's invoked with more than one argument. When invoked with a single argument, it doesn't even look at that argument.\n\n```rust\n// Rust 2018\nlet a = \"{\";\nprintln!(a); // Error: First argument must be a format string literal\npanic!(a); // Ok: The panic macro doesn't care\n```\n\nIt even accepts non-strings such as `panic!(123)`, which is uncommon and rarely useful since it produces a surprisingly unhelpful message: `panicked at 'Box<Any>'`.\n\nThis will especially be a problem once [implicit format arguments](https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html) are stabilized. That feature will make `println!(\"hello {name}\")` a short-hand for `println!(\"hello {}\", name)`. However, `panic!(\"hello {name}\")` would not work as expected, since `panic!()` doesn't process a single argument as format string.\n\nTo avoid that confusing situation, Rust 2021 features a more consistent `panic!()` macro. The new `panic!()` macro will no longer accept arbitrary expressions as the only argument. It will, just like `println!()`, always process the first argument as format string. Since `panic!()` will no longer accept arbitrary payloads, [`panic_any()`](https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html) will be the only way to panic with something other than a formatted string.\n\n```rust\n// Rust 2021\npanic!(\"{}\", 1); // Ok, panics with the message \"1\"\npanic!(\"{}\"); // Error, missing argument\npanic!(a); // Error, must be a string literal\n```\n\nIn addition, `core::panic!()` and `std::panic!()` will be identical in Rust 2021. Currently, there are some historical differences between those two, which can be noticeable when switching `#![no_std]` on or off.\n\n## [Migration](#migration-4)\n\nA lint, `non_fmt_panics`, gets triggered whenever there is some call to `panic` that uses some deprecated behavior that will error in Rust 2021. The `non_fmt_panics` lint has already been a warning by default on all editions since the 1.50 release (with several enhancements made in later releases). If your code is already warning free, then it should already be ready to go for Rust 2021!\n\nYou can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by running:\n\n```sh\ncargo fix --edition\n\n```\n\nShould you choose or need to manually migrate, you'll need to update all panic invocations to either use the same formatting as `println` or use `std::panic::panic_any` to panic with non-string data.\n\nFor example, in the case of `panic!(MyStruct)`, you'll need to convert to using `std::panic::panic_any` (note that this is a function not a macro): `std::panic::panic_any(MyStruct)`.\n\nIn the case of panic messages that include curly braces but the wrong number of arguments (e.g., `panic!(\"Some curlies: {}\")`), you can panic with the string literal by either using the same syntax as `println!` (i.e., `panic!(\"{}\", \"Some curlies: {}\")`) or by escaping the curly braces (i.e., `panic!(\"Some curlies: {{}}\")`).\n\n## [Reserving syntax](#reserving-syntax)\n\n## [Summary](#summary-10)\n\n-   `any_identifier#`, `any_identifier\"...\"`, and `any_identifier'...'` are now reserved syntax, and no longer tokenize.\n-   This is mostly relevant to macros. E.g. `quote!{ #a#b }` is no longer accepted.\n-   It doesn't treat keywords specially, so e.g. `match\"...\" {}` is no longer accepted.\n-   Insert whitespace between the identifier and the subsequent `#`, `\"`, or `'` to avoid errors.\n-   Edition migrations will help you insert whitespace in such cases.\n\n## [Details](#details-7)\n\nTo make space for new syntax in the future, we've decided to reserve syntax for prefixed identifiers and literals: `prefix#identifier`, `prefix\"string\"`, `prefix'c'`, and `prefix#123`, where `prefix` can be any identifier. (Except those prefixes that already have a meaning, such as `b'...'` (byte chars) and `r\"...\"` (raw strings).)\n\nThis provides syntax we can expand into in the future without requiring an edition boundary. We may use this for temporary syntax until the next edition, or for permanent syntax if appropriate.\n\nWithout an edition, this would be a breaking change, since macros can currently accept syntax such as `hello\"world\"`, which they will see as two separate tokens: `hello` and `\"world\"`. The (automatic) fix is simple though: just insert a space: `hello \"world\"`. Likewise, `prefix#ident` should become `prefix #ident`. Edition migrations will help with this fix.\n\nOther than turning these into a tokenization error, [the RFC](https://github.com/rust-lang/rfcs/pull/3101) does not attach a meaning to any prefix yet. Assigning meaning to specific prefixes is left to future proposals, which will now—thanks to reserving these prefixes—not be breaking changes.\n\nSome new prefixes you might potentially see in the future (though we haven't committed to any of them yet):\n\n-   `k#keyword` to allow writing keywords that don't exist yet in the current edition. For example, while `async` is not a keyword in edition 2015, this prefix would've allowed us to accept `k#async` in edition 2015 without having to wait for edition 2018 to reserve `async` as a keyword.\n    \n-   `f\"\"` as a short-hand for a format string. For example, `f\"hello {name}\"` as a short-hand for the equivalent `format!()` invocation.\n    \n-   `s\"\"` for `String` literals.\n    \n\n## [Migration](#migration-5)\n\nAs a part of the 2021 edition a migration lint, `rust_2021_prefixes_incompatible_syntax`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.\n\nIn order to migrate your code to be Rust 2021 Edition compatible, run:\n\n```sh\ncargo fix --edition\n\n```\n\nShould you want or need to manually migrate your code, migration is fairly straight-forward.\n\nLet's say you have a macro that is defined like so:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! my_macro {\n    ($a:tt $b:tt) => {};\n}\n}\n```\n\nIn Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the first token tree and the second:\n\n```rust\nmy_macro!(z\"hey\");\n```\n\nThis `z` prefix is no longer allowed in Rust 2021, so in order to call this macro, you must add a space after the prefix like so:\n\n```rust\nmy_macro!(z \"hey\");\n```\n\n## [Summary](#summary-11)\n\n-   Code that triggered the `bare_trait_objects` and `ellipsis_inclusive_range_patterns` lints will error in Rust 2021.\n\n## [Details](#details-8)\n\nTwo existing lints are becoming hard errors in Rust 2021, but these lints will remain warnings in older editions.\n\n### [`bare_trait_objects`:](#bare_trait_objects)\n\nThe use of the `dyn` keyword to identify [trait objects](https://doc.rust-lang.org/book/ch17-02-trait-objects.html) will be mandatory in Rust 2021.\n\nFor example, the following code which does not include the `dyn` keyword in `&MyTrait` will produce an error instead of just a lint in Rust 2021:\n\n```rust\n#![allow(unused)]\nfn main() {\npub trait MyTrait {}\n\npub fn my_function(_trait_object: &MyTrait) { // should be `&dyn MyTrait`\n  unimplemented!()\n}\n}\n```\n\n### [`ellipsis_inclusive_range_patterns`:](#ellipsis_inclusive_range_patterns)\n\nThe [deprecated `...` syntax](https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns) for inclusive range patterns (i.e., ranges where the end value is _included_ in the range) is no longer accepted in Rust 2021. It has been superseded by `..=`, which is consistent with expressions.\n\nFor example, the following code which uses `...` in a pattern will produce an error instead of just a lint in Rust 2021:\n\n```rust\n#![allow(unused)]\nfn main() {\npub fn less_or_eq_to_100(n: u8) -> bool {\n  matches!(n, 0...100) // should be `0..=100`\n}\n}\n```\n\n## [Migrations](#migrations)\n\nIf your Rust 2015 or 2018 code does not produce any warnings for `bare_trait_objects` or `ellipsis_inclusive_range_patterns` and you've not allowed these lints through the use of `#![allow()]` or some other mechanism, then there's no need to migrate.\n\nTo automatically migrate any crate that uses `...` in patterns or does not use `dyn` with trait objects, you can run `cargo fix --edition`.\n\n## [Or patterns in macro-rules](#or-patterns-in-macro-rules)\n\n## [Summary](#summary-12)\n\n-   How patterns work in `macro_rules` macros changes slightly:\n    -   `$_:pat` in `macro_rules` now matches usage of `|` too: e.g. `A | B`.\n    -   The new `$_:pat_param` behaves like `$_:pat` did before; it does not match (top level) `|`.\n    -   `$_:pat_param` is available in all editions.\n\n## [Details](#details-9)\n\nStarting in Rust 1.53.0, [patterns](https://doc.rust-lang.org/stable/reference/patterns.html) are extended to support `|` nested anywhere in the pattern. This enables you to write `Some(1 | 2)` instead of `Some(1) | Some(2)`. Since this was simply not allowed before, this is not a breaking change.\n\nHowever, this change also affects [`macro_rules` macros](https://doc.rust-lang.org/stable/reference/macros-by-example.html). Such macros can accept patterns using the `:pat` fragment specifier. Currently, `:pat` does _not_ match top level `|`, since before Rust 1.53, not all patterns (at all nested levels) could contain a `|`. Macros that accept patterns like `A | B`, such as [`matches!()`](https://doc.rust-lang.org/1.51.0/std/macro.matches.html) use something like `$($_:pat)|+`.\n\nBecause this would potentially break existing macros, the meaning of `:pat` did not change in Rust 1.53.0 to include `|`. Instead, that change happens in Rust 2021. In the new edition, the `:pat` fragment specifier _will_ match `A | B`.\n\n`$_:pat` fragments in Rust 2021 cannot be followed by an explicit `|`. Since there are times that one still wishes to match pattern fragments followed by a `|`, the fragment specified `:pat_param` has been added to retain the older behavior.\n\nIt's important to remember that editions are _per crate_, so the only relevant edition is the edition of the crate where the macro is defined. The edition of the crate where the macro is used does not change how the macro works.\n\n## [Migration](#migration-6)\n\nA lint, `rust_2021_incompatible_or_patterns`, gets triggered whenever there is a use `$_:pat` which will change meaning in Rust 2021.\n\nYou can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by running:\n\n```sh\ncargo fix --edition\n\n```\n\nIf you have a macro which relies on `$_:pat` not matching the top level use of `|` in patterns, you'll need to change each occurrence of `$_:pat` to `$_:pat_param`.\n\nFor example:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! my_macro { \n    ($x:pat | $y:pat) => {\n        // TODO: implementation\n    } \n}\n\n// This macro works in Rust 2018 since `$x:pat` does not match against `|`:\nmy_macro!(1 | 2);\n\n// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not allowed\n// to be followed by a `|`. To make sure this macro still works in Rust 2021\n// change the macro to the following:\nmacro_rules! my_macro { \n    ($x:pat_param | $y:pat) => { // <- this line is different\n        // TODO: implementation\n    } \n}\n}\n```\n\n## [C-string literals](#c-string-literals)\n\n## [Summary](#summary-13)\n\n-   Literals of the form `c\"foo\"` or `cr\"foo\"` represent a string of type [`&core::ffi::CStr`](rust-2021/../../core/ffi/struct.CStr.html).\n\n## [Details](#details-10)\n\nStarting with Rust 1.77, C-strings can be written using C-string literal syntax with the `c` or `cr` prefix.\n\nPreviously, it was challenging to properly produce a valid string literal that could interoperate with C APIs which terminate with a NUL byte. The [`cstr`](https://crates.io/crates/cstr) crate was a popular solution, but that required compiling a proc-macro which was quite expensive. Now, C-strings can be written directly using literal syntax notation, which will generate a value of type [`&core::ffi::CStr`](rust-2021/../../core/ffi/struct.CStr.html) which is automatically terminated with a NUL byte.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse core::ffi::CStr;\n\nassert_eq!(c\"hello\", CStr::from_bytes_with_nul(b\"hello\\0\").unwrap());\nassert_eq!(\n    c\"byte escapes \\xff work\",\n    CStr::from_bytes_with_nul(b\"byte escapes \\xff work\\0\").unwrap()\n);\nassert_eq!(\n    c\"unicode escapes \\u{00E6} work\",\n    CStr::from_bytes_with_nul(b\"unicode escapes \\xc3\\xa6 work\\0\").unwrap()\n);\nassert_eq!(\n    c\"unicode characters αβγ encoded as UTF-8\",\n    CStr::from_bytes_with_nul(\n        b\"unicode characters \\xce\\xb1\\xce\\xb2\\xce\\xb3 encoded as UTF-8\\0\"\n    )\n    .unwrap()\n);\nassert_eq!(\n    c\"strings can continue \\\n        on multiple lines\",\n    CStr::from_bytes_with_nul(b\"strings can continue on multiple lines\\0\").unwrap()\n);\n}\n```\n\nC-strings do not allow interior NUL bytes (such as with a `\\0` escape).\n\nSimilar to regular strings, C-strings also support \"raw\" syntax with the `cr` prefix. These raw C-strings do not process backslash escapes which can make it easier to write strings that contain backslashes. Double-quotes can be included by surrounding the quotes with the `#` character. Multiple `#` characters can be used to avoid ambiguity with internal `\"#` sequences.\n\n```rust\n#![allow(unused)]\nfn main() {\nassert_eq!(cr\"foo\", c\"foo\");\n// Number signs can be used to embed interior double quotes.\nassert_eq!(cr#\"\"foo\"\"#, c\"\\\"foo\\\"\");\n// This requires two #.\nassert_eq!(cr##\"\"foo\"#\"##, c\"\\\"foo\\\"#\");\n// Escapes are not processed.\nassert_eq!(cr\"C:\\foo\", c\"C:\\\\foo\");\n}\n```\n\nSee [The Reference](about:blank/reference/tokens.html#c-string-and-raw-c-string-literals) for more details.\n\n## [Migration](#migration-7)\n\nMigration is only necessary for macros which may have been assuming a sequence of tokens that looks similar to `c\"…\"` or `cr\"…\"`, which previous to the 2021 edition would tokenize as two separate tokens, but in 2021 appears as a single token.\n\nAs part of the [syntax reservation](rust-2021/reserving-syntax.html) for the 2021 edition, any macro input which may run into this issue should issue a warning from the `rust_2021_prefixes_incompatible_syntax` migration lint. See that chapter for more detail.\n\n## [Rust 2024](#rust-2024)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\n| Info |  |\n| --- | --- |\n| RFC | [#3501](https://rust-lang.github.io/rfcs/3501-edition-2024.html) |\n| Release version | 1.82.0 (anticipated) |\n\nThe Rust 2024 Edition is currently slated for release in Rust 1.82.0. Rust 1.82.0 will be in beta for six weeks, after which it is released as stable on October 17th.\n\nHowever, note that Rust is a project run by volunteers. We prioritize the personal well-being of everyone working on Rust over any deadlines and expectations we might have set. This could mean delaying the edition a version if necessary, or dropping a feature that turns out to be too difficult or stressful to finish in time.\n\nThat said, we are on schedule and many of the difficult problems are already tackled, thanks to all the people contributing to Rust 2024! 💛\n\n## [Additions to the prelude](#additions-to-the-prelude-1)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\". More information may be found in the tracking issue at [https://github.com/rust-lang/rust/issues/121042](https://github.com/rust-lang/rust/issues/121042).\n\n## [Summary](#summary-14)\n\n-   The [`Future`](rust-2024/../../std/future/trait.Future.html) and [`IntoFuture`](rust-2024/../../std/future/trait.IntoFuture.html) traits are now part of the prelude.\n-   This might make calls to trait methods ambiguous which could make some code fail to compile.\n-   `RustcEncodable` and `RustcDecodable` have been removed from the prelude.\n\n## [Details](#details-11)\n\nThe [prelude of the standard library](rust-2024/../../std/prelude/index.html) is the module containing everything that is automatically imported in every module. It contains commonly used items such as `Option`, `Vec`, `drop`, and `Clone`.\n\nThe Rust compiler prioritizes any manually imported items over those from the prelude, to make sure additions to the prelude will not break any existing code. For example, if you have a crate or module called `example` containing a `pub struct Option;`, then `use example::*;` will make `Option` unambiguously refer to the one from `example`; not the one from the standard library.\n\nHowever, adding a _trait_ to the prelude can break existing code in a subtle way. For example, a call to `x.poll()` which comes from a `MyPoller` trait might fail to compile if `std`'s `Future` is also imported, because the call to `poll` is now ambiguous and could come from either trait.\n\nAs a solution, Rust 2024 will use a new prelude. It's identical to the current one, except for the following changes:\n\n-   Added:\n    -   [`std::future::Future`](rust-2024/../../std/future/trait.Future.html)\n    -   [`std::future::IntoFuture`](rust-2024/../../std/future/trait.IntoFuture.html)\n-   Removed:\n    -   `RustcEncodable`\n    -   `RustcDecodable`\n\n### [`RustcEncodable` and `RustcDecodable` removal](#rustcencodable-and-rustcdecodable-removal)\n\n`RustcEncodable` and `RustcDecodable` are two undocumented derive macros that have been removed from the prelude. These were deprecated before Rust 1.0, but remained within the standard library prelude. The 2024 Edition has removed these from the prelude since they are not expected to be used.\n\nIf in the unlikely case there is a project still using these, it is recommended to switch to a serialization library, such as those found on [crates.io](https://crates.io/categories/encoding).\n\n## [Migration](#migration-8)\n\n🚧 The automatic migration for this has not yet been implemented.\n\n### [Migration needed](#migration-needed-1)\n\n#### [Conflicting trait methods](#conflicting-trait-methods-1)\n\nWhen two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:\n\n```rust\ntrait MyPoller {\n    // This name is the same as the `poll` method on the `Future` trait from `std`.\n    fn poll(&self) {\n        println!(\"polling\");\n    }\n}\n\nimpl<T> MyPoller for T {}\n\nfn main() {\n    // Pin<&mut async {}> implements both `std::future::Future` and `MyPoller`.\n    // If both traits are in scope (as would be the case in Rust 2024),\n    // then it becomes ambiguous which `poll` method to call\n    core::pin::pin!(async {}).poll();\n}\n```\n\nWe can fix this by using fully qualified syntax:\n\n```rust\nfn main() {\n    // Now it is clear which trait method we're referring to\n    <_ as MyPoller>::poll(&core::pin::pin!(async {}));\n}\n```\n\n#### [`RustcEncodable` and `RustcDecodable`](#rustcencodable-and-rustcdecodable)\n\nIt is strongly recommended that you migrate to a different serialization library if you are still using these. However, these derive macros are still available in the standard library, they are just required to be imported from the older prelude now:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[allow(soft_unstable)]\nuse core::prelude::v1::{RustcDecodable, RustcEncodable};\n}\n```\n\n## [unsafe\\_op\\_in\\_unsafe\\_fn warning](#unsafe_op_in_unsafe_fn-warning)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\n## [Summary](#summary-15)\n\n-   The [`unsafe_op_in_unsafe_fn`](about:blank/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint now warns by default. This warning detects calls to unsafe operations in unsafe functions without an explicit unsafe block.\n\n## [Details](#details-12)\n\nThe [`unsafe_op_in_unsafe_fn`](about:blank/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint will fire if there are [unsafe operations](rust-2024/../../reference/unsafety.html) in an unsafe function without an explicit [`unsafe {}` block](about:blank/reference/expressions/block-expr.html#unsafe-blocks).\n\n```rust\n#![allow(unused)]\nfn main() {\n#![warn(unsafe_op_in_unsafe_fn)]\nunsafe fn get_unchecked<T>(x: &[T], i: usize) -> &T {\n  x.get_unchecked(i) // WARNING: requires unsafe block\n}\n}\n```\n\nThe solution is to wrap any unsafe operations in an `unsafe` block:\n\n```rust\n#![allow(unused)]\nfn main() {\n#![deny(unsafe_op_in_unsafe_fn)]\nunsafe fn get_unchecked<T>(x: &[T], i: usize) -> &T {\n  unsafe { x.get_unchecked(i) }\n}\n}\n```\n\nThis change is intended to help protect against accidental use of unsafe operations in an unsafe function. The `unsafe` function keyword was performing two roles. One was to declare that _calling_ the function requires unsafe, and that the caller is responsible to uphold additional safety requirements. The other role was to allow the use of unsafe operations inside of the function. This second role was determined to be too risky without explicit `unsafe` blocks.\n\nMore information and motivation may be found in [RFC #2585](https://rust-lang.github.io/rfcs/2585-unsafe-block-in-unsafe-fn.html).\n\n## [Migration](#migration-9)\n\nThe [`unsafe_op_in_unsafe_fn`](about:blank/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint is part of the `rust-2024-compatibility` lint group. In order to migrate your code to be Rust 2024 Edition compatible, run:\n\n```sh\ncargo fix --edition\n\n```\n\nAlternatively, you can manually enable the lint to find places where unsafe blocks need to be added, or switch it to `allow` to silence the lint completely.\n\n```rust\n#![allow(unused)]\nfn main() {\n// Add this to the root of your crate to do a manual migration.\n#![warn(unsafe_op_in_unsafe_fn)]\n}\n```\n\n## [RPIT lifetime capture](#rpit-lifetime-capture)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\nThis feature is partially implemented, and not yet ready for testing. More information may be found in the tracking issue at [https://github.com/rust-lang/rust/issues/117587](https://github.com/rust-lang/rust/issues/117587).\n\n## [Summary](#summary-16)\n\n## [Details](#details-13)\n\n## [Migration](#migration-10)\n\n## [Disallow references to static mut](#disallow-references-to-static-mut)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\n## [Summary](#summary-17)\n\n-   The [`static_mut_refs`](about:blank/rustc/lints/listing/warn-by-default.html#static-mut-refs) lint is now a hard error that cannot be disabled. This prevents taking a shared or mutable reference to a `static mut`.\n\n## [Details](#details-14)\n\nTaking a reference to a [`static mut`](about:blank/reference/items/static-items.html#mutable-statics) is no longer allowed:\n\n```rust\n#![allow(unused)]\nfn main() {\nstatic mut X: i32 = 23;\nstatic mut Y: i32 = 24;\n\nunsafe {\n    let y = &X;             // ERROR: reference of mutable static\n    let ref x = X;          // ERROR: reference of mutable static\n    let (x, y) = (&X, &Y);  // ERROR: reference of mutable static\n}\n}\n```\n\nMerely taking such a reference in violation of Rust's mutability XOR aliasing requirement has always been _instantaneous_ [undefined behavior](rust-2024/../../reference/behavior-considered-undefined.html), **even if the reference is never read from or written to**. Furthermore, upholding mutability XOR aliasing for a `static mut` requires _reasoning about your code globally_, which can be particularly difficult in the face of reentrancy and/or multithreading.\n\n## [Alternatives](#alternatives)\n\nWherever possible, it is **strongly recommended** to use instead an _immutable_ `static` of a type that provides _interior mutability_ behind some _locally-reasoned abstraction_ (which greatly reduces the complexity of ensuring that Rust's mutability XOR aliasing requirement is upheld).\n\nIn situations where no locally-reasoned abstraction is possible and you are therefore compelled still to reason globally about accesses to your `static` variable, you must now use raw pointers such as can be obtained via the [`addr_of_mut!`](https://docs.rust-lang.org/core/ptr/macro.addr_of_mut.html) macro. By first obtaining a raw pointer rather than directly taking a reference, (the safety requirements of) accesses through that pointer will be more familiar to `unsafe` developers and can be deferred until/limited to smaller regions of code.\n\n## [Migration](#migration-11)\n\n🚧 The automatic migration for this has not yet been implemented.\n\n## [Public/private dependencies](#publicprivate-dependencies)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\nThis feature is only partially implemented, and not yet ready for testing. More information may be found in the tracking issue at [https://github.com/rust-lang/rust/issues/44663](https://github.com/rust-lang/rust/issues/44663).\n\n## [Summary](#summary-18)\n\n## [Details](#details-15)\n\n## [Migration](#migration-12)\n\n## [Cargo: Remove implicit features](#cargo-remove-implicit-features)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\n## [Summary](#summary-19)\n\n-   Optional dependencies must now be explicitly specified in the `[features]` table.\n\n## [Details](#details-16)\n\nIn previous editions, when an [optional dependency](about:blank/cargo/reference/features.html#optional-dependencies) is specified, Cargo would automatically add an implicit [feature](rust-2024/../../cargo/reference/features.html) of the same name as the dependency. For example:\n\n```toml\n[dependencies]\njpeg-decoder = { version = \"0.3.1\", optional = true }\n\n```\n\nThis would automatically add a feature `jpeg-decoder = [\"dep:jpeg-decoder\"]` to provide a way to enable the dependency. The `dep:` entries are specific syntax for referring to optional dependencies. This implicit feature is only added if `\"dep:jpeg-decoder\"` is not specified in any other feature.\n\nIn the 2024 Edition, this implicit feature is no longer added, and you are required to explicitly specify the dependency in the `[features]` table. For example, instead of exposing the particular internal name of some dependency, you may consider using a more general term for the feature name:\n\n```toml\n[features]\ngraphics = [\"dep:jpeg-decoder\"]\n\n```\n\n`cargo add --optional <NAME>` automatically adds a feature for the dependency to the `[features]` table if it isn't already there.\n\n### [Motivation](#motivation-2)\n\nOne reason for requiring this to be explicit is that it encourages a conscious decision about the public exposure of the feature name, and makes it clearer when reading the `[features]` table which features exist. This can help avoid tying the implementation details (the dependency names) to the public set of feature names.\n\nAlso, removing features is a [SemVer incompatible change](about:blank/cargo/reference/semver.html#cargo-feature-remove), which may not be obvious when removing an optional dependency that you thought was private.\n\n## [Migration](#migration-13)\n\nWhen using `cargo fix --edition`, Cargo will automatically update your `Cargo.toml` file to include the implicit features if necessary.\n\nIf you would prefer to update your `Cargo.toml` manually, add a `foo = [\"dep:foo\"]` entry for each optional dependency named _foo_ if `dep:foo` is not already specified anywhere in the `[features]` table.\n\n## [Cargo: Table and key name consistency](#cargo-table-and-key-name-consistency)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\n## [Summary](#summary-20)\n\n-   Several table and key names in `Cargo.toml` have been removed where there were previously two ways to specify the same thing.\n    -   Removed `[project]`; use `[package]` instead.\n    -   Removed `default_features`; use `default-features` instead.\n    -   Removed `crate_type`; use `crate-type` instead.\n    -   Removed `proc_macro`; use `proc-macro` instead.\n    -   Removed `dev_dependencies`; use `dev-dependencies` instead.\n    -   Removed `build_dependencies`; use `build-dependencies` instead.\n\n## [Details](#details-17)\n\nSeveral table and keys names are no longer allowed in the 2024 Edition. There were two ways to specify these tables or keys, and this helps ensure there is only one way to specify them.\n\nSome were due to a change in decisions over time, and some were inadvertent implementation artifacts. In order to avoid confusion, and to enforce a single style for specifying these tables and keys, only one variant is now allowed.\n\nFor example:\n\n```toml\n[dev_dependencies]\nrand = { version = \"0.8.5\", default_features = false }\n\n```\n\nShould be changed to:\n\n```toml\n[dev-dependencies]\nrand = { version = \"0.8.5\", default-features = false }\n\n```\n\nNotice that the underscores were changed to dashes for `dev_dependencies` and `default_features`.\n\n## [Migration](#migration-14)\n\nWhen using `cargo fix --edition`, Cargo will automatically update your `Cargo.toml` file to use the preferred table and key names.\n\nIf you would prefer to update your `Cargo.toml` manually, be sure to go through the list above and make sure only the new forms are used.\n\n## [Cargo: Reject unused inherited default-features](#cargo-reject-unused-inherited-default-features)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\n## [Summary](#summary-21)\n\n-   `default-features = false` is no longer allowed in an inherited workspace dependency if the workspace dependency specifies `default-features = true` (or does not specify `default-features`).\n\n## [Details](#details-18)\n\n[Workspace inheritance](about:blank/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace) allows you to specify dependencies in one place (the workspace), and then to refer to those workspace dependencies from within a package. There was an inadvertent interaction with how `default-features` is specified that is no longer allowed in the 2024 Edition.\n\nUnless the workspace specifies `default-features = false`, it is no longer allowed to specify `default-features = false` in an inherited package dependency. For example, with a workspace that specifies:\n\n```toml\n[workspace.dependencies]\nregex = \"1.10.4\"\n\n```\n\nThe following is now an error:\n\n```toml\n[package]\nname = \"foo\"\nversion = \"1.0.0\"\nedition = \"2024\"\n\n[dependencies]\nregex = { workspace = true, default-features = false }  # ERROR\n\n```\n\nThe reason for this change is to avoid confusion when specifying `default-features = false` when the default feature is already enabled, since it has no effect.\n\nIf you want the flexibility of deciding whether or not a dependency enables the default-features of a dependency, be sure to set `default-features = false` in the workspace definition. Just beware that if you build multiple workspace members at the same time, the features will be unified so that if one member sets `default-features = true` (which is the default if not explicitly set), the default-features will be enabled for all members using that dependency.\n\n## [Migration](#migration-15)\n\nWhen using `cargo fix --edition`, Cargo will automatically update your `Cargo.toml` file to remove `default-features = false` in this situation.\n\nIf you would prefer to update your `Cargo.toml` manually, check for any warnings when running a build and remove the corresponding entries. Previous editions should display something like:\n\n```text\nwarning: /home/project/Cargo.toml: `default-features` is ignored for regex,\nsince `default-features` was not specified for `workspace.dependencies.regex`,\nthis could become a hard error in the future\n\n```\n\n## [Rustfmt: Combine all delimited exprs as last argument](#rustfmt-combine-all-delimited-exprs-as-last-argument)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\n\nThis feature is not yet implemented. More information may be found in [https://github.com/rust-lang/rust/pull/114764](https://github.com/rust-lang/rust/pull/114764).\n\n## [Summary](#summary-22)\n\n## [Details](#details-19)\n\n## [Migration](#migration-16)\n\n## [`gen` keyword](#gen-keyword)\n\n🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\". More information may be found in the tracking issue at [https://github.com/rust-lang/rust/issues/123904](https://github.com/rust-lang/rust/issues/123904).\n\n## [Summary](#summary-23)\n\n-   `gen` is a [reserved keyword](about:blank/reference/keywords.html#reserved-keywords).\n\n## [Details](#details-20)\n\nThe `gen` keyword has been reserved as part of [RFC #3513](https://rust-lang.github.io/rfcs/3513-gen-blocks.html) to introduce \"gen blocks\" in a future release of Rust. `gen` blocks will provide a way to make it easier to write certain kinds of iterators. Reserving the keyword now will make it easier to stabilize `gen` blocks before the next edition.\n\n## [Migration](#migration-17)\n\nIntroducing the `gen` keyword can cause a problem for any identifiers that are already called `gen`. For example, any variable or function name called `gen` would clash with the new keyword. To overcome this, Rust supports the `r#` prefix for a [raw identifier](about:blank/reference/identifiers.html#raw-identifiers), which allows identifiers to overlap with keywords.\n\nThe [`keyword_idents_2024`](about:blank/rustc/lints/listing/allowed-by-default.html#keyword-idents-2024) lint will automatically modify any identifier named `gen` to be `r#gen` so that code continues to work on both editions. This lint is part of the `rust-2024-compatibility` lint group, which will automatically be applied when running `cargo fix --edition`. To migrate your code to be Rust 2024 Edition compatible, run:\n\n```sh\ncargo fix --edition\n\n```\n\nFor example, this will change:\n\n```rust\nfn gen() {\n    println!(\"generating!\");\n}\n\nfn main() {\n    gen();\n}\n```\n\nto be:\n\n```rust\nfn r#gen() {\n    println!(\"generating!\");\n}\n\nfn main() {\n    r#gen();\n}\n```\n\nAlternatively, you can manually enable the lint to find places where `gen` identifiers need to be modified to `r#gen`:\n\n```rust\n#![allow(unused)]\nfn main() {\n// Add this to the root of your crate to do a manual migration.\n#![warn(keyword_idents_2024)]\n}\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>The Rust Edition Guide</title>\n        <meta name=\"robots\" content=\"noindex\">\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"editions/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> What are editions?</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"editions/creating-a-new-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Creating a new project</a></li><li class=\"chapter-item expanded \"><a href=\"editions/transitioning-an-existing-project-to-a-new-edition.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Transitioning an existing project to a new edition</a></li><li class=\"chapter-item expanded \"><a href=\"editions/advanced-migrations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Advanced migrations</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"rust-2015/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Rust 2015</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2018/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Rust 2018</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"rust-2018/path-changes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Path and module system changes</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2018/trait-fn-parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Anonymous trait function parameters deprecated</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2018/new-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> New keywords</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2018/tyvar-behind-raw-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2018/cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Cargo changes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Rust 2021</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"rust-2021/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/default-cargo-resolver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Default Cargo feature resolver</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/IntoIterator-for-arrays.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> IntoIterator for arrays</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/disjoint-capture-in-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Disjoint capture in closures</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/panic-macro-consistency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Panic macro consistency</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/reserving-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.6.</strong> Reserving syntax</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/warnings-promoted-to-error.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.7.</strong> Warnings promoted to errors</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/or-patterns-macro-rules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.8.</strong> Or patterns in macro-rules</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2021/c-string-literals.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.9.</strong> C-string literals</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Rust 2024 🚧</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"rust-2024/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/unsafe-op-in-unsafe-fn.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> unsafe_op_in_unsafe_fn warning</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/rpit-lifetime-capture.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> RPIT lifetime capture</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/static-mut-reference.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.4.</strong> Disallow references to static mut</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/public-private-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.5.</strong> Public/private dependencies</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/cargo-remove-implicit-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.6.</strong> Cargo: Remove implicit features</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/cargo-table-key-names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.7.</strong> Cargo: Table and key name consistency</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/cargo-inherited-default-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.8.</strong> Cargo: Reject unused inherited default-features</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/rustfmt-overflow-delimited-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.9.</strong> Rustfmt: Combine all delimited exprs as last argument</a></li><li class=\"chapter-item expanded \"><a href=\"rust-2024/gen-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.10.</strong> gen keyword</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Edition Guide</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"introduction\"><a class=\"header\" href=\"#introduction\">Introduction</a></h1>\n<p>Welcome to The Rust Edition Guide! \"Editions\" are Rust's way of introducing\nchanges into the language that would not otherwise be backwards\ncompatible.</p>\n<p>In this guide, we'll discuss:</p>\n<ul>\n<li>What editions are</li>\n<li>Which changes are contained in each edition</li>\n<li>How to migrate your code from one edition to another</li>\n</ul>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"what-are-editions\"><a class=\"header\" href=\"#what-are-editions\">What are Editions?</a></h1>\n<p>In May 2015, the <a href=\"https://blog.rust-lang.org/2015/05/15/Rust-1.0.html\">release of Rust 1.0</a> established \"<a href=\"https://blog.rust-lang.org/2014/10/30/Stability.html\">stability without stagnation</a>\" as a core Rust axiom. Since then, Rust has committed to a pivotal rule: once a feature is <a href=\"https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\">released through stable</a>, contributors will continue to support that feature for all future releases.</p>\n<p>However, there are times when it's useful to make backwards-incompatible changes to the language. A common example is the introduction of a new keyword. For instance, early versions of Rust didn't feature the <code class=\"hljs\">async</code> and <code class=\"hljs\">await</code> keywords.</p>\n<p>If Rust had suddenly introduced these new keywords, some code would have broken: <code class=\"hljs\">let async = 1;</code> would no longer work.</p>\n<p>Rust uses <strong>editions</strong> to solve this problem. When there are backwards-incompatible changes, they are pushed into the next edition. Since editions are opt-in, existing crates won't use the changes unless they explicitly migrate into the new edition. For example, the latest version of Rust doesn't treat <code class=\"hljs\">async</code> as a keyword unless edition 2018 or later is chosen.</p>\n<p>Each crate chooses its edition <a href=\"https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field\">within its <code class=\"hljs\">Cargo.toml</code> file</a>. When creating a new crate with Cargo, it will automatically select the newest stable edition.</p>\n<h2 id=\"editions-do-not-split-the-ecosystem\"><a class=\"header\" href=\"#editions-do-not-split-the-ecosystem\">Editions do not split the ecosystem</a></h2>\n<p>When creating editions, there is one most consequential rule: crates in one edition <strong>must</strong> seamlessly interoperate with those compiled with other editions.</p>\n<p>In other words, each crate can decide when to migrate to a new edition independently. This decision is 'private' - it won't affect other crates in the ecosystem.</p>\n<p>For Rust, this required compatibility implies some limits on the kinds of changes that can be featured in an edition. As a result, changes found in new Rust editions tend to be 'skin deep'. All Rust code - regardless of edition - will ultimately compile down to the same internal representation within the compiler.</p>\n<h2 id=\"edition-migration-is-easy-and-largely-automated\"><a class=\"header\" href=\"#edition-migration-is-easy-and-largely-automated\">Edition migration is easy and largely automated</a></h2>\n<p>Rust aims to make upgrading to a new edition an easy process. When a new edition releases, crate authors may use <a href=\"https://doc.rust-lang.org/cargo/commands/cargo-fix.html\">automatic migration tooling within <code class=\"hljs\">cargo</code></a> to migrate. Cargo will then make minor changes to the code to make it compatible with the new version.</p>\n<p>For example, when migrating to Rust 2018, anything named <code class=\"hljs\">async</code> will now use the equivalent <a href=\"https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html\">raw identifier syntax</a>: <code class=\"hljs\">r#async</code>.</p>\n<p>Cargo's automatic migrations aren't perfect: there may still be corner cases where manual changes are required. It aims to avoid changes to semantics that could affect the correctness or performance of the code.</p>\n<h2 id=\"what-this-guide-covers\"><a class=\"header\" href=\"#what-this-guide-covers\">What this guide covers</a></h2>\n<p>In addition to tooling, this Rust Edition Guide also covers the changes that are part of each edition. It describes each change and links to additional details, if available. It also covers corner cases or tricky details crate authors should be aware of.</p>\n<p>Crate authors should find:</p>\n<ul>\n<li>An overview of editions</li>\n<li>A migration guide for specific editions</li>\n<li>A quick troubleshooting reference when automated tooling isn't working.</li>\n</ul>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"creating-a-new-project\"><a class=\"header\" href=\"#creating-a-new-project\">Creating a new project</a></h1>\n<p>A new project created with Cargo is configured to use the latest edition by\ndefault:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new foo</span>\n     Created binary (application) `foo` project\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> cat foo/Cargo.toml</span>\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n</code></pre>\n<p>That <code class=\"hljs\">edition = \"2021\"</code> setting configures your package to be built using the\nRust 2021 edition. No further configuration needed!</p>\n<p>You can use the <code class=\"hljs\">--edition &lt;YEAR&gt;</code> option of <code class=\"hljs\">cargo new</code> to create the project\nusing some specific edition. For example, creating a new project to use the\nRust 2018 edition could be done like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new --edition 2018 foo</span>\n     Created binary (application) `foo` project\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> cat foo/Cargo.toml</span>\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\n</code></pre>\n<p>Don't worry about accidentally using an invalid year for the edition; the\n<code class=\"hljs\">cargo new</code> invocation will not accept an invalid edition year value:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new --edition 2019 foo</span>\nerror: \"2019\" isn't a valid value for '--edition &lt;YEAR&gt;'\n        [possible values: 2015, 2018, 2021]\n\n        Did you mean \"2018\"?\n\nFor more information try --help\n</code></pre>\n<p>You can change the value of the <code class=\"hljs\">edition</code> key by simply editing the\n<code class=\"hljs\">Cargo.toml</code> file. For example, to cause your package to be built using the\nRust 2015 edition, you would set the key as in the following example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"foo\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2015\"</span>\n\n<span class=\"hljs-section\">[dependencies]</span>\n</code></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"transitioning-an-existing-project-to-a-new-edition\"><a class=\"header\" href=\"#transitioning-an-existing-project-to-a-new-edition\">Transitioning an existing project to a new edition</a></h1>\n<p>Rust includes tooling to automatically transition a project from one edition to the next.\nIt will update your source code so that it is compatible with the next edition.\nBriefly, the steps to update to the next edition are:</p>\n<ol>\n<li>Run <code class=\"hljs\">cargo fix --edition</code></li>\n<li>Edit <code class=\"hljs\">Cargo.toml</code> and set the <code class=\"hljs\">edition</code> field to the next edition, for example <code class=\"hljs\">edition = \"2021\"</code></li>\n<li>Run <code class=\"hljs\">cargo build</code> or <code class=\"hljs\">cargo test</code> to verify the fixes worked.</li>\n</ol>\n<p>The following sections dig into the details of these steps, and some of the issues you may encounter along the way.</p>\n<blockquote>\n<p>It's our intention that the migration to new editions is as smooth an\nexperience as possible. If it's difficult for you to upgrade to the latest edition,\nwe consider that a bug. If you run into problems with this process, please\n<a href=\"https://github.com/rust-lang/rust/issues/new/choose\">file a bug report</a>. Thank you!</p>\n</blockquote>\n<h2 id=\"starting-the-migration\"><a class=\"header\" href=\"#starting-the-migration\">Starting the migration</a></h2>\n<p>As an example, let's take a look at transitioning from the 2015 edition to the 2018 edition.\nThe steps are essentially the same when transitioning to other editions like 2021.</p>\n<p>Imagine we have a crate that has this code in <code class=\"hljs\">src/lib.rs</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, <span class=\"hljs-built_in\">i32</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code uses an anonymous parameter, that <code class=\"hljs\">i32</code>. This is <a href=\"editions/../rust-2018/trait-system/no-anon-params.html\">not\nsupported in Rust 2018</a>, and\nso this would fail to compile. Let's get this code up to date!</p>\n<h2 id=\"updating-your-code-to-be-compatible-with-the-new-edition\"><a class=\"header\" href=\"#updating-your-code-to-be-compatible-with-the-new-edition\">Updating your code to be compatible with the new edition</a></h2>\n<p>Your code may or may not use features that are incompatible with the new edition.\nIn order to help transition to the next edition, Cargo includes the <a href=\"editions/../../cargo/commands/cargo-fix.html\"><code class=\"hljs\">cargo fix</code></a> subcommand to automatically update your source code.\nTo start, let's run it:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\">cargo fix --edition\n</code></pre>\n<p>This will check your code, and automatically fix any issues that it can.\nLet's look at <code class=\"hljs\">src/lib.rs</code> again:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, _: <span class=\"hljs-built_in\">i32</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>It's re-written our code to introduce a parameter name for that <code class=\"hljs\">i32</code> value.\nIn this case, since it had no name, <code class=\"hljs\">cargo fix</code> will replace it with <code class=\"hljs\">_</code>,\nwhich is conventional for unused variables.</p>\n<p><code class=\"hljs\">cargo fix</code> can't always fix your code automatically.\nIf <code class=\"hljs\">cargo fix</code> can't fix something, it will print the warning that it cannot fix\nto the console. If you see one of these warnings, you'll have to update your code manually.\nSee the <a href=\"editions/advanced-migrations.html\">Advanced migration strategies</a> chapter for more on working with the migration process, and read the chapters in this guide which explain which changes are needed.\nIf you have problems, please seek help at the <a href=\"https://users.rust-lang.org/\">user's forums</a>.</p>\n<h2 id=\"enabling-the-new-edition-to-use-new-features\"><a class=\"header\" href=\"#enabling-the-new-edition-to-use-new-features\">Enabling the new edition to use new features</a></h2>\n<p>In order to use some new features, you must explicitly opt in to the new\nedition. Once you're ready to continue, change your <code class=\"hljs\">Cargo.toml</code> to add the new\n<code class=\"hljs\">edition</code> key/value pair. For example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"foo\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2018\"</span>\n</code></pre>\n<p>If there's no <code class=\"hljs\">edition</code> key, Cargo will default to Rust 2015. But in this case,\nwe've chosen <code class=\"hljs\">2018</code>, and so our code will compile with Rust 2018!</p>\n<p>The next step is to test your project on the new edition.\nRun your project tests to verify that everything still works, such as running <a href=\"editions/../../cargo/commands/cargo-test.html\"><code class=\"hljs\">cargo test</code></a>.\nIf new warnings are issued, you may want to consider running <code class=\"hljs\">cargo fix</code> again (without the <code class=\"hljs\">--edition</code> flag) to apply any suggestions given by the compiler.</p>\n<p>Congrats! Your code is now valid in both Rust 2015 and Rust 2018!</p>\n<h2 id=\"migrating-to-an-unstable-edition\"><a class=\"header\" href=\"#migrating-to-an-unstable-edition\">Migrating to an unstable edition</a></h2>\n<p>After an edition is released, there is roughly a three year window before the next edition.\nDuring that window, new features may be added to the next edition, which will only be available on the <a href=\"editions/../../book/appendix-07-nightly-rust.html\">nightly channel</a>.\nIf you want to help test those new features before they are stabilized, you can use the nightly channel to try them out.</p>\n<p>The steps are roughly similar to the stable channel:</p>\n<ol>\n<li>Install the most recent nightly: <code class=\"hljs\">rustup update nightly</code>.</li>\n<li>Run <code class=\"hljs\">cargo +nightly fix --edition</code>.</li>\n<li>Edit <code class=\"hljs\">Cargo.toml</code> and place <code class=\"hljs\">cargo-features = [\"edition2024\"]</code> at the top (above <code class=\"hljs\">[package]</code>), and change the edition field to say <code class=\"hljs\">edition = \"2024\"</code>.</li>\n<li>Run <code class=\"hljs\">cargo +nightly check</code> to verify it now works in the new edition.</li>\n</ol>\n<blockquote>\n<p><strong>⚠ Caution</strong>: Features implemented in the next edition may not have automatic migrations implemented with <code class=\"hljs\">cargo fix</code>, and the features themselves may not be finished.\nWhen possible, this guide should contain information about which features are implemented\non nightly along with more information about their status.\nA few months before the edition is stabilized, all of the new features should be fully implemented, and the <a href=\"https://blog.rust-lang.org/\">Rust Blog</a> will announce a call for testing.</p>\n</blockquote>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"advanced-migration-strategies\"><a class=\"header\" href=\"#advanced-migration-strategies\">Advanced migration strategies</a></h1>\n<h2 id=\"how-migrations-work\"><a class=\"header\" href=\"#how-migrations-work\">How migrations work</a></h2>\n<p><a href=\"editions/../../cargo/commands/cargo-fix.html\"><code class=\"hljs\">cargo fix --edition</code></a> works by running the equivalent of <a href=\"editions/../../cargo/commands/cargo-check.html\"><code class=\"hljs\">cargo check</code></a> on your project with special <a href=\"editions/../../rustc/lints/index.html\">lints</a> enabled which will detect code that may not compile in the next edition.\nThese lints include instructions on how to modify the code to make it compatible on both the current and the next edition.\n<code class=\"hljs\">cargo fix</code> applies these changes to the source code, and then runs <code class=\"hljs\">cargo check</code> again to verify that the fixes work.\nIf the fixes fail, then it will back out the changes and display a warning.</p>\n<p>Changing the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code.\nIf the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing <code class=\"hljs\">Cargo.toml</code> to use the next edition.</p>\n<p>The lints that <code class=\"hljs\">cargo fix --edition</code> apply are part of a <a href=\"editions/../../rustc/lints/groups.html\">lint group</a>.\nFor example, when migrating from 2018 to 2021, Cargo uses the <code class=\"hljs\">rust-2021-compatibility</code> group of lints to fix the code.\nCheck the <a href=\"editions/advanced-migrations.html#partial-migration-with-broken-code\">Partial migration</a> section below for tips on using individual lints to help with migration.</p>\n<p><code class=\"hljs\">cargo fix</code> may run <code class=\"hljs\">cargo check</code> multiple times.\nFor example, after applying one set of fixes, this may trigger new warnings which require further fixes.\nCargo repeats this until no new warnings are generated.</p>\n<h2 id=\"migrating-multiple-configurations\"><a class=\"header\" href=\"#migrating-multiple-configurations\">Migrating multiple configurations</a></h2>\n<p><code class=\"hljs\">cargo fix</code> can only work with a single configuration at a time.\nIf you use <a href=\"editions/../../cargo/reference/features.html\">Cargo features</a> or <a href=\"editions/../../reference/conditional-compilation.html\">conditional compilation</a>, then you may need to run <code class=\"hljs\">cargo fix</code> multiple times with different flags.</p>\n<p>For example, if you have code that uses <code class=\"hljs\">#[cfg]</code> attributes to include different code for different platforms, you may need to run <code class=\"hljs\">cargo fix</code> with the <code class=\"hljs\">--target</code> option to fix for different targets.\nThis may require moving your code between machines if you don't have cross-compiling available.</p>\n<p>Similarly, if you have conditions on Cargo features, like <code class=\"hljs\">#[cfg(feature = \"my-optional-thing\")]</code>, it is recommended to use the <code class=\"hljs\">--all-features</code> flag to allow <code class=\"hljs\">cargo fix</code> to migrate all the code behind those feature gates.\nIf you want to migrate feature code individually, you can use the <code class=\"hljs\">--features</code> flag to migrate one at a time.</p>\n<h2 id=\"migrating-a-large-project-or-workspace\"><a class=\"header\" href=\"#migrating-a-large-project-or-workspace\">Migrating a large project or workspace</a></h2>\n<p>You can migrate a large project incrementally to make the process easier if you run into problems.</p>\n<p>In a <a href=\"editions/../../cargo/reference/workspaces.html\">Cargo workspace</a>, each package defines its own edition, so the process naturally involves migrating one package at a time.</p>\n<p>Within a <a href=\"editions/../../cargo/reference/manifest.html#the-package-section\">Cargo package</a>, you can either migrate the entire package at once, or migrate individual <a href=\"editions/../../cargo/reference/cargo-targets.html\">Cargo targets</a> one at a time.\nFor example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with <code class=\"hljs\">cargo fix --edition</code> to migrate just that one target.\nBy default, <code class=\"hljs\">cargo fix</code> uses <code class=\"hljs\">--all-targets</code>.</p>\n<p>For even more advanced cases, you can specify the edition for each individual target in <code class=\"hljs\">Cargo.toml</code> like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[[bin]]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"my-binary\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2018\"</span>\n</code></pre>\n<p>This usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.</p>\n<h2 id=\"partial-migration-with-broken-code\"><a class=\"header\" href=\"#partial-migration-with-broken-code\">Partial migration with broken code</a></h2>\n<p>Sometimes the fixes suggested by the compiler may fail to work.\nWhen this happens, Cargo will report a warning indicating what happened and what the error was.\nHowever, by default it will automatically back out the changes it made.\nIt can be helpful to keep the code in the broken state and manually resolve the issue.\nSome of the fixes may have been correct, and the broken fix may be <em>mostly</em> correct, but just need minor tweaking.</p>\n<p>In this situation, use the <code class=\"hljs\">--broken-code</code> option with <code class=\"hljs\">cargo fix</code> to tell Cargo not to back out the changes.\nThen, you can go manually inspect the error and investigate what is needed to fix it.</p>\n<p>Another option to incrementally migrate a project is to apply individual fixes separately, one at a time.\nYou can do this by adding the individual lints as warnings, and then either running <code class=\"hljs\">cargo fix</code> (without the <code class=\"hljs\">--edition</code> flag) or using your editor or IDE to apply its suggestions if it supports \"Quick Fixes\".</p>\n<p>For example, the 2018 edition uses the <a href=\"editions/../../rustc/lints/listing/allowed-by-default.html#keyword-idents\"><code class=\"hljs\">keyword-idents</code></a> lint to fix any conflicting keywords.\nYou can add <code class=\"hljs\">#![warn(keyword_idents)]</code> to the top of each crate (like at the top of <code class=\"hljs\">src/lib.rs</code> or <code class=\"hljs\">src/main.rs</code>).\nThen, running <code class=\"hljs\">cargo fix</code> will apply just the suggestions for that lint.</p>\n<p>You can see the list of lints enabled for each edition in the <a href=\"editions/../../rustc/lints/groups.html\">lint group</a> page, or run the <code class=\"hljs\">rustc -Whelp</code> command.</p>\n<h2 id=\"migrating-macros\"><a class=\"header\" href=\"#migrating-macros\">Migrating macros</a></h2>\n<p>Some macros may require manual work to fix them for the next edition.\nFor example, <code class=\"hljs\">cargo fix --edition</code> may not be able to automatically fix a macro that generates syntax that does not work in the next edition.</p>\n<p>This may be a problem for both <a href=\"editions/../../reference/procedural-macros.html\">proc macros</a> and <code class=\"hljs\">macro_rules</code>-style macros.\n<code class=\"hljs\">macro_rules</code> macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot.\nProc macros in general cannot be automatically fixed at all.</p>\n<p>For example, if we migrate a crate containing this (contrived) macro <code class=\"hljs\">foo</code> from 2015 to 2018, <code class=\"hljs\">foo</code> would not be automatically fixed.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> foo {\n    () =&gt; {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">dyn</span> = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"it is {}\"</span>, <span class=\"hljs-keyword\">dyn</span>);\n    };\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>When this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below).\nIn 2015, <code class=\"hljs\">dyn</code> is a normal identifier and can be used without restriction.</p>\n<p>However, in 2018, <code class=\"hljs\">dyn</code> is no longer a valid identifier.\nWhen using <code class=\"hljs\">cargo fix --edition</code> to migrate to 2018, Cargo won't display any warnings or errors at all.\nHowever, <code class=\"hljs\">foo</code> won't work when called from any crate.</p>\n<p>If you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax.\nYou may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere.\nIf you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.</p>\n<h3 id=\"macro-hygiene\"><a class=\"header\" href=\"#macro-hygiene\">Macro hygiene</a></h3>\n<p>Macros use a system called \"edition hygiene\" where the tokens within a macro are marked with which edition they come from.\nThis allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.</p>\n<p>Let's take a closer look at the example above that defines a <code class=\"hljs\">macro_rules</code> macro using <code class=\"hljs\">dyn</code> as an identifier.\nIf that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where <code class=\"hljs\">dyn</code> is a keyword and that would normally be a syntax error.\nThe <code class=\"hljs\">let dyn = 1;</code> tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded.\nThe parser looks at the edition of the tokens to know how to interpret it.</p>\n<p>The problem arises when changing the edition to 2018 in the crate where it is defined.\nNow, those tokens are tagged with the 2018 edition, and those will fail to parse.\nHowever, since we never called the macro from our crate, <code class=\"hljs\">cargo fix --edition</code> never had a chance to inspect the macro and fix it.</p>\n<!-- TODO: hopefully someday, the reference will have chapters on how expansion works, and this can link there for actual details. -->\n<h2 id=\"documentation-tests\"><a class=\"header\" href=\"#documentation-tests\">Documentation tests</a></h2>\n<p>At this time, <code class=\"hljs\">cargo fix</code> is not able to update <a href=\"editions/../../rustdoc/documentation-tests.html\">documentation tests</a>.\nAfter updating the edition in <code class=\"hljs\">Cargo.toml</code>, you should run <code class=\"hljs\">cargo test</code> to ensure everything still passes.\nIf your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.</p>\n<p>In rare cases, you can manually set the edition for each test.\nFor example, you can use the <a href=\"editions/../../rustdoc/documentation-tests.html#attributes\"><code class=\"hljs\">edition2018</code> annotation</a> on the triple backticks to tell <code class=\"hljs\">rustdoc</code> which edition to use.</p>\n<h2 id=\"generated-code\"><a class=\"header\" href=\"#generated-code\">Generated code</a></h2>\n<p>Another area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see <a href=\"editions/../../cargo/reference/build-script-examples.html#code-generation\">Code generation</a> for an example).\nIn this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.</p>\n<h2 id=\"migrating-non-cargo-projects\"><a class=\"header\" href=\"#migrating-non-cargo-projects\">Migrating non-Cargo projects</a></h2>\n<p>If your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition.\nYou can enable the migration lints as described above by enabling the appropriate <a href=\"editions/../../rustc/lints/groups.html\">lint group</a>.\nFor example, you can use the <code class=\"hljs\">#![warn(rust_2021_compatibility)]</code> attribute or the <code class=\"hljs\">-Wrust-2021-compatibility</code> or <code class=\"hljs\">--force-warns=rust-2021-compatibility</code> <a href=\"editions/../../rustc/lints/levels.html#via-compiler-flag\">CLI flag</a>.</p>\n<p>The next step is to apply those lints to your code.\nThere are several options here:</p>\n<ul>\n<li>Manually read the warnings and apply the suggestions recommended by the compiler.</li>\n<li>Use an editor or IDE that supports automatically applying suggestions.\nFor example, <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a> with the <a href=\"https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer\">Rust Analyzer extension</a> has the ability to use the \"Quick Fix\" links to automatically apply suggestions.\nMany other editors and IDEs have similar functionality.</li>\n<li>Write a migration tool using the <a href=\"https://crates.io/crates/rustfix\"><code class=\"hljs\">rustfix</code></a> library.\nThis is the library that Cargo uses internally to take the <a href=\"editions/../../rustc/json.html\">JSON messages</a> from the compiler and modify the source code.\nCheck the <a href=\"https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples\"><code class=\"hljs\">examples</code> directory</a> for examples of how to use the library.</li>\n</ul>\n<h2 id=\"writing-idiomatic-code-in-a-new-edition\"><a class=\"header\" href=\"#writing-idiomatic-code-in-a-new-edition\">Writing idiomatic code in a new edition</a></h2>\n<p>Editions are not only about new features and removing old ones.\nIn any programming language, idioms change over time, and Rust is no exception.\nWhile old code will continue to compile, it might be written with different idioms today.</p>\n<p>For example, in Rust 2015, external crates must be listed with <code class=\"hljs\">extern crate</code> like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// src/lib.rs</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> rand;</code></pre>\n<p>In Rust 2018, it is <a href=\"editions/../rust-2018/path-changes.html#no-more-extern-crate\">no longer necessary</a> to include these items.</p>\n<p><code class=\"hljs\">cargo fix</code> has the <code class=\"hljs\">--edition-idioms</code> option to automatically transition some of these idioms to the new syntax.</p>\n<blockquote>\n<p><strong>Warning</strong>: The current <em>\"idiom lints\"</em> are known to have some problems.\nThey may make incorrect suggestions which may fail to compile.\nThe current lints are:</p>\n<ul>\n<li>Edition 2018:\n<ul>\n<li><a href=\"editions/../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates\"><code class=\"hljs\">unused-extern-crates</code></a></li>\n<li><a href=\"editions/../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements\"><code class=\"hljs\">explicit-outlives-requirements</code></a></li>\n</ul>\n</li>\n<li>Edition 2021 does not have any idiom lints.</li>\n</ul>\n<p>The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs!\nIf you run into problems, you can try the <code class=\"hljs\">--broken-code</code> option <a href=\"editions/advanced-migrations.html#partial-migration-with-broken-code\">described above</a> to make as much progress as possible, and then resolve the remaining issues manually.</p>\n</blockquote>\n<p>With that out of the way, we can instruct Cargo to fix our code snippet with:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\">cargo fix --edition-idioms\n</code></pre>\n<p>Afterwards, the line with <code class=\"hljs\">extern crate rand;</code> in <code class=\"hljs\">src/lib.rs</code> will be removed.</p>\n<p>We're now more idiomatic, and we didn't have to fix our code manually!</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"rust-2015\"><a class=\"header\" href=\"#rust-2015\">Rust 2015</a></h1>\n<p>Rust 2015 has a theme of \"stability\". It commenced with the release of 1.0,\nand is the \"default edition\". The edition system was conceived in late 2017,\nbut Rust 1.0 was released in May of 2015. As such, 2015 is the edition\nthat you get when you don't specify any particular edition, for backwards\ncompatibility reasons.</p>\n<p>\"Stability\" is the theme of Rust 2015 because 1.0 marked a huge change in\nRust development. Previous to Rust 1.0, Rust was changing on a daily basis.\nThis made it very difficult to write large software in Rust, and made it\ndifficult to learn. With the release of Rust 1.0 and Rust 2015, we committed\nto backwards compatibility, ensuring a solid foundation for people to build\nprojects on top of.</p>\n<p>Since it's the default edition, there's no way to port your code to Rust\n2015; it just <em>is</em>. You'll be transitioning <em>away</em> from 2015, but never\nreally <em>to</em> 2015. As such, there's not much else to say about it!</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"rust-2018\"><a class=\"header\" href=\"#rust-2018\">Rust 2018</a></h1>\n<div class=\"table-wrapper\"><table><thead><tr><th>Info</th><th></th></tr></thead><tbody>\n<tr><td>RFC</td><td><a href=\"https://rust-lang.github.io/rfcs/2052-epochs.html\">#2052</a>, which also proposed the Edition system</td></tr>\n<tr><td>Release version</td><td><a href=\"https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html\">1.31.0</a></td></tr>\n</tbody></table>\n</div>\n<p>The edition system was created for the release of Rust 2018. The release of the Rust 2018 edition coincided with a number of other features all coordinated around the theme of <em>productivity</em>. The majority of those features were backwards compatible and are now available on all editions; however, some of those changes required the edition mechanism (most notably the <a href=\"rust-2018/path-changes.html\">module system changes</a>).</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"path-and-module-system-changes\"><a class=\"header\" href=\"#path-and-module-system-changes\">Path and module system changes</a></h1>\n<p><img src=\"https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg\" alt=\"Minimum Rust version: 1.31\"></p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<ul>\n<li>Paths in <code class=\"hljs\">use</code> declarations now work the same as other paths.</li>\n<li>Paths starting with <code class=\"hljs\">::</code> must now be followed with an external crate.</li>\n<li>Paths in <code class=\"hljs\">pub(in path)</code> visibility modifiers must now start with <code class=\"hljs\">crate</code>, <code class=\"hljs\">self</code>, or <code class=\"hljs\">super</code>.</li>\n</ul>\n<h2 id=\"motivation\"><a class=\"header\" href=\"#motivation\">Motivation</a></h2>\n<p>The module system is often one of the hardest things for people new to Rust. Everyone\nhas their own things that take time to master, of course, but there's a root\ncause for why it's so confusing to many: while there are simple and\nconsistent rules defining the module system, their consequences can feel\ninconsistent, counterintuitive and mysterious.</p>\n<p>As such, the 2018 edition of Rust introduces a few new module system\nfeatures, but they end up <em>simplifying</em> the module system, to make it more\nclear as to what is going on.</p>\n<p>Here's a brief summary:</p>\n<ul>\n<li><code class=\"hljs\">extern crate</code> is no longer needed in 99% of circumstances.</li>\n<li>The <code class=\"hljs\">crate</code> keyword refers to the current crate.</li>\n<li>Paths may start with a crate name, even within submodules.</li>\n<li>Paths starting with <code class=\"hljs\">::</code> must reference an external crate.</li>\n<li>A <code class=\"hljs\">foo.rs</code> and <code class=\"hljs\">foo/</code> subdirectory may coexist; <code class=\"hljs\">mod.rs</code> is no longer needed\nwhen placing submodules in a subdirectory.</li>\n<li>Paths in <code class=\"hljs\">use</code> declarations work the same as other paths.</li>\n</ul>\n<p>These may seem like arbitrary new rules when put this way, but the mental\nmodel is now significantly simplified overall. Read on for more details!</p>\n<h2 id=\"more-details\"><a class=\"header\" href=\"#more-details\">More details</a></h2>\n<p>Let's talk about each new feature in turn.</p>\n<h3 id=\"no-more-extern-crate\"><a class=\"header\" href=\"#no-more-extern-crate\">No more <code>extern crate</code></a></h3>\n<p>This one is quite straightforward: you no longer need to write <code class=\"hljs\">extern crate</code> to\nimport a crate into your project. Before:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2015</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> futures;\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-keyword\">use</span> futures::Future;\n}</code></pre>\n<p>After:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-keyword\">use</span> futures::Future;\n}</code></pre>\n<p>Now, to add a new crate to your project, you can add it to your <code class=\"hljs\">Cargo.toml</code>,\nand then there is no step two. If you're not using Cargo, you already had to pass\n<code class=\"hljs\">--extern</code> flags to give <code class=\"hljs\">rustc</code> the location of external crates, so you'd just\nkeep doing what you were doing there as well.</p>\n<blockquote>\n<p>One small note here: <code class=\"hljs\">cargo fix</code> will not currently automate this change. We may\nhave it do this for you in the future.</p>\n</blockquote>\n<h4 id=\"an-exception\"><a class=\"header\" href=\"#an-exception\">An exception</a></h4>\n<p>There's one exception to this rule, and that's the \"sysroot\" crates. These are the\ncrates distributed with Rust itself.</p>\n<p>Usually these are only needed in very specialized situations. Starting in\n1.41, <code class=\"hljs\">rustc</code> accepts the <code class=\"hljs\">--extern=CRATE_NAME</code> flag which automatically adds\nthe given crate name in a way similar to <code class=\"hljs\">extern crate</code>. Build tools may use\nthis to inject sysroot crates into the crate's prelude. Cargo does not have a\ngeneral way to express this, though it uses it for <code class=\"hljs\">proc_macro</code> crates.</p>\n<p>Some examples of needing to explicitly import sysroot crates are:</p>\n<ul>\n<li><a href=\"rust-2018/../../std/index.html\"><code class=\"hljs\">std</code></a>: Usually this is not necessary, because <code class=\"hljs\">std</code> is automatically\nimported unless the crate is marked with <a href=\"rust-2018/../../reference/names/preludes.html#the-no_std-attribute\"><code class=\"hljs\">#![no_std]</code></a>.</li>\n<li><a href=\"rust-2018/../../core/index.html\"><code class=\"hljs\">core</code></a>: Usually this is not necessary, because <code class=\"hljs\">core</code> is automatically\nimported, unless the crate is marked with <a href=\"https://github.com/rust-lang/rust/issues/29639\"><code class=\"hljs\">#![no_core]</code></a>. For\nexample, some of the internal crates used by the standard library itself\nneed this.</li>\n<li><a href=\"rust-2018/../../proc_macro/index.html\"><code class=\"hljs\">proc_macro</code></a>: This is automatically imported by Cargo if it is a\nproc-macro crate starting in 1.42. <code class=\"hljs\">extern crate proc_macro;</code> would be\nneeded if you want to support older releases, or if using another build tool\nthat does not pass the appropriate <code class=\"hljs\">--extern</code> flags to <code class=\"hljs\">rustc</code>.</li>\n<li><a href=\"rust-2018/../../alloc/index.html\"><code class=\"hljs\">alloc</code></a>: Items in the <code class=\"hljs\">alloc</code> crate are usually accessed via re-exports in\nthe <code class=\"hljs\">std</code> crate. If you are working with a <code class=\"hljs\">no_std</code> crate that supports\nallocation, then you may need to explicitly import <code class=\"hljs\">alloc</code>.</li>\n<li><a href=\"rust-2018/../../test/index.html\"><code class=\"hljs\">test</code></a>: This is only available on the <a href=\"rust-2018/../../book/appendix-07-nightly-rust.html\">nightly channel</a>, and is usually\nonly used for the unstable benchmark support.</li>\n</ul>\n<h4 id=\"macros\"><a class=\"header\" href=\"#macros\">Macros</a></h4>\n<p>One other use for <code class=\"hljs\">extern crate</code> was to import macros; that's no longer needed.\nMacros may be imported with <code class=\"hljs\">use</code> like any other item. For example, the\nfollowing use of <code class=\"hljs\">extern crate</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-meta\">#[macro_use]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> bar;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    baz!();\n}</code></pre>\n<p>Can be changed to something like the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> bar::baz;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    baz!();\n}</code></pre>\n<h4 id=\"renaming-crates\"><a class=\"header\" href=\"#renaming-crates\">Renaming crates</a></h4>\n<p>If you've been using <code class=\"hljs\">as</code> to rename your crate like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> futures <span class=\"hljs-keyword\">as</span> f;\n\n<span class=\"hljs-keyword\">use</span> f::Future;</code></pre>\n<p>then removing the <code class=\"hljs\">extern crate</code> line on its own won't work. You'll need to do this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> futures <span class=\"hljs-keyword\">as</span> f;\n\n<span class=\"hljs-keyword\">use</span> self::f::Future;</code></pre>\n<p>This change will need to happen in any module that uses <code class=\"hljs\">f</code>.</p>\n<h3 id=\"the-crate-keyword-refers-to-the-current-crate\"><a class=\"header\" href=\"#the-crate-keyword-refers-to-the-current-crate\">The <code>crate</code> keyword refers to the current crate</a></h3>\n<p>In <code class=\"hljs\">use</code> declarations and in other code, you can refer to the root of the\ncurrent crate with the <code class=\"hljs\">crate::</code> prefix. For instance, <code class=\"hljs\">crate::foo::bar</code> will\nalways refer to the name <code class=\"hljs\">bar</code> inside the module <code class=\"hljs\">foo</code>, from anywhere else in\nthe same crate.</p>\n<p>The prefix <code class=\"hljs\">::</code> previously referred to either the crate root or an external\ncrate; it now unambiguously refers to an external crate. For instance,\n<code class=\"hljs\">::foo::bar</code> always refers to the name <code class=\"hljs\">bar</code> inside the external crate <code class=\"hljs\">foo</code>.</p>\n<h3 id=\"extern-crate-paths\"><a class=\"header\" href=\"#extern-crate-paths\">Extern crate paths</a></h3>\n<p>Previously, using an external crate in a module without a <code class=\"hljs\">use</code> import\nrequired a leading <code class=\"hljs\">::</code> on the path.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2015</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> chrono;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    <span class=\"hljs-comment\">// this works in the crate root</span>\n    <span class=\"hljs-keyword\">let</span> x = chrono::Utc::now();\n}\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-comment\">// but in a submodule it requires a leading :: if not imported with `use`</span>\n        <span class=\"hljs-keyword\">let</span> x = ::chrono::Utc::now();\n    }\n}</code></pre>\n<p>Now, extern crate names are in scope in the entire crate, including\nsubmodules.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>() {\n    <span class=\"hljs-comment\">// this works in the crate root</span>\n    <span class=\"hljs-keyword\">let</span> x = chrono::Utc::now();\n}\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">function</span></span>() {\n        <span class=\"hljs-comment\">// crates may be referenced directly, even in submodules</span>\n        <span class=\"hljs-keyword\">let</span> x = chrono::Utc::now();\n    }\n}</code></pre>\n<p>If you have a local module or item with the same name as an external crate, a\npath begining with that name will be taken to refer to the local module or\nitem. To explicitly refer to the external crate, use the <code class=\"hljs\">::name</code> form.</p>\n<h3 id=\"no-more-modrs\"><a class=\"header\" href=\"#no-more-modrs\">No more <code>mod.rs</code></a></h3>\n<p>In Rust 2015, if you have a submodule:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// This `mod` declaration looks for the `foo` module in</span>\n<span class=\"hljs-comment\">// `foo.rs` or `foo/mod.rs`.</span>\n<span class=\"hljs-keyword\">mod</span> foo;</code></pre>\n<p>It can live in <code class=\"hljs\">foo.rs</code> or <code class=\"hljs\">foo/mod.rs</code>. If it has submodules of its own, it\n<em>must</em> be <code class=\"hljs\">foo/mod.rs</code>. So a <code class=\"hljs\">bar</code> submodule of <code class=\"hljs\">foo</code> would live at\n<code class=\"hljs\">foo/bar.rs</code>.</p>\n<p>In Rust 2018 the restriction that a module with submodules must be named\n<code class=\"hljs\">mod.rs</code> is lifted. <code class=\"hljs\">foo.rs</code> can just be <code class=\"hljs\">foo.rs</code>,\nand the submodule is still <code class=\"hljs\">foo/bar.rs</code>. This eliminates the special\nname, and if you have a bunch of files open in your editor, you can clearly\nsee their names, instead of having a bunch of tabs named <code class=\"hljs\">mod.rs</code>.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Rust 2015</th>\n      <th>Rust 2018</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n<pre>.\n├── lib.rs\n└── foo/\n &nbsp;&nbsp; ├── mod.rs\n &nbsp;&nbsp; └── bar.rs\n</pre>\n    </td>\n    <td>\n<pre>.\n├── lib.rs\n├── foo.rs\n└── foo/\n &nbsp;&nbsp; └── bar.rs\n</pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<h3 id=\"use-paths\"><a class=\"header\" href=\"#use-paths\"><code>use</code> paths</a></h3>\n<p><img src=\"https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg\" alt=\"Minimum Rust version: 1.32\"></p>\n<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust\n2015, paths work differently in <code class=\"hljs\">use</code> declarations than they do elsewhere. In\nparticular, paths in <code class=\"hljs\">use</code> declarations would always start from the crate\nroot, while paths in other code implicitly started from the current scope.\nThose differences didn't have any effect in the top-level module, which meant\nthat everything would seem straightforward until working on a project large\nenough to have submodules.</p>\n<p>In Rust 2018, paths in <code class=\"hljs\">use</code> declarations and in other code work the same way,\nboth in the top-level module and in any submodule. You can use a relative path\nfrom the current scope, a path starting from an external crate name, or a path\nstarting with <code class=\"hljs\">::</code>, <code class=\"hljs\">crate</code>, <code class=\"hljs\">super</code>, or <code class=\"hljs\">self</code>.</p>\n<p>Code that looked like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2015</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> futures;\n\n<span class=\"hljs-keyword\">use</span> futures::Future;\n\n<span class=\"hljs-keyword\">mod</span> foo {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>;\n}\n\n<span class=\"hljs-keyword\">use</span> foo::Bar;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_poll</span></span>() -&gt; futures::Poll { ... }\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">SomeEnum</span></span> {\n    V1(<span class=\"hljs-built_in\">usize</span>),\n    V2(<span class=\"hljs-built_in\">String</span>),\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">func</span></span>() {\n    <span class=\"hljs-keyword\">let</span> five = std::sync::Arc::new(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">use</span> SomeEnum::*;\n    <span class=\"hljs-keyword\">match</span> ... {\n        V1(i) =&gt; { ... }\n        V2(s) =&gt; { ... }\n    }\n}</code></pre>\n<p>will look exactly the same in Rust 2018, except that you can delete the <code class=\"hljs\">extern crate</code> line:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-keyword\">use</span> futures::Future;\n\n<span class=\"hljs-keyword\">mod</span> foo {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>;\n}\n\n<span class=\"hljs-keyword\">use</span> foo::Bar;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_poll</span></span>() -&gt; futures::Poll { ... }\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">SomeEnum</span></span> {\n    V1(<span class=\"hljs-built_in\">usize</span>),\n    V2(<span class=\"hljs-built_in\">String</span>),\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">func</span></span>() {\n    <span class=\"hljs-keyword\">let</span> five = std::sync::Arc::new(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">use</span> SomeEnum::*;\n    <span class=\"hljs-keyword\">match</span> ... {\n        V1(i) =&gt; { ... }\n        V2(s) =&gt; { ... }\n    }\n}</code></pre>\n<p>The same code will also work completely unmodified in a submodule:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n\n<span class=\"hljs-keyword\">mod</span> submodule {\n    <span class=\"hljs-keyword\">use</span> futures::Future;\n\n    <span class=\"hljs-keyword\">mod</span> foo {\n        <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Bar</span></span>;\n    }\n\n    <span class=\"hljs-keyword\">use</span> foo::Bar;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_poll</span></span>() -&gt; futures::Poll { ... }\n\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">SomeEnum</span></span> {\n        V1(<span class=\"hljs-built_in\">usize</span>),\n        V2(<span class=\"hljs-built_in\">String</span>),\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">func</span></span>() {\n        <span class=\"hljs-keyword\">let</span> five = std::sync::Arc::new(<span class=\"hljs-number\">5</span>);\n        <span class=\"hljs-keyword\">use</span> SomeEnum::*;\n        <span class=\"hljs-keyword\">match</span> ... {\n            V1(i) =&gt; { ... }\n            V2(s) =&gt; { ... }\n        }\n    }\n}</code></pre>\n<p>This makes it easy to move code around in a project, and avoids introducing\nadditional complexity to multi-module projects.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"anonymous-trait-function-parameters-deprecated\"><a class=\"header\" href=\"#anonymous-trait-function-parameters-deprecated\">Anonymous trait function parameters deprecated</a></h1>\n<p><img src=\"https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg\" alt=\"Minimum Rust version: 1.31\"></p>\n<h2 id=\"summary-1\"><a class=\"header\" href=\"#summary-1\">Summary</a></h2>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns\">Trait function parameters</a> may use any irrefutable pattern when the function has a body.</li>\n</ul>\n<h2 id=\"details\"><a class=\"header\" href=\"#details\">Details</a></h2>\n<p>In accordance with RFC <a href=\"https://github.com/rust-lang/rfcs/pull/1685\">#1685</a>,\nparameters in trait method declarations are no longer allowed to be anonymous.</p>\n<p>For example, in the 2015 edition, this was allowed:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, <span class=\"hljs-built_in\">u8</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In the 2018 edition, all parameters must be given an argument name  (even if it's just\n<code class=\"hljs\">_</code>):</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foo</span></span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">foo</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, baz: <span class=\"hljs-built_in\">u8</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"new-keywords\"><a class=\"header\" href=\"#new-keywords\">New keywords</a></h1>\n<p><img src=\"https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg\" alt=\"Minimum Rust version: 1.27\"></p>\n<h2 id=\"summary-2\"><a class=\"header\" href=\"#summary-2\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">dyn</code> is a <a href=\"https://doc.rust-lang.org/reference/keywords.html#strict-keywords\">strict keyword</a>, in 2015 it is a <a href=\"https://doc.rust-lang.org/reference/keywords.html#weak-keywords\">weak keyword</a>.</li>\n<li><code class=\"hljs\">async</code> and <code class=\"hljs\">await</code> are <a href=\"https://doc.rust-lang.org/reference/keywords.html#strict-keywords\">strict keywords</a>.</li>\n<li><code class=\"hljs\">try</code> is a <a href=\"https://doc.rust-lang.org/reference/keywords.html#reserved-keywords\">reserved keyword</a>.</li>\n</ul>\n<h2 id=\"motivation-1\"><a class=\"header\" href=\"#motivation-1\">Motivation</a></h2>\n<h3 id=\"dyn-trait-for-trait-objects\"><a class=\"header\" href=\"#dyn-trait-for-trait-objects\"><code>dyn Trait</code> for trait objects</a></h3>\n<p>The <code class=\"hljs\">dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>\n<ul>\n<li><code class=\"hljs\">Box&lt;Trait&gt;</code> becomes <code class=\"hljs\">Box&lt;dyn Trait&gt;</code></li>\n<li><code class=\"hljs\">&amp;Trait</code> and <code class=\"hljs\">&amp;mut Trait</code> become <code class=\"hljs\">&amp;dyn Trait</code> and <code class=\"hljs\">&amp;mut dyn Trait</code></li>\n</ul>\n<p>And so on. In code:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Trait</span></span> {}\n\n<span class=\"hljs-keyword\">impl</span> Trait <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">i32</span> {}\n\n<span class=\"hljs-comment\">// old</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">function1</span></span>() -&gt; <span class=\"hljs-built_in\">Box</span>&lt;Trait&gt; {\n<span class=\"boring\"><span class=\"hljs-built_in\">unimplemented!</span>()\n</span>}\n\n<span class=\"hljs-comment\">// new</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">function2</span></span>() -&gt; <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> Trait&gt; {\n<span class=\"boring\"><span class=\"hljs-built_in\">unimplemented!</span>()\n</span>}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>That's it!</p>\n<h4 id=\"why\"><a class=\"header\" href=\"#why\">Why?</a></h4>\n<p>Using just the trait name for trait objects turned out to be a bad decision.\nThe current syntax is often ambiguous and confusing, even to veterans,\nand favors a feature that is not more frequently used than its alternatives,\nis sometimes slower, and often cannot be used at all when its alternatives can.</p>\n<p>Furthermore, with <code class=\"hljs\">impl Trait</code> arriving, \"<code class=\"hljs\">impl Trait</code> vs <code class=\"hljs\">dyn Trait</code>\" is much\nmore symmetric, and therefore a bit nicer, than \"<code class=\"hljs\">impl Trait</code> vs <code class=\"hljs\">Trait</code>\".\n<code class=\"hljs\">impl Trait</code> is explained <a href=\"rust-2018/../../rust-by-example/trait/impl_trait.html\">here</a>.</p>\n<p>In the new edition, you should therefore prefer <code class=\"hljs\">dyn Trait</code> to just <code class=\"hljs\">Trait</code>\nwhere you need a trait object.</p>\n<h3 id=\"async-and-await\"><a class=\"header\" href=\"#async-and-await\"><code>async</code> and <code>await</code></a></h3>\n<p>These keywords are reserved to implement the async-await feature of Rust, which was ultimately <a href=\"https://blog.rust-lang.org/2019/11/07/Async-await-stable.html\">released to stable in 1.39.0</a>.</p>\n<h3 id=\"try-keyword\"><a class=\"header\" href=\"#try-keyword\"><code>try</code> keyword</a></h3>\n<p>The <code class=\"hljs\">try</code> keyword is reserved for use in <code class=\"hljs\">try</code> blocks, which have not (as of this writing) been stabilized (<a href=\"https://github.com/rust-lang/rust/issues/31436\">tracking issue</a>)</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"method-dispatch-for-raw-pointers-to-inference-variables\"><a class=\"header\" href=\"#method-dispatch-for-raw-pointers-to-inference-variables\">Method dispatch for raw pointers to inference variables</a></h1>\n<h2 id=\"summary-3\"><a class=\"header\" href=\"#summary-3\">Summary</a></h2>\n<ul>\n<li>The <a href=\"https://github.com/rust-lang/rust/issues/46906\"><code class=\"hljs\">tyvar_behind_raw_pointer</code></a> lint is now a hard error.</li>\n</ul>\n<h2 id=\"details-1\"><a class=\"header\" href=\"#details-1\">Details</a></h2>\n<p>See Rust issue <a href=\"https://github.com/rust-lang/rust/issues/46906\">#46906</a> for details.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"cargo-changes\"><a class=\"header\" href=\"#cargo-changes\">Cargo changes</a></h1>\n<h2 id=\"summary-4\"><a class=\"header\" href=\"#summary-4\">Summary</a></h2>\n<ul>\n<li>If there is a target definition in a <code class=\"hljs\">Cargo.toml</code> manifest, it no longer\nautomatically disables automatic discovery of other targets.</li>\n<li>Target paths of the form <code class=\"hljs\">src/{target_name}.rs</code> are no longer inferred for\ntargets where the <code class=\"hljs\">path</code> field is not set.</li>\n<li><code class=\"hljs\">cargo install</code> for the current directory is no longer allowed, you must\nspecify <code class=\"hljs\">cargo install --path .</code> to install the current package.</li>\n</ul>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"rust-2021\"><a class=\"header\" href=\"#rust-2021\">Rust 2021</a></h1>\n<div class=\"table-wrapper\"><table><thead><tr><th>Info</th><th></th></tr></thead><tbody>\n<tr><td>RFC</td><td><a href=\"https://github.com/rust-lang/rfcs/pull/3085\">#3085</a></td></tr>\n<tr><td>Release version</td><td>1.56.0</td></tr>\n</tbody></table>\n</div>\n<p>The Rust 2021 Edition contains several changes that bring new capabilities and more consistency to the language,\nand opens up room for expansion in the future.\nThe following chapters dive into the details of each change,\nand they include guidance on migrating your existing code.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"additions-to-the-prelude\"><a class=\"header\" href=\"#additions-to-the-prelude\">Additions to the prelude</a></h1>\n<h2 id=\"summary-5\"><a class=\"header\" href=\"#summary-5\">Summary</a></h2>\n<ul>\n<li>The <code class=\"hljs\">TryInto</code>, <code class=\"hljs\">TryFrom</code> and <code class=\"hljs\">FromIterator</code> traits are now part of the prelude.</li>\n<li>This might make calls to trait methods ambiguous which could make some code fail to compile.</li>\n</ul>\n<h2 id=\"details-2\"><a class=\"header\" href=\"#details-2\">Details</a></h2>\n<p>The <a href=\"https://doc.rust-lang.org/stable/std/prelude/index.html\">prelude of the standard library</a>\nis the module containing everything that is automatically imported in every module.\nIt contains commonly used items such as <code class=\"hljs\">Option</code>, <code class=\"hljs\">Vec</code>, <code class=\"hljs\">drop</code>, and <code class=\"hljs\">Clone</code>.</p>\n<p>The Rust compiler prioritizes any manually imported items over those\nfrom the prelude, to make sure additions to the prelude will not break any existing code.\nFor example, if you have a crate or module called <code class=\"hljs\">example</code> containing a <code class=\"hljs\">pub struct Option;</code>,\nthen <code class=\"hljs\">use example::*;</code> will make <code class=\"hljs\">Option</code> unambiguously refer to the one from <code class=\"hljs\">example</code>;\nnot the one from the standard library.</p>\n<p>However, adding a <em>trait</em> to the prelude can break existing code in a subtle way.\nFor example, a call to <code class=\"hljs\">x.try_into()</code> which comes from a <code class=\"hljs\">MyTryInto</code> trait might fail\nto compile if <code class=\"hljs\">std</code>'s <code class=\"hljs\">TryInto</code> is also imported, because the call to <code class=\"hljs\">try_into</code> is now\nambiguous and could come from either trait. This is the reason we haven't added <code class=\"hljs\">TryInto</code>\nto the prelude yet, since there is a lot of code that would break this way.</p>\n<p>As a solution, Rust 2021 will use a new prelude.\nIt's identical to the current one, except for three new additions:</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html\"><code class=\"hljs\">std::convert::TryInto</code></a></li>\n<li><a href=\"https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html\"><code class=\"hljs\">std::convert::TryFrom</code></a></li>\n<li><a href=\"https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html\"><code class=\"hljs\">std::iter::FromIterator</code></a></li>\n</ul>\n<p>The tracking issue <a href=\"https://github.com/rust-lang/rust/issues/85684\">can be found here</a>.</p>\n<h2 id=\"migration\"><a class=\"header\" href=\"#migration\">Migration</a></h2>\n<p>As a part of the 2021 edition a migration lint, <code class=\"hljs\">rust_2021_prelude_collisions</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>\n<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.</p>\n<p>If you'd like to migrate your code manually or better understand what <code class=\"hljs\">cargo fix</code> is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.</p>\n<h3 id=\"migration-needed\"><a class=\"header\" href=\"#migration-needed\">Migration needed</a></h3>\n<h4 id=\"conflicting-trait-methods\"><a class=\"header\" href=\"#conflicting-trait-methods\">Conflicting trait methods</a></h4>\n<p>When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MyTrait</span></span>&lt;A&gt; {\n  <span class=\"hljs-comment\">// This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  </span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">from_iter</span></span>(x: <span class=\"hljs-built_in\">Option</span>&lt;A&gt;);\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyTrait&lt;()&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">Vec</span>&lt;T&gt; {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">from_iter</span></span>(_: <span class=\"hljs-built_in\">Option</span>&lt;()&gt;) {}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n  <span class=\"hljs-comment\">// Vec&lt;T&gt; implements both `std::iter::FromIterator` and `MyTrait` </span>\n  <span class=\"hljs-comment\">// If both traits are in scope (as would be the case in Rust 2021),</span>\n  <span class=\"hljs-comment\">// then it becomes ambiguous which `from_iter` method to call</span>\n  &lt;<span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt;&gt;::from_iter(<span class=\"hljs-literal\">None</span>);\n}</code></pre></pre>\n<p>We can fix this by using fully qualified syntax:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n  <span class=\"hljs-comment\">// Now it is clear which trait method we're referring to</span>\n  &lt;<span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; <span class=\"hljs-keyword\">as</span> MyTrait&lt;()&gt;&gt;::from_iter(<span class=\"hljs-literal\">None</span>);\n}</code></pre>\n<h4 id=\"inherent-methods-on-dyn-trait-objects\"><a class=\"header\" href=\"#inherent-methods-on-dyn-trait-objects\">Inherent methods on <code>dyn Trait</code> objects</a></h4>\n<p>Some users invoke methods on a <code class=\"hljs\">dyn Trait</code> value where the method name overlaps with a new prelude trait:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">mod</span> submodule {\n  <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MyTrait</span></span> {\n    <span class=\"hljs-comment\">// This has the same name as `TryInto::try_into`</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">try_into</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;<span class=\"hljs-built_in\">u32</span>, ()&gt;;\n  }\n}\n\n<span class=\"hljs-comment\">// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bar</span></span>(f: <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> submodule::MyTrait&gt;) {\n  <span class=\"hljs-comment\">// If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),</span>\n  <span class=\"hljs-comment\">// then it becomes ambiguous which `try_into` method to call</span>\n  f.try_into();\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works\nas long as there is no trait in scope with a conflicting method name. When the <code class=\"hljs\">TryInto</code> trait is in scope (which is the case in Rust 2021),\nthis causes an ambiguity. Should the call be to <code class=\"hljs\">MyTrait::try_into</code> or <code class=\"hljs\">std::convert::TryInto::try_into</code>?</p>\n<p>In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that\nthe <code class=\"hljs\">dyn Trait</code> method is chosen, versus the methods from the prelude trait. For example, turning <code class=\"hljs\">f.try_into()</code> above into <code class=\"hljs\">(&amp;*f).try_into()</code>\nensures that we're calling <code class=\"hljs\">try_into</code> on the <code class=\"hljs\">dyn MyTrait</code> which can only refer to the <code class=\"hljs\">MyTrait::try_into</code> method.</p>\n<h3 id=\"no-migration-needed\"><a class=\"header\" href=\"#no-migration-needed\">No migration needed</a></h3>\n<h4 id=\"inherent-methods\"><a class=\"header\" href=\"#inherent-methods\">Inherent methods</a></h4>\n<p>Many types define their own inherent methods with the same name as a trait method. For instance, below the struct <code class=\"hljs\">MyStruct</code> implements <code class=\"hljs\">from_iter</code> which shares the same name with the method from the trait <code class=\"hljs\">FromIterator</code> found in the standard library:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::iter::<span class=\"hljs-built_in\">IntoIterator</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyStruct</span></span> {\n  data: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">u32</span>&gt;\n}\n\n<span class=\"hljs-keyword\">impl</span> MyStruct {\n  <span class=\"hljs-comment\">// This has the same name as `std::iter::FromIterator::from_iter`</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">from_iter</span></span>(iter: <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">IntoIterator</span>&lt;Item = <span class=\"hljs-built_in\">u32</span>&gt;) -&gt; <span class=\"hljs-keyword\">Self</span> {\n    <span class=\"hljs-keyword\">Self</span> {\n      data: iter.into_iter().collect()\n    }\n  }\n}\n\n<span class=\"hljs-keyword\">impl</span> std::iter::FromIterator&lt;<span class=\"hljs-built_in\">u32</span>&gt; <span class=\"hljs-keyword\">for</span> MyStruct {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">from_iter</span></span>&lt;I: <span class=\"hljs-built_in\">IntoIterator</span>&lt;Item = <span class=\"hljs-built_in\">u32</span>&gt;&gt;(iter: I) -&gt; <span class=\"hljs-keyword\">Self</span> {\n      <span class=\"hljs-keyword\">Self</span> {\n        data: iter.into_iter().collect()\n      }\n    }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Inherent methods always take precedent over trait methods so there's no need for any migration.</p>\n<h3 id=\"implementation-reference\"><a class=\"header\" href=\"#implementation-reference\">Implementation Reference</a></h3>\n<p>The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:</p>\n<ul>\n<li>Is the call a <a href=\"https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls\">fully-qualified call</a> or does it use <a href=\"https://doc.rust-lang.org/reference/expressions/method-call-expr.html\">dot-call method syntax</a>?\n<ul>\n<li>This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. <code class=\"hljs\">&lt;Type as Trait&gt;::method</code>)</li>\n</ul>\n</li>\n<li>Is this an <a href=\"https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations\">inherent method</a> or <a href=\"https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations\">a trait method</a>?\n<ul>\n<li>Inherent methods that take <code class=\"hljs\">self</code> will take priority over <code class=\"hljs\">TryInto::try_into</code> as inherent methods take priority over trait methods, but inherent methods that take <code class=\"hljs\">&amp;self</code> or <code class=\"hljs\">&amp;mut self</code> won't take priority due to requiring a auto-reference (while <code class=\"hljs\">TryInto::try_into</code> does not, as it takes <code class=\"hljs\">self</code>)</li>\n</ul>\n</li>\n<li>Is the origin of this method from <code class=\"hljs\">core</code>/<code class=\"hljs\">std</code>? (As the traits can't have a collision with themselves)</li>\n<li>Does the given type implement the trait it could have a collision against?</li>\n<li>Is the method being called via dynamic dispatch? (i.e. is the <code class=\"hljs\">self</code> type <code class=\"hljs\">dyn Trait</code>)\n<ul>\n<li>If so, trait imports don't affect resolution, and no migration lint needs to occur</li>\n</ul>\n</li>\n</ul>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"default-cargo-feature-resolver\"><a class=\"header\" href=\"#default-cargo-feature-resolver\">Default Cargo feature resolver</a></h1>\n<h2 id=\"summary-6\"><a class=\"header\" href=\"#summary-6\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">edition = \"2021\"</code> implies <code class=\"hljs\">resolver = \"2\"</code> in <code class=\"hljs\">Cargo.toml</code>.</li>\n</ul>\n<h2 id=\"details-3\"><a class=\"header\" href=\"#details-3\">Details</a></h2>\n<p>Since Rust 1.51.0, Cargo has opt-in support for a <a href=\"rust-2021/../../cargo/reference/resolver.html#feature-resolver-version-2\">new feature resolver</a>\nwhich can be activated with <code class=\"hljs\">resolver = \"2\"</code> in <code class=\"hljs\">Cargo.toml</code>.</p>\n<p>Starting in Rust 2021, this will be the default.\nThat is, writing <code class=\"hljs\">edition = \"2021\"</code> in <code class=\"hljs\">Cargo.toml</code> will imply <code class=\"hljs\">resolver = \"2\"</code>.</p>\n<p>The resolver is a global setting for a <a href=\"rust-2021/../../cargo/reference/workspaces.html\">workspace</a>, and the setting is ignored in dependencies.\nThe setting is only honored for the top-level package of the workspace.\nIf you are using a <a href=\"rust-2021/../../cargo/reference/workspaces.html#virtual-workspace\">virtual workspace</a>, you will still need to explicitly set the <a href=\"rust-2021/../../cargo/reference/resolver.html#resolver-versions\"><code class=\"hljs\">resolver</code> field</a>\nin the <code class=\"hljs\">[workspace]</code> definition if you want to opt-in to the new resolver.</p>\n<p>The new feature resolver no longer merges all requested features for\ncrates that are depended on in multiple ways.\nSee <a href=\"https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver\">the announcement of Rust 1.51</a> for details.</p>\n<h2 id=\"migration-1\"><a class=\"header\" href=\"#migration-1\">Migration</a></h2>\n<p>There are no automated migration tools for updating for the new resolver.\nFor most projects, there are usually few or no changes as a result of updating.</p>\n<p>When updating with <code class=\"hljs\">cargo fix --edition</code>, Cargo will display a report if the new resolver will build dependencies with different features.\nIt may look something like this:</p>\n<blockquote>\n<p>note: Switching to Edition 2021 will enable the use of the version 2 feature resolver in Cargo.\nThis may cause some dependencies to be built with fewer features enabled than previously.\nMore information about the resolver changes may be found at <a href=\"https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html\">https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html</a><br>\nWhen building the following dependencies, the given features will no longer be used:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">  bstr v0.2.16: default, lazy_static, regex-automata, unicode\n  libz-sys v1.1.3 (as host dependency): libc\n</code></pre>\n</blockquote>\n<p>This lets you know that certain dependencies will no longer be built with the given features.</p>\n<h3 id=\"build-failures\"><a class=\"header\" href=\"#build-failures\">Build failures</a></h3>\n<p>There may be some circumstances where your project may not build correctly after the change.\nIf a dependency declaration in one package assumes that certain features are enabled in another, and those features are now disabled, it may fail to compile.</p>\n<p>For example, let's say we have a dependency like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Cargo.toml</span>\n\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">bstr</span> = { version = <span class=\"hljs-string\">\"0.2.16\"</span>, default-features = <span class=\"hljs-literal\">false</span> }\n<span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<p>And somewhere in our dependency tree, another package has this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Another package's Cargo.toml</span>\n\n<span class=\"hljs-section\">[build-dependencies]</span>\n<span class=\"hljs-attr\">bstr</span> = <span class=\"hljs-string\">\"0.2.16\"</span>\n</code></pre>\n<p>In our package, we've been using the <a href=\"https://docs.rs/bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks\"><code class=\"hljs\">words_with_breaks</code></a> method from <code class=\"hljs\">bstr</code>, which requires <code class=\"hljs\">bstr</code>'s  \"unicode\" feature to be enabled.\nThis has historically worked because Cargo unified the features of <code class=\"hljs\">bstr</code> between the two packages.\nHowever, after updating to Rust 2021, the new resolver will build <code class=\"hljs\">bstr</code> twice, once with the default features (as a build dependency), and once with no features (as our normal dependency).\nSince <code class=\"hljs\">bstr</code> is now being built without the \"unicode\" feature, the <code class=\"hljs\">words_with_breaks</code> method doesn't exist, and the build will fail with an error that the method is missing.</p>\n<p>The solution here is to ensure that the dependency is declared with the features you are actually using.\nFor example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">bstr</span> = { version = <span class=\"hljs-string\">\"0.2.16\"</span>, default-features = <span class=\"hljs-literal\">false</span>, features = [<span class=\"hljs-string\">\"unicode\"</span>] }\n</code></pre>\n<p>In some cases, this may be a problem with a third-party dependency that you don't have direct control over.\nYou can consider submitting a patch to that project to try to declare the correct set of features for the problematic dependency.\nAlternatively, you can add features to any dependency from within your own <code class=\"hljs\">Cargo.toml</code> file.\nFor example, if the <code class=\"hljs\">bstr</code> example given above was declared in some third-party dependency, you can just copy the correct dependency declaration into your own project.\nThe features will be unified, as long as they match the unification rules of the new resolver. Those are:</p>\n<ul>\n<li>Features enabled on platform-specific dependencies for targets not currently being built are ignored.</li>\n<li>Build-dependencies and proc-macros do not share features with normal dependencies.</li>\n<li>Dev-dependencies do not activate features unless building a target that needs them (like tests or examples).</li>\n</ul>\n<p>A real-world example is using <a href=\"https://crates.io/crates/diesel\"><code class=\"hljs\">diesel</code></a> and <a href=\"https://crates.io/crates/diesel_migrations\"><code class=\"hljs\">diesel_migrations</code></a>.\nThese packages provide database support, and the database is selected using a feature, like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">diesel</span> = { version = <span class=\"hljs-string\">\"1.4.7\"</span>, features = [<span class=\"hljs-string\">\"postgres\"</span>] }\n<span class=\"hljs-attr\">diesel_migrations</span> = <span class=\"hljs-string\">\"1.4.0\"</span>\n</code></pre>\n<p>The problem is that <code class=\"hljs\">diesel_migrations</code> has an internal proc-macro which itself depends on <code class=\"hljs\">diesel</code>, and the proc-macro assumes its own copy of <code class=\"hljs\">diesel</code> has the same features enabled as the rest of the dependency graph.\nAfter updating to the new resolver, it fails to build because now there are two copies of <code class=\"hljs\">diesel</code>, and the one built for the proc-macro is missing the \"postgres\" feature.</p>\n<p>A solution here is to add <code class=\"hljs\">diesel</code> as a build-dependency with the required features, for example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[build-dependencies]</span>\n<span class=\"hljs-attr\">diesel</span> = { version = <span class=\"hljs-string\">\"1.4.7\"</span>, features = [<span class=\"hljs-string\">\"postgres\"</span>] }\n</code></pre>\n<p>This causes Cargo to add \"postgres\" as a feature for host dependencies (proc-macros and build-dependencies).\nNow, the <code class=\"hljs\">diesel_migrations</code> proc-macro will get the \"postgres\" feature enabled, and it will build correctly.</p>\n<p>The 2.0 release of <code class=\"hljs\">diesel</code> (currently in development) does not have this problem as it has been restructured to not have this dependency requirement.</p>\n<h3 id=\"exploring-features\"><a class=\"header\" href=\"#exploring-features\">Exploring features</a></h3>\n<p>The <a href=\"rust-2021/../../cargo/commands/cargo-tree.html\"><code class=\"hljs\">cargo tree</code></a> command has had substantial improvements to help with the migration to the new resolver.\n<code class=\"hljs\">cargo tree</code> can be used to explore the dependency graph, and to see which features are being enabled, and importantly <em>why</em> they are being enabled.</p>\n<p>One option is to use the <code class=\"hljs\">--duplicates</code> flag (<code class=\"hljs\">-d</code> for short), which will tell you when a package is being built multiple times.\nTaking the <code class=\"hljs\">bstr</code> example from earlier, we might see:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">&gt;</span><span class=\"bash\"> cargo tree -d</span>\nbstr v0.2.16\n└── foo v0.1.0 (/MyProjects/foo)\n\nbstr v0.2.16\n[build-dependencies]\n└── bar v0.1.0\n    └── foo v0.1.0 (/MyProjects/foo)\n\n</code></pre>\n<p>This output tells us that <code class=\"hljs\">bstr</code> is built twice, and shows the chain of dependencies that led to its inclusion in both cases.</p>\n<p>You can print which features each package is using with the <code class=\"hljs\">-f</code> flag, like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\">cargo tree -f '{p} {f}'\n</code></pre>\n<p>This tells Cargo to change the \"format\" of the output, where it will print both the package and the enabled features.</p>\n<p>You can also use the <code class=\"hljs\">-e</code> flag to tell it which \"edges\" to display.\nFor example, <code class=\"hljs\">cargo tree -e features</code> will show in-between each dependency which features are being added by each dependency.\nThis option becomes more useful with the <code class=\"hljs\">-i</code> flag which can be used to \"invert\" the tree.\nThis allows you to see how features <em>flow</em> into a given dependency.\nFor example, let's say the dependency graph is large, and we're not quite sure who is depending on <code class=\"hljs\">bstr</code>, the following command will show that:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">&gt;</span><span class=\"bash\"> cargo tree -e features -i bstr</span>\nbstr v0.2.16\n├── bstr feature \"default\"\n│   [build-dependencies]\n│   └── bar v0.1.0\n│       └── bar feature \"default\"\n│           └── foo v0.1.0 (/MyProjects/foo)\n├── bstr feature \"lazy_static\"\n│   └── bstr feature \"unicode\"\n│       └── bstr feature \"default\" (*)\n├── bstr feature \"regex-automata\"\n│   └── bstr feature \"unicode\" (*)\n├── bstr feature \"std\"\n│   └── bstr feature \"default\" (*)\n└── bstr feature \"unicode\" (*)\n</code></pre>\n<p>This snippet of output shows that the project <code class=\"hljs\">foo</code> depends on <code class=\"hljs\">bar</code> with the \"default\" feature.\nThen, <code class=\"hljs\">bar</code> depends on <code class=\"hljs\">bstr</code> as a build-dependency with the \"default\" feature.\nWe can further see that <code class=\"hljs\">bstr</code>'s  \"default\" feature enables \"unicode\" (among other features).</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"intoiterator-for-arrays\"><a class=\"header\" href=\"#intoiterator-for-arrays\">IntoIterator for arrays</a></h1>\n<h2 id=\"summary-7\"><a class=\"header\" href=\"#summary-7\">Summary</a></h2>\n<ul>\n<li>Arrays implement <code class=\"hljs\">IntoIterator</code> in <em>all</em> editions.</li>\n<li>Calls to <code class=\"hljs\">IntoIterator::into_iter</code> are <em>hidden</em> in Rust 2015 and Rust 2018 when using method call syntax\n(i.e., <code class=\"hljs\">array.into_iter()</code>). So, <code class=\"hljs\">array.into_iter()</code> still resolves to <code class=\"hljs\">(&amp;array).into_iter()</code> as it\nhas before.</li>\n<li><code class=\"hljs\">array.into_iter()</code> changes meaning to be the call to <code class=\"hljs\">IntoIterator::into_iter</code> in Rust 2021.</li>\n</ul>\n<h2 id=\"details-4\"><a class=\"header\" href=\"#details-4\">Details</a></h2>\n<p>Until Rust 1.53, only <em>references</em> to arrays implement <code class=\"hljs\">IntoIterator</code>.\nThis means you can iterate over <code class=\"hljs\">&amp;[1, 2, 3]</code> and <code class=\"hljs\">&amp;mut [1, 2, 3]</code>,\nbut not over <code class=\"hljs\">[1, 2, 3]</code> directly.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">for</span> &amp;e <span class=\"hljs-keyword\">in</span> &amp;[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] {} <span class=\"hljs-comment\">// Ok :)</span>\n\n<span class=\"hljs-keyword\">for</span> e <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] {} <span class=\"hljs-comment\">// Error :(</span></code></pre>\n<p>This has been <a href=\"https://github.com/rust-lang/rust/issues/25725\">a long-standing issue</a>, but the solution is not as simple as it seems.\nJust <a href=\"https://github.com/rust-lang/rust/pull/65819\">adding the trait implementation</a> would break existing code.\n<code class=\"hljs\">array.into_iter()</code> already compiles today because that implicitly calls\n<code class=\"hljs\">(&amp;array).into_iter()</code> due to <a href=\"https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator\">how method call syntax works</a>.\nAdding the trait implementation would change the meaning.</p>\n<p>Usually this type of breakage (adding a trait implementation) is categorized as 'minor' and acceptable.\nBut in this case there is too much code that would be broken by it.</p>\n<p>It has been suggested many times to \"only implement <code class=\"hljs\">IntoIterator</code> for arrays in Rust 2021\".\nHowever, this is simply not possible.\nYou can't have a trait implementation exist in one edition and not in another,\nsince editions can be mixed.</p>\n<p>Instead, the trait implementation was added in <em>all</em> editions (starting in Rust 1.53.0)\nbut with a small hack to avoid breakage until Rust 2021.\nIn Rust 2015 and 2018 code, the compiler will still resolve <code class=\"hljs\">array.into_iter()</code>\nto <code class=\"hljs\">(&amp;array).into_iter()</code> like before, as if the trait implementation does not exist.\nThis <em>only</em> applies to the <code class=\"hljs\">.into_iter()</code> method call syntax.\nIt does not affect any other syntax such as <code class=\"hljs\">for e in [1, 2, 3]</code>, <code class=\"hljs\">iter.zip([1, 2, 3])</code> or\n<code class=\"hljs\">IntoIterator::into_iter([1, 2, 3])</code>.\nThose will start to work in <em>all</em> editions.</p>\n<p>While it's a shame that this required a small hack to avoid breakage,\nthis solution keeps the difference between the editions to an absolute minimum.</p>\n<h2 id=\"migration-2\"><a class=\"header\" href=\"#migration-2\">Migration</a></h2>\n<p>A lint, <code class=\"hljs\">array_into_iter</code>, gets triggered whenever there is some call to <code class=\"hljs\">into_iter()</code> that will change\nmeaning in Rust 2021. The <code class=\"hljs\">array_into_iter</code> lint has already been a warning by default on all editions\nsince the 1.41 release (with several enhancements made in 1.55). If your code is already warning free,\nthen it should already be ready to go for Rust 2021!</p>\n<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by\nrunning:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>Because the difference between editions is small, the migration to Rust 2021 is fairly straight-forward.</p>\n<p>For method calls of <code class=\"hljs\">into_iter</code> on arrays, the elements being implemented will change from references to owned values.</p>\n<p>For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n  <span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1u8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n  <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> array.into_iter() {\n    <span class=\"hljs-comment\">// x is a `&amp;u8` in Rust 2015 and Rust 2018</span>\n    <span class=\"hljs-comment\">// x is a `u8` in Rust 2021</span>\n  }\n}</code></pre></pre>\n<p>The most straightforward way to migrate in Rust 2021, is by keeping the exact behavior from previous editions\nby calling <code class=\"hljs\">iter()</code> which also iterates over owned arrays by reference:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n  <span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1u8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n  <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> array.iter() { <span class=\"hljs-comment\">// &lt;- This line changed</span>\n    <span class=\"hljs-comment\">// x is a `&amp;u8` in all editions</span>\n  }\n}</code></pre></pre>\n<h3 id=\"optional-migration\"><a class=\"header\" href=\"#optional-migration\">Optional migration</a></h3>\n<p>If you are using fully qualified method syntax (i.e., <code class=\"hljs\">IntoIterator::into_iter(array)</code>) in a previous edition,\nthis can be upgraded to method call syntax (i.e., <code class=\"hljs\">array.into_iter()</code>).</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"disjoint-capture-in-closures\"><a class=\"header\" href=\"#disjoint-capture-in-closures\">Disjoint capture in closures</a></h1>\n<h2 id=\"summary-8\"><a class=\"header\" href=\"#summary-8\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">|| a.x + 1</code> now captures only <code class=\"hljs\">a.x</code> instead of <code class=\"hljs\">a</code>.</li>\n<li>This can cause things to be dropped at different times or affect whether closures implement traits like <code class=\"hljs\">Send</code> or <code class=\"hljs\">Clone</code>.\n<ul>\n<li>If possible changes are detected, <code class=\"hljs\">cargo fix</code> will insert statements like <code class=\"hljs\">let _ = &amp;a</code> to force a closure to capture the entire variable.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"details-5\"><a class=\"header\" href=\"#details-5\">Details</a></h2>\n<p><a href=\"https://doc.rust-lang.org/book/ch13-01-closures.html\">Closures</a>\nautomatically capture anything that you refer to from within their body.\nFor example, <code class=\"hljs\">|| a + 1</code> automatically captures a reference to <code class=\"hljs\">a</code> from the surrounding context.</p>\n<p>In Rust 2018 and before, closures capture entire variables, even if the closure only uses one field.\nFor example, <code class=\"hljs\">|| a.x + 1</code> captures a reference to <code class=\"hljs\">a</code> and not just <code class=\"hljs\">a.x</code>.\nCapturing <code class=\"hljs\">a</code> in its entirety prevents mutation or moves from other fields of <code class=\"hljs\">a</code>, so that code like this does not compile:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> a = SomeStruct::new();\n<span class=\"hljs-built_in\">drop</span>(a.x); <span class=\"hljs-comment\">// Move out of one field of the struct</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, a.y); <span class=\"hljs-comment\">// Ok: Still use another field of the struct</span>\n<span class=\"hljs-keyword\">let</span> c = || <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, a.y); <span class=\"hljs-comment\">// Error: Tries to capture all of `a`</span>\nc();</code></pre>\n<p>Starting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.</p>\n<p>Disjoint capture was proposed as part of <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md\">RFC 2229</a> and the RFC contains details about the motivation.</p>\n<h2 id=\"migration-3\"><a class=\"header\" href=\"#migration-3\">Migration</a></h2>\n<p>As a part of the 2021 edition a migration lint, <code class=\"hljs\">rust_2021_incompatible_closure_captures</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>\n<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>Below is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail\nor you would like to better understand how the migration works.</p>\n<p>Changing the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:</p>\n<ul>\n<li>changes to drop order, or when destructors run (<a href=\"rust-2021/disjoint-capture-in-closures.html#drop-order\">details</a>);</li>\n<li>changes to which traits a closure implements (<a href=\"rust-2021/disjoint-capture-in-closures.html#trait-implementations\">details</a>).</li>\n</ul>\n<p>Whenever any of the scenarios below are detected, <code class=\"hljs\">cargo fix</code> will insert a \"dummy let\" into your closure to force it to capture the entire variable:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = (<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">22</span>], <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">23</span>]);\n<span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">move</span> || {\n    <span class=\"hljs-comment\">// \"Dummy let\" that forces `x` to be captured in its entirety</span>\n    <span class=\"hljs-keyword\">let</span> _ = &amp;x;\n\n    <span class=\"hljs-comment\">// Otherwise, only `x.0` would be captured here</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, x.<span class=\"hljs-number\">0</span>);\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.</p>\n<h3 id=\"wild-card-patterns\"><a class=\"header\" href=\"#wild-card-patterns\">Wild Card Patterns</a></h3>\n<p>Closures now only capture data that needs to be read, which means the following closures will not capture <code class=\"hljs\">x</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">let</span> c = || {\n    <span class=\"hljs-keyword\">let</span> _ = x; <span class=\"hljs-comment\">// no-op</span>\n};\n\n<span class=\"hljs-keyword\">let</span> c = || <span class=\"hljs-keyword\">match</span> x {\n    _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello World!\"</span>)\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The <code class=\"hljs\">let _ = x</code> statement here is a no-op, since the <code class=\"hljs\">_</code> pattern completely ignores the right-hand side, and <code class=\"hljs\">x</code> is a reference to a place in memory (in this case, a variable).</p>\n<p>This change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the \"drop order\" change below.</p>\n<p><strong>Subtle:</strong> There are other similar expressions, such as the \"dummy lets\" <code class=\"hljs\">let _ = &amp;x</code> that we insert, which are not no-ops. This is because the right-hand side (<code class=\"hljs\">&amp;x</code>) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).</p>\n<h3 id=\"drop-order\"><a class=\"header\" href=\"#drop-order\">Drop Order</a></h3>\n<p>When a closure takes ownership of a value from a variable <code class=\"hljs\">t</code>, that value is then dropped when the closure is dropped, and not when the variable <code class=\"hljs\">t</code> goes out of scope:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">move_value</span></span>&lt;T&gt;(_: T){}\n</span>{\n    <span class=\"hljs-keyword\">let</span> t = (<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>]);\n\n    {\n        <span class=\"hljs-keyword\">let</span> c = || move_value(t); <span class=\"hljs-comment\">// t is moved here</span>\n    } <span class=\"hljs-comment\">// c is dropped, which drops the tuple `t` as well</span>\n} <span class=\"hljs-comment\">// t goes out of scope here</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of <em>part</em> of a variable, there can be differences:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">move_value</span></span>&lt;T&gt;(_: T){}\n</span>{\n    <span class=\"hljs-keyword\">let</span> t = (<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>]);\n\n    {\n        <span class=\"hljs-keyword\">let</span> c = || {\n            <span class=\"hljs-comment\">// In Rust 2018, captures all of `t`.</span>\n            <span class=\"hljs-comment\">// In Rust 2021, captures only `t.0`</span>\n            move_value(t.<span class=\"hljs-number\">0</span>);\n        };\n\n        <span class=\"hljs-comment\">// In Rust 2018, `c` (and `t`) are both dropped when we</span>\n        <span class=\"hljs-comment\">// exit this block.</span>\n        <span class=\"hljs-comment\">//</span>\n        <span class=\"hljs-comment\">// In Rust 2021, `c` and `t.0` are both dropped when we</span>\n        <span class=\"hljs-comment\">// exit this block.</span>\n    }\n\n<span class=\"hljs-comment\">// In Rust 2018, the value from `t` has been moved and is</span>\n<span class=\"hljs-comment\">// not dropped.</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// In Rust 2021, the value from `t.0` has been moved, but `t.1`</span>\n<span class=\"hljs-comment\">// remains, so it will be dropped here.</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In most cases, dropping values at different times just affects when memory is freed and is not important. However, some <code class=\"hljs\">Drop</code> impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy <code class=\"hljs\">let</code> to force the entire variable to be captured.</p>\n<h3 id=\"trait-implementations\"><a class=\"header\" href=\"#trait-implementations\">Trait implementations</a></h3>\n<p>Closures automatically implement the following traits based on what values they capture:</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/std/clone/trait.Clone.html\"><code class=\"hljs\">Clone</code></a>: if all captured values are <code class=\"hljs\">Clone</code>.</li>\n<li><a href=\"https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits\">Auto traits</a> like <a href=\"https://doc.rust-lang.org/std/marker/trait.Send.html\"><code class=\"hljs\">Send</code></a>, <a href=\"https://doc.rust-lang.org/std/marker/trait.Sync.html\"><code class=\"hljs\">Sync</code></a>, and <a href=\"https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html\"><code class=\"hljs\">UnwindSafe</code></a>: if all captured values implement the given trait.</li>\n</ul>\n<p>In Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then \"dummy lets\" are inserted.</p>\n<p>For instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement <code class=\"hljs\">Send</code>/<code class=\"hljs\">Sync</code> auto trait for the wrapper. The closure that is passed to <code class=\"hljs\">thread::spawn</code> uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is <code class=\"hljs\">Send</code>/<code class=\"hljs\">Sync</code>, the code is considered safe and therefore compiles successfully.</p>\n<p>With disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally <code class=\"hljs\">Send</code>/<code class=\"hljs\">Sync</code> defeating the purpose of the wrapper.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Ptr</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>);\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> Ptr {}\n\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">let</span> px = Ptr(&amp;<span class=\"hljs-keyword\">mut</span> x <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-keyword\">let</span> c = thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        *(px.<span class=\"hljs-number\">0</span>) += <span class=\"hljs-number\">10</span>;\n    }\n}); <span class=\"hljs-comment\">// Closure captured px.0 which is not Send</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"panic-macro-consistency\"><a class=\"header\" href=\"#panic-macro-consistency\">Panic macro consistency</a></h1>\n<h2 id=\"summary-9\"><a class=\"header\" href=\"#summary-9\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">panic!(..)</code> now always uses <code class=\"hljs\">format_args!(..)</code>, just like <code class=\"hljs\">println!()</code>.</li>\n<li><code class=\"hljs\">panic!(\"{\")</code> is no longer accepted, without escaping the <code class=\"hljs\">{</code> as <code class=\"hljs\">{{</code>.</li>\n<li><code class=\"hljs\">panic!(x)</code> is no longer accepted if <code class=\"hljs\">x</code> is not a string literal.\n<ul>\n<li>Use <code class=\"hljs\">std::panic::panic_any(x)</code> to panic with a non-string payload.</li>\n<li>Or use <code class=\"hljs\">panic!(\"{}\", x)</code> to use <code class=\"hljs\">x</code>'s <code class=\"hljs\">Display</code> implementation.</li>\n</ul>\n</li>\n<li>The same applies to <code class=\"hljs\">assert!(expr, ..)</code>.</li>\n</ul>\n<h2 id=\"details-6\"><a class=\"header\" href=\"#details-6\">Details</a></h2>\n<p>The <code class=\"hljs\">panic!()</code> macro is one of Rust's most well known macros.\nHowever, it has <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md\">some subtle surprises</a>\nthat we can't just change due to backwards compatibility.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n<span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Ok, panics with the message \"1\"</span>\n<span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"{}\"</span>); <span class=\"hljs-comment\">// Ok, panics with the message \"{}\"</span></code></pre>\n<p>The <code class=\"hljs\">panic!()</code> macro only uses string formatting when it's invoked with more than one argument.\nWhen invoked with a single argument, it doesn't even look at that argument.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2018</span>\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-string\">\"{\"</span>;\n<span class=\"hljs-built_in\">println!</span>(a); <span class=\"hljs-comment\">// Error: First argument must be a format string literal</span>\n<span class=\"hljs-built_in\">panic!</span>(a); <span class=\"hljs-comment\">// Ok: The panic macro doesn't care</span></code></pre>\n<p>It even accepts non-strings such as <code class=\"hljs\">panic!(123)</code>, which is uncommon and rarely useful since it\nproduces a surprisingly unhelpful message: <code class=\"hljs\">panicked at 'Box&lt;Any&gt;'</code>.</p>\n<p>This will especially be a problem once\n<a href=\"https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html\">implicit format arguments</a>\nare stabilized.\nThat feature will make <code class=\"hljs\">println!(\"hello {name}\")</code> a short-hand for <code class=\"hljs\">println!(\"hello {}\", name)</code>.\nHowever, <code class=\"hljs\">panic!(\"hello {name}\")</code> would not work as expected,\nsince <code class=\"hljs\">panic!()</code> doesn't process a single argument as format string.</p>\n<p>To avoid that confusing situation, Rust 2021 features a more consistent <code class=\"hljs\">panic!()</code> macro.\nThe new <code class=\"hljs\">panic!()</code> macro will no longer accept arbitrary expressions as the only argument.\nIt will, just like <code class=\"hljs\">println!()</code>, always process the first argument as format string.\nSince <code class=\"hljs\">panic!()</code> will no longer accept arbitrary payloads,\n<a href=\"https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html\"><code class=\"hljs\">panic_any()</code></a>\nwill be the only way to panic with something other than a formatted string.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// Rust 2021</span>\n<span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"{}\"</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Ok, panics with the message \"1\"</span>\n<span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"{}\"</span>); <span class=\"hljs-comment\">// Error, missing argument</span>\n<span class=\"hljs-built_in\">panic!</span>(a); <span class=\"hljs-comment\">// Error, must be a string literal</span></code></pre>\n<p>In addition, <code class=\"hljs\">core::panic!()</code> and <code class=\"hljs\">std::panic!()</code> will be identical in Rust 2021.\nCurrently, there are some historical differences between those two,\nwhich can be noticeable when switching <code class=\"hljs\">#![no_std]</code> on or off.</p>\n<h2 id=\"migration-4\"><a class=\"header\" href=\"#migration-4\">Migration</a></h2>\n<p>A lint, <code class=\"hljs\">non_fmt_panics</code>, gets triggered whenever there is some call to <code class=\"hljs\">panic</code> that uses some\ndeprecated behavior that will error in Rust 2021. The <code class=\"hljs\">non_fmt_panics</code> lint has already been a warning\nby default on all editions since the 1.50 release (with several enhancements made in later releases).\nIf your code is already warning free, then it should already be ready to go for Rust 2021!</p>\n<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by\nrunning:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>Should you choose or need to manually migrate, you'll need to update all panic invocations to either use the same\nformatting as <code class=\"hljs\">println</code> or use <code class=\"hljs\">std::panic::panic_any</code> to panic with non-string data.</p>\n<p>For example, in the case of <code class=\"hljs\">panic!(MyStruct)</code>, you'll need to convert to using <code class=\"hljs\">std::panic::panic_any</code> (note\nthat this is a function not a macro): <code class=\"hljs\">std::panic::panic_any(MyStruct)</code>.</p>\n<p>In the case of panic messages that include curly braces but the wrong number of arguments (e.g., <code class=\"hljs\">panic!(\"Some curlies: {}\")</code>),\nyou can panic with the string literal by either using the same syntax as <code class=\"hljs\">println!</code> (i.e., <code class=\"hljs\">panic!(\"{}\", \"Some curlies: {}\")</code>)\nor by escaping the curly braces (i.e., <code class=\"hljs\">panic!(\"Some curlies: {{}}\")</code>).</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"reserving-syntax\"><a class=\"header\" href=\"#reserving-syntax\">Reserving syntax</a></h1>\n<h2 id=\"summary-10\"><a class=\"header\" href=\"#summary-10\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">any_identifier#</code>, <code class=\"hljs\">any_identifier\"...\"</code>, and <code class=\"hljs\">any_identifier'...'</code> are now reserved\nsyntax, and no longer tokenize.</li>\n<li>This is mostly relevant to macros. E.g. <code class=\"hljs\">quote!{ #a#b }</code> is no longer accepted.</li>\n<li>It doesn't treat keywords specially, so e.g. <code class=\"hljs\">match\"...\" {}</code> is no longer accepted.</li>\n<li>Insert whitespace between the identifier and the subsequent <code class=\"hljs\">#</code>, <code class=\"hljs\">\"</code>, or <code class=\"hljs\">'</code>\nto avoid errors.</li>\n<li>Edition migrations will help you insert whitespace in such cases.</li>\n</ul>\n<h2 id=\"details-7\"><a class=\"header\" href=\"#details-7\">Details</a></h2>\n<p>To make space for new syntax in the future,\nwe've decided to reserve syntax for prefixed identifiers and literals:\n<code class=\"hljs\">prefix#identifier</code>, <code class=\"hljs\">prefix\"string\"</code>, <code class=\"hljs\">prefix'c'</code>, and <code class=\"hljs\">prefix#123</code>,\nwhere <code class=\"hljs\">prefix</code> can be any identifier.\n(Except those prefixes that already have a meaning, such as <code class=\"hljs\">b'...'</code> (byte\nchars) and <code class=\"hljs\">r\"...\"</code> (raw strings).)</p>\n<p>This provides syntax we can expand into in the future without requiring an\nedition boundary. We may use this for temporary syntax until the next edition,\nor for permanent syntax if appropriate.</p>\n<p>Without an edition, this would be a breaking change, since macros can currently\naccept syntax such as <code class=\"hljs\">hello\"world\"</code>, which they will see as two separate\ntokens: <code class=\"hljs\">hello</code> and <code class=\"hljs\">\"world\"</code>. The (automatic) fix is simple though: just\ninsert a space: <code class=\"hljs\">hello \"world\"</code>. Likewise, <code class=\"hljs\">prefix#ident</code> should become\n<code class=\"hljs\">prefix #ident</code>. Edition migrations will help with this fix.</p>\n<p>Other than turning these into a tokenization error,\n<a href=\"https://github.com/rust-lang/rfcs/pull/3101\">the RFC</a> does not attach a meaning to any prefix yet.\nAssigning meaning to specific prefixes is left to future proposals,\nwhich will now—thanks to reserving these prefixes—not be breaking changes.</p>\n<p>Some new prefixes you might potentially see in the future (though we haven't\ncommitted to any of them yet):</p>\n<ul>\n<li>\n<p><code class=\"hljs\">k#keyword</code> to allow writing keywords that don't exist yet in the current edition.\nFor example, while <code class=\"hljs\">async</code> is not a keyword in edition 2015,\nthis prefix would've allowed us to accept <code class=\"hljs\">k#async</code> in edition 2015\nwithout having to wait for edition 2018 to reserve <code class=\"hljs\">async</code> as a keyword.</p>\n</li>\n<li>\n<p><code class=\"hljs\">f\"\"</code> as a short-hand for a format string.\nFor example, <code class=\"hljs\">f\"hello {name}\"</code> as a short-hand for the equivalent <code class=\"hljs\">format!()</code> invocation.</p>\n</li>\n<li>\n<p><code class=\"hljs\">s\"\"</code> for <code class=\"hljs\">String</code> literals.</p>\n</li>\n</ul>\n<h2 id=\"migration-5\"><a class=\"header\" href=\"#migration-5\">Migration</a></h2>\n<p>As a part of the 2021 edition a migration lint, <code class=\"hljs\">rust_2021_prefixes_incompatible_syntax</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>\n<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>Should you want or need to manually migrate your code, migration is fairly straight-forward.</p>\n<p>Let's say you have a macro that is defined like so:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">macro_rules!</span> my_macro {\n    ($a:tt $b:tt) =&gt; {};\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the first token tree and the second:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">my_macro!(z<span class=\"hljs-string\">\"hey\"</span>);</code></pre>\n<p>This <code class=\"hljs\">z</code> prefix is no longer allowed in Rust 2021, so in order to call this macro, you must add a space after the prefix like so:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">my_macro!(z <span class=\"hljs-string\">\"hey\"</span>);</code></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"warnings-promoted-to-errors\"><a class=\"header\" href=\"#warnings-promoted-to-errors\">Warnings promoted to errors</a></h1>\n<h2 id=\"summary-11\"><a class=\"header\" href=\"#summary-11\">Summary</a></h2>\n<ul>\n<li>Code that triggered the <code class=\"hljs\">bare_trait_objects</code> and <code class=\"hljs\">ellipsis_inclusive_range_patterns</code> lints will error in Rust 2021.</li>\n</ul>\n<h2 id=\"details-8\"><a class=\"header\" href=\"#details-8\">Details</a></h2>\n<p>Two existing lints are becoming hard errors in Rust 2021, but these lints will remain warnings in older editions.</p>\n<h3 id=\"bare_trait_objects\"><a class=\"header\" href=\"#bare_trait_objects\"><code>bare_trait_objects</code>:</a></h3>\n<p>The use of the <code class=\"hljs\">dyn</code> keyword to identify <a href=\"https://doc.rust-lang.org/book/ch17-02-trait-objects.html\">trait objects</a>\nwill be mandatory in Rust 2021.</p>\n<p>For example, the following code which does not include the <code class=\"hljs\">dyn</code> keyword in <code class=\"hljs\">&amp;MyTrait</code>\nwill produce an error instead of just a lint in Rust 2021:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MyTrait</span></span> {}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">my_function</span></span>(_trait_object: &amp;MyTrait) { <span class=\"hljs-comment\">// should be `&amp;dyn MyTrait`</span>\n  <span class=\"hljs-built_in\">unimplemented!</span>()\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"ellipsis_inclusive_range_patterns\"><a class=\"header\" href=\"#ellipsis_inclusive_range_patterns\"><code>ellipsis_inclusive_range_patterns</code>:</a></h3>\n<p>The <a href=\"https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns\">deprecated <code class=\"hljs\">...</code> syntax</a>\nfor inclusive range patterns (i.e., ranges where the end value is <em>included</em> in the range) is no longer\naccepted in Rust 2021. It has been superseded by <code class=\"hljs\">..=</code>, which is consistent with expressions.</p>\n<p>For example, the following code which uses <code class=\"hljs\">...</code> in a pattern will produce an error instead of\njust a lint in Rust 2021:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">less_or_eq_to_100</span></span>(n: <span class=\"hljs-built_in\">u8</span>) -&gt; <span class=\"hljs-built_in\">bool</span> {\n  matches!(n, <span class=\"hljs-number\">0</span>...<span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// should be `0..=100`</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"migrations\"><a class=\"header\" href=\"#migrations\">Migrations</a></h2>\n<p>If your Rust 2015 or 2018 code does not produce any warnings for <code class=\"hljs\">bare_trait_objects</code>\nor <code class=\"hljs\">ellipsis_inclusive_range_patterns</code> and you've not allowed these lints through the\nuse of <code class=\"hljs\">#![allow()]</code> or some other mechanism, then there's no need to migrate.</p>\n<p>To automatically migrate any crate that uses <code class=\"hljs\">...</code> in patterns or does not use <code class=\"hljs\">dyn</code> with\ntrait objects, you can run <code class=\"hljs\">cargo fix --edition</code>.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"or-patterns-in-macro-rules\"><a class=\"header\" href=\"#or-patterns-in-macro-rules\">Or patterns in macro-rules</a></h1>\n<h2 id=\"summary-12\"><a class=\"header\" href=\"#summary-12\">Summary</a></h2>\n<ul>\n<li>How patterns work in <code class=\"hljs\">macro_rules</code> macros changes slightly:\n<ul>\n<li><code class=\"hljs\">$_:pat</code> in <code class=\"hljs\">macro_rules</code> now matches usage of <code class=\"hljs\">|</code> too: e.g. <code class=\"hljs\">A | B</code>.</li>\n<li>The new <code class=\"hljs\">$_:pat_param</code> behaves like <code class=\"hljs\">$_:pat</code> did before; it does not match (top level) <code class=\"hljs\">|</code>.</li>\n<li><code class=\"hljs\">$_:pat_param</code> is available in all editions.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"details-9\"><a class=\"header\" href=\"#details-9\">Details</a></h2>\n<p>Starting in Rust 1.53.0, <a href=\"https://doc.rust-lang.org/stable/reference/patterns.html\">patterns</a>\nare extended to support <code class=\"hljs\">|</code> nested anywhere in the pattern.\nThis enables you to write <code class=\"hljs\">Some(1 | 2)</code> instead of <code class=\"hljs\">Some(1) | Some(2)</code>.\nSince this was simply not allowed before, this is not a breaking change.</p>\n<p>However, this change also affects <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html\"><code class=\"hljs\">macro_rules</code> macros</a>.\nSuch macros can accept patterns using the <code class=\"hljs\">:pat</code> fragment specifier.\nCurrently, <code class=\"hljs\">:pat</code> does <em>not</em> match top level <code class=\"hljs\">|</code>, since before Rust 1.53,\nnot all patterns (at all nested levels) could contain a <code class=\"hljs\">|</code>.\nMacros that accept patterns like <code class=\"hljs\">A | B</code>,\nsuch as <a href=\"https://doc.rust-lang.org/1.51.0/std/macro.matches.html\"><code class=\"hljs\">matches!()</code></a>\nuse something like <code class=\"hljs\">$($_:pat)|+</code>.</p>\n<p>Because this would potentially break existing macros, the meaning of <code class=\"hljs\">:pat</code> did\nnot change in Rust 1.53.0 to include <code class=\"hljs\">|</code>. Instead, that change happens in Rust 2021.\nIn the new edition, the <code class=\"hljs\">:pat</code> fragment specifier <em>will</em> match <code class=\"hljs\">A | B</code>.</p>\n<p><code class=\"hljs\">$_:pat</code> fragments in Rust 2021 cannot be followed by an explicit <code class=\"hljs\">|</code>. Since there are times\nthat one still wishes to match pattern fragments followed by a <code class=\"hljs\">|</code>, the fragment specified <code class=\"hljs\">:pat_param</code>\nhas been added to retain the older behavior.</p>\n<p>It's important to remember that editions are <em>per crate</em>, so the only relevant edition is the edition\nof the crate where the macro is defined. The edition of the crate where the macro is used does not\nchange how the macro works.</p>\n<h2 id=\"migration-6\"><a class=\"header\" href=\"#migration-6\">Migration</a></h2>\n<p>A lint, <code class=\"hljs\">rust_2021_incompatible_or_patterns</code>, gets triggered whenever there is a use <code class=\"hljs\">$_:pat</code> which\nwill change meaning in Rust 2021.</p>\n<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by\nrunning:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>If you have a macro which relies on <code class=\"hljs\">$_:pat</code> not matching the top level use of <code class=\"hljs\">|</code> in patterns,\nyou'll need to change each occurrence of <code class=\"hljs\">$_:pat</code> to <code class=\"hljs\">$_:pat_param</code>.</p>\n<p>For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">macro_rules!</span> my_macro { \n    ($x:pat | $y:pat) =&gt; {\n        <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> implementation</span>\n    } \n}\n\n<span class=\"hljs-comment\">// This macro works in Rust 2018 since `$x:pat` does not match against `|`:</span>\nmy_macro!(<span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span>);\n\n<span class=\"hljs-comment\">// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not allowed</span>\n<span class=\"hljs-comment\">// to be followed by a `|`. To make sure this macro still works in Rust 2021</span>\n<span class=\"hljs-comment\">// change the macro to the following:</span>\n<span class=\"hljs-built_in\">macro_rules!</span> my_macro { \n    ($x:pat_param | $y:pat) =&gt; { <span class=\"hljs-comment\">// &lt;- this line is different</span>\n        <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> implementation</span>\n    } \n}\n<span class=\"boring\">}</span></code></pre></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"c-string-literals\"><a class=\"header\" href=\"#c-string-literals\">C-string literals</a></h1>\n<h2 id=\"summary-13\"><a class=\"header\" href=\"#summary-13\">Summary</a></h2>\n<ul>\n<li>Literals of the form <code class=\"hljs\">c\"foo\"</code> or <code class=\"hljs\">cr\"foo\"</code> represent a string of type <a href=\"rust-2021/../../core/ffi/struct.CStr.html\"><code class=\"hljs\">&amp;core::ffi::CStr</code></a>.</li>\n</ul>\n<h2 id=\"details-10\"><a class=\"header\" href=\"#details-10\">Details</a></h2>\n<p>Starting with Rust 1.77, C-strings can be written using C-string literal syntax with the <code class=\"hljs\">c</code> or <code class=\"hljs\">cr</code> prefix.</p>\n<p>Previously, it was challenging to properly produce a valid string literal that could interoperate with C APIs which terminate with a NUL byte.\nThe <a href=\"https://crates.io/crates/cstr\"><code class=\"hljs\">cstr</code></a> crate was a popular solution, but that required compiling a proc-macro which was quite expensive.\nNow, C-strings can be written directly using literal syntax notation, which will generate a value of type <a href=\"rust-2021/../../core/ffi/struct.CStr.html\"><code class=\"hljs\">&amp;core::ffi::CStr</code></a> which is automatically terminated with a NUL byte.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> core::ffi::CStr;\n</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(c<span class=\"hljs-string\">\"hello\"</span>, CStr::from_bytes_with_nul(<span class=\"hljs-string\">b\"hello\\0\"</span>).unwrap());\n<span class=\"hljs-built_in\">assert_eq!</span>(\n    c<span class=\"hljs-string\">\"byte escapes \\xff work\"</span>,\n    CStr::from_bytes_with_nul(<span class=\"hljs-string\">b\"byte escapes \\xff work\\0\"</span>).unwrap()\n);\n<span class=\"hljs-built_in\">assert_eq!</span>(\n    c<span class=\"hljs-string\">\"unicode escapes \\u{00E6} work\"</span>,\n    CStr::from_bytes_with_nul(<span class=\"hljs-string\">b\"unicode escapes \\xc3\\xa6 work\\0\"</span>).unwrap()\n);\n<span class=\"hljs-built_in\">assert_eq!</span>(\n    c<span class=\"hljs-string\">\"unicode characters αβγ encoded as UTF-8\"</span>,\n    CStr::from_bytes_with_nul(\n        <span class=\"hljs-string\">b\"unicode characters \\xce\\xb1\\xce\\xb2\\xce\\xb3 encoded as UTF-8\\0\"</span>\n    )\n    .unwrap()\n);\n<span class=\"hljs-built_in\">assert_eq!</span>(\n    c<span class=\"hljs-string\">\"strings can continue \\\n        on multiple lines\"</span>,\n    CStr::from_bytes_with_nul(<span class=\"hljs-string\">b\"strings can continue on multiple lines\\0\"</span>).unwrap()\n);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>C-strings do not allow interior NUL bytes (such as with a <code class=\"hljs\">\\0</code> escape).</p>\n<p>Similar to regular strings, C-strings also support \"raw\" syntax with the <code class=\"hljs\">cr</code> prefix.\nThese raw C-strings do not process backslash escapes which can make it easier to write strings that contain backslashes.\nDouble-quotes can be included by surrounding the quotes with the <code class=\"hljs\">#</code> character.\nMultiple <code class=\"hljs\">#</code> characters can be used to avoid ambiguity with internal <code class=\"hljs\">\"#</code> sequences.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">assert_eq!</span>(c<span class=\"hljs-string\">r\"foo\"</span>, c<span class=\"hljs-string\">\"foo\"</span>);\n<span class=\"hljs-comment\">// Number signs can be used to embed interior double quotes.</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(c<span class=\"hljs-string\">r#\"\"foo\"\"#</span>, c<span class=\"hljs-string\">\"\\\"foo\\\"\"</span>);\n<span class=\"hljs-comment\">// This requires two #.</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(c<span class=\"hljs-string\">r##\"\"foo\"#\"##</span>, c<span class=\"hljs-string\">\"\\\"foo\\\"#\"</span>);\n<span class=\"hljs-comment\">// Escapes are not processed.</span>\n<span class=\"hljs-built_in\">assert_eq!</span>(c<span class=\"hljs-string\">r\"C:\\foo\"</span>, c<span class=\"hljs-string\">\"C:\\\\foo\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>See <a href=\"rust-2021/../../reference/tokens.html#c-string-and-raw-c-string-literals\">The Reference</a> for more details.</p>\n<h2 id=\"migration-7\"><a class=\"header\" href=\"#migration-7\">Migration</a></h2>\n<p>Migration is only necessary for macros which may have been assuming a sequence of tokens that looks similar to <code class=\"hljs\">c\"…\"</code> or <code class=\"hljs\">cr\"…\"</code>, which previous to the 2021 edition would tokenize as two separate tokens, but in 2021 appears as a single token.</p>\n<p>As part of the <a href=\"rust-2021/reserving-syntax.html\">syntax reservation</a> for the 2021 edition, any macro input which may run into this issue should issue a warning from the <code class=\"hljs\">rust_2021_prefixes_incompatible_syntax</code> migration lint.\nSee that chapter for more detail.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"rust-2024\"><a class=\"header\" href=\"#rust-2024\">Rust 2024</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Info</th><th></th></tr></thead><tbody>\n<tr><td>RFC</td><td><a href=\"https://rust-lang.github.io/rfcs/3501-edition-2024.html\">#3501</a></td></tr>\n<tr><td>Release version</td><td>1.82.0 (anticipated)</td></tr>\n</tbody></table>\n</div>\n<p>The Rust 2024 Edition is currently slated for release in Rust 1.82.0.\nRust 1.82.0 will be in beta for six weeks,\nafter which it is released as stable on October 17th.</p>\n<p>However, note that Rust is a project run by volunteers.\nWe prioritize the personal well-being of everyone working on Rust\nover any deadlines and expectations we might have set.\nThis could mean delaying the edition a version if necessary,\nor dropping a feature that turns out to be too difficult or stressful to finish in time.</p>\n<p>That said, we are on schedule and many of the difficult problems are already tackled,\nthanks to all the people contributing to Rust 2024! 💛</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"additions-to-the-prelude-1\"><a class=\"header\" href=\"#additions-to-the-prelude-1\">Additions to the prelude</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\nMore information may be found in the tracking issue at <a href=\"https://github.com/rust-lang/rust/issues/121042\">https://github.com/rust-lang/rust/issues/121042</a>.</p>\n<h2 id=\"summary-14\"><a class=\"header\" href=\"#summary-14\">Summary</a></h2>\n<ul>\n<li>The <a href=\"rust-2024/../../std/future/trait.Future.html\"><code class=\"hljs\">Future</code></a> and <a href=\"rust-2024/../../std/future/trait.IntoFuture.html\"><code class=\"hljs\">IntoFuture</code></a> traits are now part of the prelude.</li>\n<li>This might make calls to trait methods ambiguous which could make some code fail to compile.</li>\n<li><code class=\"hljs\">RustcEncodable</code> and <code class=\"hljs\">RustcDecodable</code> have been removed from the prelude.</li>\n</ul>\n<h2 id=\"details-11\"><a class=\"header\" href=\"#details-11\">Details</a></h2>\n<p>The <a href=\"rust-2024/../../std/prelude/index.html\">prelude of the standard library</a> is the module containing everything that is automatically imported in every module.\nIt contains commonly used items such as <code class=\"hljs\">Option</code>, <code class=\"hljs\">Vec</code>, <code class=\"hljs\">drop</code>, and <code class=\"hljs\">Clone</code>.</p>\n<p>The Rust compiler prioritizes any manually imported items over those from the prelude,\nto make sure additions to the prelude will not break any existing code.\nFor example, if you have a crate or module called <code class=\"hljs\">example</code> containing a <code class=\"hljs\">pub struct Option;</code>,\nthen <code class=\"hljs\">use example::*;</code> will make <code class=\"hljs\">Option</code> unambiguously refer to the one from <code class=\"hljs\">example</code>;\nnot the one from the standard library.</p>\n<p>However, adding a <em>trait</em> to the prelude can break existing code in a subtle way.\nFor example, a call to <code class=\"hljs\">x.poll()</code> which comes from a <code class=\"hljs\">MyPoller</code> trait might fail to compile if <code class=\"hljs\">std</code>'s <code class=\"hljs\">Future</code> is also imported, because the call to <code class=\"hljs\">poll</code> is now ambiguous and could come from either trait.</p>\n<p>As a solution, Rust 2024 will use a new prelude.\nIt's identical to the current one, except for the following changes:</p>\n<ul>\n<li>Added:\n<ul>\n<li><a href=\"rust-2024/../../std/future/trait.Future.html\"><code class=\"hljs\">std::future::Future</code></a></li>\n<li><a href=\"rust-2024/../../std/future/trait.IntoFuture.html\"><code class=\"hljs\">std::future::IntoFuture</code></a></li>\n</ul>\n</li>\n<li>Removed:\n<ul>\n<li><code class=\"hljs\">RustcEncodable</code></li>\n<li><code class=\"hljs\">RustcDecodable</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"rustcencodable-and-rustcdecodable-removal\"><a class=\"header\" href=\"#rustcencodable-and-rustcdecodable-removal\"><code>RustcEncodable</code> and <code>RustcDecodable</code> removal</a></h3>\n<p><code class=\"hljs\">RustcEncodable</code> and <code class=\"hljs\">RustcDecodable</code> are two undocumented derive macros that have been removed from the prelude.\nThese were deprecated before Rust 1.0, but remained within the standard library prelude.\nThe 2024 Edition has removed these from the prelude since they are not expected to be used.</p>\n<p>If in the unlikely case there is a project still using these, it is recommended to switch to a serialization library, such as those found on <a href=\"https://crates.io/categories/encoding\">crates.io</a>.</p>\n<h2 id=\"migration-8\"><a class=\"header\" href=\"#migration-8\">Migration</a></h2>\n<p>🚧 The automatic migration for this has not yet been implemented.</p>\n<h3 id=\"migration-needed-1\"><a class=\"header\" href=\"#migration-needed-1\">Migration needed</a></h3>\n<h4 id=\"conflicting-trait-methods-1\"><a class=\"header\" href=\"#conflicting-trait-methods-1\">Conflicting trait methods</a></h4>\n<p>When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">MyPoller</span></span> {\n    <span class=\"hljs-comment\">// This name is the same as the `poll` method on the `Future` trait from `std`.</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"polling\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyPoller <span class=\"hljs-keyword\">for</span> T {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// Pin&lt;&amp;mut async {}&gt; implements both `std::future::Future` and `MyPoller`.</span>\n    <span class=\"hljs-comment\">// If both traits are in scope (as would be the case in Rust 2024),</span>\n    <span class=\"hljs-comment\">// then it becomes ambiguous which `poll` method to call</span>\n    core::pin::pin!(<span class=\"hljs-keyword\">async</span> {}).poll();\n}</code></pre></pre>\n<p>We can fix this by using fully qualified syntax:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// Now it is clear which trait method we're referring to</span>\n    &lt;_ <span class=\"hljs-keyword\">as</span> MyPoller&gt;::poll(&amp;core::pin::pin!(<span class=\"hljs-keyword\">async</span> {}));\n}</code></pre>\n<h4 id=\"rustcencodable-and-rustcdecodable\"><a class=\"header\" href=\"#rustcencodable-and-rustcdecodable\"><code>RustcEncodable</code> and <code>RustcDecodable</code></a></h4>\n<p>It is strongly recommended that you migrate to a different serialization library if you are still using these.\nHowever, these derive macros are still available in the standard library, they are just required to be imported from the older prelude now:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[allow(soft_unstable)]</span>\n<span class=\"hljs-keyword\">use</span> core::prelude::v1::{RustcDecodable, RustcEncodable};\n<span class=\"boring\">}</span></code></pre></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"unsafe_op_in_unsafe_fn-warning\"><a class=\"header\" href=\"#unsafe_op_in_unsafe_fn-warning\">unsafe_op_in_unsafe_fn warning</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<h2 id=\"summary-15\"><a class=\"header\" href=\"#summary-15\">Summary</a></h2>\n<ul>\n<li>The <a href=\"rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn\"><code class=\"hljs\">unsafe_op_in_unsafe_fn</code></a> lint now warns by default.\nThis warning detects calls to unsafe operations in unsafe functions without an explicit unsafe block.</li>\n</ul>\n<h2 id=\"details-12\"><a class=\"header\" href=\"#details-12\">Details</a></h2>\n<p>The <a href=\"rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn\"><code class=\"hljs\">unsafe_op_in_unsafe_fn</code></a> lint will fire if there are <a href=\"rust-2024/../../reference/unsafety.html\">unsafe operations</a> in an unsafe function without an explicit <a href=\"rust-2024/../../reference/expressions/block-expr.html#unsafe-blocks\"><code class=\"hljs\">unsafe {}</code> block</a>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-meta\">#![warn(unsafe_op_in_unsafe_fn)]</span>\n</span><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get_unchecked</span></span>&lt;T&gt;(x: &amp;[T], i: <span class=\"hljs-built_in\">usize</span>) -&gt; &amp;T {\n  x.get_unchecked(i) <span class=\"hljs-comment\">// WARNING: requires unsafe block</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The solution is to wrap any unsafe operations in an <code class=\"hljs\">unsafe</code> block:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-meta\">#![deny(unsafe_op_in_unsafe_fn)]</span>\n</span><span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get_unchecked</span></span>&lt;T&gt;(x: &amp;[T], i: <span class=\"hljs-built_in\">usize</span>) -&gt; &amp;T {\n  <span class=\"hljs-keyword\">unsafe</span> { x.get_unchecked(i) }\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This change is intended to help protect against accidental use of unsafe operations in an unsafe function.\nThe <code class=\"hljs\">unsafe</code> function keyword was performing two roles.\nOne was to declare that <em>calling</em> the function requires unsafe, and that the caller is responsible to uphold additional safety requirements.\nThe other role was to allow the use of unsafe operations inside of the function.\nThis second role was determined to be too risky without explicit <code class=\"hljs\">unsafe</code> blocks.</p>\n<p>More information and motivation may be found in <a href=\"https://rust-lang.github.io/rfcs/2585-unsafe-block-in-unsafe-fn.html\">RFC #2585</a>.</p>\n<h2 id=\"migration-9\"><a class=\"header\" href=\"#migration-9\">Migration</a></h2>\n<p>The <a href=\"rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn\"><code class=\"hljs\">unsafe_op_in_unsafe_fn</code></a> lint is part of the <code class=\"hljs\">rust-2024-compatibility</code> lint group.\nIn order to migrate your code to be Rust 2024 Edition compatible, run:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>Alternatively, you can manually enable the lint to find places where unsafe blocks need to be added, or switch it to <code class=\"hljs\">allow</code> to silence the lint completely.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// Add this to the root of your crate to do a manual migration.</span>\n<span class=\"hljs-meta\">#![warn(unsafe_op_in_unsafe_fn)]</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"rpit-lifetime-capture\"><a class=\"header\" href=\"#rpit-lifetime-capture\">RPIT lifetime capture</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<p>This feature is partially implemented, and not yet ready for testing.\nMore information may be found in the tracking issue at <a href=\"https://github.com/rust-lang/rust/issues/117587\">https://github.com/rust-lang/rust/issues/117587</a>.</p>\n<h2 id=\"summary-16\"><a class=\"header\" href=\"#summary-16\">Summary</a></h2>\n<h2 id=\"details-13\"><a class=\"header\" href=\"#details-13\">Details</a></h2>\n<h2 id=\"migration-10\"><a class=\"header\" href=\"#migration-10\">Migration</a></h2>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"disallow-references-to-static-mut\"><a class=\"header\" href=\"#disallow-references-to-static-mut\">Disallow references to static mut</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<h2 id=\"summary-17\"><a class=\"header\" href=\"#summary-17\">Summary</a></h2>\n<ul>\n<li>The <a href=\"rust-2024/../../rustc/lints/listing/warn-by-default.html#static-mut-refs\"><code class=\"hljs\">static_mut_refs</code></a> lint is now a hard error that cannot be disabled.\nThis prevents taking a shared or mutable reference to a <code class=\"hljs\">static mut</code>.</li>\n</ul>\n<h2 id=\"details-14\"><a class=\"header\" href=\"#details-14\">Details</a></h2>\n<p>Taking a reference to a <a href=\"rust-2024/../../reference/items/static-items.html#mutable-statics\"><code class=\"hljs\">static mut</code></a> is no longer allowed:</p>\n<!-- edition2024,E0796 -->\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> X: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">23</span>;\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">mut</span> Y: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">24</span>;\n\n<span class=\"hljs-keyword\">unsafe</span> {\n    <span class=\"hljs-keyword\">let</span> y = &amp;X;             <span class=\"hljs-comment\">// ERROR: reference of mutable static</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">ref</span> x = X;          <span class=\"hljs-comment\">// ERROR: reference of mutable static</span>\n    <span class=\"hljs-keyword\">let</span> (x, y) = (&amp;X, &amp;Y);  <span class=\"hljs-comment\">// ERROR: reference of mutable static</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Merely taking such a reference in violation of Rust's mutability XOR aliasing requirement has always been <em>instantaneous</em> <a href=\"rust-2024/../../reference/behavior-considered-undefined.html\">undefined behavior</a>, <strong>even if the reference is never read from or written to</strong>.  Furthermore, upholding mutability XOR aliasing for a <code class=\"hljs\">static mut</code> requires <em>reasoning about your code globally</em>, which can be particularly difficult in the face of reentrancy and/or multithreading.</p>\n<h2 id=\"alternatives\"><a class=\"header\" href=\"#alternatives\">Alternatives</a></h2>\n<p>Wherever possible, it is <strong>strongly recommended</strong> to use instead an <em>immutable</em> <code class=\"hljs\">static</code> of a type that provides <em>interior mutability</em> behind some <em>locally-reasoned abstraction</em> (which greatly reduces the complexity of ensuring that Rust's mutability XOR aliasing requirement is upheld).</p>\n<p>In situations where no locally-reasoned abstraction is possible and you are therefore compelled still to reason globally about accesses to your <code class=\"hljs\">static</code> variable, you must now use raw pointers such as can be obtained via the <a href=\"https://docs.rust-lang.org/core/ptr/macro.addr_of_mut.html\"><code class=\"hljs\">addr_of_mut!</code></a> macro.  By first obtaining a raw pointer rather than directly taking a reference, (the safety requirements of) accesses through that pointer will be more familiar to <code class=\"hljs\">unsafe</code> developers and can be deferred until/limited to smaller regions of code.</p>\n<h2 id=\"migration-11\"><a class=\"header\" href=\"#migration-11\">Migration</a></h2>\n<p>🚧 The automatic migration for this has not yet been implemented.</p>\n<!-- TODO: Discuss alternatives around rewriting your code. -->\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"publicprivate-dependencies\"><a class=\"header\" href=\"#publicprivate-dependencies\">Public/private dependencies</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<p>This feature is only partially implemented, and not yet ready for testing.\nMore information may be found in the tracking issue at <a href=\"https://github.com/rust-lang/rust/issues/44663\">https://github.com/rust-lang/rust/issues/44663</a>.</p>\n<h2 id=\"summary-18\"><a class=\"header\" href=\"#summary-18\">Summary</a></h2>\n<h2 id=\"details-15\"><a class=\"header\" href=\"#details-15\">Details</a></h2>\n<h2 id=\"migration-12\"><a class=\"header\" href=\"#migration-12\">Migration</a></h2>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"cargo-remove-implicit-features\"><a class=\"header\" href=\"#cargo-remove-implicit-features\">Cargo: Remove implicit features</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<h2 id=\"summary-19\"><a class=\"header\" href=\"#summary-19\">Summary</a></h2>\n<ul>\n<li>Optional dependencies must now be explicitly specified in the <code class=\"hljs\">[features]</code> table.</li>\n</ul>\n<h2 id=\"details-16\"><a class=\"header\" href=\"#details-16\">Details</a></h2>\n<p>In previous editions, when an <a href=\"rust-2024/../../cargo/reference/features.html#optional-dependencies\">optional dependency</a> is specified, Cargo would automatically add an implicit <a href=\"rust-2024/../../cargo/reference/features.html\">feature</a> of the same name as the dependency. For example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">jpeg-decoder</span> = { version = <span class=\"hljs-string\">\"0.3.1\"</span>, optional = <span class=\"hljs-literal\">true</span> }\n</code></pre>\n<p>This would automatically add a feature <code class=\"hljs\">jpeg-decoder = [\"dep:jpeg-decoder\"]</code> to provide a way to enable the dependency.\nThe <code class=\"hljs\">dep:</code> entries are specific syntax for referring to optional dependencies.\nThis implicit feature is only added if <code class=\"hljs\">\"dep:jpeg-decoder\"</code> is not specified in any other feature.</p>\n<p>In the 2024 Edition, this implicit feature is no longer added, and you are required to explicitly specify the dependency in the <code class=\"hljs\">[features]</code> table.\nFor example, instead of exposing the particular internal name of some dependency, you may consider using a more general term for the feature name:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[features]</span>\n<span class=\"hljs-attr\">graphics</span> = [<span class=\"hljs-string\">\"dep:jpeg-decoder\"</span>]\n</code></pre>\n<p><code class=\"hljs\">cargo add --optional &lt;NAME&gt;</code> automatically adds a feature for the dependency to the <code class=\"hljs\">[features]</code> table if it isn't already there.</p>\n<h3 id=\"motivation-2\"><a class=\"header\" href=\"#motivation-2\">Motivation</a></h3>\n<p>One reason for requiring this to be explicit is that it encourages a conscious decision about the public exposure of the feature name, and makes it clearer when reading the <code class=\"hljs\">[features]</code> table which features exist.\nThis can help avoid tying the implementation details (the dependency names) to the public set of feature names.</p>\n<p>Also, removing features is a <a href=\"rust-2024/../../cargo/reference/semver.html#cargo-feature-remove\">SemVer incompatible change</a>, which may not be obvious when removing an optional dependency that you thought was private.</p>\n<h2 id=\"migration-13\"><a class=\"header\" href=\"#migration-13\">Migration</a></h2>\n<p>When using <code class=\"hljs\">cargo fix --edition</code>, Cargo will automatically update your <code class=\"hljs\">Cargo.toml</code> file to include the implicit features if necessary.</p>\n<p>If you would prefer to update your <code class=\"hljs\">Cargo.toml</code> manually, add a <code class=\"hljs\">foo = [\"dep:foo\"]</code> entry for each optional dependency named <em>foo</em> if <code class=\"hljs\">dep:foo</code> is not already specified anywhere in the <code class=\"hljs\">[features]</code> table.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"cargo-table-and-key-name-consistency\"><a class=\"header\" href=\"#cargo-table-and-key-name-consistency\">Cargo: Table and key name consistency</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<h2 id=\"summary-20\"><a class=\"header\" href=\"#summary-20\">Summary</a></h2>\n<ul>\n<li>Several table and key names in <code class=\"hljs\">Cargo.toml</code> have been removed where there were previously two ways to specify the same thing.\n<ul>\n<li>Removed <code class=\"hljs\">[project]</code>; use <code class=\"hljs\">[package]</code> instead.</li>\n<li>Removed <code class=\"hljs\">default_features</code>; use <code class=\"hljs\">default-features</code> instead.</li>\n<li>Removed <code class=\"hljs\">crate_type</code>; use <code class=\"hljs\">crate-type</code> instead.</li>\n<li>Removed <code class=\"hljs\">proc_macro</code>; use <code class=\"hljs\">proc-macro</code> instead.</li>\n<li>Removed <code class=\"hljs\">dev_dependencies</code>; use <code class=\"hljs\">dev-dependencies</code> instead.</li>\n<li>Removed <code class=\"hljs\">build_dependencies</code>; use <code class=\"hljs\">build-dependencies</code> instead.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"details-17\"><a class=\"header\" href=\"#details-17\">Details</a></h2>\n<p>Several table and keys names are no longer allowed in the 2024 Edition.\nThere were two ways to specify these tables or keys, and this helps ensure there is only one way to specify them.</p>\n<p>Some were due to a change in decisions over time, and some were inadvertent implementation artifacts.\nIn order to avoid confusion, and to enforce a single style for specifying these tables and keys, only one variant is now allowed.</p>\n<p>For example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[dev_dependencies]</span>\n<span class=\"hljs-attr\">rand</span> = { version = <span class=\"hljs-string\">\"0.8.5\"</span>, default_features = <span class=\"hljs-literal\">false</span> }\n</code></pre>\n<p>Should be changed to:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[dev-dependencies]</span>\n<span class=\"hljs-attr\">rand</span> = { version = <span class=\"hljs-string\">\"0.8.5\"</span>, default-features = <span class=\"hljs-literal\">false</span> }\n</code></pre>\n<p>Notice that the underscores were changed to dashes for <code class=\"hljs\">dev_dependencies</code> and <code class=\"hljs\">default_features</code>.</p>\n<h2 id=\"migration-14\"><a class=\"header\" href=\"#migration-14\">Migration</a></h2>\n<p>When using <code class=\"hljs\">cargo fix --edition</code>, Cargo will automatically update your <code class=\"hljs\">Cargo.toml</code> file to use the preferred table and key names.</p>\n<p>If you would prefer to update your <code class=\"hljs\">Cargo.toml</code> manually, be sure to go through the list above and make sure only the new forms are used.</p>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"cargo-reject-unused-inherited-default-features\"><a class=\"header\" href=\"#cargo-reject-unused-inherited-default-features\">Cargo: Reject unused inherited default-features</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<h2 id=\"summary-21\"><a class=\"header\" href=\"#summary-21\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">default-features = false</code> is no longer allowed in an inherited workspace dependency if the workspace dependency specifies <code class=\"hljs\">default-features = true</code> (or does not specify <code class=\"hljs\">default-features</code>).</li>\n</ul>\n<h2 id=\"details-18\"><a class=\"header\" href=\"#details-18\">Details</a></h2>\n<p><a href=\"rust-2024/../../cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace\">Workspace inheritance</a> allows you to specify dependencies in one place (the workspace), and then to refer to those workspace dependencies from within a package.\nThere was an inadvertent interaction with how <code class=\"hljs\">default-features</code> is specified that is no longer allowed in the 2024 Edition.</p>\n<p>Unless the workspace specifies <code class=\"hljs\">default-features = false</code>, it is no longer allowed to specify <code class=\"hljs\">default-features = false</code> in an inherited package dependency.\nFor example, with a workspace that specifies:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[workspace.dependencies]</span>\n<span class=\"hljs-attr\">regex</span> = <span class=\"hljs-string\">\"1.10.4\"</span>\n</code></pre>\n<p>The following is now an error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"foo\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"1.0.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2024\"</span>\n\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">regex</span> = { workspace = <span class=\"hljs-literal\">true</span>, default-features = <span class=\"hljs-literal\">false</span> }  <span class=\"hljs-comment\"># ERROR</span>\n</code></pre>\n<p>The reason for this change is to avoid confusion when specifying <code class=\"hljs\">default-features = false</code> when the default feature is already enabled, since it has no effect.</p>\n<p>If you want the flexibility of deciding whether or not a dependency enables the default-features of a dependency, be sure to set <code class=\"hljs\">default-features = false</code> in the workspace definition.\nJust beware that if you build multiple workspace members at the same time, the features will be unified so that if one member sets <code class=\"hljs\">default-features = true</code> (which is the default if not explicitly set), the default-features will be enabled for all members using that dependency.</p>\n<h2 id=\"migration-15\"><a class=\"header\" href=\"#migration-15\">Migration</a></h2>\n<p>When using <code class=\"hljs\">cargo fix --edition</code>, Cargo will automatically update your <code class=\"hljs\">Cargo.toml</code> file to remove <code class=\"hljs\">default-features = false</code> in this situation.</p>\n<p>If you would prefer to update your <code class=\"hljs\">Cargo.toml</code> manually, check for any warnings when running a build and remove the corresponding entries.\nPrevious editions should display something like:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">warning: /home/project/Cargo.toml: `default-features` is ignored for regex,\nsince `default-features` was not specified for `workspace.dependencies.regex`,\nthis could become a hard error in the future\n</code></pre>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"rustfmt-combine-all-delimited-exprs-as-last-argument\"><a class=\"header\" href=\"#rustfmt-combine-all-delimited-exprs-as-last-argument\">Rustfmt: Combine all delimited exprs as last argument</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".</p>\n<p>This feature is not yet implemented.\nMore information may be found in <a href=\"https://github.com/rust-lang/rust/pull/114764\">https://github.com/rust-lang/rust/pull/114764</a>.</p>\n<h2 id=\"summary-22\"><a class=\"header\" href=\"#summary-22\">Summary</a></h2>\n<h2 id=\"details-19\"><a class=\"header\" href=\"#details-19\">Details</a></h2>\n<h2 id=\"migration-16\"><a class=\"header\" href=\"#migration-16\">Migration</a></h2>\n<div style=\"break-before: page; page-break-before: always;\"></div><h1 id=\"gen-keyword\"><a class=\"header\" href=\"#gen-keyword\"><code>gen</code> keyword</a></h1>\n<p>🚧 The 2024 Edition has not yet been released and hence this section is still \"under construction\".\nMore information may be found in the tracking issue at <a href=\"https://github.com/rust-lang/rust/issues/123904\">https://github.com/rust-lang/rust/issues/123904</a>.</p>\n<h2 id=\"summary-23\"><a class=\"header\" href=\"#summary-23\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">gen</code> is a <a href=\"rust-2024/../../reference/keywords.html#reserved-keywords\">reserved keyword</a>.</li>\n</ul>\n<h2 id=\"details-20\"><a class=\"header\" href=\"#details-20\">Details</a></h2>\n<p>The <code class=\"hljs\">gen</code> keyword has been reserved as part of <a href=\"https://rust-lang.github.io/rfcs/3513-gen-blocks.html\">RFC #3513</a> to introduce \"gen blocks\" in a future release of Rust. <code class=\"hljs\">gen</code> blocks will provide a way to make it easier to write certain kinds of iterators. Reserving the keyword now will make it easier to stabilize <code class=\"hljs\">gen</code> blocks before the next edition.</p>\n<h2 id=\"migration-17\"><a class=\"header\" href=\"#migration-17\">Migration</a></h2>\n<p>Introducing the <code class=\"hljs\">gen</code> keyword can cause a problem for any identifiers that are already called <code class=\"hljs\">gen</code>. For example, any variable or function name called <code class=\"hljs\">gen</code> would clash with the new keyword. To overcome this, Rust supports the <code class=\"hljs\">r#</code> prefix for a <a href=\"rust-2024/../../reference/identifiers.html#raw-identifiers\">raw identifier</a>, which allows identifiers to overlap with keywords.</p>\n<p>The <a href=\"rust-2024/../../rustc/lints/listing/allowed-by-default.html#keyword-idents-2024\"><code class=\"hljs\">keyword_idents_2024</code></a> lint will automatically modify any identifier named <code class=\"hljs\">gen</code> to be <code class=\"hljs\">r#gen</code> so that code continues to work on both editions. This lint is part of the <code class=\"hljs\">rust-2024-compatibility</code> lint group, which will automatically be applied when running <code class=\"hljs\">cargo fix --edition</code>. To migrate your code to be Rust 2024 Edition compatible, run:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>For example, this will change:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">gen</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"generating!\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    gen();\n}</code></pre></pre>\n<p>to be:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">r</span>#<span class=\"hljs-title\">gen</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"generating!\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    r#gen();\n}</code></pre></pre>\n<p>Alternatively, you can manually enable the lint to find places where <code class=\"hljs\">gen</code> identifiers need to be modified to <code class=\"hljs\">r#gen</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// Add this to the root of your crate to do a manual migration.</span>\n<span class=\"hljs-meta\">#![warn(keyword_idents_2024)]</span>\n<span class=\"boring\">}</span></code></pre></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n        <script>\n        window.addEventListener('load', function() {\n            window.setTimeout(window.print, 100);\n        });\n        </script>\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:36.130Z"
}