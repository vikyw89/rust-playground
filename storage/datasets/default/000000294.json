{
	"title": "std::pin - Rust",
	"url": "https://doc.rust-lang.org/stable/std/pin/index.html",
	"markdown": "# std::pin - Rust\n\nTypes that pin data to a location in memory.\n\nIt is sometimes useful to be able to rely upon a certain value not being able to _move_, in the sense that its address in memory cannot change. This is useful especially when there are one or more [_pointers_](../primitive.pointer.html \"primitive pointer\") pointing at that value. The ability to rely on this guarantee that the value a [pointer](../primitive.pointer.html \"primitive pointer\") is pointing at (its **pointee**) will\n\n1.  Not be _moved_ out of its memory location\n2.  More generally, remain _valid_ at that same memory location\n\nis called “pinning.” We would say that a value which satisfies these guarantees has been “pinned,” in that it has been permanently (until the end of its lifespan) attached to its location in memory, as though pinned to a pinboard. Pinning a value is an incredibly useful building block for [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code to be able to reason about whether a raw pointer to the pinned value is still valid. [As we’ll see later](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\"), this is necessarily from the time the value is first pinned until the end of its lifespan. This concept of “pinning” is necessary to implement safe interfaces on top of things like self-referential types and intrusive data structures which cannot currently be modeled in fully safe Rust using only borrow-checked [references](../primitive.reference.html \"primitive reference\").\n\n“Pinning” allows us to put a _value_ which exists at some location in memory into a state where safe code cannot _move_ that value to a different location in memory or otherwise invalidate it at its current location (unless it implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), which we will [talk about below](about:blank/index.html#unpin \"mod std::pin\")). Anything that wants to interact with the pinned value in a way that has the potential to violate these guarantees must promise that it will not actually violate them, using the [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") keyword to mark that such a promise is upheld by the user and not the compiler. In this way, we can allow other [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code to rely on any pointers that point to the pinned value to be valid to dereference while it is pinned.\n\nNote that as long as you don’t use [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\"), it’s impossible to create or misuse a pinned value in a way that is unsound. See the documentation of [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") for more information on the practicalities of how to pin a value and how to use that pinned value from a user’s perspective without using [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\").\n\nThe rest of this documentation is intended to be the source of truth for users of [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") that are implementing the [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") pieces of an interface that relies on pinning for validity; users of [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") in safe code do not need to read it in detail.\n\nThere are several sections to this documentation:\n\n-   [What is “_moving_”?](about:blank/index.html#what-is-moving \"mod std::pin\")\n-   [What is “pinning”?](about:blank/index.html#what-is-pinning \"mod std::pin\")\n-   [Address sensitivity, AKA “when do we need pinning?”](about:blank/index.html#address-sensitive-values-aka-when-we-need-pinning \"mod std::pin\")\n-   [Examples of types with address-sensitive states](#examples-of-address-sensitive-types)\n    -   [Self-referential struct](#a-self-referential-struct)\n    -   [Intrusive, doubly-linked list](#an-intrusive-doubly-linked-list)\n-   [Subtle details and the `Drop` guarantee](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\")\n\n## [§](#what-is-moving)What is “_moving_”?\n\nWhen we say a value is _moved_, we mean that the compiler copies, byte-for-byte, the value from one location to another. In a purely mechanical sense, this is identical to [`Copy`](../marker/trait.Copy.html \"trait std::marker::Copy\")ing a value from one place in memory to another. In Rust, “move” carries with it the semantics of ownership transfer from one variable to another, which is the key difference between a [`Copy`](../marker/trait.Copy.html \"trait std::marker::Copy\") and a move. For the purposes of this module’s documentation, however, when we write _move_ in italics, we mean _specifically_ that the value has _moved_ in the mechanical sense of being located at a new place in memory.\n\nAll values in Rust are trivially _moveable_. This means that the address at which a value is located is not necessarily stable in between borrows. The compiler is allowed to _move_ a value to a new address without running any code to notify that value that its address has changed. Although the compiler will not insert memory _moves_ where no semantic move has occurred, there are many places where a value _may_ be moved. For example, when doing assignment or passing a value into a function.\n\n```\n#[derive(Default)]\nstruct AddrTracker(Option<usize>);\n\nimpl AddrTracker {\n    // If we haven't checked the addr of self yet, store the current\n    // address. If we have, confirm that the current address is the same\n    // as it was last time, or else panic.\n    fn check_for_move(&mut self) {\n        let current_addr = self as *mut Self as usize;\n        match self.0 {\n            None => self.0 = Some(current_addr),\n            Some(prev_addr) => assert_eq!(prev_addr, current_addr),\n        }\n    }\n}\n\n// Create a tracker and store the initial address\nlet mut tracker = AddrTracker::default();\ntracker.check_for_move();\n\n// Here we shadow the variable. This carries a semantic move, and may therefore also\n// come with a mechanical memory *move*\nlet mut tracker = tracker;\n\n// May panic!\n// tracker.check_for_move();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bderive(Default)%5D%0A++++struct+AddrTracker(Option%3Cusize%3E);%0A++++%0A++++impl+AddrTracker+%7B%0A++++++++//+If+we+haven%27t+checked+the+addr+of+self+yet,+store+the+current%0A++++++++//+address.+If+we+have,+confirm+that+the+current+address+is+the+same%0A++++++++//+as+it+was+last+time,+or+else+panic.%0A++++++++fn+check_for_move(%26mut+self)+%7B%0A++++++++++++let+current_addr+=+self+as+*mut+Self+as+usize;%0A++++++++++++match+self.0+%7B%0A++++++++++++++++None+=%3E+self.0+=+Some(current_addr),%0A++++++++++++++++Some(prev_addr)+=%3E+assert_eq!(prev_addr,+current_addr),%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Create+a+tracker+and+store+the+initial+address%0A++++let+mut+tracker+=+AddrTracker::default();%0A++++tracker.check_for_move();%0A++++%0A++++//+Here+we+shadow+the+variable.+This+carries+a+semantic+move,+and+may+therefore+also%0A++++//+come+with+a+mechanical+memory+*move*%0A++++let+mut+tracker+=+tracker;%0A++++%0A++++//+May+panic!%0A++++//+tracker.check_for_move();%0A%7D&edition=2021)\n\nIn this sense, Rust does not guarantee that `check_for_move()` will never panic, because the compiler is permitted to _move_ `tracker` in many situations.\n\nCommon smart-pointer types such as [`Box<T>`](../../std/boxed/struct.Box.html) and [`&mut T`](../primitive.reference.html \"primitive reference\") also allow _moving_ the underlying _value_ they point at: you can move out of a [`Box<T>`](../../std/boxed/struct.Box.html), or you can use [`mem::replace`](../mem/fn.replace.html \"fn std::mem::replace\") to move a `T` out of a [`&mut T`](../primitive.reference.html \"primitive reference\"). Therefore, putting a value (such as `tracker` above) behind a pointer isn’t enough on its own to ensure that its address does not change.\n\n## [§](#what-is-pinning)What is “pinning”?\n\nWe say that a value has been _pinned_ when it has been put into a state where it is guaranteed to remain _located at the same place in memory_ from the time it is pinned until its [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") is called.\n\n### [§](#address-sensitive-values-aka-when-we-need-pinning)Address-sensitive values, AKA “when we need pinning”\n\nMost values in Rust are entirely okay with being _moved_ around at-will. Types for which it is _always_ the case that _any_ value of that type can be _moved_ at-will should implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), which we will discuss more [below](about:blank/index.html#unpin \"mod std::pin\").\n\n[`Pin`](struct.Pin.html \"struct std::pin::Pin\") is specifically targeted at allowing the implementation of _safe interfaces_ around types which have some state during which they become “address-sensitive.” A value in such an “address-sensitive” state is _not_ okay with being _moved_ around at-will. Such a value must stay _un-moved_ and valid during the address-sensitive portion of its lifespan because some interface is relying on those invariants to be true in order for its implementation to be sound.\n\nAs a motivating example of a type which may become address-sensitive, consider a type which contains a pointer to another piece of its own data, _i.e._ a “self-referential” type. In order for such a type to be implemented soundly, the pointer which points into `self`’s data must be proven valid whenever it is accessed. But if that value is _moved_, the pointer will still point to the old address where the value was located and not into the new location of `self`, thus becoming invalid. A key example of such self-referential types are the state machines generated by the compiler to implement [`Future`](../future/trait.Future.html \"future::Future\") for `async fn`s.\n\nSuch types that have an _address-sensitive_ state usually follow a lifecycle that looks something like so:\n\n1.  A value is created which can be freely moved around.\n    -   e.g. calling an async function which returns a state machine implementing [`Future`](../future/trait.Future.html \"future::Future\")\n2.  An operation causes the value to depend on its own address not changing\n    -   e.g. calling [`poll`](about:blank/future/trait.Future.html#tymethod.poll \"future::Future::poll\") for the first time on the produced [`Future`](../future/trait.Future.html \"future::Future\")\n3.  Further pieces of the safe interface of the type use internal [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") operations which assume that the address of the value is stable\n    -   e.g. subsequent calls to [`poll`](about:blank/future/trait.Future.html#tymethod.poll \"future::Future::poll\")\n4.  Before the value is invalidated (e.g. deallocated), it is _dropped_, giving it a chance to notify anything with pointers to itself that those pointers will be invalidated\n    -   e.g. [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\")ping the [`Future`](../future/trait.Future.html \"future::Future\") [1](#fn1)\n\nThere are two possible ways to ensure the invariants required for 2. and 3. above (which apply to any address-sensitive type, not just self-referential types) do not get broken.\n\n1.  Have the value detect when it is moved and update all the pointers that point to itself.\n2.  Guarantee that the address of the value does not change (and that memory is not re-used for anything else) during the time that the pointers to it are expected to be valid to dereference.\n\nSince, as we discussed, Rust can move values without notifying them that they have moved, the first option is ruled out.\n\nIn order to implement the second option, we must in some way enforce its key invariant, _i.e._ prevent the value from being _moved_ or otherwise invalidated (you may notice this sounds an awful lot like the definition of _pinning_ a value). There a few ways one might be able to enforce this invariant in Rust:\n\n1.  Offer a wholly `unsafe` API to interact with the object, thus requiring every caller to uphold the invariant themselves\n2.  Store the value that must not be moved behind a carefully managed pointer internal to the object\n3.  Leverage the type system to encode and enforce this invariant by presenting a restricted API surface to interact with _any_ object that requires these invariants\n\nThe first option is quite obviously undesirable, as the [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\")ty of the interface will become viral throughout all code that interacts with the object.\n\nThe second option is a viable solution to the problem for some use cases, in particular for self-referential types. Under this model, any type that has an address sensitive state would ultimately store its data in something like a [`Box<T>`](../../std/boxed/struct.Box.html), carefully manage internal access to that data to ensure no _moves_ or other invalidation occurs, and finally provide a safe interface on top.\n\nThere are a couple of linked disadvantages to using this model. The most significant is that each individual object must assume it is _on its own_ to ensure that its data does not become _moved_ or otherwise invalidated. Since there is no shared contract between values of different types, an object cannot assume that others interacting with it will properly respect the invariants around interacting with its data and must therefore protect it from everyone. Because of this, _composition_ of address-sensitive types requires at least a level of pointer indirection each time a new object is added to the mix (and, practically, a heap allocation).\n\nAlthough there were other reason as well, this issue of expensive composition is the key thing that drove Rust towards adopting a different model. It is particularly a problem when one considers, for example, the implications of composing together the [`Future`](../future/trait.Future.html \"future::Future\")s which will eventually make up an asynchronous task (including address-sensitive `async fn` state machines). It is plausible that there could be many layers of [`Future`](../future/trait.Future.html \"future::Future\")s composed together, including multiple layers of `async fn`s handling different parts of a task. It was deemed unacceptable to force indirection and allocation for each layer of composition in this case.\n\n[`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") is an implementation of the third option. It allows us to solve the issues discussed with the second option by building a _shared contractual language_ around the guarantees of “pinning” data.\n\n### [§](#using-pinptr-to-pin-values)Using [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") to pin values\n\nIn order to pin a value, we wrap a _pointer to that value_ (of some type `Ptr`) in a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee** will not be _moved_ or [otherwise invalidated](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\").\n\nWe call such a [`Pin`](struct.Pin.html \"struct std::pin::Pin\")\\-wrapped pointer a **pinning pointer,** (or pinning reference, or pinning `Box`, etc.) because its existence is the thing that is conceptually pinning the underlying pointee in place: it is the metaphorical “pin” securing the data in place on the pinboard (in memory).\n\nNotice that the thing wrapped by [`Pin`](struct.Pin.html \"struct std::pin::Pin\") is not the value which we want to pin itself, but rather a pointer to that value! A [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") does not pin the `Ptr`; instead, it pins the pointer’s _**pointee** value_.\n\n#### [§](#pinning-as-a-library-contract)Pinning as a library contract\n\nPinning does not require nor make use of any compiler “magic”[2](#fn2), only a specific contract between the [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") parts of a library API and its users.\n\nIt is important to stress this point as a user of the [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") parts of the [`Pin`](struct.Pin.html \"struct std::pin::Pin\") API. Practically, this means that performing the mechanics of “pinning” a value by creating a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") to it _does not_ actually change the way the compiler behaves towards the inner value! It is possible to use incorrect [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code to create a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") to a value which does not actually satisfy the invariants that a pinned value must satisfy, and in this way lead to undefined behavior even in (from that point) fully safe code. Similarly, using [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\"), one may get access to a bare [`&mut T`](../primitive.reference.html \"primitive reference\") from a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") and use that to invalidly _move_ the pinned value out. It is the job of the user of the [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") parts of the [`Pin`](struct.Pin.html \"struct std::pin::Pin\") API to ensure these invariants are not violated.\n\nThis differs from e.g. [`UnsafeCell`](../cell/struct.UnsafeCell.html \"struct std::cell::UnsafeCell\") which changes the semantics of a program’s compiled output. A [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") is a handle to a value which we have promised we will not move out of, but Rust still considers all values themselves to be fundamentally moveable through, _e.g._ assignment or [`mem::replace`](../mem/fn.replace.html \"fn std::mem::replace\").\n\n#### [§](#how-pin-prevents-misuse-in-safe-code)How [`Pin`](struct.Pin.html \"struct std::pin::Pin\") prevents misuse in safe code\n\nIn order to accomplish the goal of pinning the pointee value, [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") restricts access to the wrapped `Ptr` type in safe code. Specifically, [`Pin`](struct.Pin.html \"struct std::pin::Pin\") disallows the ability to access the wrapped pointer in ways that would allow the user to _move_ the underlying pointee value or otherwise re-use that memory for something else without using [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\"). For example, a [`Pin<&mut T>`](struct.Pin.html \"struct std::pin::Pin\") makes it impossible to obtain the wrapped `[&mut](../primitive.reference.html \"mutable reference\") T` safely because through that `[&mut](../primitive.reference.html \"mutable reference\") T` it would be possible to _move_ the underlying value out of the pointer with [`mem::replace`](../mem/fn.replace.html \"fn std::mem::replace\"), etc.\n\nAs discussed above, this promise must be upheld manually by [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code which interacts with the [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") so that other [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code can rely on the pointee value being _un-moved_ and valid. Interfaces that operate on values which are in an address-sensitive state accept an argument like `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") T>` or `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[Box](../../std/boxed/struct.Box.html \"Box\")<T>>` to indicate this contract to the caller.\n\n[As discussed below](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\"), opting in to using pinning guarantees in the interface of an address-sensitive type has consequences for the implementation of some safe traits on that type as well.\n\n### [§](#interaction-between-deref-and-pinptr)Interaction between [`Deref`](../ops/trait.Deref.html \"ops::Deref\") and [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\")\n\nSince [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, it uses [`Deref`](../ops/trait.Deref.html \"ops::Deref\") and [`DerefMut`](../ops/trait.DerefMut.html \"ops::DerefMut\") in order to identify the type of the pinned pointee data and provide (restricted) access to it.\n\nA [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") where [`Ptr: Deref`](../ops/trait.Deref.html \"ops::Deref\") is a “`Ptr`\\-style pinning pointer” to a pinned [`Ptr::Target`](about:blank/ops/trait.Deref.html#associatedtype.Target \"ops::Deref::Target\") – so, a `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[Box](../../std/boxed/struct.Box.html \"Box\")<T>>` is an owned, pinning pointer to a pinned `T`, and a `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[Rc](../../std/rc/struct.Rc.html \"rc::Rc\")<T>>` is a reference-counted, pinning pointer to a pinned `T`.\n\n[`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") also uses the [`<Ptr as Deref>::Target`](about:blank/ops/trait.Deref.html#associatedtype.Target \"ops::Deref::Target\") type information to modify the interface it is allowed to provide for interacting with that data (for example, when a pinning pointer points at pinned data which implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), as [discussed below](about:blank/index.html#unpin \"mod std::pin\")).\n\n[`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") requires that implementations of [`Deref`](../ops/trait.Deref.html \"ops::Deref\") and [`DerefMut`](../ops/trait.DerefMut.html \"ops::DerefMut\") on `Ptr` return a pointer to the pinned data directly and do not _move_ out of the `self` parameter during their implementation of [`DerefMut::deref_mut`](about:blank/ops/trait.DerefMut.html#tymethod.deref_mut \"method std::ops::DerefMut::deref_mut\"). It is unsound for [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code to wrap pointer types with such “malicious” implementations of [`Deref`](../ops/trait.Deref.html \"ops::Deref\"); see [`Pin<Ptr>::new_unchecked`](about:blank/struct.Pin.html#method.new_unchecked \"associated function std::pin::Pin::new_unchecked\") for details.\n\n### [§](#fixing-addrtracker)Fixing `AddrTracker`\n\nThe guarantee of a stable address is necessary to make our `AddrTracker` example work. When `check_for_move` sees a `[Pin](struct.Pin.html \"struct std::pin::Pin\")<&mut AddrTracker>`, it can safely assume that value will exist at that same address until said value goes out of scope, and thus multiple calls to it _cannot_ panic.\n\n```\nuse std::marker::PhantomPinned;\nuse std::pin::Pin;\nuse std::pin::pin;\n\n#[derive(Default)]\nstruct AddrTracker {\n    prev_addr: Option<usize>,\n    // remove auto-implemented `Unpin` bound to mark this type as having some\n    // address-sensitive state. This is essential for our expected pinning\n    // guarantees to work, and is discussed more below.\n    _pin: PhantomPinned,\n}\n\nimpl AddrTracker {\n    fn check_for_move(self: Pin<&mut Self>) {\n        let current_addr = &*self as *const Self as usize;\n        match self.prev_addr {\n            None => {\n                // SAFETY: we do not move out of self\n                let self_data_mut = unsafe { self.get_unchecked_mut() };\n                self_data_mut.prev_addr = Some(current_addr);\n            },\n            Some(prev_addr) => assert_eq!(prev_addr, current_addr),\n        }\n    }\n}\n\n// 1. Create the value, not yet in an address-sensitive state\nlet tracker = AddrTracker::default();\n\n// 2. Pin the value by putting it behind a pinning pointer, thus putting\n// it into an address-sensitive state\nlet mut ptr_to_pinned_tracker: Pin<&mut AddrTracker> = pin!(tracker);\nptr_to_pinned_tracker.as_mut().check_for_move();\n\n// Trying to access `tracker` or pass `ptr_to_pinned_tracker` to anything that requires\n// mutable access to a non-pinned version of it will no longer compile\n\n// 3. We can now assume that the tracker value will never be moved, thus\n// this will never panic!\nptr_to_pinned_tracker.as_mut().check_for_move();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::marker::PhantomPinned;%0A++++use+std::pin::Pin;%0A++++use+std::pin::pin;%0A++++%0A++++%23%5Bderive(Default)%5D%0A++++struct+AddrTracker+%7B%0A++++++++prev_addr:+Option%3Cusize%3E,%0A++++++++//+remove+auto-implemented+%60Unpin%60+bound+to+mark+this+type+as+having+some%0A++++++++//+address-sensitive+state.+This+is+essential+for+our+expected+pinning%0A++++++++//+guarantees+to+work,+and+is+discussed+more+below.%0A++++++++_pin:+PhantomPinned,%0A++++%7D%0A++++%0A++++impl+AddrTracker+%7B%0A++++++++fn+check_for_move(self:+Pin%3C%26mut+Self%3E)+%7B%0A++++++++++++let+current_addr+=+%26*self+as+*const+Self+as+usize;%0A++++++++++++match+self.prev_addr+%7B%0A++++++++++++++++None+=%3E+%7B%0A++++++++++++++++++++//+SAFETY:+we+do+not+move+out+of+self%0A++++++++++++++++++++let+self_data_mut+=+unsafe+%7B+self.get_unchecked_mut()+%7D;%0A++++++++++++++++++++self_data_mut.prev_addr+=+Some(current_addr);%0A++++++++++++++++%7D,%0A++++++++++++++++Some(prev_addr)+=%3E+assert_eq!(prev_addr,+current_addr),%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+1.+Create+the+value,+not+yet+in+an+address-sensitive+state%0A++++let+tracker+=+AddrTracker::default();%0A++++%0A++++//+2.+Pin+the+value+by+putting+it+behind+a+pinning+pointer,+thus+putting%0A++++//+it+into+an+address-sensitive+state%0A++++let+mut+ptr_to_pinned_tracker:+Pin%3C%26mut+AddrTracker%3E+=+pin!(tracker);%0A++++ptr_to_pinned_tracker.as_mut().check_for_move();%0A++++%0A++++//+Trying+to+access+%60tracker%60+or+pass+%60ptr_to_pinned_tracker%60+to+anything+that+requires%0A++++//+mutable+access+to+a+non-pinned+version+of+it+will+no+longer+compile%0A++++%0A++++//+3.+We+can+now+assume+that+the+tracker+value+will+never+be+moved,+thus%0A++++//+this+will+never+panic!%0A++++ptr_to_pinned_tracker.as_mut().check_for_move();%0A%7D&edition=2021)\n\nNote that this invariant is enforced by simply making it impossible to call code that would perform a move on the pinned value. This is the case since the only way to access that pinned value is through the pinning `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") T>>`, which in turn restricts our access.\n\n### [§](#unpin)[`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\")\n\nThe vast majority of Rust types have no address-sensitive states. These types implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") auto-trait, which cancels the restrictive effects of [`Pin`](struct.Pin.html \"struct std::pin::Pin\") when the _pointee_ type `T` is [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"). When [`T: Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[Box](../../std/boxed/struct.Box.html \"Box\")<T>>` functions identically to a non-pinning [`Box<T>`](../../std/boxed/struct.Box.html); similarly, `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") T>` would impose no additional restrictions above a regular [`&mut T`](../primitive.reference.html \"primitive reference\").\n\nThe idea of this trait is to alleviate the reduced ergonomics of APIs that require the use of [`Pin`](struct.Pin.html \"struct std::pin::Pin\") for soundness for some types, but which also want to be used by other types that don’t care about pinning. The prime example of such an API is [`Future::poll`](about:blank/future/trait.Future.html#tymethod.poll \"method std::future::Future::poll\"). There are many [`Future`](../future/trait.Future.html \"future::Future\") types that don’t care about pinning. These futures can implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") and therefore get around the pinning related restrictions in the API, while still allowing the subset of [`Future`](../future/trait.Future.html \"future::Future\")s which _do_ require pinning to be implemented soundly.\n\nNote that the interaction between a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") and [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") is through the type of the **pointee** value, [`<Ptr as Deref>::Target`](about:blank/ops/trait.Deref.html#associatedtype.Target \"ops::Deref::Target\"). Whether the `Ptr` type itself implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") does not affect the behavior of a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\"). For example, whether or not [`Box`](../../std/boxed/struct.Box.html \"Box\") is [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") has no effect on the behavior of `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[Box](../../std/boxed/struct.Box.html \"Box\")<T>>`, because `T` is the type of the pointee value, not [`Box`](../../std/boxed/struct.Box.html \"Box\"). So, whether `T` implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") is the thing that will affect the behavior of the `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[Box](../../std/boxed/struct.Box.html \"Box\")<T>>`.\n\nBuiltin types that are [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") include all of the primitive types, like [`bool`](../primitive.bool.html \"primitive bool\"), [`i32`](../primitive.i32.html \"primitive i32\"), and [`f32`](../primitive.f32.html \"primitive f32\"), references (`[&](../primitive.reference.html \"shared reference\")T` and `[&mut](../primitive.reference.html \"mutable reference\") T`), etc., as well as many core and standard library types like [`Box<T>`](../../std/boxed/struct.Box.html), [`String`](../../std/string/struct.String.html \"String\"), and more. These types are marked [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") because they do not have an address-sensitive state like the ones we discussed above. If they did have such a state, those parts of their interface would be unsound without being expressed through pinning, and they would then need to not implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\").\n\nThe compiler is free to take the conservative stance of marking types as [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") so long as all of the types that compose its fields are also [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"). This is because if a type implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), then it is unsound for that type’s implementation to rely on pinning-related guarantees for soundness, _even_ when viewed through a “pinning” pointer! It is the responsibility of the implementor of a type that relies upon pinning for soundness to ensure that type is _not_ marked as [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") by adding [`PhantomPinned`](../marker/struct.PhantomPinned.html \"struct std::marker::PhantomPinned\") field. This is exactly what we did with our `AddrTracker` example above. Without doing this, you _must not_ rely on pinning-related guarantees to apply to your type!\n\nIf need to truly pin a value of a foreign or built-in type that implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), you’ll need to create your own wrapper type around the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") type you want to pin and then opts-out of [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") using [`PhantomPinned`](../marker/struct.PhantomPinned.html \"struct std::marker::PhantomPinned\").\n\nExposing access to the inner field which you want to remain pinned must then be carefully considered as well! Remember, exposing a method that gives access to a `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") InnerT>>` where `InnerT: [Unpin](../marker/trait.Unpin.html \"trait std::marker::Unpin\")` would allow safe code to trivially move the inner value out of that pinning pointer, which is precisely what you’re seeking to prevent! Exposing a field of a pinned value through a pinning pointer is called “projecting” a pin, and the more general case of deciding in which cases a pin should be able to be projected or not is called “structural pinning.” We will go into more detail about this [below](about:blank/index.html#projections-and-structural-pinning \"mod std::pin\").\n\n## [§](#examples-of-address-sensitive-types)Examples of address-sensitive types\n\n### [§](#a-self-referential-struct)A self-referential struct\n\nSelf-referential structs are the simplest kind of address-sensitive type.\n\nIt is often useful for a struct to hold a pointer back into itself, which allows the program to efficiently track subsections of the struct. Below, the `slice` field is a pointer into the `data` field, which we could imagine being used to track a sliding window of `data` in parser code.\n\nAs mentioned before, this pattern is also used extensively by compiler-generated [`Future`](../future/trait.Future.html \"future::Future\")s.\n\n```\nuse std::pin::Pin;\nuse std::marker::PhantomPinned;\nuse std::ptr::NonNull;\n\n/// This is a self-referential struct because `self.slice` points into `self.data`.\nstruct Unmovable {\n    /// Backing buffer.\n    data: [u8; 64],\n    /// Points at `self.data` which we know is itself non-null. Raw pointer because we can't do\n    /// this with a normal reference.\n    slice: NonNull<[u8]>,\n    /// Suppress `Unpin` so that this cannot be moved out of a `Pin` once constructed.\n    _pin: PhantomPinned,\n}\n\nimpl Unmovable {\n    /// Create a new `Unmovable`.\n    ///\n    /// To ensure the data doesn't move we place it on the heap behind a pinning Box.\n    /// Note that the data is pinned, but the `Pin<Box<Self>>` which is pinning it can\n    /// itself still be moved. This is important because it means we can return the pinning\n    /// pointer from the function, which is itself a kind of move!\n    fn new() -> Pin<Box<Self>> {\n        let res = Unmovable {\n            data: [0; 64],\n            // We only create the pointer once the data is in place\n            // otherwise it will have already moved before we even started.\n            slice: NonNull::from(&[]),\n            _pin: PhantomPinned,\n        };\n        // First we put the data in a box, which will be its final resting place\n        let mut boxed = Box::new(res);\n\n        // Then we make the slice field point to the proper part of that boxed data.\n        // From now on we need to make sure we don't move the boxed data.\n        boxed.slice = NonNull::from(&boxed.data);\n\n        // To do that, we pin the data in place by pointing to it with a pinning\n        // (`Pin`-wrapped) pointer.\n        //\n        // `Box::into_pin` makes existing `Box` pin the data in-place without moving it,\n        // so we can safely do this now *after* inserting the slice pointer above, but we have\n        // to take care that we haven't performed any other semantic moves of `res` in between.\n        let pin = Box::into_pin(boxed);\n\n        // Now we can return the pinned (through a pinning Box) data\n        pin\n    }\n}\n\nlet unmovable: Pin<Box<Unmovable>> = Unmovable::new();\n\n// The inner pointee `Unmovable` struct will now never be allowed to move.\n// Meanwhile, we are free to move the pointer around.\nlet mut still_unmoved = unmovable;\nassert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n\n// We cannot mutably dereference a `Pin<Ptr>` unless the pointee is `Unpin` or we use unsafe.\n// Since our type doesn't implement `Unpin`, this will fail to compile.\n// let mut new_unmoved = Unmovable::new();\n// std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++use+std::marker::PhantomPinned;%0A++++use+std::ptr::NonNull;%0A++++%0A++++///+This+is+a+self-referential+struct+because+%60self.slice%60+points+into+%60self.data%60.%0A++++struct+Unmovable+%7B%0A++++++++///+Backing+buffer.%0A++++++++data:+%5Bu8;+64%5D,%0A++++++++///+Points+at+%60self.data%60+which+we+know+is+itself+non-null.+Raw+pointer+because+we+can%27t+do%0A++++++++///+this+with+a+normal+reference.%0A++++++++slice:+NonNull%3C%5Bu8%5D%3E,%0A++++++++///+Suppress+%60Unpin%60+so+that+this+cannot+be+moved+out+of+a+%60Pin%60+once+constructed.%0A++++++++_pin:+PhantomPinned,%0A++++%7D%0A++++%0A++++impl+Unmovable+%7B%0A++++++++///+Create+a+new+%60Unmovable%60.%0A++++++++///%0A++++++++///+To+ensure+the+data+doesn%27t+move+we+place+it+on+the+heap+behind+a+pinning+Box.%0A++++++++///+Note+that+the+data+is+pinned,+but+the+%60Pin%3CBox%3CSelf%3E%3E%60+which+is+pinning+it+can%0A++++++++///+itself+still+be+moved.+This+is+important+because+it+means+we+can+return+the+pinning%0A++++++++///+pointer+from+the+function,+which+is+itself+a+kind+of+move!%0A++++++++fn+new()+-%3E+Pin%3CBox%3CSelf%3E%3E+%7B%0A++++++++++++let+res+=+Unmovable+%7B%0A++++++++++++++++data:+%5B0;+64%5D,%0A++++++++++++++++//+We+only+create+the+pointer+once+the+data+is+in+place%0A++++++++++++++++//+otherwise+it+will+have+already+moved+before+we+even+started.%0A++++++++++++++++slice:+NonNull::from(%26%5B%5D),%0A++++++++++++++++_pin:+PhantomPinned,%0A++++++++++++%7D;%0A++++++++++++//+First+we+put+the+data+in+a+box,+which+will+be+its+final+resting+place%0A++++++++++++let+mut+boxed+=+Box::new(res);%0A++++%0A++++++++++++//+Then+we+make+the+slice+field+point+to+the+proper+part+of+that+boxed+data.%0A++++++++++++//+From+now+on+we+need+to+make+sure+we+don%27t+move+the+boxed+data.%0A++++++++++++boxed.slice+=+NonNull::from(%26boxed.data);%0A++++%0A++++++++++++//+To+do+that,+we+pin+the+data+in+place+by+pointing+to+it+with+a+pinning%0A++++++++++++//+(%60Pin%60-wrapped)+pointer.%0A++++++++++++//%0A++++++++++++//+%60Box::into_pin%60+makes+existing+%60Box%60+pin+the+data+in-place+without+moving+it,%0A++++++++++++//+so+we+can+safely+do+this+now+*after*+inserting+the+slice+pointer+above,+but+we+have%0A++++++++++++//+to+take+care+that+we+haven%27t+performed+any+other+semantic+moves+of+%60res%60+in+between.%0A++++++++++++let+pin+=+Box::into_pin(boxed);%0A++++%0A++++++++++++//+Now+we+can+return+the+pinned+(through+a+pinning+Box)+data%0A++++++++++++pin%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+unmovable:+Pin%3CBox%3CUnmovable%3E%3E+=+Unmovable::new();%0A++++%0A++++//+The+inner+pointee+%60Unmovable%60+struct+will+now+never+be+allowed+to+move.%0A++++//+Meanwhile,+we+are+free+to+move+the+pointer+around.%0A++++%23%5Ballow(unused_mut)%5D%0A++++let+mut+still_unmoved+=+unmovable;%0A++++assert_eq!(still_unmoved.slice,+NonNull::from(%26still_unmoved.data));%0A++++%0A++++//+We+cannot+mutably+dereference+a+%60Pin%3CPtr%3E%60+unless+the+pointee+is+%60Unpin%60+or+we+use+unsafe.%0A++++//+Since+our+type+doesn%27t+implement+%60Unpin%60,+this+will+fail+to+compile.%0A++++//+let+mut+new_unmoved+=+Unmovable::new();%0A++++//+std::mem::swap(%26mut+*still_unmoved,+%26mut+*new_unmoved);%0A%7D&edition=2021)\n\n### [§](#an-intrusive-doubly-linked-list)An intrusive, doubly-linked list\n\nIn an intrusive doubly-linked list, the collection itself does not own the memory in which each of its elements is stored. Instead, each client is free to allocate space for elements it adds to the list in whichever manner it likes, including on the stack! Elements can live on a stack frame that lives shorter than the collection does provided the elements that live in a given stack frame are removed from the list before going out of scope.\n\nTo make such an intrusive data structure work, every element stores pointers to its predecessor and successor within its own data, rather than having the list structure itself managing those pointers. It is in this sense that the structure is “intrusive”: the details of how an element is stored within the larger structure “intrudes” on the implementation of the element type itself!\n\nThe full implementation details of such a data structure are outside the scope of this documentation, but we will discuss how [`Pin`](struct.Pin.html \"struct std::pin::Pin\") can help to do so.\n\nUsing such an intrusive pattern, elements may only be added when they are pinned. If we think about the consequences of adding non-pinned values to such a list, this becomes clear:\n\n_Moving_ or otherwise invalidating an element’s data would invalidate the pointers back to it which are stored in the elements ahead and behind it. Thus, in order to soundly dereference the pointers stored to the next and previous elements, we must satisfy the guarantee that nothing has invalidated those pointers (which point to data that we do not own).\n\nMoreover, the [`Drop`](../ops/trait.Drop.html \"trait std::ops::Drop\") implementation of each element must in some way notify its predecessor and successor elements that it should be removed from the list before it is fully destroyed, otherwise the pointers back to it would again become invalidated.\n\nCrucially, this means we have to be able to rely on [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") always being called before an element is invalidated. If an element could be deallocated or otherwise invalidated without calling [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\"), the pointers to it stored in its neighboring elements would become invalid, which would break the data structure.\n\nTherefore, pinning data also comes with [the “`Drop` guarantee”](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\").\n\n## [§](#subtle-details-and-the-drop-guarantee)Subtle details and the `Drop` guarantee\n\nThe purpose of pinning is not _just_ to prevent a value from being _moved_, but more generally to be able to rely on the pinned value _remaining valid **at a specific place**_ in memory.\n\nTo do so, pinning a value adds an _additional_ invariant that must be upheld in order for use of the pinned data to be valid, on top of the ones that must be upheld for a non-pinned value of the same type to be valid:\n\nFrom the moment a value is pinned by constructing a [`Pin`](struct.Pin.html \"struct std::pin::Pin\")ning pointer to it, that value must _remain, **valid**_, at that same address in memory, _until its [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") handler is called._\n\nThere is some subtlety to this which we have not yet talked about in detail. The invariant described above means that, yes,\n\n1.  The value must not be moved out of its location in memory\n\nbut it also implies that,\n\n2.  The memory location that stores the value must not get invalidated or otherwise repurposed during the lifespan of the pinned value until its [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") returns or panics\n\nThis point is subtle but required for intrusive data structures to be implemented soundly.\n\n### [§](#drop-guarantee)`Drop` guarantee\n\nThere needs to be a way for a pinned value to notify any code that is relying on its pinned status that it is about to be destroyed. In this way, the dependent code can remove the pinned value’s address from its data structures or otherwise change its behavior with the knowledge that it can no longer rely on that value existing at the location it was pinned to.\n\nThus, in any situation where we may want to overwrite a pinned value, that value’s [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") must be called beforehand (unless the pinned value implements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), in which case we can ignore all of [`Pin`](struct.Pin.html \"struct std::pin::Pin\")’s guarantees, as usual).\n\nThe most common storage-reuse situations occur when a value on the stack is destroyed as part of a function return and when heap storage is freed. In both cases, [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") gets run for us by Rust when using standard safe code. However, for manual heap allocations or otherwise custom-allocated storage, [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code must make sure to call [`ptr::drop_in_place`](../ptr/fn.drop_in_place.html \"fn std::ptr::drop_in_place\") before deallocating and re-using said storage.\n\nIn addition, storage “re-use”/invalidation can happen even if no storage is (de-)allocated. For example, if we had an [`Option`](../option/enum.Option.html \"enum std::option::Option\") which contained a `Some(v)` where `v` is pinned, then `v` would be invalidated by setting that option to `None`.\n\nSimilarly, if a [`Vec`](../../std/vec/struct.Vec.html \"Vec\") was used to store pinned values and [`Vec::set_len`](about:blank/std/vec/struct.Vec.html#method.set_len \"Vec::set_len\") was used to manually “kill” some elements of a vector, all of the items “killed” would become invalidated, which would be _undefined behavior_ if those items were pinned.\n\nBoth of these cases are somewhat contrived, but it is crucial to remember that [`Pin`](struct.Pin.html \"struct std::pin::Pin\")ned data _must_ be [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\")ped before it is invalidated; not just to prevent memory leaks, but as a matter of soundness. As a corollary, the following code can _never_ be made safe:\n\n```\n// Pin something inside a `ManuallyDrop`. This is fine on its own.\nlet mut pin: Pin<Box<ManuallyDrop<Type>>> = Box::pin(ManuallyDrop::new(Type));\n\n// However, creating a pinning mutable reference to the type *inside*\n// the `ManuallyDrop` is not!\nlet inner: Pin<&mut Type> = unsafe {\n    Pin::map_unchecked_mut(pin.as_mut(), |x| &mut **x)\n};\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::ManuallyDrop;%0A++++use+std::pin::Pin;%0A++++struct+Type;%0A++++//+Pin+something+inside+a+%60ManuallyDrop%60.+This+is+fine+on+its+own.%0A++++let+mut+pin:+Pin%3CBox%3CManuallyDrop%3CType%3E%3E%3E+=+Box::pin(ManuallyDrop::new(Type));%0A++++%0A++++//+However,+creating+a+pinning+mutable+reference+to+the+type+*inside*%0A++++//+the+%60ManuallyDrop%60+is+not!%0A++++let+inner:+Pin%3C%26mut+Type%3E+=+unsafe+%7B%0A++++++++Pin::map_unchecked_mut(pin.as_mut(),+%7Cx%7C+%26mut+**x)%0A++++%7D;%0A%7D&edition=2021)\n\nBecause [`mem::ManuallyDrop`](../mem/struct.ManuallyDrop.html \"struct std::mem::ManuallyDrop\") inhibits the destructor of `Type`, it won’t get run when the `[Box](../../std/boxed/struct.Box.html \"Box\")<[ManuallyDrop](../mem/struct.ManuallyDrop.html \"ManuallyDrop\")<Type>>` is dropped, thus violating the drop guarantee of the `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") Type>>`.\n\nOf course, _leaking_ memory in such a way that its underlying storage will never get invalidated or re-used is still fine: [`mem::forget`](../mem/fn.forget.html \"mem::forget\")ing a [`Box<T>`](../../std/boxed/struct.Box.html) prevents its storage from ever getting re-used, so the [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") guarantee is still satisfied.\n\n## [§](#implementing-an-address-sensitive-type)Implementing an address-sensitive type.\n\nThis section goes into detail on important considerations for implementing your own address-sensitive types, which are different from merely using [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") in a generic way.\n\n### [§](#implementing-drop-for-types-with-address-sensitive-states)Implementing [`Drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") for types with address-sensitive states\n\nThe [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") function takes [`&mut self`](../primitive.reference.html \"primitive reference\"), but this is called _even if that `self` has been pinned_! Implementing [`Drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") for a type with address-sensitive states, because if `self` was indeed in an address-sensitive state before [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") was called, it is as if the compiler automatically called [`Pin::get_unchecked_mut`](about:blank/struct.Pin.html#method.get_unchecked_mut \"method std::pin::Pin::get_unchecked_mut\").\n\nThis can never cause a problem in purely safe code because creating a pinning pointer to a type which has an address-sensitive (thus does not implement `Unpin`) requires `unsafe`, but it is important to note that choosing to take advantage of pinning-related guarantees to justify validity in the implementation of your type has consequences for that type’s [`Drop`](../ops/trait.Drop.html \"trait std::ops::Drop\") implementation as well: if an element of your type could have been pinned, you must treat [`Drop`](../ops/trait.Drop.html \"trait std::ops::Drop\") as implicitly taking `self: [Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") Self>`.\n\nYou should implement [`Drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") as follows:\n\n```\nimpl Drop for Type {\n    fn drop(&mut self) {\n        // `new_unchecked` is okay because we know this value is never used\n        // again after being dropped.\n        inner_drop(unsafe { Pin::new_unchecked(self)});\n        fn inner_drop(this: Pin<&mut Type>) {\n            // Actual drop code goes here.\n        }\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++struct+Type;%0A++++impl+Drop+for+Type+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++//+%60new_unchecked%60+is+okay+because+we+know+this+value+is+never+used%0A++++++++++++//+again+after+being+dropped.%0A++++++++++++inner_drop(unsafe+%7B+Pin::new_unchecked(self)%7D);%0A++++++++++++fn+inner_drop(this:+Pin%3C%26mut+Type%3E)+%7B%0A++++++++++++++++//+Actual+drop+code+goes+here.%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nThe function `inner_drop` has the signature that [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") _should_ have in this situation. This makes sure that you do not accidentally use `self`/`this` in a way that is in conflict with pinning’s invariants.\n\nMoreover, if your type is [`#[repr(packed)]`](https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked), the compiler will automatically move fields around to be able to drop them. It might even do that for fields that happen to be sufficiently aligned. As a consequence, you cannot use pinning with a [`#[repr(packed)]`](https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked) type.\n\n#### [§](#implementing-drop-for-pointer-types-which-will-be-used-as-pinning-pointers)Implementing [`Drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") for pointer types which will be used as [`Pin`](struct.Pin.html \"struct std::pin::Pin\")ning pointers\n\nIt should further be noted that creating a pinning pointer of some type `Ptr` _also_ carries with it implications on the way that `Ptr` type must implement [`Drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") (as well as [`Deref`](../ops/trait.Deref.html \"ops::Deref\") and [`DerefMut`](../ops/trait.DerefMut.html \"ops::DerefMut\"))! When implementing a pointer type that may be used as a pinning pointer, you must also take the same care described above not to _move_ out of or otherwise invalidate the pointee during [`Drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\"), [`Deref`](../ops/trait.Deref.html \"ops::Deref\"), or [`DerefMut`](../ops/trait.DerefMut.html \"ops::DerefMut\") implementations.\n\n### [§](#assigning-pinned-data)“Assigning” pinned data\n\nAlthough in general it is not valid to swap data or assign through a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") for the same reason that reusing a pinned object’s memory is invalid, it is possible to do validly when implemented with special care for the needs of the exact data structure which is being modified. For example, the assigning function must know how to update all uses of the pinned address (and any other invariants necessary to satisfy validity for that type). For [`Unmovable`](#a-self-referential-struct) (from the example above), we could write an assignment function like so:\n\n```\nimpl Unmovable {\n    // Copies the contents of `src` into `self`, fixing up the self-pointer\n    // in the process.\n    fn assign(self: Pin<&mut Self>, src: Pin<&mut Self>) {\n        unsafe {\n            let unpinned_self = Pin::into_inner_unchecked(self);\n            let unpinned_src = Pin::into_inner_unchecked(src);\n            *unpinned_self = Self {\n                data: unpinned_src.data,\n                slice: NonNull::from(&mut []),\n                _pin: PhantomPinned,\n            };\n\n            let data_ptr = unpinned_src.data.as_ptr() as *const u8;\n            let slice_ptr = unpinned_src.slice.as_ptr() as *const u8;\n            let offset = slice_ptr.offset_from(data_ptr) as usize;\n            let len = (*unpinned_src.slice.as_ptr()).len();\n\n            unpinned_self.slice = NonNull::from(&mut unpinned_self.data[offset..offset+len]);\n        }\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++use+std::marker::PhantomPinned;%0A++++use+std::ptr::NonNull;%0A++++struct+Unmovable+%7B%0A++++++++data:+%5Bu8;+64%5D,%0A++++++++slice:+NonNull%3C%5Bu8%5D%3E,%0A++++++++_pin:+PhantomPinned,%0A++++%7D%0A++++%0A++++impl+Unmovable+%7B%0A++++++++//+Copies+the+contents+of+%60src%60+into+%60self%60,+fixing+up+the+self-pointer%0A++++++++//+in+the+process.%0A++++++++fn+assign(self:+Pin%3C%26mut+Self%3E,+src:+Pin%3C%26mut+Self%3E)+%7B%0A++++++++++++unsafe+%7B%0A++++++++++++++++let+unpinned_self+=+Pin::into_inner_unchecked(self);%0A++++++++++++++++let+unpinned_src+=+Pin::into_inner_unchecked(src);%0A++++++++++++++++*unpinned_self+=+Self+%7B%0A++++++++++++++++++++data:+unpinned_src.data,%0A++++++++++++++++++++slice:+NonNull::from(%26mut+%5B%5D),%0A++++++++++++++++++++_pin:+PhantomPinned,%0A++++++++++++++++%7D;%0A++++%0A++++++++++++++++let+data_ptr+=+unpinned_src.data.as_ptr()+as+*const+u8;%0A++++++++++++++++let+slice_ptr+=+unpinned_src.slice.as_ptr()+as+*const+u8;%0A++++++++++++++++let+offset+=+slice_ptr.offset_from(data_ptr)+as+usize;%0A++++++++++++++++let+len+=+(*unpinned_src.slice.as_ptr()).len();%0A++++%0A++++++++++++++++unpinned_self.slice+=+NonNull::from(%26mut+unpinned_self.data%5Boffset..offset%2Blen%5D);%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nEven though we can’t have the compiler do the assignment for us, it’s possible to write such specialized functions for types that might need it.\n\nNote that it _is_ possible to assign generically through a [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") by way of [`Pin::set()`](about:blank/struct.Pin.html#method.set \"method std::pin::Pin::set\"). This does not violate any guarantees, since it will run [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") on the pointee value before assigning the new value. Thus, the [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") implementation still has a chance to perform the necessary notifications to dependent values before the memory location of the original pinned value is overwritten.\n\n### [§](#projections-and-structural-pinning)Projections and Structural Pinning\n\nWith ordinary structs, it is natural that we want to add _projection_ methods that allow borrowing one or more of the inner fields of a struct when the caller has access to a borrow of the whole struct:\n\n```\nstruct Struct {\n    field: Field,\n    // ...\n}\n\nimpl Struct {\n    fn field(&mut self) -> &mut Field { &mut self.field }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+Field;%0A++++struct+Struct+%7B%0A++++++++field:+Field,%0A++++++++//+...%0A++++%7D%0A++++%0A++++impl+Struct+%7B%0A++++++++fn+field(%26mut+self)+-%3E+%26mut+Field+%7B+%26mut+self.field+%7D%0A++++%7D%0A%7D&edition=2021)\n\nWhen working with address-sensitive types, it’s not obvious what the signature of these functions should be. If `field` takes `self: [Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut Struct](../primitive.reference.html \"mutable reference\")>`, should it return [`&mut Field`](../primitive.reference.html \"primitive reference\") or ``[Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut Field`](../primitive.reference.html \"primitive reference\")>``? This question also arises with `enum`s and wrapper types like [`Vec<T>`](../../std/vec/struct.Vec.html), [`Box<T>`](../../std/boxed/struct.Box.html), and [`RefCell<T>`](../cell/struct.RefCell.html \"struct std::cell::RefCell\"). (This question applies just as well to shared references, but we’ll examine the more common case of mutable references for illustration)\n\nIt turns out that it’s up to the author of `Struct` to decide which type the “projection” should produce. The choice must be _consistent_ though: if a pin is projected to a field in one place, then it should very likely not be exposed elsewhere without projecting the pin.\n\nAs the author of a data structure, you get to decide for each field whether pinning “propagates” to this field or not. Pinning that propagates is also called “structural”, because it follows the structure of the type.\n\nThis choice depends on what guarantees you need from the field for your [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code to work. If the field is itself address-sensitive, or participates in the parent struct’s address sensitivity, it will need to be structurally pinned.\n\nA useful test is if [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code that consumes `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut Struct](../primitive.reference.html \"mutable reference\")>` also needs to take note of the address of the field itself, it may be evidence that that field is structurally pinned. Unfortunately, there are no hard-and-fast rules.\n\n#### [§](#choosing-pinning-not-to-be-structural-for-field)Choosing pinning _not to be_ structural for `field`…\n\nWhile counter-intuitive, it’s often the easier choice: if you do not expose a `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") Field>`, you do not need to be careful about other code moving out of that field, you just have to ensure is that you never create pinning reference to that field. This does of course also mean that if you decide a field does not have structural pinning, you must not write [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\") code that assumes (invalidly) that the field _is_ structurally pinned!\n\nFields without structural pinning may have a projection method that turns `[Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut](../primitive.reference.html \"mutable reference\") Struct>` into [`&mut Field`](../primitive.reference.html \"primitive reference\"):\n\n```\nimpl Struct {\n    fn field(self: Pin<&mut Self>) -> &mut Field {\n        // This is okay because `field` is never considered pinned, therefore we do not\n        // need to uphold any pinning guarantees for this field in particular. Of course,\n        // we must not elsewhere assume this field *is* pinned if we choose to expose\n        // such a method!\n        unsafe { &mut self.get_unchecked_mut().field }\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++type+Field+=+i32;%0A++++struct+Struct+%7B+field:+Field+%7D%0A++++impl+Struct+%7B%0A++++++++fn+field(self:+Pin%3C%26mut+Self%3E)+-%3E+%26mut+Field+%7B%0A++++++++++++//+This+is+okay+because+%60field%60+is+never+considered+pinned,+therefore+we+do+not%0A++++++++++++//+need+to+uphold+any+pinning+guarantees+for+this+field+in+particular.+Of+course,%0A++++++++++++//+we+must+not+elsewhere+assume+this+field+*is*+pinned+if+we+choose+to+expose%0A++++++++++++//+such+a+method!%0A++++++++++++unsafe+%7B+%26mut+self.get_unchecked_mut().field+%7D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nYou may also in this situation `impl [Unpin](../marker/trait.Unpin.html \"trait std::marker::Unpin\") for Struct {}` _even if_ the type of `field` is not [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"). Since we have explicitly chosen not to care about pinning guarantees for `field`, the way `field`’s type interacts with pinning is no longer relevant in the context of its use in `Struct`.\n\n#### [§](#choosing-pinning-to-be-structural-for-field)Choosing pinning _to be_ structural for `field`…\n\nThe other option is to decide that pinning is “structural” for `field`, meaning that if the struct is pinned then so is the field.\n\nThis allows writing a projection that creates a ``[Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut Field`](../primitive.reference.html \"primitive reference\")>``, thus witnessing that the field is pinned:\n\n```\nimpl Struct {\n    fn field(self: Pin<&mut Self>) -> Pin<&mut Field> {\n        // This is okay because `field` is pinned when `self` is.\n        unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++type+Field+=+i32;%0A++++struct+Struct+%7B+field:+Field+%7D%0A++++impl+Struct+%7B%0A++++++++fn+field(self:+Pin%3C%26mut+Self%3E)+-%3E+Pin%3C%26mut+Field%3E+%7B%0A++++++++++++//+This+is+okay+because+%60field%60+is+pinned+when+%60self%60+is.%0A++++++++++++unsafe+%7B+self.map_unchecked_mut(%7Cs%7C+%26mut+s.field)+%7D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nStructural pinning comes with a few extra requirements:\n\n1.  _Structural [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\")._ A struct can be [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") only if all of its structurally-pinned fields are, too. This is [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\")’s behavior by default. However, as a libray author, it is your responsibility not to write something like `impl<T> [Unpin](../marker/trait.Unpin.html \"trait std::marker::Unpin\") for Struct<T> {}` and then offer a method that provides structural pinning to an inner field of `T`, which may not be [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\")! (Adding _any_ projection operation requires unsafe code, so the fact that [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") is a safe trait does not break the principle that you only have to worry about any of this if you use [`unsafe`](../../std/keyword.unsafe.html \"keyword unsafe\"))\n    \n2.  _Pinned Destruction._ As discussed [above](about:blank/index.html#implementing-drop-for-types-with-address-sensitive-states \"mod std::pin\"), [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") takes [`&mut self`](../primitive.reference.html \"primitive reference\"), but the struct (and hence its fields) might have been pinned before. The destructor must be written as if its argument was ``self: [Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut Self`](../primitive.reference.html \"primitive reference\")>``, instead.\n    \n    As a consequence, the struct _must not_ be [`#[repr(packed)]`](https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked).\n    \n3.  _Structural Notice of Destruction._ You must uphold the [`Drop` guarantee](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\"): once your struct is pinned, the struct’s storage cannot be re-used without calling the structurally-pinned fields’ destructors, as well.\n    \n    This can be tricky, as witnessed by [`VecDeque<T>`](../../std/collections/struct.VecDeque.html): the destructor of [`VecDeque<T>`](../../std/collections/struct.VecDeque.html) can fail to call [`drop`](about:blank/ops/trait.Drop.html#tymethod.drop \"method std::ops::Drop::drop\") on all elements if one of the destructors panics. This violates the [`Drop` guarantee](about:blank/index.html#subtle-details-and-the-drop-guarantee \"mod std::pin\"), because it can lead to elements being deallocated without their destructor being called.\n    \n    [`VecDeque<T>`](../../std/collections/struct.VecDeque.html) has no pinning projections, so its destructor is sound. If it wanted to provide such structural pinning, its destructor would need to abort the process if any of the destructors panicked.\n    \n4.  You must not offer any other operations that could lead to data being _moved_ out of the structural fields when your type is pinned. For example, if the struct contains an [`Option<T>`](../option/enum.Option.html \"enum std::option::Option\") and there is a [`take`](about:blank/option/enum.Option.html#method.take \"method std::option::Option::take\")\\-like operation with type ``fn([Pin](struct.Pin.html \"struct std::pin::Pin\")<[&mut Struct<T>](../primitive.reference.html \"mutable reference\")>) -> [`Option<T>`](../option/enum.Option.html \"enum std::option::Option\")``, then that operation can be used to move a `T` out of a pinned `Struct<T>` – which means pinning cannot be structural for the field holding this data.\n    \n    For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") had a method ``fn get_pin_mut(self: [Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut Self`](../primitive.reference.html \"primitive reference\")>) -> [Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut T`](../primitive.reference.html \"primitive reference\")>``. Then we could do the following:\n    \n    [ⓘ](# \"This example deliberately fails to compile\")\n    \n    ```\n    fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n        // Here we get pinned access to the `T`.\n        let _: Pin<&mut T> = rc.as_mut().get_pin_mut();\n    \n        // And here we have `&mut T` to the same data.\n        let shared: &RefCell<T> = rc.into_ref().get_ref();\n        let borrow = shared.borrow_mut();\n        let content = &mut *borrow;\n    }\n    ```\n    \n    [Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++use+std::pin::Pin;%0A++++fn+exploit_ref_cell%3CT%3E(rc:+Pin%3C%26mut+RefCell%3CT%3E%3E)+%7B%0A++++++++//+Here+we+get+pinned+access+to+the+%60T%60.%0A++++++++let+_:+Pin%3C%26mut+T%3E+=+rc.as_mut().get_pin_mut();%0A++++%0A++++++++//+And+here+we+have+%60%26mut+T%60+to+the+same+data.%0A++++++++let+shared:+%26RefCell%3CT%3E+=+rc.into_ref().get_ref();%0A++++++++let+borrow+=+shared.borrow_mut();%0A++++++++let+content+=+%26mut+*borrow;%0A++++%7D%0A%7D&edition=2021)\n    \n    This is catastrophic: it means we can first pin the content of the [`RefCell<T>`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") (using `[RefCell](../cell/struct.RefCell.html \"cell::RefCell\")::get_pin_mut`) and then move that content using the mutable reference we got later.\n    \n\n#### [§](#structural-pinning-examples)Structural Pinning examples\n\nFor a type like [`Vec<T>`](../../std/vec/struct.Vec.html), both possibilities (structural pinning or not) make sense. A [`Vec<T>`](../../std/vec/struct.Vec.html) with structural pinning could have `get_pin`/`get_pin_mut` methods to get pinning references to elements. However, it could _not_ allow calling [`pop`](about:blank/std/vec/struct.Vec.html#method.pop \"Vec::pop\") on a pinned [`Vec<T>`](../../std/vec/struct.Vec.html) because that would move the (structurally pinned) contents! Nor could it allow [`push`](about:blank/std/vec/struct.Vec.html#method.push \"Vec::push\"), which might reallocate and thus also move the contents.\n\nA [`Vec<T>`](../../std/vec/struct.Vec.html) without structural pinning could ``impl<T> [Unpin](../marker/trait.Unpin.html \"trait std::marker::Unpin\") for [`Vec<T>`](../../std/vec/struct.Vec.html)``, because the contents are never pinned and the [`Vec<T>`](../../std/vec/struct.Vec.html) itself is fine with being moved as well. At that point pinning just has no effect on the vector at all.\n\nIn the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why ``[`Box<T>`](../../std/boxed/struct.Box.html): [Unpin](../marker/trait.Unpin.html \"trait std::marker::Unpin\")`` holds for all `T`. It makes sense to do this for pointer types, because moving the [`Box<T>`](../../std/boxed/struct.Box.html) does not actually move the `T`: the [`Box<T>`](../../std/boxed/struct.Box.html) can be freely movable (aka [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\")) even if the `T` is not. In fact, even ``[Pin](struct.Pin.html \"struct std::pin::Pin\")<[`Box<T>`](../../std/boxed/struct.Box.html)>`` and ``[Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut T`](../primitive.reference.html \"primitive reference\")>`` are always [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") themselves, for the same reason: their contents (the `T`) are pinned, but the pointers themselves can be moved without moving the pinned data. For both [`Box<T>`](../../std/boxed/struct.Box.html) and ``[Pin](struct.Pin.html \"struct std::pin::Pin\")<[`Box<T>`](../../std/boxed/struct.Box.html)>``, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is _not_ structural.\n\nWhen implementing a [`Future`](../future/trait.Future.html \"future::Future\") combinator, you will usually need structural pinning for the nested futures, as you need to get pinning ([`Pin`](struct.Pin.html \"struct std::pin::Pin\")\\-wrapped) references to them to call [`poll`](about:blank/future/trait.Future.html#tymethod.poll \"future::Future::poll\"). But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have ``[Pin](struct.Pin.html \"struct std::pin::Pin\")<[`&mut Self`](../primitive.reference.html \"primitive reference\")>`` (such as in your own [`poll`](about:blank/future/trait.Future.html#tymethod.poll \"future::Future::poll\") implementation).",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Types that pin data to a location in memory.\"><title>std::pin - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module pin</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module pin</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#macros\">Macros</a></li><li><a href=\"#structs\">Structs</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">pin</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.33.0\">1.33.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#405\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Types that pin data to a location in memory.</p>\n<p>It is sometimes useful to be able to rely upon a certain value not being able to <em>move</em>,\nin the sense that its address in memory cannot change. This is useful especially when there\nare one or more <a href=\"../primitive.pointer.html\" title=\"primitive pointer\"><em>pointers</em></a> pointing at that value. The ability to rely on this\nguarantee that the value a <a href=\"../primitive.pointer.html\" title=\"primitive pointer\">pointer</a> is pointing at (its <strong>pointee</strong>) will</p>\n<ol>\n<li>Not be <em>moved</em> out of its memory location</li>\n<li>More generally, remain <em>valid</em> at that same memory location</li>\n</ol>\n<p>is called “pinning.” We would say that a value which satisfies these guarantees has been\n“pinned,” in that it has been permanently (until the end of its lifespan) attached to its\nlocation in memory, as though pinned to a pinboard. Pinning a value is an incredibly useful\nbuilding block for <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code to be able to reason about whether a raw pointer to the\npinned value is still valid. <a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\">As we’ll see later</a>, this is necessarily from the\ntime the value is first pinned until the end of its lifespan. This concept of “pinning” is\nnecessary to implement safe interfaces on top of things like self-referential types and\nintrusive data structures which cannot currently be modeled in fully safe Rust using only\nborrow-checked <a href=\"../primitive.reference.html\" title=\"primitive reference\">references</a>.</p>\n<p>“Pinning” allows us to put a <em>value</em> which exists at some location in memory into a state where\nsafe code cannot <em>move</em> that value to a different location in memory or otherwise invalidate it\nat its current location (unless it implements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>, which we will\n<a href=\"index.html#unpin\" title=\"mod std::pin\">talk about below</a>). Anything that wants to interact with the pinned value in a way\nthat has the potential to violate these guarantees must promise that it will not actually\nviolate them, using the <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> keyword to mark that such a promise is upheld by the user\nand not the compiler. In this way, we can allow other <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code to rely on any pointers\nthat point to the pinned value to be valid to dereference while it is pinned.</p>\n<p>Note that as long as you don’t use <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a>, it’s impossible to create or misuse a pinned\nvalue in a way that is unsound. See the documentation of <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> for more\ninformation on the practicalities of how to pin a value and how to use that pinned value from a\nuser’s perspective without using <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a>.</p>\n<p>The rest of this documentation is intended to be the source of truth for users of <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a>\nthat are implementing the <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> pieces of an interface that relies on pinning for validity;\nusers of <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> in safe code do not need to read it in detail.</p>\n<p>There are several sections to this documentation:</p>\n<ul>\n<li><a href=\"index.html#what-is-moving\" title=\"mod std::pin\">What is “<em>moving</em>”?</a></li>\n<li><a href=\"index.html#what-is-pinning\" title=\"mod std::pin\">What is “pinning”?</a></li>\n<li><a href=\"index.html#address-sensitive-values-aka-when-we-need-pinning\" title=\"mod std::pin\">Address sensitivity, AKA “when do we need pinning?”</a></li>\n<li><a href=\"#examples-of-address-sensitive-types\">Examples of types with address-sensitive states</a>\n<ul>\n<li><a href=\"#a-self-referential-struct\">Self-referential struct</a></li>\n<li><a href=\"#an-intrusive-doubly-linked-list\">Intrusive, doubly-linked list</a></li>\n</ul>\n</li>\n<li><a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\">Subtle details and the <code>Drop</code> guarantee</a></li>\n</ul>\n<h2 id=\"what-is-moving\"><a class=\"doc-anchor\" href=\"#what-is-moving\">§</a>What is “<em>moving</em>”?</h2>\n<p>When we say a value is <em>moved</em>, we mean that the compiler copies, byte-for-byte, the\nvalue from one location to another. In a purely mechanical sense, this is identical to\n<a href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\"><code>Copy</code></a>ing a value from one place in memory to another. In Rust, “move” carries with it the\nsemantics of ownership transfer from one variable to another, which is the key difference\nbetween a <a href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\"><code>Copy</code></a> and a move. For the purposes of this module’s documentation, however, when\nwe write <em>move</em> in italics, we mean <em>specifically</em> that the value has <em>moved</em> in the mechanical\nsense of being located at a new place in memory.</p>\n<p>All values in Rust are trivially <em>moveable</em>. This means that the address at which a value is\nlocated is not necessarily stable in between borrows. The compiler is allowed to <em>move</em> a value\nto a new address without running any code to notify that value that its address\nhas changed. Although the compiler will not insert memory <em>moves</em> where no semantic move has\noccurred, there are many places where a value <em>may</em> be moved. For example, when doing\nassignment or passing a value into a function.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[derive(Default)]\n</span><span class=\"kw\">struct </span>AddrTracker(<span class=\"prelude-ty\">Option</span>&lt;usize&gt;);\n\n<span class=\"kw\">impl </span>AddrTracker {\n    <span class=\"comment\">// If we haven't checked the addr of self yet, store the current\n    // address. If we have, confirm that the current address is the same\n    // as it was last time, or else panic.\n    </span><span class=\"kw\">fn </span>check_for_move(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"kw\">let </span>current_addr = <span class=\"self\">self </span><span class=\"kw\">as </span><span class=\"kw-2\">*mut </span><span class=\"self\">Self </span><span class=\"kw\">as </span>usize;\n        <span class=\"kw\">match </span><span class=\"self\">self</span>.<span class=\"number\">0 </span>{\n            <span class=\"prelude-val\">None </span>=&gt; <span class=\"self\">self</span>.<span class=\"number\">0 </span>= <span class=\"prelude-val\">Some</span>(current_addr),\n            <span class=\"prelude-val\">Some</span>(prev_addr) =&gt; <span class=\"macro\">assert_eq!</span>(prev_addr, current_addr),\n        }\n    }\n}\n\n<span class=\"comment\">// Create a tracker and store the initial address\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>tracker = AddrTracker::default();\ntracker.check_for_move();\n\n<span class=\"comment\">// Here we shadow the variable. This carries a semantic move, and may therefore also\n// come with a mechanical memory *move*\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>tracker = tracker;\n\n<span class=\"comment\">// May panic!\n// tracker.check_for_move();</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bderive(Default)%5D%0A++++struct+AddrTracker(Option%3Cusize%3E);%0A++++%0A++++impl+AddrTracker+%7B%0A++++++++//+If+we+haven't+checked+the+addr+of+self+yet,+store+the+current%0A++++++++//+address.+If+we+have,+confirm+that+the+current+address+is+the+same%0A++++++++//+as+it+was+last+time,+or+else+panic.%0A++++++++fn+check_for_move(%26mut+self)+%7B%0A++++++++++++let+current_addr+=+self+as+*mut+Self+as+usize;%0A++++++++++++match+self.0+%7B%0A++++++++++++++++None+=%3E+self.0+=+Some(current_addr),%0A++++++++++++++++Some(prev_addr)+=%3E+assert_eq!(prev_addr,+current_addr),%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Create+a+tracker+and+store+the+initial+address%0A++++let+mut+tracker+=+AddrTracker::default();%0A++++tracker.check_for_move();%0A++++%0A++++//+Here+we+shadow+the+variable.+This+carries+a+semantic+move,+and+may+therefore+also%0A++++//+come+with+a+mechanical+memory+*move*%0A++++let+mut+tracker+=+tracker;%0A++++%0A++++//+May+panic!%0A++++//+tracker.check_for_move();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>In this sense, Rust does not guarantee that <code>check_for_move()</code> will never panic, because the\ncompiler is permitted to <em>move</em> <code>tracker</code> in many situations.</p>\n<p>Common smart-pointer types such as <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> and <a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut T</code></a> also allow <em>moving</em> the underlying\n<em>value</em> they point at: you can move out of a <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>, or you can use <a href=\"../mem/fn.replace.html\" title=\"fn std::mem::replace\"><code>mem::replace</code></a> to\nmove a <code>T</code> out of a <a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut T</code></a>. Therefore, putting a value (such as <code>tracker</code> above) behind a\npointer isn’t enough on its own to ensure that its address does not change.</p>\n<h2 id=\"what-is-pinning\"><a class=\"doc-anchor\" href=\"#what-is-pinning\">§</a>What is “pinning”?</h2>\n<p>We say that a value has been <em>pinned</em> when it has been put into a state where it is guaranteed\nto remain <em>located at the same place in memory</em> from the time it is pinned until its\n<a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> is called.</p>\n<h3 id=\"address-sensitive-values-aka-when-we-need-pinning\"><a class=\"doc-anchor\" href=\"#address-sensitive-values-aka-when-we-need-pinning\">§</a>Address-sensitive values, AKA “when we need pinning”</h3>\n<p>Most values in Rust are entirely okay with being <em>moved</em> around at-will.\nTypes for which it is <em>always</em> the case that <em>any</em> value of that type can be\n<em>moved</em> at-will should implement <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>, which we will discuss more <a href=\"index.html#unpin\" title=\"mod std::pin\">below</a>.</p>\n<p><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> is specifically targeted at allowing the implementation of <em>safe interfaces</em> around\ntypes which have some state during which they become “address-sensitive.” A value in such an\n“address-sensitive” state is <em>not</em> okay with being <em>moved</em> around at-will. Such a value must\nstay <em>un-moved</em> and valid during the address-sensitive portion of its lifespan because some\ninterface is relying on those invariants to be true in order for its implementation to be sound.</p>\n<p>As a motivating example of a type which may become address-sensitive, consider a type which\ncontains a pointer to another piece of its own data, <em>i.e.</em> a “self-referential” type. In order\nfor such a type to be implemented soundly, the pointer which points into <code>self</code>’s data must be\nproven valid whenever it is accessed. But if that value is <em>moved</em>, the pointer will still\npoint to the old address where the value was located and not into the new location of <code>self</code>,\nthus becoming invalid. A key example of such self-referential types are the state machines\ngenerated by the compiler to implement <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a> for <code>async fn</code>s.</p>\n<p>Such types that have an <em>address-sensitive</em> state usually follow a lifecycle\nthat looks something like so:</p>\n<ol>\n<li>A value is created which can be freely moved around.\n<ul>\n<li>e.g. calling an async function which returns a state machine implementing <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a></li>\n</ul>\n</li>\n<li>An operation causes the value to depend on its own address not changing\n<ul>\n<li>e.g. calling <a href=\"../future/trait.Future.html#tymethod.poll\" title=\"future::Future::poll\"><code>poll</code></a> for the first time on the produced <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a></li>\n</ul>\n</li>\n<li>Further pieces of the safe interface of the type use internal <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> operations which\nassume that the address of the value is stable\n<ul>\n<li>e.g. subsequent calls to <a href=\"../future/trait.Future.html#tymethod.poll\" title=\"future::Future::poll\"><code>poll</code></a></li>\n</ul>\n</li>\n<li>Before the value is invalidated (e.g. deallocated), it is <em>dropped</em>, giving it a chance to\nnotify anything with pointers to itself that those pointers will be invalidated\n<ul>\n<li>e.g. <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a>ping the <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a> <sup id=\"fnref1\"><a href=\"#fn1\">1</a></sup></li>\n</ul>\n</li>\n</ol>\n<p>There are two possible ways to ensure the invariants required for 2. and 3. above (which\napply to any address-sensitive type, not just self-referential types) do not get broken.</p>\n<ol>\n<li>Have the value detect when it is moved and update all the pointers that point to itself.</li>\n<li>Guarantee that the address of the value does not change (and that memory is not re-used\nfor anything else) during the time that the pointers to it are expected to be valid to\ndereference.</li>\n</ol>\n<p>Since, as we discussed, Rust can move values without notifying them that they have moved, the\nfirst option is ruled out.</p>\n<p>In order to implement the second option, we must in some way enforce its key invariant,\n<em>i.e.</em> prevent the value from being <em>moved</em> or otherwise invalidated (you may notice this\nsounds an awful lot like the definition of <em>pinning</em> a value). There a few ways one might be\nable to enforce this invariant in Rust:</p>\n<ol>\n<li>Offer a wholly <code>unsafe</code> API to interact with the object, thus requiring every caller to\nuphold the invariant themselves</li>\n<li>Store the value that must not be moved behind a carefully managed pointer internal to\nthe object</li>\n<li>Leverage the type system to encode and enforce this invariant by presenting a restricted\nAPI surface to interact with <em>any</em> object that requires these invariants</li>\n</ol>\n<p>The first option is quite obviously undesirable, as the <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a>ty of the interface will\nbecome viral throughout all code that interacts with the object.</p>\n<p>The second option is a viable solution to the problem for some use cases, in particular\nfor self-referential types. Under this model, any type that has an address sensitive state\nwould ultimately store its data in something like a <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>, carefully manage internal\naccess to that data to ensure no <em>moves</em> or other invalidation occurs, and finally\nprovide a safe interface on top.</p>\n<p>There are a couple of linked disadvantages to using this model. The most significant is that\neach individual object must assume it is <em>on its own</em> to ensure\nthat its data does not become <em>moved</em> or otherwise invalidated. Since there is no shared\ncontract between values of different types, an object cannot assume that others interacting\nwith it will properly respect the invariants around interacting with its data and must\ntherefore protect it from everyone. Because of this, <em>composition</em> of address-sensitive types\nrequires at least a level of pointer indirection each time a new object is added to the mix\n(and, practically, a heap allocation).</p>\n<p>Although there were other reason as well, this issue of expensive composition is the key thing\nthat drove Rust towards adopting a different model. It is particularly a problem\nwhen one considers, for example, the implications of composing together the <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a>s which\nwill eventually make up an asynchronous task (including address-sensitive <code>async fn</code> state\nmachines). It is plausible that there could be many layers of <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a>s composed together,\nincluding multiple layers of <code>async fn</code>s handling different parts of a task. It was deemed\nunacceptable to force indirection and allocation for each layer of composition in this case.</p>\n<p><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> is an implementation of the third option. It allows us to solve the issues\ndiscussed with the second option by building a <em>shared contractual language</em> around the\nguarantees of “pinning” data.</p>\n<h3 id=\"using-pinptr-to-pin-values\"><a class=\"doc-anchor\" href=\"#using-pinptr-to-pin-values\">§</a>Using <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> to pin values</h3>\n<p>In order to pin a value, we wrap a <em>pointer to that value</em> (of some type <code>Ptr</code>) in a\n<a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a>. <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> can wrap any pointer type, forming a promise that the <strong>pointee</strong>\nwill not be <em>moved</em> or <a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\">otherwise invalidated</a>.</p>\n<p>We call such a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a>-wrapped pointer a <strong>pinning pointer,</strong> (or pinning reference, or pinning\n<code>Box</code>, etc.) because its existence is the thing that is conceptually pinning the underlying\npointee in place: it is the metaphorical “pin” securing the data in place on the pinboard\n(in memory).</p>\n<p>Notice that the thing wrapped by <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> is not the value which we want to pin itself, but\nrather a pointer to that value! A <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> does not pin the <code>Ptr</code>; instead, it pins the\npointer’s <em><strong>pointee</strong> value</em>.</p>\n<h4 id=\"pinning-as-a-library-contract\"><a class=\"doc-anchor\" href=\"#pinning-as-a-library-contract\">§</a>Pinning as a library contract</h4>\n<p>Pinning does not require nor make use of any compiler “magic”<sup id=\"fnref2\"><a href=\"#fn2\">2</a></sup>, only a specific\ncontract between the <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> parts of a library API and its users.</p>\n<p>It is important to stress this point as a user of the <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> parts of the <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> API.\nPractically, this means that performing the mechanics of “pinning” a value by creating a\n<a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> to it <em>does not</em> actually change the way the compiler behaves towards the\ninner value! It is possible to use incorrect <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code to create a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> to a\nvalue which does not actually satisfy the invariants that a pinned value must satisfy, and in\nthis way lead to undefined behavior even in (from that point) fully safe code. Similarly, using\n<a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a>, one may get access to a bare <a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut T</code></a> from a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> and\nuse that to invalidly <em>move</em> the pinned value out. It is the job of the user of the\n<a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> parts of the <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> API to ensure these invariants are not violated.</p>\n<p>This differs from e.g. <a href=\"../cell/struct.UnsafeCell.html\" title=\"struct std::cell::UnsafeCell\"><code>UnsafeCell</code></a> which changes the semantics of a program’s compiled\noutput. A <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> is a handle to a value which we have promised we will not move out of,\nbut Rust still considers all values themselves to be fundamentally moveable through, <em>e.g.</em>\nassignment or <a href=\"../mem/fn.replace.html\" title=\"fn std::mem::replace\"><code>mem::replace</code></a>.</p>\n<h4 id=\"how-pin-prevents-misuse-in-safe-code\"><a class=\"doc-anchor\" href=\"#how-pin-prevents-misuse-in-safe-code\">§</a>How <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> prevents misuse in safe code</h4>\n<p>In order to accomplish the goal of pinning the pointee value, <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> restricts access to\nthe wrapped <code>Ptr</code> type in safe code. Specifically, <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> disallows the ability to access\nthe wrapped pointer in ways that would allow the user to <em>move</em> the underlying pointee value or\notherwise re-use that memory for something else without using <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a>. For example, a\n<a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;&amp;mut T&gt;</code></a> makes it impossible to obtain the wrapped <code><a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T</code> safely because\nthrough that <code><a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T</code> it would be possible to <em>move</em> the underlying value out of\nthe pointer with <a href=\"../mem/fn.replace.html\" title=\"fn std::mem::replace\"><code>mem::replace</code></a>, etc.</p>\n<p>As discussed above, this promise must be upheld manually by <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code which interacts\nwith the <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> so that other <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code can rely on the pointee value being\n<em>un-moved</em> and valid. Interfaces that operate on values which are in an address-sensitive state\naccept an argument like <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T&gt;</code> or <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\" title=\"Box\">Box</a>&lt;T&gt;&gt;</code> to\nindicate this contract to the caller.</p>\n<p><a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\">As discussed below</a>, opting in to using pinning guarantees in the interface\nof an address-sensitive type has consequences for the implementation of some safe traits on\nthat type as well.</p>\n<h3 id=\"interaction-between-deref-and-pinptr\"><a class=\"doc-anchor\" href=\"#interaction-between-deref-and-pinptr\">§</a>Interaction between <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a> and <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a></h3>\n<p>Since <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> can wrap any pointer type, it uses <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a> and <a href=\"../ops/trait.DerefMut.html\" title=\"ops::DerefMut\"><code>DerefMut</code></a> in\norder to identify the type of the pinned pointee data and provide (restricted) access to it.</p>\n<p>A <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> where <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Ptr: Deref</code></a> is a “<code>Ptr</code>-style pinning pointer” to a pinned\n<a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"ops::Deref::Target\"><code>Ptr::Target</code></a> – so, a <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\" title=\"Box\">Box</a>&lt;T&gt;&gt;</code> is an owned, pinning pointer to a\npinned <code>T</code>, and a <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/rc/struct.Rc.html\" title=\"rc::Rc\">Rc</a>&lt;T&gt;&gt;</code> is a reference-counted, pinning pointer to a\npinned <code>T</code>.</p>\n<p><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> also uses the <a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"ops::Deref::Target\"><code>&lt;Ptr as Deref&gt;::Target</code></a> type information to modify the\ninterface it is allowed to provide for interacting with that data (for example, when a\npinning pointer points at pinned data which implements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>, as\n<a href=\"index.html#unpin\" title=\"mod std::pin\">discussed below</a>).</p>\n<p><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> requires that implementations of <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a> and <a href=\"../ops/trait.DerefMut.html\" title=\"ops::DerefMut\"><code>DerefMut</code></a> on <code>Ptr</code> return a\npointer to the pinned data directly and do not <em>move</em> out of the <code>self</code> parameter during their\nimplementation of <a href=\"../ops/trait.DerefMut.html#tymethod.deref_mut\" title=\"method std::ops::DerefMut::deref_mut\"><code>DerefMut::deref_mut</code></a>. It is unsound for <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code to wrap pointer\ntypes with such “malicious” implementations of <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a>; see <a href=\"struct.Pin.html#method.new_unchecked\" title=\"associated function std::pin::Pin::new_unchecked\"><code>Pin&lt;Ptr&gt;::new_unchecked</code></a> for\ndetails.</p>\n<h3 id=\"fixing-addrtracker\"><a class=\"doc-anchor\" href=\"#fixing-addrtracker\">§</a>Fixing <code>AddrTracker</code></h3>\n<p>The guarantee of a stable address is necessary to make our <code>AddrTracker</code> example work. When\n<code>check_for_move</code> sees a <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;&amp;mut AddrTracker&gt;</code>, it can safely assume that value\nwill exist at that same address until said value goes out of scope, and thus multiple calls\nto it <em>cannot</em> panic.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::marker::PhantomPinned;\n<span class=\"kw\">use </span>std::pin::Pin;\n<span class=\"kw\">use </span>std::pin::pin;\n\n<span class=\"attr\">#[derive(Default)]\n</span><span class=\"kw\">struct </span>AddrTracker {\n    prev_addr: <span class=\"prelude-ty\">Option</span>&lt;usize&gt;,\n    <span class=\"comment\">// remove auto-implemented `Unpin` bound to mark this type as having some\n    // address-sensitive state. This is essential for our expected pinning\n    // guarantees to work, and is discussed more below.\n    </span>_pin: PhantomPinned,\n}\n\n<span class=\"kw\">impl </span>AddrTracker {\n    <span class=\"kw\">fn </span>check_for_move(<span class=\"self\">self</span>: Pin&lt;<span class=\"kw-2\">&amp;mut </span><span class=\"self\">Self</span>&gt;) {\n        <span class=\"kw\">let </span>current_addr = <span class=\"kw-2\">&amp;*</span><span class=\"self\">self </span><span class=\"kw\">as </span><span class=\"kw-2\">*const </span><span class=\"self\">Self </span><span class=\"kw\">as </span>usize;\n        <span class=\"kw\">match </span><span class=\"self\">self</span>.prev_addr {\n            <span class=\"prelude-val\">None </span>=&gt; {\n                <span class=\"comment\">// SAFETY: we do not move out of self\n                </span><span class=\"kw\">let </span>self_data_mut = <span class=\"kw\">unsafe </span>{ <span class=\"self\">self</span>.get_unchecked_mut() };\n                self_data_mut.prev_addr = <span class=\"prelude-val\">Some</span>(current_addr);\n            },\n            <span class=\"prelude-val\">Some</span>(prev_addr) =&gt; <span class=\"macro\">assert_eq!</span>(prev_addr, current_addr),\n        }\n    }\n}\n\n<span class=\"comment\">// 1. Create the value, not yet in an address-sensitive state\n</span><span class=\"kw\">let </span>tracker = AddrTracker::default();\n\n<span class=\"comment\">// 2. Pin the value by putting it behind a pinning pointer, thus putting\n// it into an address-sensitive state\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ptr_to_pinned_tracker: Pin&lt;<span class=\"kw-2\">&amp;mut </span>AddrTracker&gt; = <span class=\"macro\">pin!</span>(tracker);\nptr_to_pinned_tracker.as_mut().check_for_move();\n\n<span class=\"comment\">// Trying to access `tracker` or pass `ptr_to_pinned_tracker` to anything that requires\n// mutable access to a non-pinned version of it will no longer compile\n\n// 3. We can now assume that the tracker value will never be moved, thus\n// this will never panic!\n</span>ptr_to_pinned_tracker.as_mut().check_for_move();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::marker::PhantomPinned;%0A++++use+std::pin::Pin;%0A++++use+std::pin::pin;%0A++++%0A++++%23%5Bderive(Default)%5D%0A++++struct+AddrTracker+%7B%0A++++++++prev_addr:+Option%3Cusize%3E,%0A++++++++//+remove+auto-implemented+%60Unpin%60+bound+to+mark+this+type+as+having+some%0A++++++++//+address-sensitive+state.+This+is+essential+for+our+expected+pinning%0A++++++++//+guarantees+to+work,+and+is+discussed+more+below.%0A++++++++_pin:+PhantomPinned,%0A++++%7D%0A++++%0A++++impl+AddrTracker+%7B%0A++++++++fn+check_for_move(self:+Pin%3C%26mut+Self%3E)+%7B%0A++++++++++++let+current_addr+=+%26*self+as+*const+Self+as+usize;%0A++++++++++++match+self.prev_addr+%7B%0A++++++++++++++++None+=%3E+%7B%0A++++++++++++++++++++//+SAFETY:+we+do+not+move+out+of+self%0A++++++++++++++++++++let+self_data_mut+=+unsafe+%7B+self.get_unchecked_mut()+%7D;%0A++++++++++++++++++++self_data_mut.prev_addr+=+Some(current_addr);%0A++++++++++++++++%7D,%0A++++++++++++++++Some(prev_addr)+=%3E+assert_eq!(prev_addr,+current_addr),%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+1.+Create+the+value,+not+yet+in+an+address-sensitive+state%0A++++let+tracker+=+AddrTracker::default();%0A++++%0A++++//+2.+Pin+the+value+by+putting+it+behind+a+pinning+pointer,+thus+putting%0A++++//+it+into+an+address-sensitive+state%0A++++let+mut+ptr_to_pinned_tracker:+Pin%3C%26mut+AddrTracker%3E+=+pin!(tracker);%0A++++ptr_to_pinned_tracker.as_mut().check_for_move();%0A++++%0A++++//+Trying+to+access+%60tracker%60+or+pass+%60ptr_to_pinned_tracker%60+to+anything+that+requires%0A++++//+mutable+access+to+a+non-pinned+version+of+it+will+no+longer+compile%0A++++%0A++++//+3.+We+can+now+assume+that+the+tracker+value+will+never+be+moved,+thus%0A++++//+this+will+never+panic!%0A++++ptr_to_pinned_tracker.as_mut().check_for_move();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that this invariant is enforced by simply making it impossible to call code that would\nperform a move on the pinned value. This is the case since the only way to access that pinned\nvalue is through the pinning <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T&gt;&gt;</code>, which in turn restricts our access.</p>\n<h3 id=\"unpin\"><a class=\"doc-anchor\" href=\"#unpin\">§</a><a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a></h3>\n<p>The vast majority of Rust types have no address-sensitive states. These types\nimplement the <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> auto-trait, which cancels the restrictive effects of\n<a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> when the <em>pointee</em> type <code>T</code> is <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>. When <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>T: Unpin</code></a>,\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\" title=\"Box\">Box</a>&lt;T&gt;&gt;</code> functions identically to a non-pinning <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>; similarly,\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T&gt;</code> would impose no additional restrictions above a regular\n<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut T</code></a>.</p>\n<p>The idea of this trait is to alleviate the reduced ergonomics of APIs that require the use\nof <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> for soundness for some types, but which also want to be used by other types that\ndon’t care about pinning. The prime example of such an API is <a href=\"../future/trait.Future.html#tymethod.poll\" title=\"method std::future::Future::poll\"><code>Future::poll</code></a>. There are many\n<a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a> types that don’t care about pinning. These futures can implement <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> and\ntherefore get around the pinning related restrictions in the API, while still allowing the\nsubset of <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a>s which <em>do</em> require pinning to be implemented soundly.</p>\n<p>Note that the interaction between a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> and <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> is through the type of the\n<strong>pointee</strong> value, <a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"ops::Deref::Target\"><code>&lt;Ptr as Deref&gt;::Target</code></a>. Whether the <code>Ptr</code> type itself\nimplements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> does not affect the behavior of a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a>. For example, whether or not\n<a href=\"../../std/boxed/struct.Box.html\" title=\"Box\"><code>Box</code></a> is <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> has no effect on the behavior of <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\" title=\"Box\">Box</a>&lt;T&gt;&gt;</code>, because\n<code>T</code> is the type of the pointee value, not <a href=\"../../std/boxed/struct.Box.html\" title=\"Box\"><code>Box</code></a>. So, whether <code>T</code> implements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> is\nthe thing that will affect the behavior of the <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\" title=\"Box\">Box</a>&lt;T&gt;&gt;</code>.</p>\n<p>Builtin types that are <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> include all of the primitive types, like <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>bool</code></a>, <a href=\"../primitive.i32.html\" title=\"primitive i32\"><code>i32</code></a>,\nand <a href=\"../primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a>, references (<code><a href=\"../primitive.reference.html\" title=\"shared reference\">&amp;</a>T</code> and <code><a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> T</code>), etc., as well as many\ncore and standard library types like <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>, <a href=\"../../std/string/struct.String.html\" title=\"String\"><code>String</code></a>, and more.\nThese types are marked <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> because they do not have an address-sensitive state like the\nones we discussed above. If they did have such a state, those parts of their interface would be\nunsound without being expressed through pinning, and they would then need to not\nimplement <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>.</p>\n<p>The compiler is free to take the conservative stance of marking types as <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> so long as\nall of the types that compose its fields are also <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>. This is because if a type\nimplements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>, then it is unsound for that type’s implementation to rely on\npinning-related guarantees for soundness, <em>even</em> when viewed through a “pinning” pointer! It is\nthe responsibility of the implementor of a type that relies upon pinning for soundness to\nensure that type is <em>not</em> marked as <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> by adding <a href=\"../marker/struct.PhantomPinned.html\" title=\"struct std::marker::PhantomPinned\"><code>PhantomPinned</code></a> field. This is\nexactly what we did with our <code>AddrTracker</code> example above. Without doing this, you <em>must not</em>\nrely on pinning-related guarantees to apply to your type!</p>\n<p>If need to truly pin a value of a foreign or built-in type that implements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>, you’ll\nneed to create your own wrapper type around the <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> type you want to pin and then\nopts-out of <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> using <a href=\"../marker/struct.PhantomPinned.html\" title=\"struct std::marker::PhantomPinned\"><code>PhantomPinned</code></a>.</p>\n<p>Exposing access to the inner field which you want to remain pinned must then be carefully\nconsidered as well! Remember, exposing a method that gives access to a\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> InnerT&gt;&gt;</code> where <code>InnerT: <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a></code> would allow safe code to\ntrivially move the inner value out of that pinning pointer, which is precisely what you’re\nseeking to prevent! Exposing a field of a pinned value through a pinning pointer is called\n“projecting” a pin, and the more general case of deciding in which cases a pin should be able\nto be projected or not is called “structural pinning.” We will go into more detail about this\n<a href=\"index.html#projections-and-structural-pinning\" title=\"mod std::pin\">below</a>.</p>\n<h2 id=\"examples-of-address-sensitive-types\"><a class=\"doc-anchor\" href=\"#examples-of-address-sensitive-types\">§</a>Examples of address-sensitive types</h2><h3 id=\"a-self-referential-struct\"><a class=\"doc-anchor\" href=\"#a-self-referential-struct\">§</a>A self-referential struct</h3>\n<p>Self-referential structs are the simplest kind of address-sensitive type.</p>\n<p>It is often useful for a struct to hold a pointer back into itself, which\nallows the program to efficiently track subsections of the struct.\nBelow, the <code>slice</code> field is a pointer into the <code>data</code> field, which\nwe could imagine being used to track a sliding window of <code>data</code> in parser\ncode.</p>\n<p>As mentioned before, this pattern is also used extensively by compiler-generated\n<a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a>s.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::pin::Pin;\n<span class=\"kw\">use </span>std::marker::PhantomPinned;\n<span class=\"kw\">use </span>std::ptr::NonNull;\n\n<span class=\"doccomment\">/// This is a self-referential struct because `self.slice` points into `self.data`.\n</span><span class=\"kw\">struct </span>Unmovable {\n    <span class=\"doccomment\">/// Backing buffer.\n    </span>data: [u8; <span class=\"number\">64</span>],\n    <span class=\"doccomment\">/// Points at `self.data` which we know is itself non-null. Raw pointer because we can't do\n    /// this with a normal reference.\n    </span>slice: NonNull&lt;[u8]&gt;,\n    <span class=\"doccomment\">/// Suppress `Unpin` so that this cannot be moved out of a `Pin` once constructed.\n    </span>_pin: PhantomPinned,\n}\n\n<span class=\"kw\">impl </span>Unmovable {\n    <span class=\"doccomment\">/// Create a new `Unmovable`.\n    ///\n    /// To ensure the data doesn't move we place it on the heap behind a pinning Box.\n    /// Note that the data is pinned, but the `Pin&lt;Box&lt;Self&gt;&gt;` which is pinning it can\n    /// itself still be moved. This is important because it means we can return the pinning\n    /// pointer from the function, which is itself a kind of move!\n    </span><span class=\"kw\">fn </span>new() -&gt; Pin&lt;Box&lt;<span class=\"self\">Self</span>&gt;&gt; {\n        <span class=\"kw\">let </span>res = Unmovable {\n            data: [<span class=\"number\">0</span>; <span class=\"number\">64</span>],\n            <span class=\"comment\">// We only create the pointer once the data is in place\n            // otherwise it will have already moved before we even started.\n            </span>slice: NonNull::from(<span class=\"kw-2\">&amp;</span>[]),\n            _pin: PhantomPinned,\n        };\n        <span class=\"comment\">// First we put the data in a box, which will be its final resting place\n        </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>boxed = Box::new(res);\n\n        <span class=\"comment\">// Then we make the slice field point to the proper part of that boxed data.\n        // From now on we need to make sure we don't move the boxed data.\n        </span>boxed.slice = NonNull::from(<span class=\"kw-2\">&amp;</span>boxed.data);\n\n        <span class=\"comment\">// To do that, we pin the data in place by pointing to it with a pinning\n        // (`Pin`-wrapped) pointer.\n        //\n        // `Box::into_pin` makes existing `Box` pin the data in-place without moving it,\n        // so we can safely do this now *after* inserting the slice pointer above, but we have\n        // to take care that we haven't performed any other semantic moves of `res` in between.\n        </span><span class=\"kw\">let </span>pin = Box::into_pin(boxed);\n\n        <span class=\"comment\">// Now we can return the pinned (through a pinning Box) data\n        </span>pin\n    }\n}\n\n<span class=\"kw\">let </span>unmovable: Pin&lt;Box&lt;Unmovable&gt;&gt; = Unmovable::new();\n\n<span class=\"comment\">// The inner pointee `Unmovable` struct will now never be allowed to move.\n// Meanwhile, we are free to move the pointer around.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>still_unmoved = unmovable;\n<span class=\"macro\">assert_eq!</span>(still_unmoved.slice, NonNull::from(<span class=\"kw-2\">&amp;</span>still_unmoved.data));\n\n<span class=\"comment\">// We cannot mutably dereference a `Pin&lt;Ptr&gt;` unless the pointee is `Unpin` or we use unsafe.\n// Since our type doesn't implement `Unpin`, this will fail to compile.\n// let mut new_unmoved = Unmovable::new();\n// std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++use+std::marker::PhantomPinned;%0A++++use+std::ptr::NonNull;%0A++++%0A++++///+This+is+a+self-referential+struct+because+%60self.slice%60+points+into+%60self.data%60.%0A++++struct+Unmovable+%7B%0A++++++++///+Backing+buffer.%0A++++++++data:+%5Bu8;+64%5D,%0A++++++++///+Points+at+%60self.data%60+which+we+know+is+itself+non-null.+Raw+pointer+because+we+can't+do%0A++++++++///+this+with+a+normal+reference.%0A++++++++slice:+NonNull%3C%5Bu8%5D%3E,%0A++++++++///+Suppress+%60Unpin%60+so+that+this+cannot+be+moved+out+of+a+%60Pin%60+once+constructed.%0A++++++++_pin:+PhantomPinned,%0A++++%7D%0A++++%0A++++impl+Unmovable+%7B%0A++++++++///+Create+a+new+%60Unmovable%60.%0A++++++++///%0A++++++++///+To+ensure+the+data+doesn't+move+we+place+it+on+the+heap+behind+a+pinning+Box.%0A++++++++///+Note+that+the+data+is+pinned,+but+the+%60Pin%3CBox%3CSelf%3E%3E%60+which+is+pinning+it+can%0A++++++++///+itself+still+be+moved.+This+is+important+because+it+means+we+can+return+the+pinning%0A++++++++///+pointer+from+the+function,+which+is+itself+a+kind+of+move!%0A++++++++fn+new()+-%3E+Pin%3CBox%3CSelf%3E%3E+%7B%0A++++++++++++let+res+=+Unmovable+%7B%0A++++++++++++++++data:+%5B0;+64%5D,%0A++++++++++++++++//+We+only+create+the+pointer+once+the+data+is+in+place%0A++++++++++++++++//+otherwise+it+will+have+already+moved+before+we+even+started.%0A++++++++++++++++slice:+NonNull::from(%26%5B%5D),%0A++++++++++++++++_pin:+PhantomPinned,%0A++++++++++++%7D;%0A++++++++++++//+First+we+put+the+data+in+a+box,+which+will+be+its+final+resting+place%0A++++++++++++let+mut+boxed+=+Box::new(res);%0A++++%0A++++++++++++//+Then+we+make+the+slice+field+point+to+the+proper+part+of+that+boxed+data.%0A++++++++++++//+From+now+on+we+need+to+make+sure+we+don't+move+the+boxed+data.%0A++++++++++++boxed.slice+=+NonNull::from(%26boxed.data);%0A++++%0A++++++++++++//+To+do+that,+we+pin+the+data+in+place+by+pointing+to+it+with+a+pinning%0A++++++++++++//+(%60Pin%60-wrapped)+pointer.%0A++++++++++++//%0A++++++++++++//+%60Box::into_pin%60+makes+existing+%60Box%60+pin+the+data+in-place+without+moving+it,%0A++++++++++++//+so+we+can+safely+do+this+now+*after*+inserting+the+slice+pointer+above,+but+we+have%0A++++++++++++//+to+take+care+that+we+haven't+performed+any+other+semantic+moves+of+%60res%60+in+between.%0A++++++++++++let+pin+=+Box::into_pin(boxed);%0A++++%0A++++++++++++//+Now+we+can+return+the+pinned+(through+a+pinning+Box)+data%0A++++++++++++pin%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+unmovable:+Pin%3CBox%3CUnmovable%3E%3E+=+Unmovable::new();%0A++++%0A++++//+The+inner+pointee+%60Unmovable%60+struct+will+now+never+be+allowed+to+move.%0A++++//+Meanwhile,+we+are+free+to+move+the+pointer+around.%0A++++%23%5Ballow(unused_mut)%5D%0A++++let+mut+still_unmoved+=+unmovable;%0A++++assert_eq!(still_unmoved.slice,+NonNull::from(%26still_unmoved.data));%0A++++%0A++++//+We+cannot+mutably+dereference+a+%60Pin%3CPtr%3E%60+unless+the+pointee+is+%60Unpin%60+or+we+use+unsafe.%0A++++//+Since+our+type+doesn't+implement+%60Unpin%60,+this+will+fail+to+compile.%0A++++//+let+mut+new_unmoved+=+Unmovable::new();%0A++++//+std::mem::swap(%26mut+*still_unmoved,+%26mut+*new_unmoved);%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"an-intrusive-doubly-linked-list\"><a class=\"doc-anchor\" href=\"#an-intrusive-doubly-linked-list\">§</a>An intrusive, doubly-linked list</h3>\n<p>In an intrusive doubly-linked list, the collection itself does not own the memory in which\neach of its elements is stored. Instead, each client is free to allocate space for elements it\nadds to the list in whichever manner it likes, including on the stack! Elements can live on a\nstack frame that lives shorter than the collection does provided the elements that live in a\ngiven stack frame are removed from the list before going out of scope.</p>\n<p>To make such an intrusive data structure work, every element stores pointers to its predecessor\nand successor within its own data, rather than having the list structure itself managing those\npointers. It is in this sense that the structure is “intrusive”: the details of how an\nelement is stored within the larger structure “intrudes” on the implementation of the element\ntype itself!</p>\n<p>The full implementation details of such a data structure are outside the scope of this\ndocumentation, but we will discuss how <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a> can help to do so.</p>\n<p>Using such an intrusive pattern, elements may only be added when they are pinned. If we think\nabout the consequences of adding non-pinned values to such a list, this becomes clear:</p>\n<p><em>Moving</em> or otherwise invalidating an element’s data would invalidate the pointers back to it\nwhich are stored in the elements ahead and behind it. Thus, in order to soundly dereference\nthe pointers stored to the next and previous elements, we must satisfy the guarantee that\nnothing has invalidated those pointers (which point to data that we do not own).</p>\n<p>Moreover, the <a href=\"../ops/trait.Drop.html\" title=\"trait std::ops::Drop\"><code>Drop</code></a> implementation of each element must in some way notify its\npredecessor and successor elements that it should be removed from the list before it is fully\ndestroyed, otherwise the pointers back to it would again become invalidated.</p>\n<p>Crucially, this means we have to be able to rely on <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> always being called before an\nelement is invalidated. If an element could be deallocated or otherwise invalidated without\ncalling <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a>, the pointers to it stored in its neighboring elements would\nbecome invalid, which would break the data structure.</p>\n<p>Therefore, pinning data also comes with <a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\">the “<code>Drop</code> guarantee”</a>.</p>\n<h2 id=\"subtle-details-and-the-drop-guarantee\"><a class=\"doc-anchor\" href=\"#subtle-details-and-the-drop-guarantee\">§</a>Subtle details and the <code>Drop</code> guarantee</h2>\n<p>The purpose of pinning is not <em>just</em> to prevent a value from being <em>moved</em>, but more\ngenerally to be able to rely on the pinned value <em>remaining valid <strong>at a specific place</strong></em> in\nmemory.</p>\n<p>To do so, pinning a value adds an <em>additional</em> invariant that must be upheld in order for use\nof the pinned data to be valid, on top of the ones that must be upheld for a non-pinned value\nof the same type to be valid:</p>\n<p>From the moment a value is pinned by constructing a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a>ning pointer to it, that value\nmust <em>remain, <strong>valid</strong></em>, at that same address in memory, <em>until its <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> handler is\ncalled.</em></p>\n<p>There is some subtlety to this which we have not yet talked about in detail. The invariant\ndescribed above means that, yes,</p>\n<ol>\n<li>The value must not be moved out of its location in memory</li>\n</ol>\n<p>but it also implies that,</p>\n<ol start=\"2\">\n<li>The memory location that stores the value must not get invalidated or otherwise repurposed\nduring the lifespan of the pinned value until its <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> returns or panics</li>\n</ol>\n<p>This point is subtle but required for intrusive data structures to be implemented soundly.</p>\n<h3 id=\"drop-guarantee\"><a class=\"doc-anchor\" href=\"#drop-guarantee\">§</a><code>Drop</code> guarantee</h3>\n<p>There needs to be a way for a pinned value to notify any code that is relying on its pinned\nstatus that it is about to be destroyed. In this way, the dependent code can remove the\npinned value’s address from its data structures or otherwise change its behavior with the\nknowledge that it can no longer rely on that value existing at the location it was pinned to.</p>\n<p>Thus, in any situation where we may want to overwrite a pinned value, that value’s <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> must\nbe called beforehand (unless the pinned value implements <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>, in which case we can ignore\nall of <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a>’s guarantees, as usual).</p>\n<p>The most common storage-reuse situations occur when a value on the stack is destroyed as part\nof a function return and when heap storage is freed. In both cases, <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> gets run for us\nby Rust when using standard safe code. However, for manual heap allocations or otherwise\ncustom-allocated storage, <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code must make sure to call <a href=\"../ptr/fn.drop_in_place.html\" title=\"fn std::ptr::drop_in_place\"><code>ptr::drop_in_place</code></a> before\ndeallocating and re-using said storage.</p>\n<p>In addition, storage “re-use”/invalidation can happen even if no storage is (de-)allocated.\nFor example, if we had an <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> which contained a <code>Some(v)</code> where <code>v</code> is pinned, then <code>v</code>\nwould be invalidated by setting that option to <code>None</code>.</p>\n<p>Similarly, if a <a href=\"../../std/vec/struct.Vec.html\" title=\"Vec\"><code>Vec</code></a> was used to store pinned values and <a href=\"../../std/vec/struct.Vec.html#method.set_len\" title=\"Vec::set_len\"><code>Vec::set_len</code></a> was used to\nmanually “kill” some elements of a vector, all of the items “killed” would become invalidated,\nwhich would be <em>undefined behavior</em> if those items were pinned.</p>\n<p>Both of these cases are somewhat contrived, but it is crucial to remember that <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a>ned data\n<em>must</em> be <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a>ped before it is invalidated; not just to prevent memory leaks, but as a\nmatter of soundness. As a corollary, the following code can <em>never</em> be made safe:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Pin something inside a `ManuallyDrop`. This is fine on its own.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>pin: Pin&lt;Box&lt;ManuallyDrop&lt;Type&gt;&gt;&gt; = Box::pin(ManuallyDrop::new(Type));\n\n<span class=\"comment\">// However, creating a pinning mutable reference to the type *inside*\n// the `ManuallyDrop` is not!\n</span><span class=\"kw\">let </span>inner: Pin&lt;<span class=\"kw-2\">&amp;mut </span>Type&gt; = <span class=\"kw\">unsafe </span>{\n    Pin::map_unchecked_mut(pin.as_mut(), |x| <span class=\"kw-2\">&amp;mut **</span>x)\n};</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::ManuallyDrop;%0A++++use+std::pin::Pin;%0A++++struct+Type;%0A++++//+Pin+something+inside+a+%60ManuallyDrop%60.+This+is+fine+on+its+own.%0A++++let+mut+pin:+Pin%3CBox%3CManuallyDrop%3CType%3E%3E%3E+=+Box::pin(ManuallyDrop::new(Type));%0A++++%0A++++//+However,+creating+a+pinning+mutable+reference+to+the+type+*inside*%0A++++//+the+%60ManuallyDrop%60+is+not!%0A++++let+inner:+Pin%3C%26mut+Type%3E+=+unsafe+%7B%0A++++++++Pin::map_unchecked_mut(pin.as_mut(),+%7Cx%7C+%26mut+**x)%0A++++%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because <a href=\"../mem/struct.ManuallyDrop.html\" title=\"struct std::mem::ManuallyDrop\"><code>mem::ManuallyDrop</code></a> inhibits the destructor of <code>Type</code>, it won’t get run when the\n<code><a href=\"../../std/boxed/struct.Box.html\" title=\"Box\">Box</a>&lt;<a href=\"../mem/struct.ManuallyDrop.html\" title=\"ManuallyDrop\">ManuallyDrop</a>&lt;Type&gt;&gt;</code> is dropped, thus violating the drop guarantee of the\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> Type&gt;&gt;</code>.</p>\n<p>Of course, <em>leaking</em> memory in such a way that its underlying storage will never get invalidated\nor re-used is still fine: <a href=\"../mem/fn.forget.html\" title=\"mem::forget\"><code>mem::forget</code></a>ing a <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> prevents its storage from ever getting\nre-used, so the <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> guarantee is still satisfied.</p>\n<h2 id=\"implementing-an-address-sensitive-type\"><a class=\"doc-anchor\" href=\"#implementing-an-address-sensitive-type\">§</a>Implementing an address-sensitive type.</h2>\n<p>This section goes into detail on important considerations for implementing your own\naddress-sensitive types, which are different from merely using <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> in a generic\nway.</p>\n<h3 id=\"implementing-drop-for-types-with-address-sensitive-states\"><a class=\"doc-anchor\" href=\"#implementing-drop-for-types-with-address-sensitive-states\">§</a>Implementing <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>Drop</code></a> for types with address-sensitive states</h3>\n<p>The <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> function takes <a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut self</code></a>, but this is called <em>even if that <code>self</code> has been\npinned</em>! Implementing <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>Drop</code></a> for a type with address-sensitive states, because if <code>self</code> was\nindeed in an address-sensitive state before <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> was called, it is as if the compiler\nautomatically called <a href=\"struct.Pin.html#method.get_unchecked_mut\" title=\"method std::pin::Pin::get_unchecked_mut\"><code>Pin::get_unchecked_mut</code></a>.</p>\n<p>This can never cause a problem in purely safe code because creating a pinning pointer to\na type which has an address-sensitive (thus does not implement <code>Unpin</code>) requires <code>unsafe</code>,\nbut it is important to note that choosing to take advantage of pinning-related guarantees\nto justify validity in the implementation of your type has consequences for that type’s\n<a href=\"../ops/trait.Drop.html\" title=\"trait std::ops::Drop\"><code>Drop</code></a> implementation as well: if an element of your type could have been pinned,\nyou must treat <a href=\"../ops/trait.Drop.html\" title=\"trait std::ops::Drop\"><code>Drop</code></a> as implicitly taking <code>self: <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> Self&gt;</code>.</p>\n<p>You should implement <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>Drop</code></a> as follows:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl </span>Drop <span class=\"kw\">for </span>Type {\n    <span class=\"kw\">fn </span>drop(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"comment\">// `new_unchecked` is okay because we know this value is never used\n        // again after being dropped.\n        </span>inner_drop(<span class=\"kw\">unsafe </span>{ Pin::new_unchecked(<span class=\"self\">self</span>)});\n        <span class=\"kw\">fn </span>inner_drop(this: Pin&lt;<span class=\"kw-2\">&amp;mut </span>Type&gt;) {\n            <span class=\"comment\">// Actual drop code goes here.\n        </span>}\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++struct+Type;%0A++++impl+Drop+for+Type+%7B%0A++++++++fn+drop(%26mut+self)+%7B%0A++++++++++++//+%60new_unchecked%60+is+okay+because+we+know+this+value+is+never+used%0A++++++++++++//+again+after+being+dropped.%0A++++++++++++inner_drop(unsafe+%7B+Pin::new_unchecked(self)%7D);%0A++++++++++++fn+inner_drop(this:+Pin%3C%26mut+Type%3E)+%7B%0A++++++++++++++++//+Actual+drop+code+goes+here.%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The function <code>inner_drop</code> has the signature that <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> <em>should</em> have in this situation.\nThis makes sure that you do not accidentally use <code>self</code>/<code>this</code> in a way that is in conflict\nwith pinning’s invariants.</p>\n<p>Moreover, if your type is <a href=\"https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked\"><code>#[repr(packed)]</code></a>, the compiler will automatically\nmove fields around to be able to drop them. It might even do\nthat for fields that happen to be sufficiently aligned. As a consequence, you cannot use\npinning with a <a href=\"https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked\"><code>#[repr(packed)]</code></a> type.</p>\n<h4 id=\"implementing-drop-for-pointer-types-which-will-be-used-as-pinning-pointers\"><a class=\"doc-anchor\" href=\"#implementing-drop-for-pointer-types-which-will-be-used-as-pinning-pointers\">§</a>Implementing <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>Drop</code></a> for pointer types which will be used as <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a>ning pointers</h4>\n<p>It should further be noted that creating a pinning pointer of some type <code>Ptr</code> <em>also</em> carries\nwith it implications on the way that <code>Ptr</code> type must implement <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>Drop</code></a>\n(as well as <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a> and <a href=\"../ops/trait.DerefMut.html\" title=\"ops::DerefMut\"><code>DerefMut</code></a>)! When implementing a pointer type that may be used as\na pinning pointer, you must also take the same care described above not to <em>move</em> out of or\notherwise invalidate the pointee during <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>Drop</code></a>, <a href=\"../ops/trait.Deref.html\" title=\"ops::Deref\"><code>Deref</code></a>, or <a href=\"../ops/trait.DerefMut.html\" title=\"ops::DerefMut\"><code>DerefMut</code></a>\nimplementations.</p>\n<h3 id=\"assigning-pinned-data\"><a class=\"doc-anchor\" href=\"#assigning-pinned-data\">§</a>“Assigning” pinned data</h3>\n<p>Although in general it is not valid to swap data or assign through a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> for the same\nreason that reusing a pinned object’s memory is invalid, it is possible to do validly when\nimplemented with special care for the needs of the exact data structure which is being\nmodified. For example, the assigning function must know how to update all uses of the pinned\naddress (and any other invariants necessary to satisfy validity for that type). For\n<a href=\"#a-self-referential-struct\"><code>Unmovable</code></a> (from the example above), we could write an assignment function like so:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl </span>Unmovable {\n    <span class=\"comment\">// Copies the contents of `src` into `self`, fixing up the self-pointer\n    // in the process.\n    </span><span class=\"kw\">fn </span>assign(<span class=\"self\">self</span>: Pin&lt;<span class=\"kw-2\">&amp;mut </span><span class=\"self\">Self</span>&gt;, src: Pin&lt;<span class=\"kw-2\">&amp;mut </span><span class=\"self\">Self</span>&gt;) {\n        <span class=\"kw\">unsafe </span>{\n            <span class=\"kw\">let </span>unpinned_self = Pin::into_inner_unchecked(<span class=\"self\">self</span>);\n            <span class=\"kw\">let </span>unpinned_src = Pin::into_inner_unchecked(src);\n            <span class=\"kw-2\">*</span>unpinned_self = <span class=\"self\">Self </span>{\n                data: unpinned_src.data,\n                slice: NonNull::from(<span class=\"kw-2\">&amp;mut </span>[]),\n                _pin: PhantomPinned,\n            };\n\n            <span class=\"kw\">let </span>data_ptr = unpinned_src.data.as_ptr() <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>u8;\n            <span class=\"kw\">let </span>slice_ptr = unpinned_src.slice.as_ptr() <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>u8;\n            <span class=\"kw\">let </span>offset = slice_ptr.offset_from(data_ptr) <span class=\"kw\">as </span>usize;\n            <span class=\"kw\">let </span>len = (<span class=\"kw-2\">*</span>unpinned_src.slice.as_ptr()).len();\n\n            unpinned_self.slice = NonNull::from(<span class=\"kw-2\">&amp;mut </span>unpinned_self.data[offset..offset+len]);\n        }\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++use+std::marker::PhantomPinned;%0A++++use+std::ptr::NonNull;%0A++++struct+Unmovable+%7B%0A++++++++data:+%5Bu8;+64%5D,%0A++++++++slice:+NonNull%3C%5Bu8%5D%3E,%0A++++++++_pin:+PhantomPinned,%0A++++%7D%0A++++%0A++++impl+Unmovable+%7B%0A++++++++//+Copies+the+contents+of+%60src%60+into+%60self%60,+fixing+up+the+self-pointer%0A++++++++//+in+the+process.%0A++++++++fn+assign(self:+Pin%3C%26mut+Self%3E,+src:+Pin%3C%26mut+Self%3E)+%7B%0A++++++++++++unsafe+%7B%0A++++++++++++++++let+unpinned_self+=+Pin::into_inner_unchecked(self);%0A++++++++++++++++let+unpinned_src+=+Pin::into_inner_unchecked(src);%0A++++++++++++++++*unpinned_self+=+Self+%7B%0A++++++++++++++++++++data:+unpinned_src.data,%0A++++++++++++++++++++slice:+NonNull::from(%26mut+%5B%5D),%0A++++++++++++++++++++_pin:+PhantomPinned,%0A++++++++++++++++%7D;%0A++++%0A++++++++++++++++let+data_ptr+=+unpinned_src.data.as_ptr()+as+*const+u8;%0A++++++++++++++++let+slice_ptr+=+unpinned_src.slice.as_ptr()+as+*const+u8;%0A++++++++++++++++let+offset+=+slice_ptr.offset_from(data_ptr)+as+usize;%0A++++++++++++++++let+len+=+(*unpinned_src.slice.as_ptr()).len();%0A++++%0A++++++++++++++++unpinned_self.slice+=+NonNull::from(%26mut+unpinned_self.data%5Boffset..offset%2Blen%5D);%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Even though we can’t have the compiler do the assignment for us, it’s possible to write\nsuch specialized functions for types that might need it.</p>\n<p>Note that it <em>is</em> possible to assign generically through a <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin&lt;Ptr&gt;</code></a> by way of <a href=\"struct.Pin.html#method.set\" title=\"method std::pin::Pin::set\"><code>Pin::set()</code></a>.\nThis does not violate any guarantees, since it will run <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> on the pointee value before\nassigning the new value. Thus, the <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> implementation still has a chance to perform the\nnecessary notifications to dependent values before the memory location of the original pinned\nvalue is overwritten.</p>\n<h3 id=\"projections-and-structural-pinning\"><a class=\"doc-anchor\" href=\"#projections-and-structural-pinning\">§</a>Projections and Structural Pinning</h3>\n<p>With ordinary structs, it is natural that we want to add <em>projection</em> methods that allow\nborrowing one or more of the inner fields of a struct when the caller has access to a\nborrow of the whole struct:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">struct </span>Struct {\n    field: Field,\n    <span class=\"comment\">// ...\n</span>}\n\n<span class=\"kw\">impl </span>Struct {\n    <span class=\"kw\">fn </span>field(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"kw-2\">&amp;mut </span>Field { <span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>.field }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+Field;%0A++++struct+Struct+%7B%0A++++++++field:+Field,%0A++++++++//+...%0A++++%7D%0A++++%0A++++impl+Struct+%7B%0A++++++++fn+field(%26mut+self)+-%3E+%26mut+Field+%7B+%26mut+self.field+%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>When working with address-sensitive types, it’s not obvious what the signature of these\nfunctions should be. If <code>field</code> takes <code>self: <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut Struct</a>&gt;</code>, should it\nreturn <a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Field</code></a> or <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Field</code></a>&gt;</code>? This question also arises with\n<code>enum</code>s and wrapper types like <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a>, <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>, and <a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a>. (This question\napplies just as well to shared references, but we’ll examine the more common case of mutable\nreferences for illustration)</p>\n<p>It turns out that it’s up to the author of <code>Struct</code> to decide which type the “projection”\nshould produce. The choice must be <em>consistent</em> though: if a pin is projected to a field\nin one place, then it should very likely not be exposed elsewhere without projecting the\npin.</p>\n<p>As the author of a data structure, you get to decide for each field whether pinning\n“propagates” to this field or not. Pinning that propagates is also called “structural”,\nbecause it follows the structure of the type.</p>\n<p>This choice depends on what guarantees you need from the field for your <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code to work.\nIf the field is itself address-sensitive, or participates in the parent struct’s address\nsensitivity, it will need to be structurally pinned.</p>\n<p>A useful test is if <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code that consumes <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut Struct</a>&gt;</code>\nalso needs to take note of the address of the field itself, it may be evidence that that field\nis structurally pinned. Unfortunately, there are no hard-and-fast rules.</p>\n<h4 id=\"choosing-pinning-not-to-be-structural-for-field\"><a class=\"doc-anchor\" href=\"#choosing-pinning-not-to-be-structural-for-field\">§</a>Choosing pinning <em>not to be</em> structural for <code>field</code>…</h4>\n<p>While counter-intuitive, it’s often the easier choice: if you do not expose a\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> Field&gt;</code>, you do not need to be careful about other code\nmoving out of that field, you just have to ensure is that you never create pinning\nreference to that field. This does of course also mean that if you decide a field does not\nhave structural pinning, you must not write <a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a> code that assumes (invalidly) that the\nfield <em>is</em> structurally pinned!</p>\n<p>Fields without structural pinning may have a projection method that turns\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut</a> Struct&gt;</code> into <a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Field</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl </span>Struct {\n    <span class=\"kw\">fn </span>field(<span class=\"self\">self</span>: Pin&lt;<span class=\"kw-2\">&amp;mut </span><span class=\"self\">Self</span>&gt;) -&gt; <span class=\"kw-2\">&amp;mut </span>Field {\n        <span class=\"comment\">// This is okay because `field` is never considered pinned, therefore we do not\n        // need to uphold any pinning guarantees for this field in particular. Of course,\n        // we must not elsewhere assume this field *is* pinned if we choose to expose\n        // such a method!\n        </span><span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>.get_unchecked_mut().field }\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++type+Field+=+i32;%0A++++struct+Struct+%7B+field:+Field+%7D%0A++++impl+Struct+%7B%0A++++++++fn+field(self:+Pin%3C%26mut+Self%3E)+-%3E+%26mut+Field+%7B%0A++++++++++++//+This+is+okay+because+%60field%60+is+never+considered+pinned,+therefore+we+do+not%0A++++++++++++//+need+to+uphold+any+pinning+guarantees+for+this+field+in+particular.+Of+course,%0A++++++++++++//+we+must+not+elsewhere+assume+this+field+*is*+pinned+if+we+choose+to+expose%0A++++++++++++//+such+a+method!%0A++++++++++++unsafe+%7B+%26mut+self.get_unchecked_mut().field+%7D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>You may also in this situation <code>impl <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for Struct {}</code> <em>even if</em> the type of\n<code>field</code> is not <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>. Since we have explicitly chosen not to care about pinning guarantees\nfor <code>field</code>, the way <code>field</code>’s type interacts with pinning is no longer relevant in the\ncontext of its use in <code>Struct</code>.</p>\n<h4 id=\"choosing-pinning-to-be-structural-for-field\"><a class=\"doc-anchor\" href=\"#choosing-pinning-to-be-structural-for-field\">§</a>Choosing pinning <em>to be</em> structural for <code>field</code>…</h4>\n<p>The other option is to decide that pinning is “structural” for <code>field</code>,\nmeaning that if the struct is pinned then so is the field.</p>\n<p>This allows writing a projection that creates a <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Field</code></a>&gt;</code>, thus\nwitnessing that the field is pinned:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl </span>Struct {\n    <span class=\"kw\">fn </span>field(<span class=\"self\">self</span>: Pin&lt;<span class=\"kw-2\">&amp;mut </span><span class=\"self\">Self</span>&gt;) -&gt; Pin&lt;<span class=\"kw-2\">&amp;mut </span>Field&gt; {\n        <span class=\"comment\">// This is okay because `field` is pinned when `self` is.\n        </span><span class=\"kw\">unsafe </span>{ <span class=\"self\">self</span>.map_unchecked_mut(|s| <span class=\"kw-2\">&amp;mut </span>s.field) }\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::pin::Pin;%0A++++type+Field+=+i32;%0A++++struct+Struct+%7B+field:+Field+%7D%0A++++impl+Struct+%7B%0A++++++++fn+field(self:+Pin%3C%26mut+Self%3E)+-%3E+Pin%3C%26mut+Field%3E+%7B%0A++++++++++++//+This+is+okay+because+%60field%60+is+pinned+when+%60self%60+is.%0A++++++++++++unsafe+%7B+self.map_unchecked_mut(%7Cs%7C+%26mut+s.field)+%7D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Structural pinning comes with a few extra requirements:</p>\n<ol>\n<li>\n<p><em>Structural <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>.</em> A struct can be <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> only if all of its\nstructurally-pinned fields are, too. This is <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>’s behavior by default.\nHowever, as a libray author, it is your responsibility not to write something like\n<code>impl&lt;T&gt; <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for Struct&lt;T&gt; {}</code> and then offer a method that provides\nstructural pinning to an inner field of <code>T</code>, which may not be <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>! (Adding <em>any</em>\nprojection operation requires unsafe code, so the fact that <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> is a safe trait does\nnot break the principle that you only have to worry about any of this if you use\n<a href=\"../../std/keyword.unsafe.html\" title=\"keyword unsafe\"><code>unsafe</code></a>)</p>\n</li>\n<li>\n<p><em>Pinned Destruction.</em> As discussed <a href=\"index.html#implementing-drop-for-types-with-address-sensitive-states\" title=\"mod std::pin\">above</a>, <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> takes\n<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut self</code></a>, but the struct (and hence its fields) might have been pinned\nbefore. The destructor must be written as if its argument was\n<code>self: <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Self</code></a>&gt;</code>, instead.</p>\n<p>As a consequence, the struct <em>must not</em> be <a href=\"https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked\"><code>#[repr(packed)]</code></a>.</p>\n</li>\n<li>\n<p><em>Structural Notice of Destruction.</em> You must uphold the\n<a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\"><code>Drop</code> guarantee</a>: once your struct is pinned, the struct’s storage cannot\nbe re-used without calling the structurally-pinned fields’ destructors, as well.</p>\n<p>This can be tricky, as witnessed by <a href=\"../../std/collections/struct.VecDeque.html\"><code>VecDeque&lt;T&gt;</code></a>: the destructor of <a href=\"../../std/collections/struct.VecDeque.html\"><code>VecDeque&lt;T&gt;</code></a>\ncan fail to call <a href=\"../ops/trait.Drop.html#tymethod.drop\" title=\"method std::ops::Drop::drop\"><code>drop</code></a> on all elements if one of the destructors panics. This violates\nthe <a href=\"index.html#subtle-details-and-the-drop-guarantee\" title=\"mod std::pin\"><code>Drop</code> guarantee</a>, because it can lead to elements being deallocated\nwithout their destructor being called.</p>\n<p><a href=\"../../std/collections/struct.VecDeque.html\"><code>VecDeque&lt;T&gt;</code></a> has no pinning projections, so its destructor is sound. If it wanted\nto provide such structural pinning, its destructor would need to abort the process if any\nof the destructors panicked.</p>\n</li>\n<li>\n<p>You must not offer any other operations that could lead to data being <em>moved</em> out of\nthe structural fields when your type is pinned. For example, if the struct contains an\n<a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> and there is a <a href=\"../option/enum.Option.html#method.take\" title=\"method std::option::Option::take\"><code>take</code></a>-like operation with type\n<code>fn(<a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"mutable reference\">&amp;mut Struct&lt;T&gt;</a>&gt;) -&gt; <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a></code>,\nthen that operation can be used to move a <code>T</code> out of a pinned <code>Struct&lt;T&gt;</code> – which\nmeans pinning cannot be structural for the field holding this data.</p>\n<p>For a more complex example of moving data out of a pinned type,\nimagine if <a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a> had a method\n<code>fn get_pin_mut(self: <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Self</code></a>&gt;) -&gt; <a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut T</code></a>&gt;</code>.\nThen we could do the following:</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>exploit_ref_cell&lt;T&gt;(rc: Pin&lt;<span class=\"kw-2\">&amp;mut </span>RefCell&lt;T&gt;&gt;) {\n    <span class=\"comment\">// Here we get pinned access to the `T`.\n    </span><span class=\"kw\">let _</span>: Pin&lt;<span class=\"kw-2\">&amp;mut </span>T&gt; = rc.as_mut().get_pin_mut();\n\n    <span class=\"comment\">// And here we have `&amp;mut T` to the same data.\n    </span><span class=\"kw\">let </span>shared: <span class=\"kw-2\">&amp;</span>RefCell&lt;T&gt; = rc.into_ref().get_ref();\n    <span class=\"kw\">let </span>borrow = shared.borrow_mut();\n    <span class=\"kw\">let </span>content = <span class=\"kw-2\">&amp;mut *</span>borrow;\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++use+std::pin::Pin;%0A++++fn+exploit_ref_cell%3CT%3E(rc:+Pin%3C%26mut+RefCell%3CT%3E%3E)+%7B%0A++++++++//+Here+we+get+pinned+access+to+the+%60T%60.%0A++++++++let+_:+Pin%3C%26mut+T%3E+=+rc.as_mut().get_pin_mut();%0A++++%0A++++++++//+And+here+we+have+%60%26mut+T%60+to+the+same+data.%0A++++++++let+shared:+%26RefCell%3CT%3E+=+rc.into_ref().get_ref();%0A++++++++let+borrow+=+shared.borrow_mut();%0A++++++++let+content+=+%26mut+*borrow;%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This is catastrophic: it means we can first pin the content of the\n<a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a> (using <code><a href=\"../cell/struct.RefCell.html\" title=\"cell::RefCell\">RefCell</a>::get_pin_mut</code>) and then move that\ncontent using the mutable reference we got later.</p>\n</li>\n</ol>\n<h4 id=\"structural-pinning-examples\"><a class=\"doc-anchor\" href=\"#structural-pinning-examples\">§</a>Structural Pinning examples</h4>\n<p>For a type like <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a>, both possibilities (structural pinning or not) make\nsense. A <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a> with structural pinning could have <code>get_pin</code>/<code>get_pin_mut</code>\nmethods to get pinning references to elements. However, it could <em>not</em> allow calling\n<a href=\"../../std/vec/struct.Vec.html#method.pop\" title=\"Vec::pop\"><code>pop</code></a> on a pinned <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a> because that would move the (structurally\npinned) contents! Nor could it allow <a href=\"../../std/vec/struct.Vec.html#method.push\" title=\"Vec::push\"><code>push</code></a>, which might reallocate and thus also\nmove the contents.</p>\n<p>A <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a> without structural pinning could\n<code>impl&lt;T&gt; <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a></code>, because the contents are never pinned\nand the <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a> itself is fine with being moved as well.\nAt that point pinning just has no effect on the vector at all.</p>\n<p>In the standard library, pointer types generally do not have structural pinning,\nand thus they do not offer pinning projections. This is why <code><a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>: <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a></code>\nholds for all <code>T</code>. It makes sense to do this for pointer types, because moving the\n<a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> does not actually move the <code>T</code>: the <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> can be freely\nmovable (aka <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a>) even if the <code>T</code> is not. In fact, even <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>&gt;</code> and\n<code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut T</code></a>&gt;</code> are always <a href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\"><code>Unpin</code></a> themselves, for the same reason:\ntheir contents (the <code>T</code>) are pinned, but the pointers themselves can be moved without moving\nthe pinned data. For both <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> and <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a>&gt;</code>,\nwhether the content is pinned is entirely independent of whether the\npointer is pinned, meaning pinning is <em>not</em> structural.</p>\n<p>When implementing a <a href=\"../future/trait.Future.html\" title=\"future::Future\"><code>Future</code></a> combinator, you will usually need structural pinning\nfor the nested futures, as you need to get pinning (<a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\"><code>Pin</code></a>-wrapped) references to them to\ncall <a href=\"../future/trait.Future.html#tymethod.poll\" title=\"future::Future::poll\"><code>poll</code></a>. But if your combinator contains any other data that does not need to be pinned,\nyou can make those fields not structural and hence freely access them with a\nmutable reference even when you just have <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\"><code>&amp;mut Self</code></a>&gt;</code>\n(such as in your own <a href=\"../future/trait.Future.html#tymethod.poll\" title=\"future::Future::poll\"><code>poll</code></a> implementation).</p>\n<div class=\"footnotes\"><hr><ol><li id=\"fn1\"><p>Futures themselves do not ever need to notify other bits of code that\nthey are being dropped, however data structures like stack-based intrusive linked lists do.&nbsp;<a href=\"#fnref1\">↩</a></p></li><li id=\"fn2\"><p>There is a bit of nuance here that is still being decided about what the aliasing\nsemantics of <code>Pin&lt;&amp;mut T&gt;</code> should be, but this is true as of today.&nbsp;<a href=\"#fnref2\">↩</a></p></li></ol></div></div></details><h2 id=\"macros\" class=\"section-header\">Macros<a href=\"#macros\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"macro\" href=\"macro.pin.html\" title=\"macro std::pin::pin\">pin</a></div><div class=\"desc docblock-short\">Constructs a <code><a href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a>&lt;<a href=\"../primitive.reference.html\" title=\"primitive reference\">&amp;mut</a> T&gt;</code>, by pinning a <code>value: T</code> locally.</div></li></ul><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Pin.html\" title=\"struct std::pin::Pin\">Pin</a></div><div class=\"desc docblock-short\">A pointer which pins its pointee in place.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:05.286Z"
}