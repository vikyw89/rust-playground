{
	"title": "Ipv6Addr in std::net - Rust",
	"url": "https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html",
	"markdown": "# Ipv6Addr in std::net - Rust\n\n## Struct [std](../index.html)::[net](index.html)::[Ipv6Addr](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#155) ·\n\n```\npub struct Ipv6Addr { /* private fields */ }\n```\n\nExpand description\n\nAn IPv6 address.\n\nIPv6 addresses are defined as 128-bit integers in [IETF RFC 4291](https://tools.ietf.org/html/rfc4291). They are usually represented as eight 16-bit segments.\n\n## [§](#embedding-ipv4-addresses)Embedding IPv4 Addresses\n\nSee [`IpAddr`](enum.IpAddr.html \"enum std::net::IpAddr\") for a type encompassing both IPv4 and IPv6 addresses.\n\nTo assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined: IPv4-compatible and IPv4-mapped addresses. Of these IPv4-compatible addresses have been officially deprecated.\n\nBoth types of addresses are not assigned any special meaning by this implementation, other than what the relevant standards prescribe. This means that an address like `::ffff:127.0.0.1`, while representing an IPv4 loopback address, is not itself an IPv6 loopback address; only `::1` is. To handle these so called “IPv4-in-IPv6” addresses, they have to first be converted to their canonical IPv4 address.\n\n#### [§](#ipv4-compatible-ipv6-addresses)IPv4-Compatible IPv6 Addresses\n\nIPv4-compatible IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.1](https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.1), and have been officially deprecated. The RFC describes the format of an “IPv4-Compatible IPv6 address” as follows:\n\n```text\n|                80 bits               | 16 |      32 bits        |\n+--------------------------------------+--------------------------+\n|0000..............................0000|0000|    IPv4 address     |\n+--------------------------------------+----+---------------------+\n\n```\n\nSo `::a.b.c.d` would be an IPv4-compatible IPv6 address representing the IPv4 address `a.b.c.d`.\n\nTo convert from an IPv4 address to an IPv4-compatible IPv6 address, use [`Ipv4Addr::to_ipv6_compatible`](about:blank/struct.Ipv4Addr.html#method.to_ipv6_compatible \"method std::net::Ipv4Addr::to_ipv6_compatible\"). Use [`Ipv6Addr::to_ipv4`](about:blank/struct.Ipv6Addr.html#method.to_ipv4 \"method std::net::Ipv6Addr::to_ipv4\") to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.\n\n#### [§](#ipv4-mapped-ipv6-addresses)IPv4-Mapped IPv6 Addresses\n\nIPv4-mapped IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.2](https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2). The RFC describes the format of an “IPv4-Mapped IPv6 address” as follows:\n\n```text\n|                80 bits               | 16 |      32 bits        |\n+--------------------------------------+--------------------------+\n|0000..............................0000|FFFF|    IPv4 address     |\n+--------------------------------------+----+---------------------+\n\n```\n\nSo `::ffff:a.b.c.d` would be an IPv4-mapped IPv6 address representing the IPv4 address `a.b.c.d`.\n\nTo convert from an IPv4 address to an IPv4-mapped IPv6 address, use [`Ipv4Addr::to_ipv6_mapped`](about:blank/struct.Ipv4Addr.html#method.to_ipv6_mapped \"method std::net::Ipv4Addr::to_ipv6_mapped\"). Use [`Ipv6Addr::to_ipv4`](about:blank/struct.Ipv6Addr.html#method.to_ipv4 \"method std::net::Ipv6Addr::to_ipv4\") to convert an IPv4-mapped IPv6 address to the canonical IPv4 address. Note that this will also convert the IPv6 loopback address `::1` to `0.0.0.1`. Use [`Ipv6Addr::to_ipv4_mapped`](about:blank/struct.Ipv6Addr.html#method.to_ipv4_mapped \"method std::net::Ipv6Addr::to_ipv4_mapped\") to avoid this.\n\n## [§](#textual-representation)Textual representation\n\n`Ipv6Addr` provides a [`FromStr`](../str/trait.FromStr.html \"trait std::str::FromStr\") implementation. There are many ways to represent an IPv6 address in text, but in general, each segments is written in hexadecimal notation, and segments are separated by `:`. For more information, see [IETF RFC 5952](https://tools.ietf.org/html/rfc5952).\n\n## [§](#examples)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\nassert_eq!(\"::1\".parse(), Ok(localhost));\nassert_eq!(localhost.is_loopback(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+localhost+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1);%0A++++assert_eq!(%22::1%22.parse(),+Ok(localhost));%0A++++assert_eq!(localhost.is_loopback(),+true);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1198)[§](#impl-Ipv6Addr)\n\n1.0.0 (const: 1.32.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1214)\n\nCreates a new IPv6 address from eight 16-bit segments.\n\nThe result will represent the IP address `a:b:c:d:e:f:g:h`.\n\n##### [§](#examples-1)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff);%0A%7D&edition=2021)\n\n1.80.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1242)\n\nThe size of an IPv6 address in bits.\n\n##### [§](#examples-2)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::BITS, 128);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::BITS,+128);%0A%7D&edition=2021)\n\n1.80.0 (const: 1.80.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1284)\n\nConverts an IPv6 address into a `u128` representation using native byte order.\n\nAlthough IPv6 addresses are big-endian, the `u128` value will use the target platform’s native byte order. That is, the `u128` value is an integer representation of the IPv6 address and not an integer interpretation of the IPv6 address’s big-endian bitstring. This means that the `u128` value masked with `0xffffffffffffffffffffffffffff0000_u128` will set the last segment in the address to 0, regardless of the target platform’s endianness.\n\n##### [§](#examples-3)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::new(\n    0x1020, 0x3040, 0x5060, 0x7080,\n    0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n);\nassert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::new(%0A++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++0x90A0,+0xB0C0,+0xD0E0,+0xF00D,%0A++++);%0A++++assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128,+u128::from(addr));%0A%7D&edition=2021)\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::new(\n    0x1020, 0x3040, 0x5060, 0x7080,\n    0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n);\nlet addr_bits = addr.to_bits() & 0xffffffffffffffffffffffffffff0000_u128;\nassert_eq!(\n    Ipv6Addr::new(\n        0x1020, 0x3040, 0x5060, 0x7080,\n        0x90A0, 0xB0C0, 0xD0E0, 0x0000,\n    ),\n    Ipv6Addr::from_bits(addr_bits));\n\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::new(%0A++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++0x90A0,+0xB0C0,+0xD0E0,+0xF00D,%0A++++);%0A++++let+addr_bits+=+addr.to_bits()+%26+0xffffffffffffffffffffffffffff0000_u128;%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++++++0x90A0,+0xB0C0,+0xD0E0,+0x0000,%0A++++++++),%0A++++++++Ipv6Addr::from_bits(addr_bits));%0A%7D&edition=2021)\n\n1.80.0 (const: 1.80.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1309)\n\nConverts a native byte order `u128` into an IPv6 address.\n\nSee [`Ipv6Addr::to_bits`](about:blank/struct.Ipv6Addr.html#method.to_bits \"method std::net::Ipv6Addr::to_bits\") for an explanation on endianness.\n\n##### [§](#examples-4)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\nassert_eq!(\n    Ipv6Addr::new(\n        0x1020, 0x3040, 0x5060, 0x7080,\n        0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n    ),\n    addr);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++++++0x90A0,+0xB0C0,+0xD0E0,+0xF00D,%0A++++++++),%0A++++++++addr);%0A%7D&edition=2021)\n\n1.30.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1329)\n\nAn IPv6 address representing localhost: `::1`.\n\nThis corresponds to constant `IN6ADDR_LOOPBACK_INIT` or `in6addr_loopback` in other languages.\n\n##### [§](#examples-5)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::LOCALHOST;\nassert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::LOCALHOST;%0A++++assert_eq!(addr,+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1));%0A%7D&edition=2021)\n\n1.30.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1346)\n\nAn IPv6 address representing the unspecified address: `::`\n\nThis corresponds to constant `IN6ADDR_ANY_INIT` or `in6addr_any` in other languages.\n\n##### [§](#examples-6)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::UNSPECIFIED;\nassert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::UNSPECIFIED;%0A++++assert_eq!(addr,+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+0));%0A%7D&edition=2021)\n\n1.0.0 (const: 1.50.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1362)\n\nReturns the eight 16-bit segments that make up this address.\n\n##### [§](#examples-7)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n           [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).segments(),%0A+++++++++++++++%5B0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff%5D);%0A%7D&edition=2021)\n\n1.7.0 (const: 1.50.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1397)\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") for the special ‘unspecified’ address (`::`).\n\nThis property is defined in [IETF RFC 4291](https://tools.ietf.org/html/rfc4291).\n\n##### [§](#examples-8)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_unspecified(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+0).is_unspecified(),+true);%0A%7D&edition=2021)\n\n1.7.0 (const: 1.50.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1421)\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if this is the [loopback address](about:blank/struct.Ipv6Addr.html#associatedconstant.LOCALHOST \"associated constant std::net::Ipv6Addr::LOCALHOST\") (`::1`), as defined in [IETF RFC 4291 section 2.5.3](https://tools.ietf.org/html/rfc4291#section-2.5.3).\n\nContrary to IPv4, in IPv6 there is only one loopback address.\n\n##### [§](#examples-9)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_loopback(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+0x1).is_loopback(),+true);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1493)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if the address appears to be globally reachable as specified by the [IANA IPv6 Special-Purpose Address Registry](https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml). Whether or not an address is practically reachable will depend on your network configuration.\n\nMost IPv6 addresses are globally reachable; unless they are specifically defined as _not_ globally reachable.\n\nNon-exhaustive list of notable addresses that are not globally reachable:\n\n-   The [unspecified address](about:blank/struct.Ipv6Addr.html#associatedconstant.UNSPECIFIED \"associated constant std::net::Ipv6Addr::UNSPECIFIED\") ([`is_unspecified`](about:blank/struct.Ipv6Addr.html#method.is_unspecified \"method std::net::Ipv6Addr::is_unspecified\"))\n-   The [loopback address](about:blank/struct.Ipv6Addr.html#associatedconstant.LOCALHOST \"associated constant std::net::Ipv6Addr::LOCALHOST\") ([`is_loopback`](about:blank/struct.Ipv6Addr.html#method.is_loopback \"method std::net::Ipv6Addr::is_loopback\"))\n-   IPv4-mapped addresses\n-   Addresses reserved for benchmarking ([`is_benchmarking`](about:blank/struct.Ipv6Addr.html#method.is_benchmarking \"method std::net::Ipv6Addr::is_benchmarking\"))\n-   Addresses reserved for documentation ([`is_documentation`](about:blank/struct.Ipv6Addr.html#method.is_documentation \"method std::net::Ipv6Addr::is_documentation\"))\n-   Unique local addresses ([`is_unique_local`](about:blank/struct.Ipv6Addr.html#method.is_unique_local \"method std::net::Ipv6Addr::is_unique_local\"))\n-   Unicast addresses with link-local scope ([`is_unicast_link_local`](about:blank/struct.Ipv6Addr.html#method.is_unicast_link_local \"method std::net::Ipv6Addr::is_unicast_link_local\"))\n\nFor the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry](https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml).\n\nNote that an address having global scope is not the same as being globally reachable, and there is no direct relation between the two concepts: There exist addresses with global scope that are not globally reachable (for example unique local addresses), and addresses that are globally reachable without having global scope (multicast addresses with non-global scope).\n\n##### [§](#examples-10)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\n// Most IPv6 addresses are globally reachable:\nassert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n\n// However some addresses have been assigned a special meaning\n// that makes them not globally reachable. Some examples are:\n\n// The unspecified address (`::`)\nassert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n\n// The loopback address (`::1`)\nassert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n\n// IPv4-mapped addresses (`::ffff:0:0/96`)\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n\n// Addresses reserved for benchmarking (`2001:2::/48`)\nassert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n\n// Addresses reserved for documentation (`2001:db8::/32`)\nassert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n\n// Unique local addresses (`fc00::/7`)\nassert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n\n// Unicast addresses with link-local scope (`fe80::/10`)\nassert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n\n// For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++//+Most+IPv6+addresses+are+globally+reachable:%0A++++assert_eq!(Ipv6Addr::new(0x26,+0,+0x1c9,+0,+0,+0xafc8,+0x10,+0x1).is_global(),+true);%0A++++%0A++++//+However+some+addresses+have+been+assigned+a+special+meaning%0A++++//+that+makes+them+not+globally+reachable.+Some+examples+are:%0A++++%0A++++//+The+unspecified+address+(%60::%60)%0A++++assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(),+false);%0A++++%0A++++//+The+loopback+address+(%60::1%60)%0A++++assert_eq!(Ipv6Addr::LOCALHOST.is_global(),+false);%0A++++%0A++++//+IPv4-mapped+addresses+(%60::ffff:0:0/96%60)%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_global(),+false);%0A++++%0A++++//+Addresses+reserved+for+benchmarking+(%602001:2::/48%60)%0A++++assert_eq!(Ipv6Addr::new(0x2001,+2,+0,+0,+0,+0,+0,+1,).is_global(),+false);%0A++++%0A++++//+Addresses+reserved+for+documentation+(%602001:db8::/32%60)%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+1).is_global(),+false);%0A++++%0A++++//+Unique+local+addresses+(%60fc00::/7%60)%0A++++assert_eq!(Ipv6Addr::new(0xfc02,+0,+0,+0,+0,+0,+0,+1).is_global(),+false);%0A++++%0A++++//+Unicast+addresses+with+link-local+scope+(%60fe80::/10%60)%0A++++assert_eq!(Ipv6Addr::new(0xfe81,+0,+0,+0,+0,+0,+0,+1).is_global(),+false);%0A++++%0A++++//+For+a+complete+overview+see+the+IANA+IPv6+Special-Purpose+Address+Registry.%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1545)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if this is a unique local address (`fc00::/7`).\n\nThis property is defined in [IETF RFC 4193](https://tools.ietf.org/html/rfc4193).\n\n##### [§](#examples-11)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\nassert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_unique_local(),+false);%0A++++assert_eq!(Ipv6Addr::new(0xfc02,+0,+0,+0,+0,+0,+0,+0).is_unique_local(),+true);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1574)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if this is a unicast address, as defined by [IETF RFC 4291](https://tools.ietf.org/html/rfc4291). Any address that is not a [multicast address](about:blank/struct.Ipv6Addr.html#method.is_multicast \"method std::net::Ipv6Addr::is_multicast\") (`ff00::/8`) is unicast.\n\n##### [§](#examples-12)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\n// The unspecified and loopback addresses are unicast.\nassert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(), true);\nassert_eq!(Ipv6Addr::LOCALHOST.is_unicast(), true);\n\n// Any address that is not a multicast address (`ff00::/8`) is unicast.\nassert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast(), true);\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_unicast(), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++//+The+unspecified+and+loopback+addresses+are+unicast.%0A++++assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(),+true);%0A++++assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(),+true);%0A++++%0A++++//+Any+address+that+is+not+a+multicast+address+(%60ff00::/8%60)+is+unicast.%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_unicast(),+true);%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).is_unicast(),+false);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1626)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns `true` if the address is a unicast address with link-local scope, as defined in [RFC 4291](https://tools.ietf.org/html/rfc4291).\n\nA unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4](https://tools.ietf.org/html/rfc4291#section-2.4). Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6](https://tools.ietf.org/html/rfc4291#section-2.5.6), which describes “Link-Local IPv6 Unicast Addresses” as having the following stricter format:\n\n```text\n| 10 bits  |         54 bits         |          64 bits           |\n+----------+-------------------------+----------------------------+\n|1111111010|           0             |       interface ID         |\n+----------+-------------------------+----------------------------+\n\n```\n\nSo while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`, this might change in the future with the publication of new standards. More addresses in `fe80::/10` could be allocated, and those addresses will have link-local scope.\n\nAlso note that while [RFC 4291 section 2.5.3](https://tools.ietf.org/html/rfc4291#section-2.5.3) mentions about the [loopback address](about:blank/struct.Ipv6Addr.html#associatedconstant.LOCALHOST \"associated constant std::net::Ipv6Addr::LOCALHOST\") (`::1`) that “it is treated as having Link-Local scope”, this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.\n\n##### [§](#examples-13)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\n// The loopback address (`::1`) does not actually have link-local scope.\nassert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(), false);\n\n// Only addresses in `fe80::/10` have link-local scope.\nassert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), false);\nassert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n\n// Addresses outside the stricter `fe80::/64` also have link-local scope.\nassert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0).is_unicast_link_local(), true);\nassert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++//+The+loopback+address+(%60::1%60)+does+not+actually+have+link-local+scope.%0A++++assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(),+false);%0A++++%0A++++//+Only+addresses+in+%60fe80::/10%60+have+link-local+scope.%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_unicast_link_local(),+false);%0A++++assert_eq!(Ipv6Addr::new(0xfe80,+0,+0,+0,+0,+0,+0,+0).is_unicast_link_local(),+true);%0A++++%0A++++//+Addresses+outside+the+stricter+%60fe80::/64%60+also+have+link-local+scope.%0A++++assert_eq!(Ipv6Addr::new(0xfe80,+0,+0,+1,+0,+0,+0,+0).is_unicast_link_local(),+true);%0A++++assert_eq!(Ipv6Addr::new(0xfe81,+0,+0,+0,+0,+0,+0,+0).is_unicast_link_local(),+true);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1651)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if this is an address reserved for documentation (`2001:db8::/32`).\n\nThis property is defined in [IETF RFC 3849](https://tools.ietf.org/html/rfc3849).\n\n##### [§](#examples-14)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\nassert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_documentation(),+false);%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_documentation(),+true);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1674)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if this is an address reserved for benchmarking (`2001:2::/48`).\n\nThis property is defined in [IETF RFC 5180](https://tools.ietf.org/html/rfc5180), where it is mistakenly specified as covering the range `2001:0200::/48`. This is corrected in [IETF RFC Errata 1752](https://www.rfc-editor.org/errata_search.php?eid=1752) to `2001:0002::/48`.\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc613, 0x0).is_benchmarking(), false);\nassert_eq!(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0).is_benchmarking(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc613,+0x0).is_benchmarking(),+false);%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0x2,+0,+0,+0,+0,+0,+0).is_benchmarking(),+true);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1712)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if the address is a globally routable unicast address.\n\nThe following return false:\n\n-   the loopback address\n-   the link-local addresses\n-   unique local addresses\n-   the unspecified address\n-   the address range reserved for documentation\n\nThis method returns [`true`](../primitive.bool.html \"primitive bool\") for site-local addresses as per [RFC 4291 section 2.5.7](https://tools.ietf.org/html/rfc4291#section-2.5.7)\n\n```no\nThe special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\nbe supported in new implementations (i.e., new implementations must treat this prefix as\nGlobal Unicast).\n\n```\n\n##### [§](#examples-15)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_unicast_global(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_unicast_global(),+true);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1741)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns the address’s multicast scope if the address is multicast.\n\n##### [§](#examples-16)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::{Ipv6Addr, Ipv6MulticastScope};\n\nassert_eq!(\n    Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n    Some(Ipv6MulticastScope::Global)\n);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::%7BIpv6Addr,+Ipv6MulticastScope%7D;%0A++++%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(0xff0e,+0,+0,+0,+0,+0,+0,+0).multicast_scope(),%0A++++++++Some(Ipv6MulticastScope::Global)%0A++++);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).multicast_scope(),+None);%0A%7D&version=nightly&edition=2021)\n\n1.7.0 (const: 1.50.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1776)\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if this is a multicast address (`ff00::/8`).\n\nThis property is defined by [IETF RFC 4291](https://tools.ietf.org/html/rfc4291).\n\n##### [§](#examples-17)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).is_multicast(),+true);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_multicast(),+false);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1801)\n\n🔬This is a nightly-only experimental API. (`ip` [#27709](https://github.com/rust-lang/rust/issues/27709))\n\nReturns [`true`](../primitive.bool.html \"primitive bool\") if the address is an IPv4-mapped address (`::ffff:0:0/96`).\n\nIPv4-mapped addresses can be converted to their canonical IPv4 address with [`to_ipv4_mapped`](about:blank/struct.Ipv6Addr.html#method.to_ipv4_mapped \"method std::net::Ipv6Addr::to_ipv4_mapped\").\n\n##### [§](#examples-18)Examples\n\n```\n#![feature(ip)]\n\nuse std::net::{Ipv4Addr, Ipv6Addr};\n\nlet ipv4_mapped = Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped();\nassert_eq!(ipv4_mapped.is_ipv4_mapped(), true);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff).is_ipv4_mapped(), true);\n\nassert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_ipv4_mapped(), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::%7BIpv4Addr,+Ipv6Addr%7D;%0A++++%0A++++let+ipv4_mapped+=+Ipv4Addr::new(192,+0,+2,+255).to_ipv6_mapped();%0A++++assert_eq!(ipv4_mapped.is_ipv4_mapped(),+true);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc000,+0x2ff).is_ipv4_mapped(),+true);%0A++++%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_ipv4_mapped(),+false);%0A%7D&version=nightly&edition=2021)\n\n1.63.0 (const: 1.75.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1830)\n\nConverts this address to an [`IPv4` address](struct.Ipv4Addr.html \"struct std::net::Ipv4Addr\") if it’s an [IPv4-mapped](struct.Ipv6Addr.html \"struct std::net::Ipv6Addr\") address, as defined in [IETF RFC 4291 section 2.5.5.2](https://tools.ietf.org/html/rfc4291#section-2.5.5.2), otherwise returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\n`::ffff:a.b.c.d` becomes `a.b.c.d`. All addresses _not_ starting with `::ffff` will return `None`.\n\n##### [§](#examples-19)Examples\n\n```\nuse std::net::{Ipv4Addr, Ipv6Addr};\n\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n           Some(Ipv4Addr::new(192, 10, 2, 255)));\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::%7BIpv4Addr,+Ipv6Addr%7D;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).to_ipv4_mapped(),+None);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).to_ipv4_mapped(),%0A+++++++++++++++Some(Ipv4Addr::new(192,+10,+2,+255)));%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1).to_ipv4_mapped(),+None);%0A%7D&edition=2021)\n\n1.0.0 (const: 1.50.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1872)\n\nConverts this address to an [`IPv4` address](struct.Ipv4Addr.html \"struct std::net::Ipv4Addr\") if it is either an [IPv4-compatible](about:blank/struct.Ipv6Addr.html#ipv4-compatible-ipv6-addresses \"struct std::net::Ipv6Addr\") address as defined in [IETF RFC 4291 section 2.5.5.1](https://tools.ietf.org/html/rfc4291#section-2.5.5.1), or an [IPv4-mapped](about:blank/struct.Ipv6Addr.html#ipv4-mapped-ipv6-addresses \"struct std::net::Ipv6Addr\") address as defined in [IETF RFC 4291 section 2.5.5.2](https://tools.ietf.org/html/rfc4291#section-2.5.5.2), otherwise returns [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\").\n\nNote that this will return an [`IPv4` address](struct.Ipv4Addr.html \"struct std::net::Ipv4Addr\") for the IPv6 loopback address `::1`. Use [`Ipv6Addr::to_ipv4_mapped`](about:blank/struct.Ipv6Addr.html#method.to_ipv4_mapped \"method std::net::Ipv6Addr::to_ipv4_mapped\") to avoid this.\n\n`::a.b.c.d` and `::ffff:a.b.c.d` become `a.b.c.d`. `::1` becomes `0.0.0.1`. All addresses _not_ starting with either all zeroes or `::ffff` will return `None`.\n\n##### [§](#examples-20)Examples\n\n```\nuse std::net::{Ipv4Addr, Ipv6Addr};\n\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n           Some(Ipv4Addr::new(192, 10, 2, 255)));\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n           Some(Ipv4Addr::new(0, 0, 0, 1)));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::%7BIpv4Addr,+Ipv6Addr%7D;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).to_ipv4(),+None);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).to_ipv4(),%0A+++++++++++++++Some(Ipv4Addr::new(192,+10,+2,+255)));%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1).to_ipv4(),%0A+++++++++++++++Some(Ipv4Addr::new(0,+0,+0,+1)));%0A%7D&edition=2021)\n\n1.75.0 (const: 1.75.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1898)\n\nConverts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it returns self wrapped in an `IpAddr::V6`.\n\n##### [§](#examples-21)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).is_loopback(), false);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).to_canonical().is_loopback(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0x7f00,+0x1).is_loopback(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0x7f00,+0x1).to_canonical().is_loopback(),+true);%0A%7D&edition=2021)\n\n1.12.0 (const: 1.32.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1917)\n\nReturns the sixteen eight-bit integers the IPv6 address consists of.\n\n```\nuse std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n           [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).octets(),%0A+++++++++++++++%5B255,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0%5D);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#362)[§](#impl-Ipv6Addr-1)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#375)\n\n🔬This is a nightly-only experimental API. (`addr_parse_ascii` [#101035](https://github.com/rust-lang/rust/issues/101035))\n\nParse an IPv6 address from a slice of bytes.\n\n```\n#![feature(addr_parse_ascii)]\n\nuse std::net::Ipv6Addr;\n\nlet localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n\nassert_eq!(Ipv6Addr::parse_ascii(b\"::1\"), Ok(localhost));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(addr_parse_ascii)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+localhost+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1);%0A++++%0A++++assert_eq!(Ipv6Addr::parse_ascii(b%22::1%22),+Ok(localhost));%0A%7D&version=nightly&edition=2021)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitAnd%3C%26Ipv6Addr%3E-for-%26Ipv6Addr)\n\n[§](#associatedtype.Output-7)\n\nThe resulting type after applying the `&` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitand-3)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitAnd%3C%26Ipv6Addr%3E-for-Ipv6Addr)\n\n[§](#associatedtype.Output-6)\n\nThe resulting type after applying the `&` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitand-2)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitAnd%3CIpv6Addr%3E-for-%26Ipv6Addr)\n\n[§](#associatedtype.Output-5)\n\nThe resulting type after applying the `&` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitand-1)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitAnd-for-Ipv6Addr)\n\n[§](#associatedtype.Output-4)\n\nThe resulting type after applying the `&` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitand)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitAndAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitAndAssign-for-Ipv6Addr)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitOr%3C%26Ipv6Addr%3E-for-%26Ipv6Addr)\n\n[§](#associatedtype.Output-3)\n\nThe resulting type after applying the `|` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitor-3)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitOr%3C%26Ipv6Addr%3E-for-Ipv6Addr)\n\n[§](#associatedtype.Output)\n\nThe resulting type after applying the `|` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitor)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitOr%3CIpv6Addr%3E-for-%26Ipv6Addr)\n\n[§](#associatedtype.Output-2)\n\nThe resulting type after applying the `|` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitor-2)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitOr-for-Ipv6Addr)\n\n[§](#associatedtype.Output-1)\n\nThe resulting type after applying the `|` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#method.bitor-1)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitOrAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326)[§](#impl-BitOrAssign-for-Ipv6Addr)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#impl-Clone-for-Ipv6Addr)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1999)[§](#impl-Debug-for-Ipv6Addr)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1925)[§](#impl-Display-for-Ipv6Addr)\n\nWrite an Ipv6Addr, conforming to the canonical style described by [RFC 5952](https://tools.ietf.org/html/rfc5952).\n\n1.16.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2112)[§](#impl-From%3C%5Bu16;+8%5D%3E-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2135)[§](#method.from-3)\n\nCreates an `Ipv6Addr` from an eight element 16-bit array.\n\n##### [§](#examples-23)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::from([\n    525u16, 524u16, 523u16, 522u16,\n    521u16, 520u16, 519u16, 518u16,\n]);\nassert_eq!(\n    Ipv6Addr::new(\n        0x20d, 0x20c,\n        0x20b, 0x20a,\n        0x209, 0x208,\n        0x207, 0x206\n    ),\n    addr\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::from(%5B%0A++++++++525u16,+524u16,+523u16,+522u16,%0A++++++++521u16,+520u16,+519u16,+518u16,%0A++++%5D);%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x20d,+0x20c,%0A++++++++++++0x20b,+0x20a,%0A++++++++++++0x209,+0x208,%0A++++++++++++0x207,+0x206%0A++++++++),%0A++++++++addr%0A++++);%0A%7D&edition=2021)\n\n1.9.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2083)[§](#impl-From%3C%5Bu8;+16%5D%3E-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2106)[§](#method.from-4)\n\nCreates an `Ipv6Addr` from a sixteen element byte array.\n\n##### [§](#examples-24)Examples\n\n```\nuse std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::from([\n    25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n    17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n]);\nassert_eq!(\n    Ipv6Addr::new(\n        0x1918, 0x1716,\n        0x1514, 0x1312,\n        0x1110, 0x0f0e,\n        0x0d0c, 0x0b0a\n    ),\n    addr\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::from(%5B%0A++++++++25u8,+24u8,+23u8,+22u8,+21u8,+20u8,+19u8,+18u8,%0A++++++++17u8,+16u8,+15u8,+14u8,+13u8,+12u8,+11u8,+10u8,%0A++++%5D);%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x1918,+0x1716,%0A++++++++++++0x1514,+0x1312,%0A++++++++++++0x1110,+0x0f0e,%0A++++++++++++0x0d0c,+0x0b0a%0A++++++++),%0A++++++++addr%0A++++);%0A%7D&edition=2021)\n\n1.16.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1035)[§](#impl-From%3CIpv6Addr%3E-for-IpAddr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1051)[§](#method.from-2)\n\nCopies this address to a new `IpAddr::V6`.\n\n##### [§](#examples-22)Examples\n\n```\nuse std::net::{IpAddr, Ipv6Addr};\n\nlet addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n\nassert_eq!(\n    IpAddr::V6(addr),\n    IpAddr::from(addr)\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::%7BIpAddr,+Ipv6Addr%7D;%0A++++%0A++++let+addr+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff);%0A++++%0A++++assert_eq!(%0A++++++++IpAddr::V6(addr),%0A++++++++IpAddr::from(addr)%0A++++);%0A%7D&edition=2021)\n\n1.26.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2066)[§](#impl-From%3CIpv6Addr%3E-for-u128)\n\n1.26.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2074)[§](#impl-From%3Cu128%3E-for-Ipv6Addr)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#381)[§](#impl-FromStr-for-Ipv6Addr)\n\n[§](#associatedtype.Err)\n\nThe associated error which can be returned from parsing.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#383)[§](#method.from_str)\n\nParses a string `s` to return a value of this type. [Read more](about:blank/str/trait.FromStr.html#tymethod.from_str)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#impl-Hash-for-Ipv6Addr)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2236)[§](#impl-Not-for-%26Ipv6Addr)\n\n[§](#associatedtype.Output-9)\n\nThe resulting type after applying the `!` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2240)[§](#method.not-1)\n\nPerforms the unary `!` operation. [Read more](about:blank/ops/trait.Not.html#tymethod.not)\n\n1.75.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2223)[§](#impl-Not-for-Ipv6Addr)\n\n[§](#associatedtype.Output-8)\n\nThe resulting type after applying the `!` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2227)[§](#method.not)\n\nPerforms the unary `!` operation. [Read more](about:blank/ops/trait.Not.html#tymethod.not)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2058)[§](#impl-Ord-for-Ipv6Addr)\n\n1.16.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2006)[§](#impl-PartialEq%3CIpAddr%3E-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2008)[§](#method.eq-2)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263)[§](#method.ne-2)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.16.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2017)[§](#impl-PartialEq%3CIpv6Addr%3E-for-IpAddr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2019)[§](#method.eq)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263)[§](#method.ne)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#impl-PartialEq-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#method.eq-1)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263)[§](#method.ne-1)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.16.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2047)[§](#impl-PartialOrd%3CIpAddr%3E-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2049)[§](#method.partial_cmp-2)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180)[§](#method.lt-2)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198)[§](#method.le-2)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215)[§](#method.gt-2)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233)[§](#method.ge-2)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n1.16.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2036)[§](#impl-PartialOrd%3CIpv6Addr%3E-for-IpAddr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2038)[§](#method.partial_cmp)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180)[§](#method.lt)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198)[§](#method.le)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215)[§](#method.gt)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233)[§](#method.ge)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2028)[§](#impl-PartialOrd-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2030)[§](#method.partial_cmp-1)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180)[§](#method.lt-1)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198)[§](#method.le-1)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215)[§](#method.gt-1)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233)[§](#method.ge-1)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#588)[§](#impl-Step-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#590)[§](#method.steps_between)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the number of _successor_ steps required to get from `start` to `end`. [Read more](about:blank/iter/trait.Step.html#tymethod.steps_between)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#595)[§](#method.forward_checked)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the value that would be obtained by taking the _successor_ of `self` `count` times. [Read more](about:blank/iter/trait.Step.html#tymethod.forward_checked)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#600)[§](#method.backward_checked)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the value that would be obtained by taking the _predecessor_ of `self` `count` times. [Read more](about:blank/iter/trait.Step.html#tymethod.backward_checked)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#605)[§](#method.forward_unchecked)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the value that would be obtained by taking the _successor_ of `self` `count` times. [Read more](about:blank/iter/trait.Step.html#method.forward_unchecked)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#612)[§](#method.backward_unchecked)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the value that would be obtained by taking the _predecessor_ of `self` `count` times. [Read more](about:blank/iter/trait.Step.html#method.backward_unchecked)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#85)[§](#method.forward)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the value that would be obtained by taking the _successor_ of `self` `count` times. [Read more](about:blank/iter/trait.Step.html#method.forward)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#155)[§](#method.backward)\n\n🔬This is a nightly-only experimental API. (`step_trait` [#42168](https://github.com/rust-lang/rust/issues/42168))\n\nReturns the value that would be obtained by taking the _predecessor_ of `self` `count` times. [Read more](about:blank/iter/trait.Step.html#method.backward)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#impl-Copy-for-Ipv6Addr)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#impl-Eq-for-Ipv6Addr)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153)[§](#impl-StructuralPartialEq-for-Ipv6Addr)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#18)[§](#impl-TrustedStep-for-Ipv6Addr)\n\n[§](#impl-Freeze-for-Ipv6Addr)\n\n[§](#impl-RefUnwindSafe-for-Ipv6Addr)\n\n[§](#impl-Send-for-Ipv6Addr)\n\n[§](#impl-Sync-for-Ipv6Addr)\n\n[§](#impl-Unpin-for-Ipv6Addr)\n\n[§](#impl-UnwindSafe-for-Ipv6Addr)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"An IPv6 address.\"><title>Ipv6Addr in std::net - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Ipv6Addr</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Ipv6Addr</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Associated Constants</a></h3><ul class=\"block associatedconstant\"><li><a href=\"#associatedconstant.BITS\">BITS</a></li><li><a href=\"#associatedconstant.LOCALHOST\">LOCALHOST</a></li><li><a href=\"#associatedconstant.UNSPECIFIED\">UNSPECIFIED</a></li></ul><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.from_bits\">from_bits</a></li><li><a href=\"#method.is_benchmarking\">is_benchmarking</a></li><li><a href=\"#method.is_documentation\">is_documentation</a></li><li><a href=\"#method.is_global\">is_global</a></li><li><a href=\"#method.is_ipv4_mapped\">is_ipv4_mapped</a></li><li><a href=\"#method.is_loopback\">is_loopback</a></li><li><a href=\"#method.is_multicast\">is_multicast</a></li><li><a href=\"#method.is_unicast\">is_unicast</a></li><li><a href=\"#method.is_unicast_global\">is_unicast_global</a></li><li><a href=\"#method.is_unicast_link_local\">is_unicast_link_local</a></li><li><a href=\"#method.is_unique_local\">is_unique_local</a></li><li><a href=\"#method.is_unspecified\">is_unspecified</a></li><li><a href=\"#method.multicast_scope\">multicast_scope</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.octets\">octets</a></li><li><a href=\"#method.parse_ascii\">parse_ascii</a></li><li><a href=\"#method.segments\">segments</a></li><li><a href=\"#method.to_bits\">to_bits</a></li><li><a href=\"#method.to_canonical\">to_canonical</a></li><li><a href=\"#method.to_ipv4\">to_ipv4</a></li><li><a href=\"#method.to_ipv4_mapped\">to_ipv4_mapped</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-BitAnd-for-Ipv6Addr\">BitAnd</a></li><li><a href=\"#impl-BitAnd%3C%26Ipv6Addr%3E-for-%26Ipv6Addr\">BitAnd&lt;&amp;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitAnd%3C%26Ipv6Addr%3E-for-Ipv6Addr\">BitAnd&lt;&amp;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitAnd%3CIpv6Addr%3E-for-%26Ipv6Addr\">BitAnd&lt;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitAndAssign-for-Ipv6Addr\">BitAndAssign</a></li><li><a href=\"#impl-BitAndAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr\">BitAndAssign&lt;&amp;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitOr-for-Ipv6Addr\">BitOr</a></li><li><a href=\"#impl-BitOr%3C%26Ipv6Addr%3E-for-%26Ipv6Addr\">BitOr&lt;&amp;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitOr%3C%26Ipv6Addr%3E-for-Ipv6Addr\">BitOr&lt;&amp;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitOr%3CIpv6Addr%3E-for-%26Ipv6Addr\">BitOr&lt;Ipv6Addr&gt;</a></li><li><a href=\"#impl-BitOrAssign-for-Ipv6Addr\">BitOrAssign</a></li><li><a href=\"#impl-BitOrAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr\">BitOrAssign&lt;&amp;Ipv6Addr&gt;</a></li><li><a href=\"#impl-Clone-for-Ipv6Addr\">Clone</a></li><li><a href=\"#impl-Copy-for-Ipv6Addr\">Copy</a></li><li><a href=\"#impl-Debug-for-Ipv6Addr\">Debug</a></li><li><a href=\"#impl-Display-for-Ipv6Addr\">Display</a></li><li><a href=\"#impl-Eq-for-Ipv6Addr\">Eq</a></li><li><a href=\"#impl-From%3CIpv6Addr%3E-for-IpAddr\">From&lt;Ipv6Addr&gt;</a></li><li><a href=\"#impl-From%3CIpv6Addr%3E-for-u128\">From&lt;Ipv6Addr&gt;</a></li><li><a href=\"#impl-From%3C%5Bu16;+8%5D%3E-for-Ipv6Addr\">From&lt;[u16; 8]&gt;</a></li><li><a href=\"#impl-From%3C%5Bu8;+16%5D%3E-for-Ipv6Addr\">From&lt;[u8; 16]&gt;</a></li><li><a href=\"#impl-From%3Cu128%3E-for-Ipv6Addr\">From&lt;u128&gt;</a></li><li><a href=\"#impl-FromStr-for-Ipv6Addr\">FromStr</a></li><li><a href=\"#impl-Hash-for-Ipv6Addr\">Hash</a></li><li><a href=\"#impl-Not-for-%26Ipv6Addr\">Not</a></li><li><a href=\"#impl-Not-for-Ipv6Addr\">Not</a></li><li><a href=\"#impl-Ord-for-Ipv6Addr\">Ord</a></li><li><a href=\"#impl-PartialEq-for-Ipv6Addr\">PartialEq</a></li><li><a href=\"#impl-PartialEq%3CIpAddr%3E-for-Ipv6Addr\">PartialEq&lt;IpAddr&gt;</a></li><li><a href=\"#impl-PartialEq%3CIpv6Addr%3E-for-IpAddr\">PartialEq&lt;Ipv6Addr&gt;</a></li><li><a href=\"#impl-PartialOrd-for-Ipv6Addr\">PartialOrd</a></li><li><a href=\"#impl-PartialOrd%3CIpAddr%3E-for-Ipv6Addr\">PartialOrd&lt;IpAddr&gt;</a></li><li><a href=\"#impl-PartialOrd%3CIpv6Addr%3E-for-IpAddr\">PartialOrd&lt;Ipv6Addr&gt;</a></li><li><a href=\"#impl-Step-for-Ipv6Addr\">Step</a></li><li><a href=\"#impl-StructuralPartialEq-for-Ipv6Addr\">StructuralPartialEq</a></li><li><a href=\"#impl-TrustedStep-for-Ipv6Addr\">TrustedStep</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-Ipv6Addr\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-Ipv6Addr\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-Ipv6Addr\">Send</a></li><li><a href=\"#impl-Sync-for-Ipv6Addr\">Sync</a></li><li><a href=\"#impl-Unpin-for-Ipv6Addr\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-Ipv6Addr\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-ToString-for-T\">ToString</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::net</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AddrParseError.html\">AddrParseError</a></li><li><a href=\"struct.Incoming.html\">Incoming</a></li><li><a href=\"struct.IntoIncoming.html\">IntoIncoming</a></li><li><a href=\"struct.Ipv4Addr.html\">Ipv4Addr</a></li><li><a href=\"struct.Ipv6Addr.html\">Ipv6Addr</a></li><li><a href=\"struct.SocketAddrV4.html\">SocketAddrV4</a></li><li><a href=\"struct.SocketAddrV6.html\">SocketAddrV6</a></li><li><a href=\"struct.TcpListener.html\">TcpListener</a></li><li><a href=\"struct.TcpStream.html\">TcpStream</a></li><li><a href=\"struct.UdpSocket.html\">UdpSocket</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.IpAddr.html\">IpAddr</a></li><li><a href=\"enum.Ipv6MulticastScope.html\">Ipv6MulticastScope</a></li><li><a href=\"enum.Shutdown.html\">Shutdown</a></li><li><a href=\"enum.SocketAddr.html\">SocketAddr</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.ToSocketAddrs.html\">ToSocketAddrs</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">net</a>::<wbr><a class=\"struct\" href=\"#\">Ipv6Addr</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#155\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct Ipv6Addr { <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>An IPv6 address.</p>\n<p>IPv6 addresses are defined as 128-bit integers in <a href=\"https://tools.ietf.org/html/rfc4291\">IETF RFC 4291</a>.\nThey are usually represented as eight 16-bit segments.</p>\n<h2 id=\"embedding-ipv4-addresses\"><a class=\"doc-anchor\" href=\"#embedding-ipv4-addresses\">§</a>Embedding IPv4 Addresses</h2>\n<p>See <a href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\"><code>IpAddr</code></a> for a type encompassing both IPv4 and IPv6 addresses.</p>\n<p>To assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined:\nIPv4-compatible and IPv4-mapped addresses. Of these IPv4-compatible addresses have been officially deprecated.</p>\n<p>Both types of addresses are not assigned any special meaning by this implementation,\nother than what the relevant standards prescribe. This means that an address like <code>::ffff:127.0.0.1</code>,\nwhile representing an IPv4 loopback address, is not itself an IPv6 loopback address; only <code>::1</code> is.\nTo handle these so called “IPv4-in-IPv6” addresses, they have to first be converted to their canonical IPv4 address.</p>\n<h4 id=\"ipv4-compatible-ipv6-addresses\"><a class=\"doc-anchor\" href=\"#ipv4-compatible-ipv6-addresses\">§</a>IPv4-Compatible IPv6 Addresses</h4>\n<p>IPv4-compatible IPv6 addresses are defined in <a href=\"https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.1\">IETF RFC 4291 Section 2.5.5.1</a>, and have been officially deprecated.\nThe RFC describes the format of an “IPv4-Compatible IPv6 address” as follows:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>|                80 bits               | 16 |      32 bits        |\n+--------------------------------------+--------------------------+\n|0000..............................0000|0000|    IPv4 address     |\n+--------------------------------------+----+---------------------+\n</code></pre></div>\n<p>So <code>::a.b.c.d</code> would be an IPv4-compatible IPv6 address representing the IPv4 address <code>a.b.c.d</code>.</p>\n<p>To convert from an IPv4 address to an IPv4-compatible IPv6 address, use <a href=\"struct.Ipv4Addr.html#method.to_ipv6_compatible\" title=\"method std::net::Ipv4Addr::to_ipv6_compatible\"><code>Ipv4Addr::to_ipv6_compatible</code></a>.\nUse <a href=\"struct.Ipv6Addr.html#method.to_ipv4\" title=\"method std::net::Ipv6Addr::to_ipv4\"><code>Ipv6Addr::to_ipv4</code></a> to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.</p>\n<h4 id=\"ipv4-mapped-ipv6-addresses\"><a class=\"doc-anchor\" href=\"#ipv4-mapped-ipv6-addresses\">§</a>IPv4-Mapped IPv6 Addresses</h4>\n<p>IPv4-mapped IPv6 addresses are defined in <a href=\"https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\">IETF RFC 4291 Section 2.5.5.2</a>.\nThe RFC describes the format of an “IPv4-Mapped IPv6 address” as follows:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>|                80 bits               | 16 |      32 bits        |\n+--------------------------------------+--------------------------+\n|0000..............................0000|FFFF|    IPv4 address     |\n+--------------------------------------+----+---------------------+\n</code></pre></div>\n<p>So <code>::ffff:a.b.c.d</code> would be an IPv4-mapped IPv6 address representing the IPv4 address <code>a.b.c.d</code>.</p>\n<p>To convert from an IPv4 address to an IPv4-mapped IPv6 address, use <a href=\"struct.Ipv4Addr.html#method.to_ipv6_mapped\" title=\"method std::net::Ipv4Addr::to_ipv6_mapped\"><code>Ipv4Addr::to_ipv6_mapped</code></a>.\nUse <a href=\"struct.Ipv6Addr.html#method.to_ipv4\" title=\"method std::net::Ipv6Addr::to_ipv4\"><code>Ipv6Addr::to_ipv4</code></a> to convert an IPv4-mapped IPv6 address to the canonical IPv4 address.\nNote that this will also convert the IPv6 loopback address <code>::1</code> to <code>0.0.0.1</code>. Use\n<a href=\"struct.Ipv6Addr.html#method.to_ipv4_mapped\" title=\"method std::net::Ipv6Addr::to_ipv4_mapped\"><code>Ipv6Addr::to_ipv4_mapped</code></a> to avoid this.</p>\n<h2 id=\"textual-representation\"><a class=\"doc-anchor\" href=\"#textual-representation\">§</a>Textual representation</h2>\n<p><code>Ipv6Addr</code> provides a <a href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\"><code>FromStr</code></a> implementation. There are many ways to represent\nan IPv6 address in text, but in general, each segments is written in hexadecimal\nnotation, and segments are separated by <code>:</code>. For more information, see\n<a href=\"https://tools.ietf.org/html/rfc5952\">IETF RFC 5952</a>.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>localhost = Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"::1\"</span>.parse(), <span class=\"prelude-val\">Ok</span>(localhost));\n<span class=\"macro\">assert_eq!</span>(localhost.is_loopback(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+localhost+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1);%0A++++assert_eq!(%22::1%22.parse(),+Ok(localhost));%0A++++assert_eq!(localhost.is_loopback(),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ipv6Addr\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1198\">source</a><a href=\"#impl-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.32.0\">1.0.0 (const: 1.32.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1214\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.new\" class=\"fn\">new</a>(\n    a: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    b: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    c: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    d: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    e: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    f: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    g: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n    h: <a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>,\n) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\"><p>Creates a new IPv6 address from eight 16-bit segments.</p>\n<p>The result will represent the IP address <code>a:b:c:d:e:f:g:h</code>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.BITS\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1242\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.BITS\" class=\"constant\">BITS</a>: <a class=\"primitive\" href=\"../primitive.u32.html\">u32</a> = 128u32</h4></section></summary><div class=\"docblock\"><p>The size of an IPv6 address in bits.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::BITS, <span class=\"number\">128</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::BITS,+128);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_bits\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.80.0\">1.80.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1284\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.to_bits\" class=\"fn\">to_bits</a>(self) -&gt; <a class=\"primitive\" href=\"../primitive.u128.html\">u128</a></h4></section></summary><div class=\"docblock\"><p>Converts an IPv6 address into a <code>u128</code> representation using native byte order.</p>\n<p>Although IPv6 addresses are big-endian, the <code>u128</code> value will use the target platform’s\nnative byte order. That is, the <code>u128</code> value is an integer representation of the IPv6\naddress and not an integer interpretation of the IPv6 address’s big-endian bitstring. This\nmeans that the <code>u128</code> value masked with <code>0xffffffffffffffffffffffffffff0000_u128</code> will set\nthe last segment in the address to 0, regardless of the target platform’s endianness.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::new(\n    <span class=\"number\">0x1020</span>, <span class=\"number\">0x3040</span>, <span class=\"number\">0x5060</span>, <span class=\"number\">0x7080</span>,\n    <span class=\"number\">0x90A0</span>, <span class=\"number\">0xB0C0</span>, <span class=\"number\">0xD0E0</span>, <span class=\"number\">0xF00D</span>,\n);\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">0x102030405060708090A0B0C0D0E0F00D_u128</span>, u128::from(addr));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::new(%0A++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++0x90A0,+0xB0C0,+0xD0E0,+0xF00D,%0A++++);%0A++++assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128,+u128::from(addr));%0A%7D&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::new(\n    <span class=\"number\">0x1020</span>, <span class=\"number\">0x3040</span>, <span class=\"number\">0x5060</span>, <span class=\"number\">0x7080</span>,\n    <span class=\"number\">0x90A0</span>, <span class=\"number\">0xB0C0</span>, <span class=\"number\">0xD0E0</span>, <span class=\"number\">0xF00D</span>,\n);\n<span class=\"kw\">let </span>addr_bits = addr.to_bits() &amp; <span class=\"number\">0xffffffffffffffffffffffffffff0000_u128</span>;\n<span class=\"macro\">assert_eq!</span>(\n    Ipv6Addr::new(\n        <span class=\"number\">0x1020</span>, <span class=\"number\">0x3040</span>, <span class=\"number\">0x5060</span>, <span class=\"number\">0x7080</span>,\n        <span class=\"number\">0x90A0</span>, <span class=\"number\">0xB0C0</span>, <span class=\"number\">0xD0E0</span>, <span class=\"number\">0x0000</span>,\n    ),\n    Ipv6Addr::from_bits(addr_bits));\n</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::new(%0A++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++0x90A0,+0xB0C0,+0xD0E0,+0xF00D,%0A++++);%0A++++let+addr_bits+=+addr.to_bits()+%26+0xffffffffffffffffffffffffffff0000_u128;%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++++++0x90A0,+0xB0C0,+0xD0E0,+0x0000,%0A++++++++),%0A++++++++Ipv6Addr::from_bits(addr_bits));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_bits\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.80.0\">1.80.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1309\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.from_bits\" class=\"fn\">from_bits</a>(bits: <a class=\"primitive\" href=\"../primitive.u128.html\">u128</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\"><p>Converts a native byte order <code>u128</code> into an IPv6 address.</p>\n<p>See <a href=\"struct.Ipv6Addr.html#method.to_bits\" title=\"method std::net::Ipv6Addr::to_bits\"><code>Ipv6Addr::to_bits</code></a> for an explanation on endianness.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::from(<span class=\"number\">0x102030405060708090A0B0C0D0E0F00D_u128</span>);\n<span class=\"macro\">assert_eq!</span>(\n    Ipv6Addr::new(\n        <span class=\"number\">0x1020</span>, <span class=\"number\">0x3040</span>, <span class=\"number\">0x5060</span>, <span class=\"number\">0x7080</span>,\n        <span class=\"number\">0x90A0</span>, <span class=\"number\">0xB0C0</span>, <span class=\"number\">0xD0E0</span>, <span class=\"number\">0xF00D</span>,\n    ),\n    addr);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x1020,+0x3040,+0x5060,+0x7080,%0A++++++++++++0x90A0,+0xB0C0,+0xD0E0,+0xF00D,%0A++++++++),%0A++++++++addr);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.LOCALHOST\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1329\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.LOCALHOST\" class=\"constant\">LOCALHOST</a>: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a> = _</h4></section></summary><div class=\"docblock\"><p>An IPv6 address representing localhost: <code>::1</code>.</p>\n<p>This corresponds to constant <code>IN6ADDR_LOOPBACK_INIT</code> or <code>in6addr_loopback</code> in other\nlanguages.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::LOCALHOST;\n<span class=\"macro\">assert_eq!</span>(addr, Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::LOCALHOST;%0A++++assert_eq!(addr,+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.UNSPECIFIED\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1346\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.UNSPECIFIED\" class=\"constant\">UNSPECIFIED</a>: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a> = _</h4></section></summary><div class=\"docblock\"><p>An IPv6 address representing the unspecified address: <code>::</code></p>\n<p>This corresponds to constant <code>IN6ADDR_ANY_INIT</code> or <code>in6addr_any</code> in other languages.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::UNSPECIFIED;\n<span class=\"macro\">assert_eq!</span>(addr, Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::UNSPECIFIED;%0A++++assert_eq!(addr,+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+0));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.segments\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.50.0\">1.0.0 (const: 1.50.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1362\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.segments\" class=\"fn\">segments</a>(&amp;self) -&gt; [<a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>; <a class=\"primitive\" href=\"../primitive.array.html\">8</a>]</h4></section></summary><div class=\"docblock\"><p>Returns the eight 16-bit segments that make up this address.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).segments(),\n           [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).segments(),%0A+++++++++++++++%5B0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_unspecified\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0, const since 1.50.0\">1.7.0 (const: 1.50.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1397\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.is_unspecified\" class=\"fn\">is_unspecified</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> for the special ‘unspecified’ address (<code>::</code>).</p>\n<p>This property is defined in <a href=\"https://tools.ietf.org/html/rfc4291\">IETF RFC 4291</a>.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_unspecified(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unspecified(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_unspecified(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+0).is_unspecified(),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_loopback\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0, const since 1.50.0\">1.7.0 (const: 1.50.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1421\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.is_loopback\" class=\"fn\">is_loopback</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if this is the <a href=\"struct.Ipv6Addr.html#associatedconstant.LOCALHOST\" title=\"associated constant std::net::Ipv6Addr::LOCALHOST\">loopback address</a> (<code>::1</code>),\nas defined in <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.3\">IETF RFC 4291 section 2.5.3</a>.</p>\n<p>Contrary to IPv4, in IPv6 there is only one loopback address.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_loopback(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x1</span>).is_loopback(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_loopback(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+0x1).is_loopback(),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_global\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1493\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_global\" class=\"fn\">is_global</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if the address appears to be globally reachable\nas specified by the <a href=\"https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\">IANA IPv6 Special-Purpose Address Registry</a>.\nWhether or not an address is practically reachable will depend on your network configuration.</p>\n<p>Most IPv6 addresses are globally reachable;\nunless they are specifically defined as <em>not</em> globally reachable.</p>\n<p>Non-exhaustive list of notable addresses that are not globally reachable:</p>\n<ul>\n<li>The <a href=\"struct.Ipv6Addr.html#associatedconstant.UNSPECIFIED\" title=\"associated constant std::net::Ipv6Addr::UNSPECIFIED\">unspecified address</a> (<a href=\"struct.Ipv6Addr.html#method.is_unspecified\" title=\"method std::net::Ipv6Addr::is_unspecified\"><code>is_unspecified</code></a>)</li>\n<li>The <a href=\"struct.Ipv6Addr.html#associatedconstant.LOCALHOST\" title=\"associated constant std::net::Ipv6Addr::LOCALHOST\">loopback address</a> (<a href=\"struct.Ipv6Addr.html#method.is_loopback\" title=\"method std::net::Ipv6Addr::is_loopback\"><code>is_loopback</code></a>)</li>\n<li>IPv4-mapped addresses</li>\n<li>Addresses reserved for benchmarking (<a href=\"struct.Ipv6Addr.html#method.is_benchmarking\" title=\"method std::net::Ipv6Addr::is_benchmarking\"><code>is_benchmarking</code></a>)</li>\n<li>Addresses reserved for documentation (<a href=\"struct.Ipv6Addr.html#method.is_documentation\" title=\"method std::net::Ipv6Addr::is_documentation\"><code>is_documentation</code></a>)</li>\n<li>Unique local addresses (<a href=\"struct.Ipv6Addr.html#method.is_unique_local\" title=\"method std::net::Ipv6Addr::is_unique_local\"><code>is_unique_local</code></a>)</li>\n<li>Unicast addresses with link-local scope (<a href=\"struct.Ipv6Addr.html#method.is_unicast_link_local\" title=\"method std::net::Ipv6Addr::is_unicast_link_local\"><code>is_unicast_link_local</code></a>)</li>\n</ul>\n<p>For the complete overview of which addresses are globally reachable, see the table at the <a href=\"https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\">IANA IPv6 Special-Purpose Address Registry</a>.</p>\n<p>Note that an address having global scope is not the same as being globally reachable,\nand there is no direct relation between the two concepts: There exist addresses with global scope\nthat are not globally reachable (for example unique local addresses),\nand addresses that are globally reachable without having global scope\n(multicast addresses with non-global scope).</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"comment\">// Most IPv6 addresses are globally reachable:\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x26</span>, <span class=\"number\">0</span>, <span class=\"number\">0x1c9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xafc8</span>, <span class=\"number\">0x10</span>, <span class=\"number\">0x1</span>).is_global(), <span class=\"bool-val\">true</span>);\n\n<span class=\"comment\">// However some addresses have been assigned a special meaning\n// that makes them not globally reachable. Some examples are:\n\n// The unspecified address (`::`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::UNSPECIFIED.is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// The loopback address (`::1`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::LOCALHOST.is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// IPv4-mapped addresses (`::ffff:0:0/96`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// Addresses reserved for benchmarking (`2001:2::/48`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,).is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// Addresses reserved for documentation (`2001:db8::/32`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0xdb8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// Unique local addresses (`fc00::/7`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xfc02</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// Unicast addresses with link-local scope (`fe80::/10`)\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xfe81</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).is_global(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// For a complete overview see the IANA IPv6 Special-Purpose Address Registry.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++//+Most+IPv6+addresses+are+globally+reachable:%0A++++assert_eq!(Ipv6Addr::new(0x26,+0,+0x1c9,+0,+0,+0xafc8,+0x10,+0x1).is_global(),+true);%0A++++%0A++++//+However+some+addresses+have+been+assigned+a+special+meaning%0A++++//+that+makes+them+not+globally+reachable.+Some+examples+are:%0A++++%0A++++//+The+unspecified+address+(%60::%60)%0A++++assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(),+false);%0A++++%0A++++//+The+loopback+address+(%60::1%60)%0A++++assert_eq!(Ipv6Addr::LOCALHOST.is_global(),+false);%0A++++%0A++++//+IPv4-mapped+addresses+(%60::ffff:0:0/96%60)%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_global(),+false);%0A++++%0A++++//+Addresses+reserved+for+benchmarking+(%602001:2::/48%60)%0A++++assert_eq!(Ipv6Addr::new(0x2001,+2,+0,+0,+0,+0,+0,+1,).is_global(),+false);%0A++++%0A++++//+Addresses+reserved+for+documentation+(%602001:db8::/32%60)%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+1).is_global(),+false);%0A++++%0A++++//+Unique+local+addresses+(%60fc00::/7%60)%0A++++assert_eq!(Ipv6Addr::new(0xfc02,+0,+0,+0,+0,+0,+0,+1).is_global(),+false);%0A++++%0A++++//+Unicast+addresses+with+link-local+scope+(%60fe80::/10%60)%0A++++assert_eq!(Ipv6Addr::new(0xfe81,+0,+0,+0,+0,+0,+0,+1).is_global(),+false);%0A++++%0A++++//+For+a+complete+overview+see+the+IANA+IPv6+Special-Purpose+Address+Registry.%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_unique_local\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1545\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_unique_local\" class=\"fn\">is_unique_local</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if this is a unique local address (<code>fc00::/7</code>).</p>\n<p>This property is defined in <a href=\"https://tools.ietf.org/html/rfc4193\">IETF RFC 4193</a>.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_unique_local(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xfc02</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unique_local(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_unique_local(),+false);%0A++++assert_eq!(Ipv6Addr::new(0xfc02,+0,+0,+0,+0,+0,+0,+0).is_unique_local(),+true);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_unicast\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1574\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_unicast\" class=\"fn\">is_unicast</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if this is a unicast address, as defined by <a href=\"https://tools.ietf.org/html/rfc4291\">IETF RFC 4291</a>.\nAny address that is not a <a href=\"struct.Ipv6Addr.html#method.is_multicast\" title=\"method std::net::Ipv6Addr::is_multicast\">multicast address</a> (<code>ff00::/8</code>) is unicast.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"comment\">// The unspecified and loopback addresses are unicast.\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::UNSPECIFIED.is_unicast(), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::LOCALHOST.is_unicast(), <span class=\"bool-val\">true</span>);\n\n<span class=\"comment\">// Any address that is not a multicast address (`ff00::/8`) is unicast.\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0xdb8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast(), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xff00</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast(), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++//+The+unspecified+and+loopback+addresses+are+unicast.%0A++++assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(),+true);%0A++++assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(),+true);%0A++++%0A++++//+Any+address+that+is+not+a+multicast+address+(%60ff00::/8%60)+is+unicast.%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_unicast(),+true);%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).is_unicast(),+false);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_unicast_link_local\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1626\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_unicast_link_local\" class=\"fn\">is_unicast_link_local</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <code>true</code> if the address is a unicast address with link-local scope,\nas defined in <a href=\"https://tools.ietf.org/html/rfc4291\">RFC 4291</a>.</p>\n<p>A unicast address has link-local scope if it has the prefix <code>fe80::/10</code>, as per <a href=\"https://tools.ietf.org/html/rfc4291#section-2.4\">RFC 4291 section 2.4</a>.\nNote that this encompasses more addresses than those defined in <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.6\">RFC 4291 section 2.5.6</a>,\nwhich describes “Link-Local IPv6 Unicast Addresses” as having the following stricter format:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>| 10 bits  |         54 bits         |          64 bits           |\n+----------+-------------------------+----------------------------+\n|1111111010|           0             |       interface ID         |\n+----------+-------------------------+----------------------------+\n</code></pre></div>\n<p>So while currently the only addresses with link-local scope an application will encounter are all in <code>fe80::/64</code>,\nthis might change in the future with the publication of new standards. More addresses in <code>fe80::/10</code> could be allocated,\nand those addresses will have link-local scope.</p>\n<p>Also note that while <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.3\">RFC 4291 section 2.5.3</a> mentions about the <a href=\"struct.Ipv6Addr.html#associatedconstant.LOCALHOST\" title=\"associated constant std::net::Ipv6Addr::LOCALHOST\">loopback address</a> (<code>::1</code>) that “it is treated as having Link-Local scope”,\nthis does not mean that the loopback address actually has link-local scope and this method will return <code>false</code> on it.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"comment\">// The loopback address (`::1`) does not actually have link-local scope.\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::LOCALHOST.is_unicast_link_local(), <span class=\"bool-val\">false</span>);\n\n<span class=\"comment\">// Only addresses in `fe80::/10` have link-local scope.\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0xdb8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast_link_local(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xfe80</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast_link_local(), <span class=\"bool-val\">true</span>);\n\n<span class=\"comment\">// Addresses outside the stricter `fe80::/64` also have link-local scope.\n</span><span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xfe80</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast_link_local(), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xfe81</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast_link_local(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++//+The+loopback+address+(%60::1%60)+does+not+actually+have+link-local+scope.%0A++++assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(),+false);%0A++++%0A++++//+Only+addresses+in+%60fe80::/10%60+have+link-local+scope.%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_unicast_link_local(),+false);%0A++++assert_eq!(Ipv6Addr::new(0xfe80,+0,+0,+0,+0,+0,+0,+0).is_unicast_link_local(),+true);%0A++++%0A++++//+Addresses+outside+the+stricter+%60fe80::/64%60+also+have+link-local+scope.%0A++++assert_eq!(Ipv6Addr::new(0xfe80,+0,+0,+1,+0,+0,+0,+0).is_unicast_link_local(),+true);%0A++++assert_eq!(Ipv6Addr::new(0xfe81,+0,+0,+0,+0,+0,+0,+0).is_unicast_link_local(),+true);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_documentation\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1651\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_documentation\" class=\"fn\">is_documentation</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if this is an address reserved for documentation\n(<code>2001:db8::/32</code>).</p>\n<p>This property is defined in <a href=\"https://tools.ietf.org/html/rfc3849\">IETF RFC 3849</a>.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_documentation(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0xdb8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_documentation(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_documentation(),+false);%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_documentation(),+true);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_benchmarking\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1674\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_benchmarking\" class=\"fn\">is_benchmarking</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if this is an address reserved for benchmarking (<code>2001:2::/48</code>).</p>\n<p>This property is defined in <a href=\"https://tools.ietf.org/html/rfc5180\">IETF RFC 5180</a>, where it is mistakenly specified as covering the range <code>2001:0200::/48</code>.\nThis is corrected in <a href=\"https://www.rfc-editor.org/errata_search.php?eid=1752\">IETF RFC Errata 1752</a> to <code>2001:0002::/48</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc613</span>, <span class=\"number\">0x0</span>).is_benchmarking(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0x2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_benchmarking(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc613,+0x0).is_benchmarking(),+false);%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0x2,+0,+0,+0,+0,+0,+0).is_benchmarking(),+true);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_unicast_global\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1712\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_unicast_global\" class=\"fn\">is_unicast_global</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if the address is a globally routable unicast address.</p>\n<p>The following return false:</p>\n<ul>\n<li>the loopback address</li>\n<li>the link-local addresses</li>\n<li>unique local addresses</li>\n<li>the unspecified address</li>\n<li>the address range reserved for documentation</li>\n</ul>\n<p>This method returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> for site-local addresses as per <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.7\">RFC 4291 section 2.5.7</a></p>\n<div class=\"example-wrap\"><pre class=\"language-no_rust\"><code>The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\nbe supported in new implementations (i.e., new implementations must treat this prefix as\nGlobal Unicast).\n</code></pre></div><h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0xdb8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_unicast_global(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_unicast_global(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_unicast_global(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_unicast_global(),+true);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.multicast_scope\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1741\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.multicast_scope\" class=\"fn\">multicast_scope</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"enum.Ipv6MulticastScope.html\" title=\"enum std::net::Ipv6MulticastScope\">Ipv6MulticastScope</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the address’s multicast scope if the address is multicast.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::{Ipv6Addr, Ipv6MulticastScope};\n\n<span class=\"macro\">assert_eq!</span>(\n    Ipv6Addr::new(<span class=\"number\">0xff0e</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).multicast_scope(),\n    <span class=\"prelude-val\">Some</span>(Ipv6MulticastScope::Global)\n);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).multicast_scope(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::%7BIpv6Addr,+Ipv6MulticastScope%7D;%0A++++%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(0xff0e,+0,+0,+0,+0,+0,+0,+0).multicast_scope(),%0A++++++++Some(Ipv6MulticastScope::Global)%0A++++);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).multicast_scope(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_multicast\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0, const since 1.50.0\">1.7.0 (const: 1.50.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1776\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.is_multicast\" class=\"fn\">is_multicast</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if this is a multicast address (<code>ff00::/8</code>).</p>\n<p>This property is defined by <a href=\"https://tools.ietf.org/html/rfc4291\">IETF RFC 4291</a>.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xff00</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_multicast(), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).is_multicast(), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).is_multicast(),+true);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).is_multicast(),+false);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_ipv4_mapped\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1801\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.is_ipv4_mapped\" class=\"fn\">is_ipv4_mapped</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ip</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/27709\">#27709</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if the address is an IPv4-mapped address (<code>::ffff:0:0/96</code>).</p>\n<p>IPv4-mapped addresses can be converted to their canonical IPv4 address with\n<a href=\"struct.Ipv6Addr.html#method.to_ipv4_mapped\" title=\"method std::net::Ipv6Addr::to_ipv4_mapped\"><code>to_ipv4_mapped</code></a>.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(ip)]\n\n</span><span class=\"kw\">use </span>std::net::{Ipv4Addr, Ipv6Addr};\n\n<span class=\"kw\">let </span>ipv4_mapped = Ipv4Addr::new(<span class=\"number\">192</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">255</span>).to_ipv6_mapped();\n<span class=\"macro\">assert_eq!</span>(ipv4_mapped.is_ipv4_mapped(), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc000</span>, <span class=\"number\">0x2ff</span>).is_ipv4_mapped(), <span class=\"bool-val\">true</span>);\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0x2001</span>, <span class=\"number\">0xdb8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).is_ipv4_mapped(), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ip)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::%7BIpv4Addr,+Ipv6Addr%7D;%0A++++%0A++++let+ipv4_mapped+=+Ipv4Addr::new(192,+0,+2,+255).to_ipv6_mapped();%0A++++assert_eq!(ipv4_mapped.is_ipv4_mapped(),+true);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc000,+0x2ff).is_ipv4_mapped(),+true);%0A++++%0A++++assert_eq!(Ipv6Addr::new(0x2001,+0xdb8,+0,+0,+0,+0,+0,+0).is_ipv4_mapped(),+false);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_ipv4_mapped\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0, const since 1.75.0\">1.63.0 (const: 1.75.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1830\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.to_ipv4_mapped\" class=\"fn\">to_ipv4_mapped</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.Ipv4Addr.html\" title=\"struct std::net::Ipv4Addr\">Ipv4Addr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts this address to an <a href=\"struct.Ipv4Addr.html\" title=\"struct std::net::Ipv4Addr\"><code>IPv4</code> address</a> if it’s an <a href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">IPv4-mapped</a> address,\nas defined in <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.5.2\">IETF RFC 4291 section 2.5.5.2</a>, otherwise returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p><code>::ffff:a.b.c.d</code> becomes <code>a.b.c.d</code>.\nAll addresses <em>not</em> starting with <code>::ffff</code> will return <code>None</code>.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::{Ipv4Addr, Ipv6Addr};\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xff00</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).to_ipv4_mapped(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).to_ipv4_mapped(),\n           <span class=\"prelude-val\">Some</span>(Ipv4Addr::new(<span class=\"number\">192</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">255</span>)));\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).to_ipv4_mapped(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::%7BIpv4Addr,+Ipv6Addr%7D;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).to_ipv4_mapped(),+None);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).to_ipv4_mapped(),%0A+++++++++++++++Some(Ipv4Addr::new(192,+10,+2,+255)));%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1).to_ipv4_mapped(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_ipv4\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.50.0\">1.0.0 (const: 1.50.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1872\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.to_ipv4\" class=\"fn\">to_ipv4</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.Ipv4Addr.html\" title=\"struct std::net::Ipv4Addr\">Ipv4Addr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts this address to an <a href=\"struct.Ipv4Addr.html\" title=\"struct std::net::Ipv4Addr\"><code>IPv4</code> address</a> if it is either\nan <a href=\"struct.Ipv6Addr.html#ipv4-compatible-ipv6-addresses\" title=\"struct std::net::Ipv6Addr\">IPv4-compatible</a> address as defined in <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.5.1\">IETF RFC 4291 section 2.5.5.1</a>,\nor an <a href=\"struct.Ipv6Addr.html#ipv4-mapped-ipv6-addresses\" title=\"struct std::net::Ipv6Addr\">IPv4-mapped</a> address as defined in <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.5.2\">IETF RFC 4291 section 2.5.5.2</a>,\notherwise returns <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>.</p>\n<p>Note that this will return an <a href=\"struct.Ipv4Addr.html\" title=\"struct std::net::Ipv4Addr\"><code>IPv4</code> address</a> for the IPv6 loopback address <code>::1</code>. Use\n<a href=\"struct.Ipv6Addr.html#method.to_ipv4_mapped\" title=\"method std::net::Ipv6Addr::to_ipv4_mapped\"><code>Ipv6Addr::to_ipv4_mapped</code></a> to avoid this.</p>\n<p><code>::a.b.c.d</code> and <code>::ffff:a.b.c.d</code> become <code>a.b.c.d</code>. <code>::1</code> becomes <code>0.0.0.1</code>.\nAll addresses <em>not</em> starting with either all zeroes or <code>::ffff</code> will return <code>None</code>.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::{Ipv4Addr, Ipv6Addr};\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xff00</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).to_ipv4(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>).to_ipv4(),\n           <span class=\"prelude-val\">Some</span>(Ipv4Addr::new(<span class=\"number\">192</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">255</span>)));\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).to_ipv4(),\n           <span class=\"prelude-val\">Some</span>(Ipv4Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::%7BIpv4Addr,+Ipv6Addr%7D;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).to_ipv4(),+None);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff).to_ipv4(),%0A+++++++++++++++Some(Ipv4Addr::new(192,+10,+2,+255)));%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1).to_ipv4(),%0A+++++++++++++++Some(Ipv4Addr::new(0,+0,+0,+1)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_canonical\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0, const since 1.75.0\">1.75.0 (const: 1.75.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1898\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.to_canonical\" class=\"fn\">to_canonical</a>(&amp;self) -&gt; <a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a></h4></section></summary><div class=\"docblock\"><p>Converts this address to an <code>IpAddr::V4</code> if it is an IPv4-mapped addresses, otherwise it\nreturns self wrapped in an <code>IpAddr::V6</code>.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0x7f00</span>, <span class=\"number\">0x1</span>).is_loopback(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0x7f00</span>, <span class=\"number\">0x1</span>).to_canonical().is_loopback(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0x7f00,+0x1).is_loopback(),+false);%0A++++assert_eq!(Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0x7f00,+0x1).to_canonical().is_loopback(),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.octets\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0, const since 1.32.0\">1.12.0 (const: 1.32.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1917\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.octets\" class=\"fn\">octets</a>(&amp;self) -&gt; [<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"../primitive.array.html\">16</a>]</h4></section></summary><div class=\"docblock\"><p>Returns the sixteen eight-bit integers the IPv6 address consists of.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::new(<span class=\"number\">0xff00</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>).octets(),\n           [<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++assert_eq!(Ipv6Addr::new(0xff00,+0,+0,+0,+0,+0,+0,+0).octets(),%0A+++++++++++++++%5B255,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0,+0%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ipv6Addr-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#362\">source</a><a href=\"#impl-Ipv6Addr-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.parse_ascii\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#375\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.parse_ascii\" class=\"fn\">parse_ascii</a>(b: &amp;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, <a class=\"struct\" href=\"struct.AddrParseError.html\" title=\"struct std::net::AddrParseError\">AddrParseError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>addr_parse_ascii</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/101035\">#101035</a>)</span></div></span></summary><div class=\"docblock\"><p>Parse an IPv6 address from a slice of bytes.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(addr_parse_ascii)]\n\n</span><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>localhost = Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);\n\n<span class=\"macro\">assert_eq!</span>(Ipv6Addr::parse_ascii(<span class=\"string\">b\"::1\"</span>), <span class=\"prelude-val\">Ok</span>(localhost));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(addr_parse_ascii)%5D%0A%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+localhost+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0,+0,+1);%0A++++%0A++++assert_eq!(Ipv6Addr::parse_ascii(b%22::1%22),+Ok(localhost));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitAnd%3C%26Ipv6Addr%3E-for-%26Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitAnd%3C%26Ipv6Addr%3E-for-%26Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitAnd.html\" title=\"trait std::ops::BitAnd\">BitAnd</a>&lt;&amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-7\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-7\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitAnd.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>&amp;</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitand-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitand-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\" class=\"fn\">bitand</a>(self, rhs: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>&amp;</code> operation. <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitAnd%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitAnd%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitAnd.html\" title=\"trait std::ops::BitAnd\">BitAnd</a>&lt;&amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-6\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-6\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitAnd.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>&amp;</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitand-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitand-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\" class=\"fn\">bitand</a>(self, rhs: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>&amp;</code> operation. <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitAnd%3CIpv6Addr%3E-for-%26Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitAnd%3CIpv6Addr%3E-for-%26Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitAnd.html\" title=\"trait std::ops::BitAnd\">BitAnd</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-5\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-5\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitAnd.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>&amp;</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitand-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitand-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\" class=\"fn\">bitand</a>(self, rhs: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>&amp;</code> operation. <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitAnd-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitAnd-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitAnd.html\" title=\"trait std::ops::BitAnd\">BitAnd</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-4\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-4\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitAnd.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>&amp;</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitand\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitand\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\" class=\"fn\">bitand</a>(self, rhs: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>&amp;</code> operation. <a href=\"../ops/trait.BitAnd.html#tymethod.bitand\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitAndAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitAndAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitAndAssign.html\" title=\"trait std::ops::BitAndAssign\">BitAndAssign</a>&lt;&amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitand_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitand_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitAndAssign.html#tymethod.bitand_assign\" class=\"fn\">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>&amp;=</code> operation. <a href=\"../ops/trait.BitAndAssign.html#tymethod.bitand_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitAndAssign-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitAndAssign-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitAndAssign.html\" title=\"trait std::ops::BitAndAssign\">BitAndAssign</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitand_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitand_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitAndAssign.html#tymethod.bitand_assign\" class=\"fn\">bitand_assign</a>(&amp;mut self, rhs: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>&amp;=</code> operation. <a href=\"../ops/trait.BitAndAssign.html#tymethod.bitand_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitOr%3C%26Ipv6Addr%3E-for-%26Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitOr%3C%26Ipv6Addr%3E-for-%26Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitOr.html\" title=\"trait std::ops::BitOr\">BitOr</a>&lt;&amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-3\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-3\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitOr.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>|</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitor-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitor-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitOr.html#tymethod.bitor\" class=\"fn\">bitor</a>(self, rhs: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>|</code> operation. <a href=\"../ops/trait.BitOr.html#tymethod.bitor\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitOr%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitOr%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitOr.html\" title=\"trait std::ops::BitOr\">BitOr</a>&lt;&amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitOr.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>|</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitor\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitor\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitOr.html#tymethod.bitor\" class=\"fn\">bitor</a>(self, rhs: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>|</code> operation. <a href=\"../ops/trait.BitOr.html#tymethod.bitor\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitOr%3CIpv6Addr%3E-for-%26Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitOr%3CIpv6Addr%3E-for-%26Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitOr.html\" title=\"trait std::ops::BitOr\">BitOr</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-2\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitOr.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>|</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitor-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitor-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitOr.html#tymethod.bitor\" class=\"fn\">bitor</a>(self, rhs: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>|</code> operation. <a href=\"../ops/trait.BitOr.html#tymethod.bitor\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitOr-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitOr-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitOr.html\" title=\"trait std::ops::BitOr\">BitOr</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.BitOr.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>|</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitor-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitor-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitOr.html#tymethod.bitor\" class=\"fn\">bitor</a>(self, rhs: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the <code>|</code> operation. <a href=\"../ops/trait.BitOr.html#tymethod.bitor\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitOrAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitOrAssign%3C%26Ipv6Addr%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitOrAssign.html\" title=\"trait std::ops::BitOrAssign\">BitOrAssign</a>&lt;&amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitor_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitor_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitOrAssign.html#tymethod.bitor_assign\" class=\"fn\">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>|=</code> operation. <a href=\"../ops/trait.BitOrAssign.html#tymethod.bitor_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BitOrAssign-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a></span><a href=\"#impl-BitOrAssign-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.BitOrAssign.html\" title=\"trait std::ops::BitOrAssign\">BitOrAssign</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bitor_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2316-2326\">source</a><a href=\"#method.bitor_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.BitOrAssign.html#tymethod.bitor_assign\" class=\"fn\">bitor_assign</a>(&amp;mut self, rhs: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>|=</code> operation. <a href=\"../ops/trait.BitOrAssign.html#tymethod.bitor_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a></span><a href=\"#impl-Clone-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Returns a copy of the value. <a href=\"../clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class=\"docblock\">Performs copy-assignment from <code>source</code>. <a href=\"../clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1999\">source</a></span><a href=\"#impl-Debug-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2000\">source</a><a href=\"#method.fmt-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Display-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1925\">source</a></span><a href=\"#impl-Display-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"docblock\"><p>Write an Ipv6Addr, conforming to the canonical style described by\n<a href=\"https://tools.ietf.org/html/rfc5952\">RFC 5952</a>.</p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1926\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Display.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Display.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%5Bu16;+8%5D%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2112\">source</a></span><a href=\"#impl-From%3C%5Bu16;+8%5D%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;[<a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>; <a class=\"primitive\" href=\"../primitive.array.html\">8</a>]&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2135\">source</a><a href=\"#method.from-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(segments: [<a class=\"primitive\" href=\"../primitive.u16.html\">u16</a>; <a class=\"primitive\" href=\"../primitive.array.html\">8</a>]) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\"><p>Creates an <code>Ipv6Addr</code> from an eight element 16-bit array.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::from([\n    <span class=\"number\">525u16</span>, <span class=\"number\">524u16</span>, <span class=\"number\">523u16</span>, <span class=\"number\">522u16</span>,\n    <span class=\"number\">521u16</span>, <span class=\"number\">520u16</span>, <span class=\"number\">519u16</span>, <span class=\"number\">518u16</span>,\n]);\n<span class=\"macro\">assert_eq!</span>(\n    Ipv6Addr::new(\n        <span class=\"number\">0x20d</span>, <span class=\"number\">0x20c</span>,\n        <span class=\"number\">0x20b</span>, <span class=\"number\">0x20a</span>,\n        <span class=\"number\">0x209</span>, <span class=\"number\">0x208</span>,\n        <span class=\"number\">0x207</span>, <span class=\"number\">0x206\n    </span>),\n    addr\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::from(%5B%0A++++++++525u16,+524u16,+523u16,+522u16,%0A++++++++521u16,+520u16,+519u16,+518u16,%0A++++%5D);%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x20d,+0x20c,%0A++++++++++++0x20b,+0x20a,%0A++++++++++++0x209,+0x208,%0A++++++++++++0x207,+0x206%0A++++++++),%0A++++++++addr%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%5Bu8;+16%5D%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2083\">source</a></span><a href=\"#impl-From%3C%5Bu8;+16%5D%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"../primitive.array.html\">16</a>]&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2106\">source</a><a href=\"#method.from-4\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(octets: [<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"../primitive.array.html\">16</a>]) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\"><p>Creates an <code>Ipv6Addr</code> from a sixteen element byte array.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::Ipv6Addr;\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::from([\n    <span class=\"number\">25u8</span>, <span class=\"number\">24u8</span>, <span class=\"number\">23u8</span>, <span class=\"number\">22u8</span>, <span class=\"number\">21u8</span>, <span class=\"number\">20u8</span>, <span class=\"number\">19u8</span>, <span class=\"number\">18u8</span>,\n    <span class=\"number\">17u8</span>, <span class=\"number\">16u8</span>, <span class=\"number\">15u8</span>, <span class=\"number\">14u8</span>, <span class=\"number\">13u8</span>, <span class=\"number\">12u8</span>, <span class=\"number\">11u8</span>, <span class=\"number\">10u8</span>,\n]);\n<span class=\"macro\">assert_eq!</span>(\n    Ipv6Addr::new(\n        <span class=\"number\">0x1918</span>, <span class=\"number\">0x1716</span>,\n        <span class=\"number\">0x1514</span>, <span class=\"number\">0x1312</span>,\n        <span class=\"number\">0x1110</span>, <span class=\"number\">0x0f0e</span>,\n        <span class=\"number\">0x0d0c</span>, <span class=\"number\">0x0b0a\n    </span>),\n    addr\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::Ipv6Addr;%0A++++%0A++++let+addr+=+Ipv6Addr::from(%5B%0A++++++++25u8,+24u8,+23u8,+22u8,+21u8,+20u8,+19u8,+18u8,%0A++++++++17u8,+16u8,+15u8,+14u8,+13u8,+12u8,+11u8,+10u8,%0A++++%5D);%0A++++assert_eq!(%0A++++++++Ipv6Addr::new(%0A++++++++++++0x1918,+0x1716,%0A++++++++++++0x1514,+0x1312,%0A++++++++++++0x1110,+0x0f0e,%0A++++++++++++0x0d0c,+0x0b0a%0A++++++++),%0A++++++++addr%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CIpv6Addr%3E-for-IpAddr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1035\">source</a></span><a href=\"#impl-From%3CIpv6Addr%3E-for-IpAddr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#1051\">source</a><a href=\"#method.from-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(ipv6: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a></h4></section></summary><div class=\"docblock\"><p>Copies this address to a new <code>IpAddr::V6</code>.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::{IpAddr, Ipv6Addr};\n\n<span class=\"kw\">let </span>addr = Ipv6Addr::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xffff</span>, <span class=\"number\">0xc00a</span>, <span class=\"number\">0x2ff</span>);\n\n<span class=\"macro\">assert_eq!</span>(\n    IpAddr::V6(addr),\n    IpAddr::from(addr)\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::net::%7BIpAddr,+Ipv6Addr%7D;%0A++++%0A++++let+addr+=+Ipv6Addr::new(0,+0,+0,+0,+0,+0xffff,+0xc00a,+0x2ff);%0A++++%0A++++assert_eq!(%0A++++++++IpAddr::V6(addr),%0A++++++++IpAddr::from(addr)%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CIpv6Addr%3E-for-u128\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2066\">source</a></span><a href=\"#impl-From%3CIpv6Addr%3E-for-u128\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"primitive\" href=\"../primitive.u128.html\">u128</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2069\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(ip: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"primitive\" href=\"../primitive.u128.html\">u128</a></h4></section></summary><div class=\"docblock\"><p>Uses <a href=\"struct.Ipv6Addr.html#method.to_bits\" title=\"method std::net::Ipv6Addr::to_bits\"><code>Ipv6Addr::to_bits</code></a> to convert an IPv6 address to a host byte order <code>u128</code>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cu128%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2074\">source</a></span><a href=\"#impl-From%3Cu128%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.u128.html\">u128</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2077\">source</a><a href=\"#method.from-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(ip: <a class=\"primitive\" href=\"../primitive.u128.html\">u128</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\"><p>Uses <a href=\"struct.Ipv6Addr.html#method.from_bits\" title=\"associated function std::net::Ipv6Addr::from_bits\"><code>Ipv6Addr::from_bits</code></a> to convert a host byte order <code>u128</code> to an IPv6 address.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromStr-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#381\">source</a></span><a href=\"#impl-FromStr-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../str/trait.FromStr.html\" title=\"trait std::str::FromStr\">FromStr</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Err\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Err\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../str/trait.FromStr.html#associatedtype.Err\" class=\"associatedtype\">Err</a> = <a class=\"struct\" href=\"struct.AddrParseError.html\" title=\"struct std::net::AddrParseError\">AddrParseError</a></h4></section></summary><div class=\"docblock\">The associated error which can be returned from parsing.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_str\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/parser.rs.html#383\">source</a><a href=\"#method.from_str\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../str/trait.FromStr.html#tymethod.from_str\" class=\"fn\">from_str</a>(s: &amp;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, <a class=\"struct\" href=\"struct.AddrParseError.html\" title=\"struct std::net::AddrParseError\">AddrParseError</a>&gt;</h4></section></summary><div class=\"docblock\">Parses a string <code>s</code> to return a value of this type. <a href=\"../str/trait.FromStr.html#tymethod.from_str\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Hash-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a></span><a href=\"#impl-Hash-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a><a href=\"#method.hash\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;__H&gt;(&amp;self, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut __H</a>)<div class=\"where\">where\n    __H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class=\"docblock\">Feeds this value into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240\">source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;<a class=\"primitive\" href=\"../primitive.slice.html\">[Self]</a>, state: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Feeds a slice of this type into the given <a href=\"../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Not-for-%26Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2236\">source</a></span><a href=\"#impl-Not-for-%26Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.Not.html\" title=\"trait std::ops::Not\">Not</a> for &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-9\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-9\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Not.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>!</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.not-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2240\">source</a><a href=\"#method.not-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Not.html#tymethod.not\" class=\"fn\">not</a>(self) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the unary <code>!</code> operation. <a href=\"../ops/trait.Not.html#tymethod.not\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Not-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.75.0\">1.75.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2223\">source</a></span><a href=\"#impl-Not-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../ops/trait.Not.html\" title=\"trait std::ops::Not\">Not</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-8\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-8\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../ops/trait.Not.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>!</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.not\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2227\">source</a><a href=\"#method.not\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../ops/trait.Not.html#tymethod.not\" class=\"fn\">not</a>(self) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><div class=\"docblock\">Performs the unary <code>!</code> operation. <a href=\"../ops/trait.Not.html#tymethod.not\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ord-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2058\">source</a></span><a href=\"#impl-Ord-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2060\">source</a><a href=\"#method.cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\">This method returns an <a href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href=\"../cmp/trait.Ord.html#tymethod.cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858\">source</a></span><a href=\"#method.max\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.max\" class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the maximum of two values. <a href=\"../cmp/trait.Ord.html#method.max\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879\">source</a></span><a href=\"#method.min\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.min\" class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the minimum of two values. <a href=\"../cmp/trait.Ord.html#method.min\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906\">source</a></span><a href=\"#method.clamp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.Ord.html#method.clamp\" class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\">Restrict a value to a certain interval. <a href=\"../cmp/trait.Ord.html#method.clamp\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3CIpAddr%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2006\">source</a></span><a href=\"#impl-PartialEq%3CIpAddr%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2008\">source</a><a href=\"#method.eq-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-2\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263\">source</a></span><a href=\"#method.ne-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq%3CIpv6Addr%3E-for-IpAddr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2017\">source</a></span><a href=\"#impl-PartialEq%3CIpv6Addr%3E-for-IpAddr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2019\">source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263\">source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a></span><a href=\"#impl-PartialEq-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a><a href=\"#method.eq-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne-1\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263\">source</a></span><a href=\"#method.ne-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd%3CIpAddr%3E-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2047\">source</a></span><a href=\"#impl-PartialOrd%3CIpAddr%3E-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;<a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a>&gt; for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2049\">source</a><a href=\"#method.partial_cmp-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt-2\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180\">source</a></span><a href=\"#method.lt-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le-2\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198\">source</a></span><a href=\"#method.le-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt-2\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215\">source</a></span><a href=\"#method.gt-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge-2\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233\">source</a></span><a href=\"#method.ge-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd%3CIpv6Addr%3E-for-IpAddr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2036\">source</a></span><a href=\"#impl-PartialOrd%3CIpv6Addr%3E-for-IpAddr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt; for <a class=\"enum\" href=\"enum.IpAddr.html\" title=\"enum std::net::IpAddr\">IpAddr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2038\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180\">source</a></span><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198\">source</a></span><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215\">source</a></span><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233\">source</a></span><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2028\">source</a></span><a href=\"#impl-PartialOrd-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#2030\">source</a><a href=\"#method.partial_cmp-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"../cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt-1\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180\">source</a></span><a href=\"#method.lt-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le-1\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198\">source</a></span><a href=\"#method.le-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt-1\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215\">source</a></span><a href=\"#method.gt-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"../cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge-1\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233\">source</a></span><a href=\"#method.ge-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"../cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Step-for-Ipv6Addr\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#588\">source</a><a href=\"#impl-Step-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.steps_between\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#590\">source</a><a href=\"#method.steps_between\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Step.html#tymethod.steps_between\" class=\"fn\">steps_between</a>(_: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, _: &amp;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the number of <em>successor</em> steps required to get from <code>start</code> to <code>end</code>. <a href=\"../iter/trait.Step.html#tymethod.steps_between\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.forward_checked\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#595\">source</a><a href=\"#method.forward_checked\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Step.html#tymethod.forward_checked\" class=\"fn\">forward_checked</a>(start: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the value that would be obtained by taking the <em>successor</em>\nof <code>self</code> <code>count</code> times. <a href=\"../iter/trait.Step.html#tymethod.forward_checked\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.backward_checked\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#600\">source</a><a href=\"#method.backward_checked\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Step.html#tymethod.backward_checked\" class=\"fn\">backward_checked</a>(start: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the value that would be obtained by taking the <em>predecessor</em>\nof <code>self</code> <code>count</code> times. <a href=\"../iter/trait.Step.html#tymethod.backward_checked\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.forward_unchecked\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#605\">source</a><a href=\"#method.forward_unchecked\" class=\"anchor\">§</a><h4 class=\"code-header\">unsafe fn <a href=\"../iter/trait.Step.html#method.forward_unchecked\" class=\"fn\">forward_unchecked</a>(start: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the value that would be obtained by taking the <em>successor</em>\nof <code>self</code> <code>count</code> times. <a href=\"../iter/trait.Step.html#method.forward_unchecked\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.backward_unchecked\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#612\">source</a><a href=\"#method.backward_unchecked\" class=\"anchor\">§</a><h4 class=\"code-header\">unsafe fn <a href=\"../iter/trait.Step.html#method.backward_unchecked\" class=\"fn\">backward_unchecked</a>(start: <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a>, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the value that would be obtained by taking the <em>predecessor</em>\nof <code>self</code> <code>count</code> times. <a href=\"../iter/trait.Step.html#method.backward_unchecked\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.forward\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#85\">source</a><a href=\"#method.forward\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Step.html#method.forward\" class=\"fn\">forward</a>(start: Self, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; Self</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the value that would be obtained by taking the <em>successor</em>\nof <code>self</code> <code>count</code> times. <a href=\"../iter/trait.Step.html#method.forward\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.backward\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#155\">source</a><a href=\"#method.backward\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../iter/trait.Step.html#method.backward\" class=\"fn\">backward</a>(start: Self, count: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>) -&gt; Self</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>step_trait</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/42168\">#42168</a>)</span></div></span><div class=\"docblock\">Returns the value that would be obtained by taking the <em>predecessor</em>\nof <code>self</code> <code>count</code> times. <a href=\"../iter/trait.Step.html#method.backward\">Read more</a></div></details></div></details><section id=\"impl-Copy-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a></span><a href=\"#impl-Copy-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-Eq-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a></span><a href=\"#impl-Eq-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-StructuralPartialEq-for-Ipv6Addr\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/net/ip_addr.rs.html#153\">source</a></span><a href=\"#impl-StructuralPartialEq-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.StructuralPartialEq.html\" title=\"trait std::marker::StructuralPartialEq\">StructuralPartialEq</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-TrustedStep-for-Ipv6Addr\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/range.rs.html#18\">source</a><a href=\"#impl-TrustedStep-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../iter/trait.TrustedStep.html\" title=\"trait std::iter::TrustedStep\">TrustedStep</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-Ipv6Addr\" class=\"impl\"><a href=\"#impl-Freeze-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-RefUnwindSafe-for-Ipv6Addr\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-Send-for-Ipv6Addr\" class=\"impl\"><a href=\"#impl-Send-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-Sync-for-Ipv6Addr\" class=\"impl\"><a href=\"#impl-Sync-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-Unpin-for-Ipv6Addr\" class=\"impl\"><a href=\"#impl-Unpin-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section><section id=\"impl-UnwindSafe-for-Ipv6Addr\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-Ipv6Addr\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.Ipv6Addr.html\" title=\"struct std::net::Ipv6Addr\">Ipv6Addr</a></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-5\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToString-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2552\">source</a><a href=\"#impl-ToString-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../string/trait.ToString.html\" title=\"trait std::string::ToString\">ToString</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_string\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2558\">source</a><a href=\"#method.to_string\" class=\"anchor\">§</a><h4 class=\"code-header\">default fn <a href=\"../string/trait.ToString.html#tymethod.to_string\" class=\"fn\">to_string</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Converts the given value to a <code>String</code>. <a href=\"../string/trait.ToString.html#tymethod.to_string\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:14:01.217Z"
}