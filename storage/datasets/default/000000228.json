{
	"title": "f32 - Rust",
	"url": "https://doc.rust-lang.org/stable/std/primitive.f32.html",
	"markdown": "# f32 - Rust\n\n## Primitive Type [f32](#)\n\n1.0.0 ·\n\nExpand description\n\nA 32-bit floating point type (specifically, the “binary32” type defined in IEEE 754-2008).\n\nThis type can represent a wide range of decimal numbers, like `3.5`, `27`, `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types (such as `i32`), floating point types can represent non-integer numbers, too.\n\nHowever, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results in `0.20000000298023223876953125` since `0.2` cannot be exactly represented as `f32`. Note, however, that printing floats with `println` and friends will often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will print `0.2`.\n\nAdditionally, `f32` can represent some special values:\n\n-   −0.0: IEEE 754 floating point numbers have a bit that indicates their sign, so −0.0 is a possible value. For comparison −0.0 = +0.0, but floating point operations can carry the sign bit through arithmetic operations. This means −0.0 × +0.0 produces −0.0 and a negative number rounded to a value smaller than a float can represent also produces −0.0.\n-   [∞](#associatedconstant.INFINITY) and [−∞](#associatedconstant.NEG_INFINITY): these result from calculations like `1.0 / 0.0`.\n-   [NaN (not a number)](#associatedconstant.NAN): this value results from calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected behavior:\n    -   It is not equal to any float, including itself! This is the reason `f32` doesn’t implement the `Eq` trait.\n    -   It is also neither smaller nor greater than any float, making it impossible to sort by the default comparison operation, which is the reason `f32` doesn’t implement the `Ord` trait.\n    -   It is also considered _infectious_ as almost all calculations where one of the operands is NaN will also result in NaN. The explanations on this page only explicitly document behavior on NaN operands if this default is deviated from.\n    -   Lastly, there are multiple bit patterns that are considered NaN. Rust does not currently guarantee that the bit patterns of NaN are preserved over arithmetic operations, and they are not guaranteed to be portable or even fully deterministic! This means that there may be some surprising results upon inspecting the bit patterns, as the same calculations might produce NaNs with different bit patterns.\n\nWhen a primitive operation (addition, subtraction, multiplication, or division) is performed on this type, the result is rounded according to the roundTiesToEven direction defined in IEEE 754-2008. That means:\n\n-   The result is the representable value closest to the true value, if there is a unique closest representable value.\n-   If the true value is exactly half-way between two representable values, the result is the one with an even least-significant binary digit.\n-   If the true value’s magnitude is ≥ `f32::MAX` + 2(`f32::MAX_EXP` − `f32::MANTISSA_DIGITS` − 1), the result is ∞ or −∞ (preserving the true value’s sign).\n-   If the result of a sum exactly equals zero, the outcome is +0.0 unless both arguments were negative, then it is -0.0. Subtraction `a - b` is regarded as a sum `a + (-b)`.\n\nFor more information on floating point numbers, see [Wikipedia](https://en.wikipedia.org/wiki/Single-precision_floating-point_format).\n\n_[See also the `std::f32::consts` module](f32/consts/index.html \"mod std::f32::consts\")._\n\n[source](about:blank/src/std/f32.rs.html#31-1228)[§](#impl-f32)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#51-53)\n\nReturns the largest integer less than or equal to `self`.\n\nThis function always returns the precise result.\n\n##### [§](#examples)Examples\n\n```\nlet f = 3.7_f32;\nlet g = 3.0_f32;\nlet h = -3.7_f32;\n\nassert_eq!(f.floor(), 3.0);\nassert_eq!(g.floor(), 3.0);\nassert_eq!(h.floor(), -4.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.7_f32;%0A++++let+g+=+3.0_f32;%0A++++let+h+=+-3.7_f32;%0A++++%0A++++assert_eq!(f.floor(),+3.0);%0A++++assert_eq!(g.floor(),+3.0);%0A++++assert_eq!(h.floor(),+-4.0);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#73-75)\n\nReturns the smallest integer greater than or equal to `self`.\n\nThis function always returns the precise result.\n\n##### [§](#examples-1)Examples\n\n```\nlet f = 3.01_f32;\nlet g = 4.0_f32;\n\nassert_eq!(f.ceil(), 4.0);\nassert_eq!(g.ceil(), 4.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.01_f32;%0A++++let+g+=+4.0_f32;%0A++++%0A++++assert_eq!(f.ceil(),+4.0);%0A++++assert_eq!(g.ceil(),+4.0);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#101-103)\n\nReturns the nearest integer to `self`. If a value is half-way between two integers, round away from `0.0`.\n\nThis function always returns the precise result.\n\n##### [§](#examples-2)Examples\n\n```\nlet f = 3.3_f32;\nlet g = -3.3_f32;\nlet h = -3.7_f32;\nlet i = 3.5_f32;\nlet j = 4.5_f32;\n\nassert_eq!(f.round(), 3.0);\nassert_eq!(g.round(), -3.0);\nassert_eq!(h.round(), -4.0);\nassert_eq!(i.round(), 4.0);\nassert_eq!(j.round(), 5.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.3_f32;%0A++++let+g+=+-3.3_f32;%0A++++let+h+=+-3.7_f32;%0A++++let+i+=+3.5_f32;%0A++++let+j+=+4.5_f32;%0A++++%0A++++assert_eq!(f.round(),+3.0);%0A++++assert_eq!(g.round(),+-3.0);%0A++++assert_eq!(h.round(),+-4.0);%0A++++assert_eq!(i.round(),+4.0);%0A++++assert_eq!(j.round(),+5.0);%0A%7D&edition=2021)\n\n1.77.0 · [source](about:blank/src/std/f32.rs.html#127-129)\n\nReturns the nearest integer to a number. Rounds half-way cases to the number with an even least significant digit.\n\nThis function always returns the precise result.\n\n##### [§](#examples-3)Examples\n\n```\nlet f = 3.3_f32;\nlet g = -3.3_f32;\nlet h = 3.5_f32;\nlet i = 4.5_f32;\n\nassert_eq!(f.round_ties_even(), 3.0);\nassert_eq!(g.round_ties_even(), -3.0);\nassert_eq!(h.round_ties_even(), 4.0);\nassert_eq!(i.round_ties_even(), 4.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.3_f32;%0A++++let+g+=+-3.3_f32;%0A++++let+h+=+3.5_f32;%0A++++let+i+=+4.5_f32;%0A++++%0A++++assert_eq!(f.round_ties_even(),+3.0);%0A++++assert_eq!(g.round_ties_even(),+-3.0);%0A++++assert_eq!(h.round_ties_even(),+4.0);%0A++++assert_eq!(i.round_ties_even(),+4.0);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#152-154)\n\nReturns the integer part of `self`. This means that non-integer numbers are always truncated towards zero.\n\nThis function always returns the precise result.\n\n##### [§](#examples-4)Examples\n\n```\nlet f = 3.7_f32;\nlet g = 3.0_f32;\nlet h = -3.7_f32;\n\nassert_eq!(f.trunc(), 3.0);\nassert_eq!(g.trunc(), 3.0);\nassert_eq!(h.trunc(), -3.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.7_f32;%0A++++let+g+=+3.0_f32;%0A++++let+h+=+-3.7_f32;%0A++++%0A++++assert_eq!(f.trunc(),+3.0);%0A++++assert_eq!(g.trunc(),+3.0);%0A++++assert_eq!(h.trunc(),+-3.0);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#175-177)\n\nReturns the fractional part of `self`.\n\nThis function always returns the precise result.\n\n##### [§](#examples-5)Examples\n\n```\nlet x = 3.6_f32;\nlet y = -3.6_f32;\nlet abs_difference_x = (x.fract() - 0.6).abs();\nlet abs_difference_y = (y.fract() - (-0.6)).abs();\n\nassert!(abs_difference_x <= f32::EPSILON);\nassert!(abs_difference_y <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.6_f32;%0A++++let+y+=+-3.6_f32;%0A++++let+abs_difference_x+=+(x.fract()+-+0.6).abs();%0A++++let+abs_difference_y+=+(y.fract()+-+(-0.6)).abs();%0A++++%0A++++assert!(abs_difference_x+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_y+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#198-200)\n\nComputes the absolute value of `self`.\n\nThis function always returns the precise result.\n\n##### [§](#examples-6)Examples\n\n```\nlet x = 3.5_f32;\nlet y = -3.5_f32;\n\nassert_eq!(x.abs(), x);\nassert_eq!(y.abs(), -y);\n\nassert!(f32::NAN.abs().is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.5_f32;%0A++++let+y+=+-3.5_f32;%0A++++%0A++++assert_eq!(x.abs(),+x);%0A++++assert_eq!(y.abs(),+-y);%0A++++%0A++++assert!(f32::NAN.abs().is_nan());%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#222-224)\n\nReturns a number that represents the sign of `self`.\n\n-   `1.0` if the number is positive, `+0.0` or `INFINITY`\n-   `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-   NaN if the number is NaN\n\n##### [§](#examples-7)Examples\n\n```\nlet f = 3.5_f32;\n\nassert_eq!(f.signum(), 1.0);\nassert_eq!(f32::NEG_INFINITY.signum(), -1.0);\n\nassert!(f32::NAN.signum().is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.5_f32;%0A++++%0A++++assert_eq!(f.signum(),+1.0);%0A++++assert_eq!(f32::NEG_INFINITY.signum(),+-1.0);%0A++++%0A++++assert!(f32::NAN.signum().is_nan());%0A%7D&edition=2021)\n\n1.35.0 · [source](about:blank/src/std/f32.rs.html#251-253)\n\nReturns a number composed of the magnitude of `self` and the sign of `sign`.\n\nEqual to `self` if the sign of `self` and `sign` are the same, otherwise equal to `-self`. If `self` is a NaN, then a NaN with the sign bit of `sign` is returned. Note, however, that conserving the sign bit on NaN across arithmetical operations is not generally guaranteed. See [explanation of NaN as a special value](primitive.f32.html \"primitive f32\") for more info.\n\n##### [§](#examples-8)Examples\n\n```\nlet f = 3.5_f32;\n\nassert_eq!(f.copysign(0.42), 3.5_f32);\nassert_eq!(f.copysign(-0.42), -3.5_f32);\nassert_eq!((-f).copysign(0.42), 3.5_f32);\nassert_eq!((-f).copysign(-0.42), -3.5_f32);\n\nassert!(f32::NAN.copysign(1.0).is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.5_f32;%0A++++%0A++++assert_eq!(f.copysign(0.42),+3.5_f32);%0A++++assert_eq!(f.copysign(-0.42),+-3.5_f32);%0A++++assert_eq!((-f).copysign(0.42),+3.5_f32);%0A++++assert_eq!((-f).copysign(-0.42),+-3.5_f32);%0A++++%0A++++assert!(f32::NAN.copysign(1.0).is_nan());%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#292-294)\n\nFused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.\n\nUsing `mul_add` _may_ be more performant than an unfused multiply-add if the target architecture has a dedicated `fma` CPU instruction. However, this is not always true, and will be heavily dependant on designing algorithms with specific target hardware in mind.\n\n##### [§](#precision)Precision\n\nThe result of this operation is guaranteed to be the rounded infinite-precision result. It is specified by IEEE 754 as `fusedMultiplyAdd` and guaranteed not to change.\n\n##### [§](#examples-9)Examples\n\n```\nlet m = 10.0_f32;\nlet x = 4.0_f32;\nlet b = 60.0_f32;\n\nassert_eq!(m.mul_add(x, b), 100.0);\nassert_eq!(m * x + b, 100.0);\n\nlet one_plus_eps = 1.0_f32 + f32::EPSILON;\nlet one_minus_eps = 1.0_f32 - f32::EPSILON;\nlet minus_one = -1.0_f32;\n\n// The exact result (1 + eps) * (1 - eps) = 1 - eps * eps.\nassert_eq!(one_plus_eps.mul_add(one_minus_eps, minus_one), -f32::EPSILON * f32::EPSILON);\n// Different rounding with the non-fused multiply and add.\nassert_eq!(one_plus_eps * one_minus_eps + minus_one, 0.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+m+=+10.0_f32;%0A++++let+x+=+4.0_f32;%0A++++let+b+=+60.0_f32;%0A++++%0A++++assert_eq!(m.mul_add(x,+b),+100.0);%0A++++assert_eq!(m+*+x+%2B+b,+100.0);%0A++++%0A++++let+one_plus_eps+=+1.0_f32+%2B+f32::EPSILON;%0A++++let+one_minus_eps+=+1.0_f32+-+f32::EPSILON;%0A++++let+minus_one+=+-1.0_f32;%0A++++%0A++++//+The+exact+result+(1+%2B+eps)+*+(1+-+eps)+=+1+-+eps+*+eps.%0A++++assert_eq!(one_plus_eps.mul_add(one_minus_eps,+minus_one),+-f32::EPSILON+*+f32::EPSILON);%0A++++//+Different+rounding+with+the+non-fused+multiply+and+add.%0A++++assert_eq!(one_plus_eps+*+one_minus_eps+%2B+minus_one,+0.0);%0A%7D&edition=2021)\n\n1.38.0 · [source](about:blank/src/std/f32.rs.html#322-328)\n\nCalculates Euclidean division, the matching method for `rem_euclid`.\n\nThis computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`. In other words, the result is `self / rhs` rounded to the integer `n` such that `self >= n * rhs`.\n\n##### [§](#precision-1)Precision\n\nThe result of this operation is guaranteed to be the rounded infinite-precision result.\n\n##### [§](#examples-10)Examples\n\n```\nlet a: f32 = 7.0;\nlet b = 4.0;\nassert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\nassert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\nassert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\nassert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a:+f32+=+7.0;%0A++++let+b+=+4.0;%0A++++assert_eq!(a.div_euclid(b),+1.0);+//+7.0+%3E+4.0+*+1.0%0A++++assert_eq!((-a).div_euclid(b),+-2.0);+//+-7.0+%3E=+4.0+*+-2.0%0A++++assert_eq!(a.div_euclid(-b),+-1.0);+//+7.0+%3E=+-4.0+*+-1.0%0A++++assert_eq!((-a).div_euclid(-b),+2.0);+//+-7.0+%3E=+-4.0+*+2.0%0A%7D&edition=2021)\n\n1.38.0 · [source](about:blank/src/std/f32.rs.html#363-366)\n\nCalculates the least nonnegative remainder of `self (mod rhs)`.\n\nIn particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in most cases. However, due to a floating point round-off error it can result in `r == rhs.abs()`, violating the mathematical definition, if `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`. This result is not an element of the function’s codomain, but it is the closest floating point number in the real numbers and thus fulfills the property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)` approximately.\n\n##### [§](#precision-2)Precision\n\nThe result of this operation is guaranteed to be the rounded infinite-precision result.\n\n##### [§](#examples-11)Examples\n\n```\nlet a: f32 = 7.0;\nlet b = 4.0;\nassert_eq!(a.rem_euclid(b), 3.0);\nassert_eq!((-a).rem_euclid(b), 1.0);\nassert_eq!(a.rem_euclid(-b), 3.0);\nassert_eq!((-a).rem_euclid(-b), 1.0);\n// limitation due to round-off error\nassert!((-f32::EPSILON).rem_euclid(3.0) != 0.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a:+f32+=+7.0;%0A++++let+b+=+4.0;%0A++++assert_eq!(a.rem_euclid(b),+3.0);%0A++++assert_eq!((-a).rem_euclid(b),+1.0);%0A++++assert_eq!(a.rem_euclid(-b),+3.0);%0A++++assert_eq!((-a).rem_euclid(-b),+1.0);%0A++++//+limitation+due+to+round-off+error%0A++++assert!((-f32::EPSILON).rem_euclid(3.0)+!=+0.0);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#391-393)\n\nRaises a number to an integer power.\n\nUsing this function is generally faster than using `powf`. It might have a different sequence of rounding operations than `powf`, so the results are not guaranteed to agree.\n\n##### [§](#unspecified-precision)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-12)Examples\n\n```\nlet x = 2.0_f32;\nlet abs_difference = (x.powi(2) - (x * x)).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.powi(2)+-+(x+*+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#414-416)\n\nRaises a number to a floating point power.\n\n##### [§](#unspecified-precision-1)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-13)Examples\n\n```\nlet x = 2.0_f32;\nlet abs_difference = (x.powf(2.0) - (x * x)).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.powf(2.0)+-+(x+*+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#443-445)\n\nReturns the square root of a number.\n\nReturns NaN if `self` is a negative number other than `-0.0`.\n\n##### [§](#precision-3)Precision\n\nThe result of this operation is guaranteed to be the rounded infinite-precision result. It is specified by IEEE 754 as `squareRoot` and guaranteed not to change.\n\n##### [§](#examples-14)Examples\n\n```\nlet positive = 4.0_f32;\nlet negative = -4.0_f32;\nlet negative_zero = -0.0_f32;\n\nassert_eq!(positive.sqrt(), 2.0);\nassert!(negative.sqrt().is_nan());\nassert!(negative_zero.sqrt() == negative_zero);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+positive+=+4.0_f32;%0A++++let+negative+=+-4.0_f32;%0A++++let+negative_zero+=+-0.0_f32;%0A++++%0A++++assert_eq!(positive.sqrt(),+2.0);%0A++++assert!(negative.sqrt().is_nan());%0A++++assert!(negative_zero.sqrt()+==+negative_zero);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#470-472)\n\nReturns `e^(self)`, (the exponential function).\n\n##### [§](#unspecified-precision-2)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-15)Examples\n\n```\nlet one = 1.0f32;\n// e^1\nlet e = one.exp();\n\n// ln(e) - 1 == 0\nlet abs_difference = (e.ln() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+one+=+1.0f32;%0A++++//+e%5E1%0A++++let+e+=+one.exp();%0A++++%0A++++//+ln(e)+-+1+==+0%0A++++let+abs_difference+=+(e.ln()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#495-497)\n\nReturns `2^(self)`.\n\n##### [§](#unspecified-precision-3)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-16)Examples\n\n```\nlet f = 2.0f32;\n\n// 2^2 - 4 == 0\nlet abs_difference = (f.exp2() - 4.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+2.0f32;%0A++++%0A++++//+2%5E2+-+4+==+0%0A++++let+abs_difference+=+(f.exp2()+-+4.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#522-524)\n\nReturns the natural logarithm of the number.\n\n##### [§](#unspecified-precision-4)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-17)Examples\n\n```\nlet one = 1.0f32;\n// e^1\nlet e = one.exp();\n\n// ln(e) - 1 == 0\nlet abs_difference = (e.ln() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+one+=+1.0f32;%0A++++//+e%5E1%0A++++let+e+=+one.exp();%0A++++%0A++++//+ln(e)+-+1+==+0%0A++++let+abs_difference+=+(e.ln()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#551-553)\n\nReturns the logarithm of the number with respect to an arbitrary base.\n\nThe result might not be correctly rounded owing to implementation details; `self.log2()` can produce more accurate results for base 2, and `self.log10()` can produce more accurate results for base 10.\n\n##### [§](#unspecified-precision-5)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-18)Examples\n\n```\nlet five = 5.0f32;\n\n// log5(5) - 1 == 0\nlet abs_difference = (five.log(5.0) - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+five+=+5.0f32;%0A++++%0A++++//+log5(5)+-+1+==+0%0A++++let+abs_difference+=+(five.log(5.0)+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#576-578)\n\nReturns the base 2 logarithm of the number.\n\n##### [§](#unspecified-precision-6)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-19)Examples\n\n```\nlet two = 2.0f32;\n\n// log2(2) - 1 == 0\nlet abs_difference = (two.log2() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+two+=+2.0f32;%0A++++%0A++++//+log2(2)+-+1+==+0%0A++++let+abs_difference+=+(two.log2()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#601-603)\n\nReturns the base 10 logarithm of the number.\n\n##### [§](#unspecified-precision-7)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-20)Examples\n\n```\nlet ten = 10.0f32;\n\n// log10(10) - 1 == 0\nlet abs_difference = (ten.log10() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ten+=+10.0f32;%0A++++%0A++++//+log10(10)+-+1+==+0%0A++++let+abs_difference+=+(ten.log10()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#643-645)\n\n👎Deprecated since 1.10.0: you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)` except that `abs_sub` also propagates NaNs (also known as `fdimf` in C). If you truly need the positive difference, consider using that expression or the C function `fdimf`, depending on how you wish to handle NaN (please consider filing an issue describing your use-case too).\n\nThe positive difference of two numbers.\n\n-   If `self <= other`: `0.0`\n-   Else: `self - other`\n\n##### [§](#unspecified-precision-8)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `fdimf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-21)Examples\n\n```\nlet x = 3.0f32;\nlet y = -3.0f32;\n\nlet abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\nlet abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n\nassert!(abs_difference_x <= f32::EPSILON);\nassert!(abs_difference_y <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.0f32;%0A++++let+y+=+-3.0f32;%0A++++%0A++++let+abs_difference_x+=+(x.abs_sub(1.0)+-+2.0).abs();%0A++++let+abs_difference_y+=+(y.abs_sub(1.0)+-+0.0).abs();%0A++++%0A++++assert!(abs_difference_x+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_y+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#670-672)\n\nReturns the cube root of a number.\n\n##### [§](#unspecified-precision-9)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `cbrtf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-22)Examples\n\n```\nlet x = 8.0f32;\n\n// x^(1/3) - 2 == 0\nlet abs_difference = (x.cbrt() - 2.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+8.0f32;%0A++++%0A++++//+x%5E(1/3)+-+2+==+0%0A++++let+abs_difference+=+(x.cbrt()+-+2.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#701-703)\n\nCompute the distance between the origin and a point (`x`, `y`) on the Euclidean plane. Equivalently, compute the length of the hypotenuse of a right-angle triangle with other sides having length `x.abs()` and `y.abs()`.\n\n##### [§](#unspecified-precision-10)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `hypotf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-23)Examples\n\n```\nlet x = 2.0f32;\nlet y = 3.0f32;\n\n// sqrt(x^2 + y^2)\nlet abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0f32;%0A++++let+y+=+3.0f32;%0A++++%0A++++//+sqrt(x%5E2+%2B+y%5E2)%0A++++let+abs_difference+=+(x.hypot(y)+-+(x.powi(2)+%2B+y.powi(2)).sqrt()).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#725-727)\n\nComputes the sine of a number (in radians).\n\n##### [§](#unspecified-precision-11)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-24)Examples\n\n```\nlet x = std::f32::consts::FRAC_PI_2;\n\nlet abs_difference = (x.sin() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_2;%0A++++%0A++++let+abs_difference+=+(x.sin()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#749-751)\n\nComputes the cosine of a number (in radians).\n\n##### [§](#unspecified-precision-12)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-25)Examples\n\n```\nlet x = 2.0 * std::f32::consts::PI;\n\nlet abs_difference = (x.cos() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0+*+std::f32::consts::PI;%0A++++%0A++++let+abs_difference+=+(x.cos()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#774-776)\n\nComputes the tangent of a number (in radians).\n\n##### [§](#unspecified-precision-13)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `tanf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-26)Examples\n\n```\nlet x = std::f32::consts::FRAC_PI_4;\nlet abs_difference = (x.tan() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_4;%0A++++let+abs_difference+=+(x.tan()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#804-806)\n\nComputes the arcsine of a number. Return value is in radians in the range \\[-pi/2, pi/2\\] or NaN if the number is outside the range \\[-1, 1\\].\n\n##### [§](#unspecified-precision-14)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `asinf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-27)Examples\n\n```\nlet f = std::f32::consts::FRAC_PI_2;\n\n// asin(sin(pi/2))\nlet abs_difference = (f.sin().asin() - std::f32::consts::FRAC_PI_2).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+std::f32::consts::FRAC_PI_2;%0A++++%0A++++//+asin(sin(pi/2))%0A++++let+abs_difference+=+(f.sin().asin()+-+std::f32::consts::FRAC_PI_2).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#834-836)\n\nComputes the arccosine of a number. Return value is in radians in the range \\[0, pi\\] or NaN if the number is outside the range \\[-1, 1\\].\n\n##### [§](#unspecified-precision-15)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `acosf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-28)Examples\n\n```\nlet f = std::f32::consts::FRAC_PI_4;\n\n// acos(cos(pi/4))\nlet abs_difference = (f.cos().acos() - std::f32::consts::FRAC_PI_4).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+std::f32::consts::FRAC_PI_4;%0A++++%0A++++//+acos(cos(pi/4))%0A++++let+abs_difference+=+(f.cos().acos()+-+std::f32::consts::FRAC_PI_4).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#863-865)\n\nComputes the arctangent of a number. Return value is in radians in the range \\[-pi/2, pi/2\\];\n\n##### [§](#unspecified-precision-16)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `atanf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-29)Examples\n\n```\nlet f = 1.0f32;\n\n// atan(tan(1))\nlet abs_difference = (f.tan().atan() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+1.0f32;%0A++++%0A++++//+atan(tan(1))%0A++++let+abs_difference+=+(f.tan().atan()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#904-906)\n\nComputes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n\n-   `x = 0`, `y = 0`: `0`\n-   `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n-   `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n-   `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n\n##### [§](#unspecified-precision-17)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `atan2f` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-30)Examples\n\n```\n// Positive angles measured counter-clockwise\n// from positive x axis\n// -pi/4 radians (45 deg clockwise)\nlet x1 = 3.0f32;\nlet y1 = -3.0f32;\n\n// 3pi/4 radians (135 deg counter-clockwise)\nlet x2 = -3.0f32;\nlet y2 = 3.0f32;\n\nlet abs_difference_1 = (y1.atan2(x1) - (-std::f32::consts::FRAC_PI_4)).abs();\nlet abs_difference_2 = (y2.atan2(x2) - (3.0 * std::f32::consts::FRAC_PI_4)).abs();\n\nassert!(abs_difference_1 <= f32::EPSILON);\nassert!(abs_difference_2 <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Positive+angles+measured+counter-clockwise%0A//+from+positive+x+axis%0A//+-pi/4+radians+(45+deg+clockwise)%0Afn+main()+%7B%0A++++let+x1+=+3.0f32;%0A++++let+y1+=+-3.0f32;%0A++++%0A++++//+3pi/4+radians+(135+deg+counter-clockwise)%0A++++let+x2+=+-3.0f32;%0A++++let+y2+=+3.0f32;%0A++++%0A++++let+abs_difference_1+=+(y1.atan2(x1)+-+(-std::f32::consts::FRAC_PI_4)).abs();%0A++++let+abs_difference_2+=+(y2.atan2(x2)+-+(3.0+*+std::f32::consts::FRAC_PI_4)).abs();%0A++++%0A++++assert!(abs_difference_1+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_2+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#934-936)\n\nSimultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.\n\n##### [§](#unspecified-precision-18)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `(f32::sin(x), f32::cos(x))`. Note that this might change in the future.\n\n##### [§](#examples-31)Examples\n\n```\nlet x = std::f32::consts::FRAC_PI_4;\nlet f = x.sin_cos();\n\nlet abs_difference_0 = (f.0 - x.sin()).abs();\nlet abs_difference_1 = (f.1 - x.cos()).abs();\n\nassert!(abs_difference_0 <= f32::EPSILON);\nassert!(abs_difference_1 <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_4;%0A++++let+f+=+x.sin_cos();%0A++++%0A++++let+abs_difference_0+=+(f.0+-+x.sin()).abs();%0A++++let+abs_difference_1+=+(f.1+-+x.cos()).abs();%0A++++%0A++++assert!(abs_difference_0+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_1+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#963-965)\n\nReturns `e^(self) - 1` in a way that is accurate even if the number is close to zero.\n\n##### [§](#unspecified-precision-19)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `expm1f` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-32)Examples\n\n```\nlet x = 1e-8_f32;\n\n// for very small x, e^x is approximately 1 + x + x^2 / 2\nlet approx = x + x * x / 2.0;\nlet abs_difference = (x.exp_m1() - approx).abs();\n\nassert!(abs_difference < 1e-10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1e-8_f32;%0A++++%0A++++//+for+very+small+x,+e%5Ex+is+approximately+1+%2B+x+%2B+x%5E2+/+2%0A++++let+approx+=+x+%2B+x+*+x+/+2.0;%0A++++let+abs_difference+=+(x.exp_m1()+-+approx).abs();%0A++++%0A++++assert!(abs_difference+%3C+1e-10);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#993-995)\n\nReturns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.\n\n##### [§](#unspecified-precision-20)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `log1pf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-33)Examples\n\n```\nlet x = 1e-8_f32;\n\n// for very small x, ln(1 + x) is approximately x - x^2 / 2\nlet approx = x - x * x / 2.0;\nlet abs_difference = (x.ln_1p() - approx).abs();\n\nassert!(abs_difference < 1e-10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1e-8_f32;%0A++++%0A++++//+for+very+small+x,+ln(1+%2B+x)+is+approximately+x+-+x%5E2+/+2%0A++++let+approx+=+x+-+x+*+x+/+2.0;%0A++++let+abs_difference+=+(x.ln_1p()+-+approx).abs();%0A++++%0A++++assert!(abs_difference+%3C+1e-10);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#1023-1025)\n\nHyperbolic sine function.\n\n##### [§](#unspecified-precision-21)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `sinhf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-34)Examples\n\n```\nlet e = std::f32::consts::E;\nlet x = 1.0f32;\n\nlet f = x.sinh();\n// Solving sinh() at 1 gives `(e^2-1)/(2e)`\nlet g = ((e * e) - 1.0) / (2.0 * e);\nlet abs_difference = (f - g).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++%0A++++let+f+=+x.sinh();%0A++++//+Solving+sinh()+at+1+gives+%60(e%5E2-1)/(2e)%60%0A++++let+g+=+((e+*+e)+-+1.0)+/+(2.0+*+e);%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#1053-1055)\n\nHyperbolic cosine function.\n\n##### [§](#unspecified-precision-22)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `coshf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-35)Examples\n\n```\nlet e = std::f32::consts::E;\nlet x = 1.0f32;\nlet f = x.cosh();\n// Solving cosh() at 1 gives this result\nlet g = ((e * e) + 1.0) / (2.0 * e);\nlet abs_difference = (f - g).abs();\n\n// Same result\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.cosh();%0A++++//+Solving+cosh()+at+1+gives+this+result%0A++++let+g+=+((e+*+e)+%2B+1.0)+/+(2.0+*+e);%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++//+Same+result%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#1083-1085)\n\nHyperbolic tangent function.\n\n##### [§](#unspecified-precision-23)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `tanhf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-36)Examples\n\n```\nlet e = std::f32::consts::E;\nlet x = 1.0f32;\n\nlet f = x.tanh();\n// Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\nlet g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\nlet abs_difference = (f - g).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++%0A++++let+f+=+x.tanh();%0A++++//+Solving+tanh()+at+1+gives+%60(1+-+e%5E(-2))/(1+%2B+e%5E(-2))%60%0A++++let+g+=+(1.0+-+e.powi(-2))+/+(1.0+%2B+e.powi(-2));%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#1109-1113)\n\nInverse hyperbolic sine function.\n\n##### [§](#unspecified-precision-24)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-37)Examples\n\n```\nlet x = 1.0f32;\nlet f = x.sinh().asinh();\n\nlet abs_difference = (f - x).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.sinh().asinh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#1137-1143)\n\nInverse hyperbolic cosine function.\n\n##### [§](#unspecified-precision-25)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-38)Examples\n\n```\nlet x = 1.0f32;\nlet f = x.cosh().acosh();\n\nlet abs_difference = (f - x).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.cosh().acosh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/f32.rs.html#1167-1169)\n\nInverse hyperbolic tangent function.\n\n##### [§](#unspecified-precision-26)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.\n\n##### [§](#examples-39)Examples\n\n```\nlet e = std::f32::consts::E;\nlet f = e.tanh().atanh();\n\nlet abs_difference = (f - e).abs();\n\nassert!(abs_difference <= 1e-5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+f+=+e.tanh().atanh();%0A++++%0A++++let+abs_difference+=+(f+-+e).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-5);%0A%7D&edition=2021)\n\n[source](about:blank/src/std/f32.rs.html#1194-1196)\n\n🔬This is a nightly-only experimental API. (`float_gamma` [#99842](https://github.com/rust-lang/rust/issues/99842))\n\nGamma function.\n\n##### [§](#unspecified-precision-27)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `tgammaf` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-40)Examples\n\n```\n#![feature(float_gamma)]\nlet x = 5.0f32;\n\nlet abs_difference = (x.gamma() - 24.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_gamma)%5D%0Afn+main()+%7B%0A++++let+x+=+5.0f32;%0A++++%0A++++let+abs_difference+=+(x.gamma()+-+24.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&version=nightly&edition=2021)\n\n[source](about:blank/src/std/f32.rs.html#1223-1227)\n\n🔬This is a nightly-only experimental API. (`float_gamma` [#99842](https://github.com/rust-lang/rust/issues/99842))\n\nNatural logarithm of the absolute value of the gamma function\n\nThe integer part of the tuple indicates the sign of the gamma function.\n\n##### [§](#unspecified-precision-28)Unspecified precision\n\nThe precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the `lgamma_r` from libc on Unix and Windows. Note that this might change in the future.\n\n##### [§](#examples-41)Examples\n\n```\n#![feature(float_gamma)]\nlet x = 2.0f32;\n\nlet abs_difference = (x.ln_gamma().0 - 0.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_gamma)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0f32;%0A++++%0A++++let+abs_difference+=+(x.ln_gamma().0+-+0.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#384)[§](#impl-f32-1)\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#387)\n\nThe radix or base of the internal representation of `f32`.\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#391)\n\nNumber of significant digits in base 2.\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#402)\n\nApproximate number of significant digits in base 10.\n\nThis is the maximum _x_ such that any decimal number with _x_ significant digits can be converted to `f32` and back without loss.\n\nEqual to floor(log10 2[`MANTISSA_DIGITS`](about:blank/primitive.f32.html#associatedconstant.MANTISSA_DIGITS \"associated constant f32::MANTISSA_DIGITS\") − 1).\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#413)\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#421)\n\nSmallest finite `f32` value.\n\nEqual to −[`MAX`](about:blank/primitive.f32.html#associatedconstant.MAX \"associated constant f32::MAX\").\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#428)\n\nSmallest positive normal `f32` value.\n\nEqual to 2[`MIN_EXP`](about:blank/primitive.f32.html#associatedconstant.MIN_EXP \"associated constant f32::MIN_EXP\") − 1.\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#437)\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#444)\n\nOne greater than the minimum possible normal power of 2 exponent.\n\nIf _x_ = `MIN_EXP`, then normal numbers ≥ 0.5 × 2_x_.\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#450)\n\nMaximum possible power of 2 exponent.\n\nIf _x_ = `MAX_EXP`, then normal numbers < 1 × 2_x_.\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#458)\n\nMinimum _x_ for which 10_x_ is normal.\n\nEqual to ceil(log10 [`MIN_POSITIVE`](about:blank/primitive.f32.html#associatedconstant.MIN_POSITIVE \"associated constant f32::MIN_POSITIVE\")).\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#465)\n\nMaximum _x_ for which 10_x_ is normal.\n\nEqual to floor(log10 [`MAX`](about:blank/primitive.f32.html#associatedconstant.MAX \"associated constant f32::MAX\")).\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#480)\n\nNot a Number (NaN).\n\nNote that IEEE 754 doesn’t define just a single NaN value; a plethora of bit patterns are considered to be NaN. Furthermore, the standard makes a difference between a “signaling” and a “quiet” NaN, and allows inspecting its “payload” (the unspecified bits in the bit pattern). This constant isn’t guaranteed to equal to any specific NaN bitpattern, and the stability of its representation over Rust versions and target platforms isn’t guaranteed.\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#483)\n\nInfinity (∞).\n\n1.43.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#486)\n\nNegative infinity (−∞).\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#502)\n\nReturns `true` if this value is NaN.\n\n```\nlet nan = f32::NAN;\nlet f = 7.0_f32;\n\nassert!(nan.is_nan());\nassert!(!f.is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nan+=+f32::NAN;%0A++++let+f+=+7.0_f32;%0A++++%0A++++assert!(nan.is_nan());%0A++++assert!(!f.is_nan());%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#535)\n\nReturns `true` if this value is positive infinity or negative infinity, and `false` otherwise.\n\n```\nlet f = 7.0f32;\nlet inf = f32::INFINITY;\nlet neg_inf = f32::NEG_INFINITY;\nlet nan = f32::NAN;\n\nassert!(!f.is_infinite());\nassert!(!nan.is_infinite());\n\nassert!(inf.is_infinite());\nassert!(neg_inf.is_infinite());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+inf+=+f32::INFINITY;%0A++++let+neg_inf+=+f32::NEG_INFINITY;%0A++++let+nan+=+f32::NAN;%0A++++%0A++++assert!(!f.is_infinite());%0A++++assert!(!nan.is_infinite());%0A++++%0A++++assert!(inf.is_infinite());%0A++++assert!(neg_inf.is_infinite());%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#560)\n\nReturns `true` if this number is neither infinite nor NaN.\n\n```\nlet f = 7.0f32;\nlet inf = f32::INFINITY;\nlet neg_inf = f32::NEG_INFINITY;\nlet nan = f32::NAN;\n\nassert!(f.is_finite());\n\nassert!(!nan.is_finite());\nassert!(!inf.is_finite());\nassert!(!neg_inf.is_finite());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+inf+=+f32::INFINITY;%0A++++let+neg_inf+=+f32::NEG_INFINITY;%0A++++let+nan+=+f32::NAN;%0A++++%0A++++assert!(f.is_finite());%0A++++%0A++++assert!(!nan.is_finite());%0A++++assert!(!inf.is_finite());%0A++++assert!(!neg_inf.is_finite());%0A%7D&edition=2021)\n\n1.53.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#588)\n\nReturns `true` if the number is [subnormal](https://en.wikipedia.org/wiki/Denormal_number).\n\n```\nlet min = f32::MIN_POSITIVE; // 1.17549435e-38f32\nlet max = f32::MAX;\nlet lower_than_min = 1.0e-40_f32;\nlet zero = 0.0_f32;\n\nassert!(!min.is_subnormal());\nassert!(!max.is_subnormal());\n\nassert!(!zero.is_subnormal());\nassert!(!f32::NAN.is_subnormal());\nassert!(!f32::INFINITY.is_subnormal());\n// Values between `0` and `min` are Subnormal.\nassert!(lower_than_min.is_subnormal());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+min+=+f32::MIN_POSITIVE;+//+1.17549435e-38f32%0A++++let+max+=+f32::MAX;%0A++++let+lower_than_min+=+1.0e-40_f32;%0A++++let+zero+=+0.0_f32;%0A++++%0A++++assert!(!min.is_subnormal());%0A++++assert!(!max.is_subnormal());%0A++++%0A++++assert!(!zero.is_subnormal());%0A++++assert!(!f32::NAN.is_subnormal());%0A++++assert!(!f32::INFINITY.is_subnormal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(lower_than_min.is_subnormal());%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#615)\n\nReturns `true` if the number is neither zero, infinite, [subnormal](https://en.wikipedia.org/wiki/Denormal_number), or NaN.\n\n```\nlet min = f32::MIN_POSITIVE; // 1.17549435e-38f32\nlet max = f32::MAX;\nlet lower_than_min = 1.0e-40_f32;\nlet zero = 0.0_f32;\n\nassert!(min.is_normal());\nassert!(max.is_normal());\n\nassert!(!zero.is_normal());\nassert!(!f32::NAN.is_normal());\nassert!(!f32::INFINITY.is_normal());\n// Values between `0` and `min` are Subnormal.\nassert!(!lower_than_min.is_normal());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+min+=+f32::MIN_POSITIVE;+//+1.17549435e-38f32%0A++++let+max+=+f32::MAX;%0A++++let+lower_than_min+=+1.0e-40_f32;%0A++++let+zero+=+0.0_f32;%0A++++%0A++++assert!(min.is_normal());%0A++++assert!(max.is_normal());%0A++++%0A++++assert!(!zero.is_normal());%0A++++assert!(!f32::NAN.is_normal());%0A++++assert!(!f32::INFINITY.is_normal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(!lower_than_min.is_normal());%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#634)\n\nReturns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.\n\n```\nuse std::num::FpCategory;\n\nlet num = 12.4_f32;\nlet inf = f32::INFINITY;\n\nassert_eq!(num.classify(), FpCategory::Normal);\nassert_eq!(inf.classify(), FpCategory::Infinite);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::FpCategory;%0A++++%0A++++let+num+=+12.4_f32;%0A++++let+inf+=+f32::INFINITY;%0A++++%0A++++assert_eq!(num.classify(),+FpCategory::Normal);%0A++++assert_eq!(inf.classify(),+FpCategory::Infinite);%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#727)\n\nReturns `true` if `self` has a positive sign, including `+0.0`, NaNs with positive sign bit and positive infinity. Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are conserved over arithmetic operations, the result of `is_sign_positive` on a NaN might produce an unexpected result in some cases. See [explanation of NaN as a special value](primitive.f32.html \"primitive f32\") for more info.\n\n```\nlet f = 7.0_f32;\nlet g = -7.0_f32;\n\nassert!(f.is_sign_positive());\nassert!(!g.is_sign_positive());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0_f32;%0A++++let+g+=+-7.0_f32;%0A++++%0A++++assert!(f.is_sign_positive());%0A++++assert!(!g.is_sign_positive());%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72505 \"Tracking issue for const_float_classify\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#749)\n\nReturns `true` if `self` has a negative sign, including `-0.0`, NaNs with negative sign bit and negative infinity. Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are conserved over arithmetic operations, the result of `is_sign_negative` on a NaN might produce an unexpected result in some cases. See [explanation of NaN as a special value](primitive.f32.html \"primitive f32\") for more info.\n\n```\nlet f = 7.0f32;\nlet g = -7.0f32;\n\nassert!(!f.is_sign_negative());\nassert!(g.is_sign_negative());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+g+=+-7.0f32;%0A++++%0A++++assert!(!f.is_sign_negative());%0A++++assert!(g.is_sign_negative());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#784)\n\n🔬This is a nightly-only experimental API. (`float_next_up_down` [#91399](https://github.com/rust-lang/rust/issues/91399))\n\nReturns the least number greater than `self`.\n\nLet `TINY` be the smallest representable positive `f32`. Then,\n\n-   if `self.is_nan()`, this returns `self`;\n-   if `self` is [`NEG_INFINITY`](about:blank/primitive.f32.html#associatedconstant.NEG_INFINITY \"associated constant f32::NEG_INFINITY\"), this returns [`MIN`](about:blank/primitive.f32.html#associatedconstant.MIN \"associated constant f32::MIN\");\n-   if `self` is `-TINY`, this returns -0.0;\n-   if `self` is -0.0 or +0.0, this returns `TINY`;\n-   if `self` is [`MAX`](about:blank/primitive.f32.html#associatedconstant.MAX \"associated constant f32::MAX\") or [`INFINITY`](about:blank/primitive.f32.html#associatedconstant.INFINITY \"associated constant f32::INFINITY\"), this returns [`INFINITY`](about:blank/primitive.f32.html#associatedconstant.INFINITY \"associated constant f32::INFINITY\");\n-   otherwise the unique least value greater than `self` is returned.\n\nThe identity `x.next_up() == -(-x).next_down()` holds for all non-NaN `x`. When `x` is finite `x == x.next_up().next_down()` also holds.\n\n```\n#![feature(float_next_up_down)]\n// f32::EPSILON is the difference between 1.0 and the next number up.\nassert_eq!(1.0f32.next_up(), 1.0 + f32::EPSILON);\n// But not for most numbers.\nassert!(0.1f32.next_up() < 0.1 + f32::EPSILON);\nassert_eq!(16777216f32.next_up(), 16777218.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_next_up_down)%5D%0A//+f32::EPSILON+is+the+difference+between+1.0+and+the+next+number+up.%0Afn+main()+%7B%0A++++assert_eq!(1.0f32.next_up(),+1.0+%2B+f32::EPSILON);%0A++++//+But+not+for+most+numbers.%0A++++assert!(0.1f32.next_up()+%3C+0.1+%2B+f32::EPSILON);%0A++++assert_eq!(16777216f32.next_up(),+16777218.0);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#834)\n\n🔬This is a nightly-only experimental API. (`float_next_up_down` [#91399](https://github.com/rust-lang/rust/issues/91399))\n\nReturns the greatest number less than `self`.\n\nLet `TINY` be the smallest representable positive `f32`. Then,\n\n-   if `self.is_nan()`, this returns `self`;\n-   if `self` is [`INFINITY`](about:blank/primitive.f32.html#associatedconstant.INFINITY \"associated constant f32::INFINITY\"), this returns [`MAX`](about:blank/primitive.f32.html#associatedconstant.MAX \"associated constant f32::MAX\");\n-   if `self` is `TINY`, this returns 0.0;\n-   if `self` is -0.0 or +0.0, this returns `-TINY`;\n-   if `self` is [`MIN`](about:blank/primitive.f32.html#associatedconstant.MIN \"associated constant f32::MIN\") or [`NEG_INFINITY`](about:blank/primitive.f32.html#associatedconstant.NEG_INFINITY \"associated constant f32::NEG_INFINITY\"), this returns [`NEG_INFINITY`](about:blank/primitive.f32.html#associatedconstant.NEG_INFINITY \"associated constant f32::NEG_INFINITY\");\n-   otherwise the unique greatest value less than `self` is returned.\n\nThe identity `x.next_down() == -(-x).next_up()` holds for all non-NaN `x`. When `x` is finite `x == x.next_down().next_up()` also holds.\n\n```\n#![feature(float_next_up_down)]\nlet x = 1.0f32;\n// Clamp value into range [0, 1).\nlet clamped = x.clamp(0.0, 1.0f32.next_down());\nassert!(clamped < 1.0);\nassert_eq!(clamped.next_up(), 1.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_next_up_down)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++//+Clamp+value+into+range+%5B0,+1).%0A++++let+clamped+=+x.clamp(0.0,+1.0f32.next_down());%0A++++assert!(clamped+%3C+1.0);%0A++++assert_eq!(clamped.next_up(),+1.0);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#867)\n\nTakes the reciprocal (inverse) of a number, `1/x`.\n\n```\nlet x = 2.0_f32;\nlet abs_difference = (x.recip() - (1.0 / x)).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.recip()+-+(1.0+/+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.7.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#884)\n\nConverts radians to degrees.\n\n```\nlet angle = std::f32::consts::PI;\n\nlet abs_difference = (angle.to_degrees() - 180.0).abs();\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+angle+=+std::f32::consts::PI;%0A++++%0A++++let+abs_difference+=+(angle.to_degrees()+-+180.0).abs();%0A++++%23%5Bcfg(any(not(target_arch+=+%22x86%22),+target_feature+=+%22sse2%22))%5D%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.7.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#903)\n\nConverts degrees to radians.\n\n```\nlet angle = 180.0f32;\n\nlet abs_difference = (angle.to_radians() - std::f32::consts::PI).abs();\n\nassert!(abs_difference <= f32::EPSILON);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+angle+=+180.0f32;%0A++++%0A++++let+abs_difference+=+(angle.to_radians()+-+std::f32::consts::PI).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#924)\n\nReturns the maximum of the two numbers, ignoring NaN.\n\nIf one of the arguments is NaN, then the other argument is returned. This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs; this function handles all NaNs the same way and avoids maxNum’s problems with associativity. This also matches the behavior of libm’s fmax.\n\n```\nlet x = 1.0f32;\nlet y = 2.0f32;\n\nassert_eq!(x.max(y), y);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.max(y),+y);%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#944)\n\nReturns the minimum of the two numbers, ignoring NaN.\n\nIf one of the arguments is NaN, then the other argument is returned. This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs; this function handles all NaNs the same way and avoids minNum’s problems with associativity. This also matches the behavior of libm’s fmin.\n\n```\nlet x = 1.0f32;\nlet y = 2.0f32;\n\nassert_eq!(x.min(y), x);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.min(y),+x);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#971)\n\n🔬This is a nightly-only experimental API. (`float_minimum_maximum` [#91079](https://github.com/rust-lang/rust/issues/91079))\n\nReturns the maximum of the two numbers, propagating NaN.\n\nThis returns NaN when _either_ argument is NaN, as opposed to [`f32::max`](about:blank/primitive.f32.html#method.max \"method f32::max\") which only returns NaN when _both_ arguments are NaN.\n\n```\n#![feature(float_minimum_maximum)]\nlet x = 1.0f32;\nlet y = 2.0f32;\n\nassert_eq!(x.maximum(y), y);\nassert!(x.maximum(f32::NAN).is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.maximum(y),+y);%0A++++assert!(x.maximum(f32::NAN).is_nan());%0A%7D&version=nightly&edition=2021)\n\nIf one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater of the two numbers. For this operation, -0.0 is considered to be less than +0.0. Note that this follows the semantics specified in IEEE 754-2019.\n\nAlso note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN operand is conserved; see [explanation of NaN as a special value](primitive.f32.html \"primitive f32\") for more info.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1006)\n\n🔬This is a nightly-only experimental API. (`float_minimum_maximum` [#91079](https://github.com/rust-lang/rust/issues/91079))\n\nReturns the minimum of the two numbers, propagating NaN.\n\nThis returns NaN when _either_ argument is NaN, as opposed to [`f32::min`](about:blank/primitive.f32.html#method.min \"method f32::min\") which only returns NaN when _both_ arguments are NaN.\n\n```\n#![feature(float_minimum_maximum)]\nlet x = 1.0f32;\nlet y = 2.0f32;\n\nassert_eq!(x.minimum(y), x);\nassert!(x.minimum(f32::NAN).is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.minimum(y),+x);%0A++++assert!(x.minimum(f32::NAN).is_nan());%0A%7D&version=nightly&edition=2021)\n\nIf one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser of the two numbers. For this operation, -0.0 is considered to be less than +0.0. Note that this follows the semantics specified in IEEE 754-2019.\n\nAlso note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN operand is conserved; see [explanation of NaN as a special value](primitive.f32.html \"primitive f32\") for more info.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1032)\n\n🔬This is a nightly-only experimental API. (`num_midpoint` [#110840](https://github.com/rust-lang/rust/issues/110840))\n\nCalculates the middle point of `self` and `rhs`.\n\nThis returns NaN when _either_ argument is NaN or if a combination of +inf and -inf is provided as arguments.\n\n##### [§](#examples-42)Examples\n\n```\n#![feature(num_midpoint)]\nassert_eq!(1f32.midpoint(4.0), 2.5);\nassert_eq!((-5.5f32).midpoint(8.0), 1.25);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(num_midpoint)%5D%0Afn+main()+%7B%0A++++assert_eq!(1f32.midpoint(4.0),+2.5);%0A++++assert_eq!((-5.5f32).midpoint(8.0),+1.25);%0A%7D&version=nightly&edition=2021)\n\n1.44.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1096-1098)\n\nRounds toward zero and converts to any primitive integer type, assuming that the value is finite and fits in that type.\n\n```\nlet value = 4.6_f32;\nlet rounded = unsafe { value.to_int_unchecked::<u16>() };\nassert_eq!(rounded, 4);\n\nlet value = -128.9_f32;\nlet rounded = unsafe { value.to_int_unchecked::<i8>() };\nassert_eq!(rounded, i8::MIN);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+4.6_f32;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Cu16%3E()+%7D;%0A++++assert_eq!(rounded,+4);%0A++++%0A++++let+value+=+-128.9_f32;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Ci8%3E()+%7D;%0A++++assert_eq!(rounded,+i8::MIN);%0A%7D&edition=2021)\n\n##### [§](#safety)Safety\n\nThe value must:\n\n-   Not be `NaN`\n-   Not be infinite\n-   Be representable in the return type `Int`, after truncating off its fractional part\n\n1.20.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1127)\n\nRaw transmutation to `u32`.\n\nThis is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\nNote that this function is distinct from `as` casting, which attempts to preserve the _numeric_ value, and not the bitwise value.\n\n##### [§](#examples-43)Examples\n\n```\nassert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\nassert_eq!((12.5f32).to_bits(), 0x41480000);\n\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_ne!((1f32).to_bits(),+1f32+as+u32);+//+to_bits()+is+not+casting!%0A++++assert_eq!((12.5f32).to_bits(),+0x41480000);%0A%7D&edition=2021)\n\n1.20.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1216)\n\nRaw transmutation from `u32`.\n\nThis is currently identical to `transmute::<u32, f32>(v)` on all platforms. It turns out this is incredibly portable, for two reasons:\n\n-   Floats and Ints have the same endianness on all supported platforms.\n-   IEEE 754 very precisely specifies the bit layout of floats.\n\nHowever there is one caveat: prior to the 2008 version of IEEE 754, how to interpret the NaN signaling bit wasn’t actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn’t (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n\nRather than trying to preserve signaling-ness cross-platform, this implementation favors preserving the exact bits. This means that any payloads encoded in NaNs will be preserved even if the result of this method is sent over the network from an x86 machine to a MIPS one.\n\nIf the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.\n\nIf the input isn’t NaN, then there is no portability concern.\n\nIf you don’t care about signalingness (very likely), then there is no portability concern.\n\nNote that this function is distinct from `as` casting, which attempts to preserve the _numeric_ value, and not the bitwise value.\n\n##### [§](#examples-44)Examples\n\n```\nlet v = f32::from_bits(0x41480000);\nassert_eq!(v, 12.5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+f32::from_bits(0x41480000);%0A++++assert_eq!(v,+12.5);%0A%7D&edition=2021)\n\n1.40.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1284)\n\nReturn the memory representation of this floating point number as a byte array in big-endian (network) byte order.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\n##### [§](#examples-45)Examples\n\n```\nlet bytes = 12.5f32.to_be_bytes();\nassert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_be_bytes();%0A++++assert_eq!(bytes,+%5B0x41,+0x48,+0x00,+0x00%5D);%0A%7D&edition=2021)\n\n1.40.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1305)\n\nReturn the memory representation of this floating point number as a byte array in little-endian byte order.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\n##### [§](#examples-46)Examples\n\n```\nlet bytes = 12.5f32.to_le_bytes();\nassert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_le_bytes();%0A++++assert_eq!(bytes,+%5B0x00,+0x00,+0x48,+0x41%5D);%0A%7D&edition=2021)\n\n1.40.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1339)\n\nReturn the memory representation of this floating point number as a byte array in native byte order.\n\nAs the target platform’s native endianness is used, portable code should use [`to_be_bytes`](about:blank/primitive.f32.html#method.to_be_bytes \"method f32::to_be_bytes\") or [`to_le_bytes`](about:blank/primitive.f32.html#method.to_le_bytes \"method f32::to_le_bytes\"), as appropriate, instead.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\n##### [§](#examples-47)Examples\n\n```\nlet bytes = 12.5f32.to_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \"big\") {\n        [0x41, 0x48, 0x00, 0x00]\n    } else {\n        [0x00, 0x00, 0x48, 0x41]\n    }\n);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_ne_bytes();%0A++++assert_eq!(%0A++++++++bytes,%0A++++++++if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++++++%5B0x41,+0x48,+0x00,+0x00%5D%0A++++++++%7D+else+%7B%0A++++++++++++%5B0x00,+0x00,+0x48,+0x41%5D%0A++++++++%7D%0A++++);%0A%7D&edition=2021)\n\n1.40.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1358)\n\nCreate a floating point value from its representation as a byte array in big endian.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\n##### [§](#examples-48)Examples\n\n```\nlet value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\nassert_eq!(value, 12.5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_be_bytes(%5B0x41,+0x48,+0x00,+0x00%5D);%0A++++assert_eq!(value,+12.5);%0A%7D&edition=2021)\n\n1.40.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1377)\n\nCreate a floating point value from its representation as a byte array in little endian.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\n##### [§](#examples-49)Examples\n\n```\nlet value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\nassert_eq!(value, 12.5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_le_bytes(%5B0x00,+0x00,+0x48,+0x41%5D);%0A++++assert_eq!(value,+12.5);%0A%7D&edition=2021)\n\n1.40.0 (const: [unstable](https://github.com/rust-lang/rust/issues/72447 \"Tracking issue for const_float_bits_conv\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1407)\n\nCreate a floating point value from its representation as a byte array in native endian.\n\nAs the target platform’s native endianness is used, portable code likely wants to use [`from_be_bytes`](about:blank/primitive.f32.html#method.from_be_bytes \"associated function f32::from_be_bytes\") or [`from_le_bytes`](about:blank/primitive.f32.html#method.from_le_bytes \"associated function f32::from_le_bytes\"), as appropriate instead.\n\nSee [`from_bits`](about:blank/primitive.f32.html#method.from_bits \"associated function f32::from_bits\") for some discussion of the portability of this operation (there are almost no issues).\n\n##### [§](#examples-50)Examples\n\n```\nlet value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    [0x41, 0x48, 0x00, 0x00]\n} else {\n    [0x00, 0x00, 0x48, 0x41]\n});\nassert_eq!(value, 12.5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_ne_bytes(if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++%5B0x41,+0x48,+0x00,+0x00%5D%0A++++%7D+else+%7B%0A++++++++%5B0x00,+0x00,+0x48,+0x41%5D%0A++++%7D);%0A++++assert_eq!(value,+12.5);%0A%7D&edition=2021)\n\n1.62.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1473)\n\nReturn the ordering between `self` and `other`.\n\nUnlike the standard partial comparison between floating point numbers, this comparison always produces an ordering in accordance to the `totalOrder` predicate as defined in the IEEE 754 (2008 revision) floating point standard. The values are ordered in the following sequence:\n\n-   negative quiet NaN\n-   negative signaling NaN\n-   negative infinity\n-   negative numbers\n-   negative subnormal numbers\n-   negative zero\n-   positive zero\n-   positive subnormal numbers\n-   positive numbers\n-   positive infinity\n-   positive signaling NaN\n-   positive quiet NaN.\n\nThe ordering established by this function does not always agree with the [`PartialOrd`](cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\") and [`PartialEq`](cmp/trait.PartialEq.html \"trait std::cmp::PartialEq\") implementations of `f32`. For example, they consider negative and positive zero equal, while `total_cmp` doesn’t.\n\nThe interpretation of the signaling NaN bit follows the definition in the IEEE 754 standard, which may not match the interpretation by some of the older, non-conformant (e.g. MIPS) hardware implementations.\n\n##### [§](#example)Example\n\n```\nstruct GoodBoy {\n    name: String,\n    weight: f32,\n}\n\nlet mut bois = vec![\n    GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n    GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n    GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n    GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n    GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n    GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n];\n\nbois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n\n// `f32::NAN` could be positive or negative, which will affect the sort order.\nif f32::NAN.is_sign_negative() {\n    assert!(bois.into_iter().map(|b| b.weight)\n        .zip([f32::NAN, -5.0, 0.1, 10.0, 99.0, f32::INFINITY].iter())\n        .all(|(a, b)| a.to_bits() == b.to_bits()))\n} else {\n    assert!(bois.into_iter().map(|b| b.weight)\n        .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n        .all(|(a, b)| a.to_bits() == b.to_bits()))\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+GoodBoy+%7B%0A++++++++name:+String,%0A++++++++weight:+f32,%0A++++%7D%0A++++%0A++++let+mut+bois+=+vec!%5B%0A++++++++GoodBoy+%7B+name:+%22Pucci%22.to_owned(),+weight:+0.1+%7D,%0A++++++++GoodBoy+%7B+name:+%22Woofer%22.to_owned(),+weight:+99.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Yapper%22.to_owned(),+weight:+10.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Chonk%22.to_owned(),+weight:+f32::INFINITY+%7D,%0A++++++++GoodBoy+%7B+name:+%22Abs.+Unit%22.to_owned(),+weight:+f32::NAN+%7D,%0A++++++++GoodBoy+%7B+name:+%22Floaty%22.to_owned(),+weight:+-5.0+%7D,%0A++++%5D;%0A++++%0A++++bois.sort_by(%7Ca,+b%7C+a.weight.total_cmp(%26b.weight));%0A++++%0A++++//+%60f32::NAN%60+could+be+positive+or+negative,+which+will+affect+the+sort+order.%0A++++if+f32::NAN.is_sign_negative()+%7B%0A++++++++assert!(bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5Bf32::NAN,+-5.0,+0.1,+10.0,+99.0,+f32::INFINITY%5D.iter())%0A++++++++++++.all(%7C(a,+b)%7C+a.to_bits()+==+b.to_bits()))%0A++++%7D+else+%7B%0A++++++++assert!(bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5B-5.0,+0.1,+10.0,+99.0,+f32::INFINITY,+f32::NAN%5D.iter())%0A++++++++++++.all(%7C(a,+b)%7C+a.to_bits()+==+b.to_bits()))%0A++++%7D%0A%7D&edition=2021)\n\n1.50.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1528)\n\nRestrict a value to a certain interval unless it is NaN.\n\nReturns `max` if `self` is greater than `max`, and `min` if `self` is less than `min`. Otherwise this returns `self`.\n\nNote that this function returns NaN if the initial value was NaN as well.\n\n##### [§](#panics)Panics\n\nPanics if `min > max`, `min` is NaN, or `max` is NaN.\n\n##### [§](#examples-51)Examples\n\n```\nassert!((-3.0f32).clamp(-2.0, 1.0) == -2.0);\nassert!((0.0f32).clamp(-2.0, 1.0) == 0.0);\nassert!((2.0f32).clamp(-2.0, 1.0) == 1.0);\nassert!((f32::NAN).clamp(-2.0, 1.0).is_nan());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!((-3.0f32).clamp(-2.0,+1.0)+==+-2.0);%0A++++assert!((0.0f32).clamp(-2.0,+1.0)+==+0.0);%0A++++assert!((2.0f32).clamp(-2.0,+1.0)+==+1.0);%0A++++assert!((f32::NAN).clamp(-2.0,+1.0).is_nan());%0A%7D&edition=2021)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#impl-Add%3C%26f32%3E-for-%26f32)\n\n[§](#associatedtype.Output-11)\n\nThe resulting type after applying the `+` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#method.add-1)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#impl-Add%3C%26f32%3E-for-f32)\n\n[§](#associatedtype.Output-10)\n\nThe resulting type after applying the `+` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#method.add)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#impl-Add%3Cf32%3E-for-%26f32)\n\n[§](#associatedtype.Output-12)\n\nThe resulting type after applying the `+` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#method.add-2)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/90080 \"Tracking issue for const_ops\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#impl-Add-for-f32)\n\n[§](#associatedtype.Output-13)\n\nThe resulting type after applying the `+` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112)[§](#method.add-3)\n\n1.22.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768)[§](#impl-AddAssign%3C%26f32%3E-for-f32)\n\n1.8.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768)[§](#impl-AddAssign-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#227-232)[§](#impl-Clone-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229)[§](#impl-Debug-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/default.rs.html#182)[§](#impl-Default-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/default.rs.html#182)[§](#method.default)\n\nReturns the default value of `0.0`\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229)[§](#impl-Display-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#impl-Div%3C%26f32%3E-for-%26f32)\n\n[§](#associatedtype.Output-14)\n\nThe resulting type after applying the `/` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#method.div)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#impl-Div%3C%26f32%3E-for-f32)\n\n[§](#associatedtype.Output-17)\n\nThe resulting type after applying the `/` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#method.div-3)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#impl-Div%3Cf32%3E-for-%26f32)\n\n[§](#associatedtype.Output-16)\n\nThe resulting type after applying the `/` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#method.div-2)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#impl-Div-for-f32)\n\n[§](#associatedtype.Output-15)\n\nThe resulting type after applying the `/` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509)[§](#method.div-1)\n\n1.22.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950)[§](#impl-DivAssign%3C%26f32%3E-for-f32)\n\n1.8.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950)[§](#impl-DivAssign-for-f32)\n\n1.68.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#201)[§](#impl-From%3Cbool%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#201)[§](#method.from-6)\n\nConverts a [`bool`](primitive.bool.html \"primitive bool\") to [`f32`](primitive.f32.html \"primitive f32\") losslessly. The resulting value is positive `0.0` for `false` and `1.0` for `true` values.\n\n##### [§](#examples-52)Examples\n\n```\nlet x: f32 = false.into();\nassert_eq!(x, 0.0);\nassert!(x.is_sign_positive());\n\nlet y: f32 = true.into();\nassert_eq!(y, 1.0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+false.into();%0A++++assert_eq!(x,+0.0);%0A++++assert!(x.is_sign_positive());%0A++++%0A++++let+y:+f32+=+true.into();%0A++++assert_eq!(y,+1.0);%0A%7D&edition=2021)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#173)[§](#impl-From%3Cf32%3E-for-f128)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#172)[§](#impl-From%3Cf32%3E-for-f64)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#156)[§](#impl-From%3Ci16%3E-for-f32)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#154)[§](#impl-From%3Ci8%3E-for-f32)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#163)[§](#impl-From%3Cu16%3E-for-f32)\n\n1.6.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#161)[§](#impl-From%3Cu8%3E-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/num/dec2flt/mod.rs.html#163)[§](#impl-FromStr-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/num/dec2flt/mod.rs.html#163)[§](#method.from_str)\n\nConverts a string in base 10 to a float. Accepts an optional decimal exponent.\n\nThis function accepts strings such as\n\n-   ‘3.14’\n-   ‘-3.14’\n-   ‘2.5E10’, or equivalently, ‘2.5e10’\n-   ‘2.5E-10’\n-   ‘5.’\n-   ‘.5’, or, equivalently, ‘0.5’\n-   ‘inf’, ‘-inf’, ‘+infinity’, ‘NaN’\n\nNote that alphabetical characters are not case-sensitive.\n\nLeading and trailing whitespace represent an error.\n\n##### [§](#grammar)Grammar\n\nAll strings that adhere to the following [EBNF](https://www.w3.org/TR/REC-xml/#sec-notation) grammar when lowercased will result in an [`Ok`](about:blank/result/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") being returned:\n\n```txt\nFloat  ::= Sign? ( 'inf' | 'infinity' | 'nan' | Number )\nNumber ::= ( Digit+ |\n             Digit+ '.' Digit* |\n             Digit* '.' Digit+ ) Exp?\nExp    ::= 'e' Sign? Digit+\nSign   ::= [+-]\nDigit  ::= [0-9]\n\n```\n\n##### [§](#arguments)Arguments\n\n-   src - A string\n\n##### [§](#return-value)Return value\n\n`Err(ParseFloatError)` if the string did not represent a valid number. Otherwise, `Ok(n)` where `n` is the closest representable floating-point number to the number represented by `src` (following the same rules for rounding as for the results of primitive operations).\n\n[§](#associatedtype.Err)\n\nThe associated error which can be returned from parsing.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229)[§](#impl-LowerExp-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#impl-Mul%3C%26f32%3E-for-%26f32)\n\n[§](#associatedtype.Output-2)\n\nThe resulting type after applying the `*` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#method.mul-2)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#impl-Mul%3C%26f32%3E-for-f32)\n\n[§](#associatedtype.Output)\n\nThe resulting type after applying the `*` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#method.mul)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#impl-Mul%3Cf32%3E-for-%26f32)\n\n[§](#associatedtype.Output-3)\n\nThe resulting type after applying the `*` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#method.mul-3)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#impl-Mul-for-f32)\n\n[§](#associatedtype.Output-1)\n\nThe resulting type after applying the `*` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351)[§](#method.mul-1)\n\n1.22.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893)[§](#impl-MulAssign%3C%26f32%3E-for-f32)\n\n1.8.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893)[§](#impl-MulAssign-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701)[§](#impl-Neg-for-%26f32)\n\n[§](#associatedtype.Output-5)\n\nThe resulting type after applying the `-` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701)[§](#method.neg-1)\n\nPerforms the unary `-` operation. [Read more](about:blank/ops/trait.Neg.html#tymethod.neg)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701)[§](#impl-Neg-for-f32)\n\n[§](#associatedtype.Output-4)\n\nThe resulting type after applying the `-` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701)[§](#method.neg)\n\nPerforms the unary `-` operation. [Read more](about:blank/ops/trait.Neg.html#tymethod.neg)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/92391 \"Tracking issue for const_cmp\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502)[§](#impl-PartialEq-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502)[§](#method.eq)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502)[§](#method.ne)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554)[§](#impl-PartialOrd-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554)[§](#method.partial_cmp)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554)[§](#method.lt)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554)[§](#method.le)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554)[§](#method.ge)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554)[§](#method.gt)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.12.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#impl-Product%3C%26f32%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#method.product)\n\nMethod which takes an iterator and generates `Self` from the elements by multiplying the items.\n\n1.12.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#impl-Product-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#method.product-1)\n\nMethod which takes an iterator and generates `Self` from the elements by multiplying the items.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#impl-Rem%3C%26f32%3E-for-%26f32)\n\n[§](#associatedtype.Output-19)\n\nThe resulting type after applying the `%` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#method.rem-1)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#impl-Rem%3C%26f32%3E-for-f32)\n\n[§](#associatedtype.Output-18)\n\nThe resulting type after applying the `%` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#method.rem)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#impl-Rem%3Cf32%3E-for-%26f32)\n\n[§](#associatedtype.Output-21)\n\nThe resulting type after applying the `%` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#method.rem-3)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#impl-Rem-for-f32)\n\nThe remainder from the division of two floats.\n\nThe remainder has the same sign as the dividend and is computed as: `x - (x / y).trunc() * y`.\n\n#### [§](#examples-53)Examples\n\n```\nlet x: f32 = 50.50;\nlet y: f32 = 8.125;\nlet remainder = x - (x / y).trunc() * y;\n\n// The answer to both operations is 1.75\nassert_eq!(x % y, remainder);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+50.50;%0A++++let+y:+f32+=+8.125;%0A++++let+remainder+=+x+-+(x+/+y).trunc()+*+y;%0A++++%0A++++//+The+answer+to+both+operations+is+1.75%0A++++assert_eq!(x+%25+y,+remainder);%0A%7D&edition=2021)\n\n[§](#associatedtype.Output-20)\n\nThe resulting type after applying the `%` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626)[§](#method.rem-2)\n\n1.22.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011)[§](#impl-RemAssign%3C%26f32%3E-for-f32)\n\n1.8.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011)[§](#impl-RemAssign-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/vector.rs.html#1158)[§](#impl-SimdElement-for-f32)\n\n[§](#associatedtype.Mask)\n\n🔬This is a nightly-only experimental API. (`portable_simd` [#86656](https://github.com/rust-lang/rust/issues/86656))\n\nThe mask element type corresponding to this element type.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#impl-Sub%3C%26f32%3E-for-%26f32)\n\n[§](#associatedtype.Output-7)\n\nThe resulting type after applying the `-` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#method.sub-1)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#impl-Sub%3C%26f32%3E-for-f32)\n\n[§](#associatedtype.Output-9)\n\nThe resulting type after applying the `-` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#method.sub-3)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#impl-Sub%3Cf32%3E-for-%26f32)\n\n[§](#associatedtype.Output-8)\n\nThe resulting type after applying the `-` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#method.sub-2)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#impl-Sub-for-f32)\n\n[§](#associatedtype.Output-6)\n\nThe resulting type after applying the `-` operator.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221)[§](#method.sub)\n\n1.22.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835)[§](#impl-SubAssign%3C%26f32%3E-for-f32)\n\n1.8.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835)[§](#impl-SubAssign-for-f32)\n\n1.12.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#impl-Sum%3C%26f32%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#method.sum)\n\nMethod which takes an iterator and generates `Self` from the elements by “summing up” the items.\n\n1.12.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#impl-Sum-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150)[§](#method.sum-1)\n\nMethod which takes an iterator and generates `Self` from the elements by “summing up” the items.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229)[§](#impl-UpperExp-for-f32)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/marker.rs.html#420-430)[§](#impl-Copy-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Ci128%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Ci16%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Ci32%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Ci64%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Ci8%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cisize%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cu128%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cu16%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cu32%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cu64%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cu8%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38)[§](#impl-FloatToInt%3Cusize%3E-for-f32)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/cast.rs.html#48)[§](#impl-SimdCast-for-f32)\n\n[§](#impl-Freeze-for-f32)\n\n[§](#impl-RefUnwindSafe-for-f32)\n\n[§](#impl-Send-for-f32)\n\n[§](#impl-Sync-for-f32)\n\n[§](#impl-Unpin-for-f32)\n\n[§](#impl-UnwindSafe-for-f32)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A 32-bit floating point type (specifically, the “binary32” type defined in IEEE 754-2008).\"><title>f32 - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../\" data-static-root-path=\"../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc primitive\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../std/index.html\"><img class=\"rust-logo\" src=\"../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">f32</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../std/index.html\"><img class=\"rust-logo\" src=\"../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">f32</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Associated Constants</a></h3><ul class=\"block associatedconstant\"><li><a href=\"#associatedconstant.DIGITS\">DIGITS</a></li><li><a href=\"#associatedconstant.EPSILON\">EPSILON</a></li><li><a href=\"#associatedconstant.INFINITY\">INFINITY</a></li><li><a href=\"#associatedconstant.MANTISSA_DIGITS\">MANTISSA_DIGITS</a></li><li><a href=\"#associatedconstant.MAX\">MAX</a></li><li><a href=\"#associatedconstant.MAX_10_EXP\">MAX_10_EXP</a></li><li><a href=\"#associatedconstant.MAX_EXP\">MAX_EXP</a></li><li><a href=\"#associatedconstant.MIN\">MIN</a></li><li><a href=\"#associatedconstant.MIN_10_EXP\">MIN_10_EXP</a></li><li><a href=\"#associatedconstant.MIN_EXP\">MIN_EXP</a></li><li><a href=\"#associatedconstant.MIN_POSITIVE\">MIN_POSITIVE</a></li><li><a href=\"#associatedconstant.NAN\">NAN</a></li><li><a href=\"#associatedconstant.NEG_INFINITY\">NEG_INFINITY</a></li><li><a href=\"#associatedconstant.RADIX\">RADIX</a></li></ul><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.abs\">abs</a></li><li><a href=\"#method.abs_sub\">abs_sub</a></li><li><a href=\"#method.acos\">acos</a></li><li><a href=\"#method.acosh\">acosh</a></li><li><a href=\"#method.asin\">asin</a></li><li><a href=\"#method.asinh\">asinh</a></li><li><a href=\"#method.atan\">atan</a></li><li><a href=\"#method.atan2\">atan2</a></li><li><a href=\"#method.atanh\">atanh</a></li><li><a href=\"#method.cbrt\">cbrt</a></li><li><a href=\"#method.ceil\">ceil</a></li><li><a href=\"#method.clamp\">clamp</a></li><li><a href=\"#method.classify\">classify</a></li><li><a href=\"#method.copysign\">copysign</a></li><li><a href=\"#method.cos\">cos</a></li><li><a href=\"#method.cosh\">cosh</a></li><li><a href=\"#method.div_euclid\">div_euclid</a></li><li><a href=\"#method.exp\">exp</a></li><li><a href=\"#method.exp2\">exp2</a></li><li><a href=\"#method.exp_m1\">exp_m1</a></li><li><a href=\"#method.floor\">floor</a></li><li><a href=\"#method.fract\">fract</a></li><li><a href=\"#method.from_be_bytes\">from_be_bytes</a></li><li><a href=\"#method.from_bits\">from_bits</a></li><li><a href=\"#method.from_le_bytes\">from_le_bytes</a></li><li><a href=\"#method.from_ne_bytes\">from_ne_bytes</a></li><li><a href=\"#method.gamma\">gamma</a></li><li><a href=\"#method.hypot\">hypot</a></li><li><a href=\"#method.is_finite\">is_finite</a></li><li><a href=\"#method.is_infinite\">is_infinite</a></li><li><a href=\"#method.is_nan\">is_nan</a></li><li><a href=\"#method.is_normal\">is_normal</a></li><li><a href=\"#method.is_sign_negative\">is_sign_negative</a></li><li><a href=\"#method.is_sign_positive\">is_sign_positive</a></li><li><a href=\"#method.is_subnormal\">is_subnormal</a></li><li><a href=\"#method.ln\">ln</a></li><li><a href=\"#method.ln_1p\">ln_1p</a></li><li><a href=\"#method.ln_gamma\">ln_gamma</a></li><li><a href=\"#method.log\">log</a></li><li><a href=\"#method.log10\">log10</a></li><li><a href=\"#method.log2\">log2</a></li><li><a href=\"#method.max\">max</a></li><li><a href=\"#method.maximum\">maximum</a></li><li><a href=\"#method.midpoint\">midpoint</a></li><li><a href=\"#method.min\">min</a></li><li><a href=\"#method.minimum\">minimum</a></li><li><a href=\"#method.mul_add\">mul_add</a></li><li><a href=\"#method.next_down\">next_down</a></li><li><a href=\"#method.next_up\">next_up</a></li><li><a href=\"#method.powf\">powf</a></li><li><a href=\"#method.powi\">powi</a></li><li><a href=\"#method.recip\">recip</a></li><li><a href=\"#method.rem_euclid\">rem_euclid</a></li><li><a href=\"#method.round\">round</a></li><li><a href=\"#method.round_ties_even\">round_ties_even</a></li><li><a href=\"#method.signum\">signum</a></li><li><a href=\"#method.sin\">sin</a></li><li><a href=\"#method.sin_cos\">sin_cos</a></li><li><a href=\"#method.sinh\">sinh</a></li><li><a href=\"#method.sqrt\">sqrt</a></li><li><a href=\"#method.tan\">tan</a></li><li><a href=\"#method.tanh\">tanh</a></li><li><a href=\"#method.to_be_bytes\">to_be_bytes</a></li><li><a href=\"#method.to_bits\">to_bits</a></li><li><a href=\"#method.to_degrees\">to_degrees</a></li><li><a href=\"#method.to_int_unchecked\">to_int_unchecked</a></li><li><a href=\"#method.to_le_bytes\">to_le_bytes</a></li><li><a href=\"#method.to_ne_bytes\">to_ne_bytes</a></li><li><a href=\"#method.to_radians\">to_radians</a></li><li><a href=\"#method.total_cmp\">total_cmp</a></li><li><a href=\"#method.trunc\">trunc</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Add-for-f32\">Add</a></li><li><a href=\"#impl-Add%3C%26f32%3E-for-%26f32\">Add&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Add%3C%26f32%3E-for-f32\">Add&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Add%3Cf32%3E-for-%26f32\">Add&lt;f32&gt;</a></li><li><a href=\"#impl-AddAssign-for-f32\">AddAssign</a></li><li><a href=\"#impl-AddAssign%3C%26f32%3E-for-f32\">AddAssign&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Clone-for-f32\">Clone</a></li><li><a href=\"#impl-Copy-for-f32\">Copy</a></li><li><a href=\"#impl-Debug-for-f32\">Debug</a></li><li><a href=\"#impl-Default-for-f32\">Default</a></li><li><a href=\"#impl-Display-for-f32\">Display</a></li><li><a href=\"#impl-Div-for-f32\">Div</a></li><li><a href=\"#impl-Div%3C%26f32%3E-for-%26f32\">Div&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Div%3C%26f32%3E-for-f32\">Div&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Div%3Cf32%3E-for-%26f32\">Div&lt;f32&gt;</a></li><li><a href=\"#impl-DivAssign-for-f32\">DivAssign</a></li><li><a href=\"#impl-DivAssign%3C%26f32%3E-for-f32\">DivAssign&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-FloatToInt%3Ci128%3E-for-f32\">FloatToInt&lt;i128&gt;</a></li><li><a href=\"#impl-FloatToInt%3Ci16%3E-for-f32\">FloatToInt&lt;i16&gt;</a></li><li><a href=\"#impl-FloatToInt%3Ci32%3E-for-f32\">FloatToInt&lt;i32&gt;</a></li><li><a href=\"#impl-FloatToInt%3Ci64%3E-for-f32\">FloatToInt&lt;i64&gt;</a></li><li><a href=\"#impl-FloatToInt%3Ci8%3E-for-f32\">FloatToInt&lt;i8&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cisize%3E-for-f32\">FloatToInt&lt;isize&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cu128%3E-for-f32\">FloatToInt&lt;u128&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cu16%3E-for-f32\">FloatToInt&lt;u16&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cu32%3E-for-f32\">FloatToInt&lt;u32&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cu64%3E-for-f32\">FloatToInt&lt;u64&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cu8%3E-for-f32\">FloatToInt&lt;u8&gt;</a></li><li><a href=\"#impl-FloatToInt%3Cusize%3E-for-f32\">FloatToInt&lt;usize&gt;</a></li><li><a href=\"#impl-From%3Cbool%3E-for-f32\">From&lt;bool&gt;</a></li><li><a href=\"#impl-From%3Cf32%3E-for-f128\">From&lt;f32&gt;</a></li><li><a href=\"#impl-From%3Cf32%3E-for-f64\">From&lt;f32&gt;</a></li><li><a href=\"#impl-From%3Ci16%3E-for-f32\">From&lt;i16&gt;</a></li><li><a href=\"#impl-From%3Ci8%3E-for-f32\">From&lt;i8&gt;</a></li><li><a href=\"#impl-From%3Cu16%3E-for-f32\">From&lt;u16&gt;</a></li><li><a href=\"#impl-From%3Cu8%3E-for-f32\">From&lt;u8&gt;</a></li><li><a href=\"#impl-FromStr-for-f32\">FromStr</a></li><li><a href=\"#impl-LowerExp-for-f32\">LowerExp</a></li><li><a href=\"#impl-Mul-for-f32\">Mul</a></li><li><a href=\"#impl-Mul%3C%26f32%3E-for-%26f32\">Mul&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Mul%3C%26f32%3E-for-f32\">Mul&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Mul%3Cf32%3E-for-%26f32\">Mul&lt;f32&gt;</a></li><li><a href=\"#impl-MulAssign-for-f32\">MulAssign</a></li><li><a href=\"#impl-MulAssign%3C%26f32%3E-for-f32\">MulAssign&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Neg-for-%26f32\">Neg</a></li><li><a href=\"#impl-Neg-for-f32\">Neg</a></li><li><a href=\"#impl-PartialEq-for-f32\">PartialEq</a></li><li><a href=\"#impl-PartialOrd-for-f32\">PartialOrd</a></li><li><a href=\"#impl-Product-for-f32\">Product</a></li><li><a href=\"#impl-Product%3C%26f32%3E-for-f32\">Product&lt;&amp;'a f32&gt;</a></li><li><a href=\"#impl-Rem-for-f32\">Rem</a></li><li><a href=\"#impl-Rem%3C%26f32%3E-for-%26f32\">Rem&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Rem%3C%26f32%3E-for-f32\">Rem&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Rem%3Cf32%3E-for-%26f32\">Rem&lt;f32&gt;</a></li><li><a href=\"#impl-RemAssign-for-f32\">RemAssign</a></li><li><a href=\"#impl-RemAssign%3C%26f32%3E-for-f32\">RemAssign&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-SimdCast-for-f32\">SimdCast</a></li><li><a href=\"#impl-SimdElement-for-f32\">SimdElement</a></li><li><a href=\"#impl-Sub-for-f32\">Sub</a></li><li><a href=\"#impl-Sub%3C%26f32%3E-for-%26f32\">Sub&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Sub%3C%26f32%3E-for-f32\">Sub&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Sub%3Cf32%3E-for-%26f32\">Sub&lt;f32&gt;</a></li><li><a href=\"#impl-SubAssign-for-f32\">SubAssign</a></li><li><a href=\"#impl-SubAssign%3C%26f32%3E-for-f32\">SubAssign&lt;&amp;f32&gt;</a></li><li><a href=\"#impl-Sum-for-f32\">Sum</a></li><li><a href=\"#impl-Sum%3C%26f32%3E-for-f32\">Sum&lt;&amp;'a f32&gt;</a></li><li><a href=\"#impl-UpperExp-for-f32\">UpperExp</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-f32\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-f32\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-f32\">Send</a></li><li><a href=\"#impl-Sync-for-f32\">Sync</a></li><li><a href=\"#impl-Unpin-for-f32\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-f32\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-ToString-for-T\">ToString</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In crate std</a></h2><h3><a href=\"index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"primitive.array.html\">array</a></li><li><a href=\"primitive.bool.html\">bool</a></li><li><a href=\"primitive.char.html\">char</a></li><li><a href=\"primitive.f128.html\">f128</a></li><li><a href=\"primitive.f16.html\">f16</a></li><li><a href=\"primitive.f32.html\">f32</a></li><li><a href=\"primitive.f64.html\">f64</a></li><li><a href=\"primitive.fn.html\">fn</a></li><li><a href=\"primitive.i128.html\">i128</a></li><li><a href=\"primitive.i16.html\">i16</a></li><li><a href=\"primitive.i32.html\">i32</a></li><li><a href=\"primitive.i64.html\">i64</a></li><li><a href=\"primitive.i8.html\">i8</a></li><li><a href=\"primitive.isize.html\">isize</a></li><li><a href=\"primitive.never.html\">never</a></li><li><a href=\"primitive.pointer.html\">pointer</a></li><li><a href=\"primitive.reference.html\">reference</a></li><li><a href=\"primitive.slice.html\">slice</a></li><li><a href=\"primitive.str.html\">str</a></li><li><a href=\"primitive.tuple.html\">tuple</a></li><li><a href=\"primitive.u128.html\">u128</a></li><li><a href=\"primitive.u16.html\">u16</a></li><li><a href=\"primitive.u32.html\">u32</a></li><li><a href=\"primitive.u64.html\">u64</a></li><li><a href=\"primitive.u8.html\">u8</a></li><li><a href=\"primitive.unit.html\">unit</a></li><li><a href=\"primitive.usize.html\">usize</a></li></ul><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"alloc/index.html\">alloc</a></li><li><a href=\"any/index.html\">any</a></li><li><a href=\"arch/index.html\">arch</a></li><li><a href=\"array/index.html\">array</a></li><li><a href=\"ascii/index.html\">ascii</a></li><li><a href=\"assert_matches/index.html\">assert_matches</a></li><li><a href=\"async_iter/index.html\">async_iter</a></li><li><a href=\"backtrace/index.html\">backtrace</a></li><li><a href=\"borrow/index.html\">borrow</a></li><li><a href=\"boxed/index.html\">boxed</a></li><li><a href=\"cell/index.html\">cell</a></li><li><a href=\"char/index.html\">char</a></li><li><a href=\"clone/index.html\">clone</a></li><li><a href=\"cmp/index.html\">cmp</a></li><li><a href=\"collections/index.html\">collections</a></li><li><a href=\"convert/index.html\">convert</a></li><li><a href=\"default/index.html\">default</a></li><li><a href=\"env/index.html\">env</a></li><li><a href=\"error/index.html\">error</a></li><li><a href=\"f128/index.html\">f128</a></li><li><a href=\"f16/index.html\">f16</a></li><li><a href=\"f32/index.html\">f32</a></li><li><a href=\"f64/index.html\">f64</a></li><li><a href=\"ffi/index.html\">ffi</a></li><li><a href=\"fmt/index.html\">fmt</a></li><li><a href=\"fs/index.html\">fs</a></li><li><a href=\"future/index.html\">future</a></li><li><a href=\"hash/index.html\">hash</a></li><li><a href=\"hint/index.html\">hint</a></li><li><a href=\"i128/index.html\">i128</a></li><li><a href=\"i16/index.html\">i16</a></li><li><a href=\"i32/index.html\">i32</a></li><li><a href=\"i64/index.html\">i64</a></li><li><a href=\"i8/index.html\">i8</a></li><li><a href=\"intrinsics/index.html\">intrinsics</a></li><li><a href=\"io/index.html\">io</a></li><li><a href=\"isize/index.html\">isize</a></li><li><a href=\"iter/index.html\">iter</a></li><li><a href=\"marker/index.html\">marker</a></li><li><a href=\"mem/index.html\">mem</a></li><li><a href=\"net/index.html\">net</a></li><li><a href=\"num/index.html\">num</a></li><li><a href=\"ops/index.html\">ops</a></li><li><a href=\"option/index.html\">option</a></li><li><a href=\"os/index.html\">os</a></li><li><a href=\"panic/index.html\">panic</a></li><li><a href=\"pat/index.html\">pat</a></li><li><a href=\"path/index.html\">path</a></li><li><a href=\"pin/index.html\">pin</a></li><li><a href=\"prelude/index.html\">prelude</a></li><li><a href=\"primitive/index.html\">primitive</a></li><li><a href=\"process/index.html\">process</a></li><li><a href=\"ptr/index.html\">ptr</a></li><li><a href=\"rc/index.html\">rc</a></li><li><a href=\"result/index.html\">result</a></li><li><a href=\"simd/index.html\">simd</a></li><li><a href=\"slice/index.html\">slice</a></li><li><a href=\"str/index.html\">str</a></li><li><a href=\"string/index.html\">string</a></li><li><a href=\"sync/index.html\">sync</a></li><li><a href=\"task/index.html\">task</a></li><li><a href=\"thread/index.html\">thread</a></li><li><a href=\"time/index.html\">time</a></li><li><a href=\"u128/index.html\">u128</a></li><li><a href=\"u16/index.html\">u16</a></li><li><a href=\"u32/index.html\">u32</a></li><li><a href=\"u64/index.html\">u64</a></li><li><a href=\"u8/index.html\">u8</a></li><li><a href=\"usize/index.html\">usize</a></li><li><a href=\"vec/index.html\">vec</a></li></ul><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.assert.html\">assert</a></li><li><a href=\"macro.assert_eq.html\">assert_eq</a></li><li><a href=\"macro.assert_ne.html\">assert_ne</a></li><li><a href=\"macro.cfg.html\">cfg</a></li><li><a href=\"macro.cfg_match.html\">cfg_match</a></li><li><a href=\"macro.column.html\">column</a></li><li><a href=\"macro.compile_error.html\">compile_error</a></li><li><a href=\"macro.concat.html\">concat</a></li><li><a href=\"macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"macro.concat_idents.html\">concat_idents</a></li><li><a href=\"macro.const_format_args.html\">const_format_args</a></li><li><a href=\"macro.dbg.html\">dbg</a></li><li><a href=\"macro.debug_assert.html\">debug_assert</a></li><li><a href=\"macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"macro.env.html\">env</a></li><li><a href=\"macro.eprint.html\">eprint</a></li><li><a href=\"macro.eprintln.html\">eprintln</a></li><li><a href=\"macro.file.html\">file</a></li><li><a href=\"macro.format.html\">format</a></li><li><a href=\"macro.format_args.html\">format_args</a></li><li><a href=\"macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"macro.include.html\">include</a></li><li><a href=\"macro.include_bytes.html\">include_bytes</a></li><li><a href=\"macro.include_str.html\">include_str</a></li><li><a href=\"macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"macro.line.html\">line</a></li><li><a href=\"macro.log_syntax.html\">log_syntax</a></li><li><a href=\"macro.matches.html\">matches</a></li><li><a href=\"macro.module_path.html\">module_path</a></li><li><a href=\"macro.option_env.html\">option_env</a></li><li><a href=\"macro.panic.html\">panic</a></li><li><a href=\"macro.print.html\">print</a></li><li><a href=\"macro.println.html\">println</a></li><li><a href=\"macro.stringify.html\">stringify</a></li><li><a href=\"macro.thread_local.html\">thread_local</a></li><li><a href=\"macro.todo.html\">todo</a></li><li><a href=\"macro.trace_macros.html\">trace_macros</a></li><li><a href=\"macro.try.html\">try</a></li><li><a href=\"macro.unimplemented.html\">unimplemented</a></li><li><a href=\"macro.unreachable.html\">unreachable</a></li><li><a href=\"macro.vec.html\">vec</a></li><li><a href=\"macro.write.html\">write</a></li><li><a href=\"macro.writeln.html\">writeln</a></li></ul><h3><a href=\"index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"keyword.as.html\">as</a></li><li><a href=\"keyword.async.html\">async</a></li><li><a href=\"keyword.await.html\">await</a></li><li><a href=\"keyword.break.html\">break</a></li><li><a href=\"keyword.const.html\">const</a></li><li><a href=\"keyword.continue.html\">continue</a></li><li><a href=\"keyword.crate.html\">crate</a></li><li><a href=\"keyword.dyn.html\">dyn</a></li><li><a href=\"keyword.else.html\">else</a></li><li><a href=\"keyword.enum.html\">enum</a></li><li><a href=\"keyword.extern.html\">extern</a></li><li><a href=\"keyword.false.html\">false</a></li><li><a href=\"keyword.fn.html\">fn</a></li><li><a href=\"keyword.for.html\">for</a></li><li><a href=\"keyword.if.html\">if</a></li><li><a href=\"keyword.impl.html\">impl</a></li><li><a href=\"keyword.in.html\">in</a></li><li><a href=\"keyword.let.html\">let</a></li><li><a href=\"keyword.loop.html\">loop</a></li><li><a href=\"keyword.match.html\">match</a></li><li><a href=\"keyword.mod.html\">mod</a></li><li><a href=\"keyword.move.html\">move</a></li><li><a href=\"keyword.mut.html\">mut</a></li><li><a href=\"keyword.pub.html\">pub</a></li><li><a href=\"keyword.ref.html\">ref</a></li><li><a href=\"keyword.return.html\">return</a></li><li><a href=\"keyword.self.html\">self</a></li><li><a href=\"keyword.static.html\">static</a></li><li><a href=\"keyword.struct.html\">struct</a></li><li><a href=\"keyword.super.html\">super</a></li><li><a href=\"keyword.trait.html\">trait</a></li><li><a href=\"keyword.true.html\">true</a></li><li><a href=\"keyword.type.html\">type</a></li><li><a href=\"keyword.union.html\">union</a></li><li><a href=\"keyword.unsafe.html\">unsafe</a></li><li><a href=\"keyword.use.html\">use</a></li><li><a href=\"keyword.where.html\">where</a></li><li><a href=\"keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Primitive Type <a class=\"primitive\" href=\"#\">f32</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A 32-bit floating point type (specifically, the “binary32” type defined in IEEE 754-2008).</p>\n<p>This type can represent a wide range of decimal numbers, like <code>3.5</code>, <code>27</code>,\n<code>-113.75</code>, <code>0.0078125</code>, <code>34359738368</code>, <code>0</code>, <code>-1</code>. So unlike integer types\n(such as <code>i32</code>), floating point types can represent non-integer numbers,\ntoo.</p>\n<p>However, being able to represent this wide range of numbers comes at the\ncost of precision: floats can only represent some of the real numbers and\ncalculation with floats round to a nearby representable number. For example,\n<code>5.0</code> and <code>1.0</code> can be exactly represented as <code>f32</code>, but <code>1.0 / 5.0</code> results\nin <code>0.20000000298023223876953125</code> since <code>0.2</code> cannot be exactly represented\nas <code>f32</code>. Note, however, that printing floats with <code>println</code> and friends will\noften discard insignificant digits: <code>println!(\"{}\", 1.0f32 / 5.0f32)</code> will\nprint <code>0.2</code>.</p>\n<p>Additionally, <code>f32</code> can represent some special values:</p>\n<ul>\n<li>−0.0: IEEE 754 floating point numbers have a bit that indicates their sign, so −0.0 is a\npossible value. For comparison −0.0 = +0.0, but floating point operations can carry\nthe sign bit through arithmetic operations. This means −0.0 × +0.0 produces −0.0 and\na negative number rounded to a value smaller than a float can represent also produces −0.0.</li>\n<li><a href=\"#associatedconstant.INFINITY\">∞</a> and\n<a href=\"#associatedconstant.NEG_INFINITY\">−∞</a>: these result from calculations\nlike <code>1.0 / 0.0</code>.</li>\n<li><a href=\"#associatedconstant.NAN\">NaN (not a number)</a>: this value results from\ncalculations like <code>(-1.0).sqrt()</code>. NaN has some potentially unexpected\nbehavior:\n<ul>\n<li>It is not equal to any float, including itself! This is the reason <code>f32</code>\ndoesn’t implement the <code>Eq</code> trait.</li>\n<li>It is also neither smaller nor greater than any float, making it\nimpossible to sort by the default comparison operation, which is the\nreason <code>f32</code> doesn’t implement the <code>Ord</code> trait.</li>\n<li>It is also considered <em>infectious</em> as almost all calculations where one\nof the operands is NaN will also result in NaN. The explanations on this\npage only explicitly document behavior on NaN operands if this default\nis deviated from.</li>\n<li>Lastly, there are multiple bit patterns that are considered NaN.\nRust does not currently guarantee that the bit patterns of NaN are\npreserved over arithmetic operations, and they are not guaranteed to be\nportable or even fully deterministic! This means that there may be some\nsurprising results upon inspecting the bit patterns,\nas the same calculations might produce NaNs with different bit patterns.</li>\n</ul>\n</li>\n</ul>\n<p>When a primitive operation (addition, subtraction, multiplication, or\ndivision) is performed on this type, the result is rounded according to the\nroundTiesToEven direction defined in IEEE 754-2008. That means:</p>\n<ul>\n<li>The result is the representable value closest to the true value, if there\nis a unique closest representable value.</li>\n<li>If the true value is exactly half-way between two representable values,\nthe result is the one with an even least-significant binary digit.</li>\n<li>If the true value’s magnitude is ≥ <code>f32::MAX</code> + 2<sup>(<code>f32::MAX_EXP</code> −\n<code>f32::MANTISSA_DIGITS</code> − 1)</sup>, the result is ∞ or −∞ (preserving the\ntrue value’s sign).</li>\n<li>If the result of a sum exactly equals zero, the outcome is +0.0 unless\nboth arguments were negative, then it is -0.0. Subtraction <code>a - b</code> is\nregarded as a sum <code>a + (-b)</code>.</li>\n</ul>\n<p>For more information on floating point numbers, see <a href=\"https://en.wikipedia.org/wiki/Single-precision_floating-point_format\">Wikipedia</a>.</p>\n<p><em><a href=\"f32/consts/index.html\" title=\"mod std::f32::consts\">See also the <code>std::f32::consts</code> module</a>.</em></p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-f32\" class=\"impl\"><a class=\"src rightside\" href=\"../src/std/f32.rs.html#31-1228\">source</a><a href=\"#impl-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.floor\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#51-53\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.floor\" class=\"fn\">floor</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the largest integer less than or equal to <code>self</code>.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.7_f32</span>;\n<span class=\"kw\">let </span>g = <span class=\"number\">3.0_f32</span>;\n<span class=\"kw\">let </span>h = -<span class=\"number\">3.7_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.floor(), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(g.floor(), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(h.floor(), -<span class=\"number\">4.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.7_f32;%0A++++let+g+=+3.0_f32;%0A++++let+h+=+-3.7_f32;%0A++++%0A++++assert_eq!(f.floor(),+3.0);%0A++++assert_eq!(g.floor(),+3.0);%0A++++assert_eq!(h.floor(),+-4.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ceil\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#73-75\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.ceil\" class=\"fn\">ceil</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the smallest integer greater than or equal to <code>self</code>.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.01_f32</span>;\n<span class=\"kw\">let </span>g = <span class=\"number\">4.0_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.ceil(), <span class=\"number\">4.0</span>);\n<span class=\"macro\">assert_eq!</span>(g.ceil(), <span class=\"number\">4.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.01_f32;%0A++++let+g+=+4.0_f32;%0A++++%0A++++assert_eq!(f.ceil(),+4.0);%0A++++assert_eq!(g.ceil(),+4.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.round\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#101-103\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.round\" class=\"fn\">round</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the nearest integer to <code>self</code>. If a value is half-way between two\nintegers, round away from <code>0.0</code>.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.3_f32</span>;\n<span class=\"kw\">let </span>g = -<span class=\"number\">3.3_f32</span>;\n<span class=\"kw\">let </span>h = -<span class=\"number\">3.7_f32</span>;\n<span class=\"kw\">let </span>i = <span class=\"number\">3.5_f32</span>;\n<span class=\"kw\">let </span>j = <span class=\"number\">4.5_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.round(), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(g.round(), -<span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(h.round(), -<span class=\"number\">4.0</span>);\n<span class=\"macro\">assert_eq!</span>(i.round(), <span class=\"number\">4.0</span>);\n<span class=\"macro\">assert_eq!</span>(j.round(), <span class=\"number\">5.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.3_f32;%0A++++let+g+=+-3.3_f32;%0A++++let+h+=+-3.7_f32;%0A++++let+i+=+3.5_f32;%0A++++let+j+=+4.5_f32;%0A++++%0A++++assert_eq!(f.round(),+3.0);%0A++++assert_eq!(g.round(),+-3.0);%0A++++assert_eq!(h.round(),+-4.0);%0A++++assert_eq!(i.round(),+4.0);%0A++++assert_eq!(j.round(),+5.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.round_ties_even\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#127-129\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.round_ties_even\" class=\"fn\">round_ties_even</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the nearest integer to a number. Rounds half-way cases to the number\nwith an even least significant digit.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.3_f32</span>;\n<span class=\"kw\">let </span>g = -<span class=\"number\">3.3_f32</span>;\n<span class=\"kw\">let </span>h = <span class=\"number\">3.5_f32</span>;\n<span class=\"kw\">let </span>i = <span class=\"number\">4.5_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.round_ties_even(), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(g.round_ties_even(), -<span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(h.round_ties_even(), <span class=\"number\">4.0</span>);\n<span class=\"macro\">assert_eq!</span>(i.round_ties_even(), <span class=\"number\">4.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.3_f32;%0A++++let+g+=+-3.3_f32;%0A++++let+h+=+3.5_f32;%0A++++let+i+=+4.5_f32;%0A++++%0A++++assert_eq!(f.round_ties_even(),+3.0);%0A++++assert_eq!(g.round_ties_even(),+-3.0);%0A++++assert_eq!(h.round_ties_even(),+4.0);%0A++++assert_eq!(i.round_ties_even(),+4.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.trunc\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#152-154\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.trunc\" class=\"fn\">trunc</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the integer part of <code>self</code>.\nThis means that non-integer numbers are always truncated towards zero.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.7_f32</span>;\n<span class=\"kw\">let </span>g = <span class=\"number\">3.0_f32</span>;\n<span class=\"kw\">let </span>h = -<span class=\"number\">3.7_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.trunc(), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(g.trunc(), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>(h.trunc(), -<span class=\"number\">3.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.7_f32;%0A++++let+g+=+3.0_f32;%0A++++let+h+=+-3.7_f32;%0A++++%0A++++assert_eq!(f.trunc(),+3.0);%0A++++assert_eq!(g.trunc(),+3.0);%0A++++assert_eq!(h.trunc(),+-3.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fract\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#175-177\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.fract\" class=\"fn\">fract</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the fractional part of <code>self</code>.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">3.6_f32</span>;\n<span class=\"kw\">let </span>y = -<span class=\"number\">3.6_f32</span>;\n<span class=\"kw\">let </span>abs_difference_x = (x.fract() - <span class=\"number\">0.6</span>).abs();\n<span class=\"kw\">let </span>abs_difference_y = (y.fract() - (-<span class=\"number\">0.6</span>)).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference_x &lt;= f32::EPSILON);\n<span class=\"macro\">assert!</span>(abs_difference_y &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.6_f32;%0A++++let+y+=+-3.6_f32;%0A++++let+abs_difference_x+=+(x.fract()+-+0.6).abs();%0A++++let+abs_difference_y+=+(y.fract()+-+(-0.6)).abs();%0A++++%0A++++assert!(abs_difference_x+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_y+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.abs\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#198-200\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.abs\" class=\"fn\">abs</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the absolute value of <code>self</code>.</p>\n<p>This function always returns the precise result.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">3.5_f32</span>;\n<span class=\"kw\">let </span>y = -<span class=\"number\">3.5_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(x.abs(), x);\n<span class=\"macro\">assert_eq!</span>(y.abs(), -y);\n\n<span class=\"macro\">assert!</span>(f32::NAN.abs().is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.5_f32;%0A++++let+y+=+-3.5_f32;%0A++++%0A++++assert_eq!(x.abs(),+x);%0A++++assert_eq!(y.abs(),+-y);%0A++++%0A++++assert!(f32::NAN.abs().is_nan());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.signum\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#222-224\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.signum\" class=\"fn\">signum</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns a number that represents the sign of <code>self</code>.</p>\n<ul>\n<li><code>1.0</code> if the number is positive, <code>+0.0</code> or <code>INFINITY</code></li>\n<li><code>-1.0</code> if the number is negative, <code>-0.0</code> or <code>NEG_INFINITY</code></li>\n<li>NaN if the number is NaN</li>\n</ul>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.5_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.signum(), <span class=\"number\">1.0</span>);\n<span class=\"macro\">assert_eq!</span>(f32::NEG_INFINITY.signum(), -<span class=\"number\">1.0</span>);\n\n<span class=\"macro\">assert!</span>(f32::NAN.signum().is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.5_f32;%0A++++%0A++++assert_eq!(f.signum(),+1.0);%0A++++assert_eq!(f32::NEG_INFINITY.signum(),+-1.0);%0A++++%0A++++assert!(f32::NAN.signum().is_nan());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.copysign\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.35.0\">1.35.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#251-253\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.copysign\" class=\"fn\">copysign</a>(self, sign: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns a number composed of the magnitude of <code>self</code> and the sign of\n<code>sign</code>.</p>\n<p>Equal to <code>self</code> if the sign of <code>self</code> and <code>sign</code> are the same, otherwise\nequal to <code>-self</code>. If <code>self</code> is a NaN, then a NaN with the sign bit of\n<code>sign</code> is returned. Note, however, that conserving the sign bit on NaN\nacross arithmetical operations is not generally guaranteed.\nSee <a href=\"primitive.f32.html\" title=\"primitive f32\">explanation of NaN as a special value</a> for more info.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">3.5_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(f.copysign(<span class=\"number\">0.42</span>), <span class=\"number\">3.5_f32</span>);\n<span class=\"macro\">assert_eq!</span>(f.copysign(-<span class=\"number\">0.42</span>), -<span class=\"number\">3.5_f32</span>);\n<span class=\"macro\">assert_eq!</span>((-f).copysign(<span class=\"number\">0.42</span>), <span class=\"number\">3.5_f32</span>);\n<span class=\"macro\">assert_eq!</span>((-f).copysign(-<span class=\"number\">0.42</span>), -<span class=\"number\">3.5_f32</span>);\n\n<span class=\"macro\">assert!</span>(f32::NAN.copysign(<span class=\"number\">1.0</span>).is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.5_f32;%0A++++%0A++++assert_eq!(f.copysign(0.42),+3.5_f32);%0A++++assert_eq!(f.copysign(-0.42),+-3.5_f32);%0A++++assert_eq!((-f).copysign(0.42),+3.5_f32);%0A++++assert_eq!((-f).copysign(-0.42),+-3.5_f32);%0A++++%0A++++assert!(f32::NAN.copysign(1.0).is_nan());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul_add\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#292-294\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.mul_add\" class=\"fn\">mul_add</a>(self, a: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>, b: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Fused multiply-add. Computes <code>(self * a) + b</code> with only one rounding\nerror, yielding a more accurate result than an unfused multiply-add.</p>\n<p>Using <code>mul_add</code> <em>may</em> be more performant than an unfused multiply-add if\nthe target architecture has a dedicated <code>fma</code> CPU instruction. However,\nthis is not always true, and will be heavily dependant on designing\nalgorithms with specific target hardware in mind.</p>\n<h5 id=\"precision\"><a class=\"doc-anchor\" href=\"#precision\">§</a>Precision</h5>\n<p>The result of this operation is guaranteed to be the rounded\ninfinite-precision result. It is specified by IEEE 754 as\n<code>fusedMultiplyAdd</code> and guaranteed not to change.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = <span class=\"number\">10.0_f32</span>;\n<span class=\"kw\">let </span>x = <span class=\"number\">4.0_f32</span>;\n<span class=\"kw\">let </span>b = <span class=\"number\">60.0_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(m.mul_add(x, b), <span class=\"number\">100.0</span>);\n<span class=\"macro\">assert_eq!</span>(m * x + b, <span class=\"number\">100.0</span>);\n\n<span class=\"kw\">let </span>one_plus_eps = <span class=\"number\">1.0_f32 </span>+ f32::EPSILON;\n<span class=\"kw\">let </span>one_minus_eps = <span class=\"number\">1.0_f32 </span>- f32::EPSILON;\n<span class=\"kw\">let </span>minus_one = -<span class=\"number\">1.0_f32</span>;\n\n<span class=\"comment\">// The exact result (1 + eps) * (1 - eps) = 1 - eps * eps.\n</span><span class=\"macro\">assert_eq!</span>(one_plus_eps.mul_add(one_minus_eps, minus_one), -f32::EPSILON * f32::EPSILON);\n<span class=\"comment\">// Different rounding with the non-fused multiply and add.\n</span><span class=\"macro\">assert_eq!</span>(one_plus_eps * one_minus_eps + minus_one, <span class=\"number\">0.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+m+=+10.0_f32;%0A++++let+x+=+4.0_f32;%0A++++let+b+=+60.0_f32;%0A++++%0A++++assert_eq!(m.mul_add(x,+b),+100.0);%0A++++assert_eq!(m+*+x+%2B+b,+100.0);%0A++++%0A++++let+one_plus_eps+=+1.0_f32+%2B+f32::EPSILON;%0A++++let+one_minus_eps+=+1.0_f32+-+f32::EPSILON;%0A++++let+minus_one+=+-1.0_f32;%0A++++%0A++++//+The+exact+result+(1+%2B+eps)+*+(1+-+eps)+=+1+-+eps+*+eps.%0A++++assert_eq!(one_plus_eps.mul_add(one_minus_eps,+minus_one),+-f32::EPSILON+*+f32::EPSILON);%0A++++//+Different+rounding+with+the+non-fused+multiply+and+add.%0A++++assert_eq!(one_plus_eps+*+one_minus_eps+%2B+minus_one,+0.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div_euclid\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.38.0\">1.38.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#322-328\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.div_euclid\" class=\"fn\">div_euclid</a>(self, rhs: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Calculates Euclidean division, the matching method for <code>rem_euclid</code>.</p>\n<p>This computes the integer <code>n</code> such that\n<code>self = n * rhs + self.rem_euclid(rhs)</code>.\nIn other words, the result is <code>self / rhs</code> rounded to the integer <code>n</code>\nsuch that <code>self &gt;= n * rhs</code>.</p>\n<h5 id=\"precision-1\"><a class=\"doc-anchor\" href=\"#precision-1\">§</a>Precision</h5>\n<p>The result of this operation is guaranteed to be the rounded\ninfinite-precision result.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a: f32 = <span class=\"number\">7.0</span>;\n<span class=\"kw\">let </span>b = <span class=\"number\">4.0</span>;\n<span class=\"macro\">assert_eq!</span>(a.div_euclid(b), <span class=\"number\">1.0</span>); <span class=\"comment\">// 7.0 &gt; 4.0 * 1.0\n</span><span class=\"macro\">assert_eq!</span>((-a).div_euclid(b), -<span class=\"number\">2.0</span>); <span class=\"comment\">// -7.0 &gt;= 4.0 * -2.0\n</span><span class=\"macro\">assert_eq!</span>(a.div_euclid(-b), -<span class=\"number\">1.0</span>); <span class=\"comment\">// 7.0 &gt;= -4.0 * -1.0\n</span><span class=\"macro\">assert_eq!</span>((-a).div_euclid(-b), <span class=\"number\">2.0</span>); <span class=\"comment\">// -7.0 &gt;= -4.0 * 2.0</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a:+f32+=+7.0;%0A++++let+b+=+4.0;%0A++++assert_eq!(a.div_euclid(b),+1.0);+//+7.0+%3E+4.0+*+1.0%0A++++assert_eq!((-a).div_euclid(b),+-2.0);+//+-7.0+%3E=+4.0+*+-2.0%0A++++assert_eq!(a.div_euclid(-b),+-1.0);+//+7.0+%3E=+-4.0+*+-1.0%0A++++assert_eq!((-a).div_euclid(-b),+2.0);+//+-7.0+%3E=+-4.0+*+2.0%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem_euclid\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.38.0\">1.38.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#363-366\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.rem_euclid\" class=\"fn\">rem_euclid</a>(self, rhs: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Calculates the least nonnegative remainder of <code>self (mod rhs)</code>.</p>\n<p>In particular, the return value <code>r</code> satisfies <code>0.0 &lt;= r &lt; rhs.abs()</code> in\nmost cases. However, due to a floating point round-off error it can\nresult in <code>r == rhs.abs()</code>, violating the mathematical definition, if\n<code>self</code> is much smaller than <code>rhs.abs()</code> in magnitude and <code>self &lt; 0.0</code>.\nThis result is not an element of the function’s codomain, but it is the\nclosest floating point number in the real numbers and thus fulfills the\nproperty <code>self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)</code>\napproximately.</p>\n<h5 id=\"precision-2\"><a class=\"doc-anchor\" href=\"#precision-2\">§</a>Precision</h5>\n<p>The result of this operation is guaranteed to be the rounded\ninfinite-precision result.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a: f32 = <span class=\"number\">7.0</span>;\n<span class=\"kw\">let </span>b = <span class=\"number\">4.0</span>;\n<span class=\"macro\">assert_eq!</span>(a.rem_euclid(b), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>((-a).rem_euclid(b), <span class=\"number\">1.0</span>);\n<span class=\"macro\">assert_eq!</span>(a.rem_euclid(-b), <span class=\"number\">3.0</span>);\n<span class=\"macro\">assert_eq!</span>((-a).rem_euclid(-b), <span class=\"number\">1.0</span>);\n<span class=\"comment\">// limitation due to round-off error\n</span><span class=\"macro\">assert!</span>((-f32::EPSILON).rem_euclid(<span class=\"number\">3.0</span>) != <span class=\"number\">0.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a:+f32+=+7.0;%0A++++let+b+=+4.0;%0A++++assert_eq!(a.rem_euclid(b),+3.0);%0A++++assert_eq!((-a).rem_euclid(b),+1.0);%0A++++assert_eq!(a.rem_euclid(-b),+3.0);%0A++++assert_eq!((-a).rem_euclid(-b),+1.0);%0A++++//+limitation+due+to+round-off+error%0A++++assert!((-f32::EPSILON).rem_euclid(3.0)+!=+0.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.powi\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#391-393\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.powi\" class=\"fn\">powi</a>(self, n: <a class=\"primitive\" href=\"primitive.i32.html\">i32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Raises a number to an integer power.</p>\n<p>Using this function is generally faster than using <code>powf</code>.\nIt might have a different sequence of rounding operations than <code>powf</code>,\nso the results are not guaranteed to agree.</p>\n<h5 id=\"unspecified-precision\"><a class=\"doc-anchor\" href=\"#unspecified-precision\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">2.0_f32</span>;\n<span class=\"kw\">let </span>abs_difference = (x.powi(<span class=\"number\">2</span>) - (x * x)).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.powi(2)+-+(x+*+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.powf\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#414-416\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.powf\" class=\"fn\">powf</a>(self, n: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Raises a number to a floating point power.</p>\n<h5 id=\"unspecified-precision-1\"><a class=\"doc-anchor\" href=\"#unspecified-precision-1\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">2.0_f32</span>;\n<span class=\"kw\">let </span>abs_difference = (x.powf(<span class=\"number\">2.0</span>) - (x * x)).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.powf(2.0)+-+(x+*+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sqrt\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#443-445\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.sqrt\" class=\"fn\">sqrt</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the square root of a number.</p>\n<p>Returns NaN if <code>self</code> is a negative number other than <code>-0.0</code>.</p>\n<h5 id=\"precision-3\"><a class=\"doc-anchor\" href=\"#precision-3\">§</a>Precision</h5>\n<p>The result of this operation is guaranteed to be the rounded\ninfinite-precision result. It is specified by IEEE 754 as <code>squareRoot</code>\nand guaranteed not to change.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>positive = <span class=\"number\">4.0_f32</span>;\n<span class=\"kw\">let </span>negative = -<span class=\"number\">4.0_f32</span>;\n<span class=\"kw\">let </span>negative_zero = -<span class=\"number\">0.0_f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(positive.sqrt(), <span class=\"number\">2.0</span>);\n<span class=\"macro\">assert!</span>(negative.sqrt().is_nan());\n<span class=\"macro\">assert!</span>(negative_zero.sqrt() == negative_zero);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+positive+=+4.0_f32;%0A++++let+negative+=+-4.0_f32;%0A++++let+negative_zero+=+-0.0_f32;%0A++++%0A++++assert_eq!(positive.sqrt(),+2.0);%0A++++assert!(negative.sqrt().is_nan());%0A++++assert!(negative_zero.sqrt()+==+negative_zero);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.exp\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#470-472\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.exp\" class=\"fn\">exp</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>e^(self)</code>, (the exponential function).</p>\n<h5 id=\"unspecified-precision-2\"><a class=\"doc-anchor\" href=\"#unspecified-precision-2\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>one = <span class=\"number\">1.0f32</span>;\n<span class=\"comment\">// e^1\n</span><span class=\"kw\">let </span>e = one.exp();\n\n<span class=\"comment\">// ln(e) - 1 == 0\n</span><span class=\"kw\">let </span>abs_difference = (e.ln() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+one+=+1.0f32;%0A++++//+e%5E1%0A++++let+e+=+one.exp();%0A++++%0A++++//+ln(e)+-+1+==+0%0A++++let+abs_difference+=+(e.ln()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.exp2\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#495-497\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.exp2\" class=\"fn\">exp2</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>2^(self)</code>.</p>\n<h5 id=\"unspecified-precision-3\"><a class=\"doc-anchor\" href=\"#unspecified-precision-3\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">2.0f32</span>;\n\n<span class=\"comment\">// 2^2 - 4 == 0\n</span><span class=\"kw\">let </span>abs_difference = (f.exp2() - <span class=\"number\">4.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+2.0f32;%0A++++%0A++++//+2%5E2+-+4+==+0%0A++++let+abs_difference+=+(f.exp2()+-+4.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ln\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#522-524\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.ln\" class=\"fn\">ln</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the natural logarithm of the number.</p>\n<h5 id=\"unspecified-precision-4\"><a class=\"doc-anchor\" href=\"#unspecified-precision-4\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>one = <span class=\"number\">1.0f32</span>;\n<span class=\"comment\">// e^1\n</span><span class=\"kw\">let </span>e = one.exp();\n\n<span class=\"comment\">// ln(e) - 1 == 0\n</span><span class=\"kw\">let </span>abs_difference = (e.ln() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+one+=+1.0f32;%0A++++//+e%5E1%0A++++let+e+=+one.exp();%0A++++%0A++++//+ln(e)+-+1+==+0%0A++++let+abs_difference+=+(e.ln()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.log\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#551-553\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.log\" class=\"fn\">log</a>(self, base: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the logarithm of the number with respect to an arbitrary base.</p>\n<p>The result might not be correctly rounded owing to implementation details;\n<code>self.log2()</code> can produce more accurate results for base 2, and\n<code>self.log10()</code> can produce more accurate results for base 10.</p>\n<h5 id=\"unspecified-precision-5\"><a class=\"doc-anchor\" href=\"#unspecified-precision-5\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>five = <span class=\"number\">5.0f32</span>;\n\n<span class=\"comment\">// log5(5) - 1 == 0\n</span><span class=\"kw\">let </span>abs_difference = (five.log(<span class=\"number\">5.0</span>) - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+five+=+5.0f32;%0A++++%0A++++//+log5(5)+-+1+==+0%0A++++let+abs_difference+=+(five.log(5.0)+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.log2\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#576-578\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.log2\" class=\"fn\">log2</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the base 2 logarithm of the number.</p>\n<h5 id=\"unspecified-precision-6\"><a class=\"doc-anchor\" href=\"#unspecified-precision-6\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>two = <span class=\"number\">2.0f32</span>;\n\n<span class=\"comment\">// log2(2) - 1 == 0\n</span><span class=\"kw\">let </span>abs_difference = (two.log2() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+two+=+2.0f32;%0A++++%0A++++//+log2(2)+-+1+==+0%0A++++let+abs_difference+=+(two.log2()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.log10\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#601-603\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.log10\" class=\"fn\">log10</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the base 10 logarithm of the number.</p>\n<h5 id=\"unspecified-precision-7\"><a class=\"doc-anchor\" href=\"#unspecified-precision-7\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>ten = <span class=\"number\">10.0f32</span>;\n\n<span class=\"comment\">// log10(10) - 1 == 0\n</span><span class=\"kw\">let </span>abs_difference = (ten.log10() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ten+=+10.0f32;%0A++++%0A++++//+log10(10)+-+1+==+0%0A++++let+abs_difference+=+(ten.log10()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.abs_sub\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#643-645\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.abs_sub\" class=\"fn\">abs_sub</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.10.0: you probably meant <code>(self - other).abs()</code>: this operation is <code>(self - other).max(0.0)</code> except that <code>abs_sub</code> also propagates NaNs (also known as <code>fdimf</code> in C). If you truly need the positive difference, consider using that expression or the C function <code>fdimf</code>, depending on how you wish to handle NaN (please consider filing an issue describing your use-case too).</span></div></span></summary><div class=\"docblock\"><p>The positive difference of two numbers.</p>\n<ul>\n<li>If <code>self &lt;= other</code>: <code>0.0</code></li>\n<li>Else: <code>self - other</code></li>\n</ul>\n<h5 id=\"unspecified-precision-8\"><a class=\"doc-anchor\" href=\"#unspecified-precision-8\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>fdimf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">3.0f32</span>;\n<span class=\"kw\">let </span>y = -<span class=\"number\">3.0f32</span>;\n\n<span class=\"kw\">let </span>abs_difference_x = (x.abs_sub(<span class=\"number\">1.0</span>) - <span class=\"number\">2.0</span>).abs();\n<span class=\"kw\">let </span>abs_difference_y = (y.abs_sub(<span class=\"number\">1.0</span>) - <span class=\"number\">0.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference_x &lt;= f32::EPSILON);\n<span class=\"macro\">assert!</span>(abs_difference_y &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.0f32;%0A++++let+y+=+-3.0f32;%0A++++%0A++++let+abs_difference_x+=+(x.abs_sub(1.0)+-+2.0).abs();%0A++++let+abs_difference_y+=+(y.abs_sub(1.0)+-+0.0).abs();%0A++++%0A++++assert!(abs_difference_x+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_y+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cbrt\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#670-672\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.cbrt\" class=\"fn\">cbrt</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the cube root of a number.</p>\n<h5 id=\"unspecified-precision-9\"><a class=\"doc-anchor\" href=\"#unspecified-precision-9\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>cbrtf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">8.0f32</span>;\n\n<span class=\"comment\">// x^(1/3) - 2 == 0\n</span><span class=\"kw\">let </span>abs_difference = (x.cbrt() - <span class=\"number\">2.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+8.0f32;%0A++++%0A++++//+x%5E(1/3)+-+2+==+0%0A++++let+abs_difference+=+(x.cbrt()+-+2.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hypot\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#701-703\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.hypot\" class=\"fn\">hypot</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Compute the distance between the origin and a point (<code>x</code>, <code>y</code>) on the\nEuclidean plane. Equivalently, compute the length of the hypotenuse of a\nright-angle triangle with other sides having length <code>x.abs()</code> and\n<code>y.abs()</code>.</p>\n<h5 id=\"unspecified-precision-10\"><a class=\"doc-anchor\" href=\"#unspecified-precision-10\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>hypotf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">2.0f32</span>;\n<span class=\"kw\">let </span>y = <span class=\"number\">3.0f32</span>;\n\n<span class=\"comment\">// sqrt(x^2 + y^2)\n</span><span class=\"kw\">let </span>abs_difference = (x.hypot(y) - (x.powi(<span class=\"number\">2</span>) + y.powi(<span class=\"number\">2</span>)).sqrt()).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0f32;%0A++++let+y+=+3.0f32;%0A++++%0A++++//+sqrt(x%5E2+%2B+y%5E2)%0A++++let+abs_difference+=+(x.hypot(y)+-+(x.powi(2)+%2B+y.powi(2)).sqrt()).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sin\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#725-727\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.sin\" class=\"fn\">sin</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the sine of a number (in radians).</p>\n<h5 id=\"unspecified-precision-11\"><a class=\"doc-anchor\" href=\"#unspecified-precision-11\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = std::f32::consts::FRAC_PI_2;\n\n<span class=\"kw\">let </span>abs_difference = (x.sin() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_2;%0A++++%0A++++let+abs_difference+=+(x.sin()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cos\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#749-751\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.cos\" class=\"fn\">cos</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the cosine of a number (in radians).</p>\n<h5 id=\"unspecified-precision-12\"><a class=\"doc-anchor\" href=\"#unspecified-precision-12\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">2.0 </span>* std::f32::consts::PI;\n\n<span class=\"kw\">let </span>abs_difference = (x.cos() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0+*+std::f32::consts::PI;%0A++++%0A++++let+abs_difference+=+(x.cos()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.tan\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#774-776\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.tan\" class=\"fn\">tan</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the tangent of a number (in radians).</p>\n<h5 id=\"unspecified-precision-13\"><a class=\"doc-anchor\" href=\"#unspecified-precision-13\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>tanf</code> from libc on Unix and\nWindows. Note that this might change in the future.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = std::f32::consts::FRAC_PI_4;\n<span class=\"kw\">let </span>abs_difference = (x.tan() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_4;%0A++++let+abs_difference+=+(x.tan()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.asin\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#804-806\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.asin\" class=\"fn\">asin</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the arcsine of a number. Return value is in radians in\nthe range [-pi/2, pi/2] or NaN if the number is outside the range\n[-1, 1].</p>\n<h5 id=\"unspecified-precision-14\"><a class=\"doc-anchor\" href=\"#unspecified-precision-14\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>asinf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = std::f32::consts::FRAC_PI_2;\n\n<span class=\"comment\">// asin(sin(pi/2))\n</span><span class=\"kw\">let </span>abs_difference = (f.sin().asin() - std::f32::consts::FRAC_PI_2).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+std::f32::consts::FRAC_PI_2;%0A++++%0A++++//+asin(sin(pi/2))%0A++++let+abs_difference+=+(f.sin().asin()+-+std::f32::consts::FRAC_PI_2).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.acos\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#834-836\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.acos\" class=\"fn\">acos</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the arccosine of a number. Return value is in radians in\nthe range [0, pi] or NaN if the number is outside the range\n[-1, 1].</p>\n<h5 id=\"unspecified-precision-15\"><a class=\"doc-anchor\" href=\"#unspecified-precision-15\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>acosf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = std::f32::consts::FRAC_PI_4;\n\n<span class=\"comment\">// acos(cos(pi/4))\n</span><span class=\"kw\">let </span>abs_difference = (f.cos().acos() - std::f32::consts::FRAC_PI_4).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+std::f32::consts::FRAC_PI_4;%0A++++%0A++++//+acos(cos(pi/4))%0A++++let+abs_difference+=+(f.cos().acos()+-+std::f32::consts::FRAC_PI_4).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.atan\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#863-865\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.atan\" class=\"fn\">atan</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the arctangent of a number. Return value is in radians in the\nrange [-pi/2, pi/2];</p>\n<h5 id=\"unspecified-precision-16\"><a class=\"doc-anchor\" href=\"#unspecified-precision-16\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>atanf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">1.0f32</span>;\n\n<span class=\"comment\">// atan(tan(1))\n</span><span class=\"kw\">let </span>abs_difference = (f.tan().atan() - <span class=\"number\">1.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+1.0f32;%0A++++%0A++++//+atan(tan(1))%0A++++let+abs_difference+=+(f.tan().atan()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.atan2\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#904-906\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.atan2\" class=\"fn\">atan2</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Computes the four quadrant arctangent of <code>self</code> (<code>y</code>) and <code>other</code> (<code>x</code>) in radians.</p>\n<ul>\n<li><code>x = 0</code>, <code>y = 0</code>: <code>0</code></li>\n<li><code>x &gt;= 0</code>: <code>arctan(y/x)</code> -&gt; <code>[-pi/2, pi/2]</code></li>\n<li><code>y &gt;= 0</code>: <code>arctan(y/x) + pi</code> -&gt; <code>(pi/2, pi]</code></li>\n<li><code>y &lt; 0</code>: <code>arctan(y/x) - pi</code> -&gt; <code>(-pi, -pi/2)</code></li>\n</ul>\n<h5 id=\"unspecified-precision-17\"><a class=\"doc-anchor\" href=\"#unspecified-precision-17\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>atan2f</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Positive angles measured counter-clockwise\n// from positive x axis\n// -pi/4 radians (45 deg clockwise)\n</span><span class=\"kw\">let </span>x1 = <span class=\"number\">3.0f32</span>;\n<span class=\"kw\">let </span>y1 = -<span class=\"number\">3.0f32</span>;\n\n<span class=\"comment\">// 3pi/4 radians (135 deg counter-clockwise)\n</span><span class=\"kw\">let </span>x2 = -<span class=\"number\">3.0f32</span>;\n<span class=\"kw\">let </span>y2 = <span class=\"number\">3.0f32</span>;\n\n<span class=\"kw\">let </span>abs_difference_1 = (y1.atan2(x1) - (-std::f32::consts::FRAC_PI_4)).abs();\n<span class=\"kw\">let </span>abs_difference_2 = (y2.atan2(x2) - (<span class=\"number\">3.0 </span>* std::f32::consts::FRAC_PI_4)).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference_1 &lt;= f32::EPSILON);\n<span class=\"macro\">assert!</span>(abs_difference_2 &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Positive+angles+measured+counter-clockwise%0A//+from+positive+x+axis%0A//+-pi/4+radians+(45+deg+clockwise)%0Afn+main()+%7B%0A++++let+x1+=+3.0f32;%0A++++let+y1+=+-3.0f32;%0A++++%0A++++//+3pi/4+radians+(135+deg+counter-clockwise)%0A++++let+x2+=+-3.0f32;%0A++++let+y2+=+3.0f32;%0A++++%0A++++let+abs_difference_1+=+(y1.atan2(x1)+-+(-std::f32::consts::FRAC_PI_4)).abs();%0A++++let+abs_difference_2+=+(y2.atan2(x2)+-+(3.0+*+std::f32::consts::FRAC_PI_4)).abs();%0A++++%0A++++assert!(abs_difference_1+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_2+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sin_cos\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#934-936\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.sin_cos\" class=\"fn\">sin_cos</a>(self) -&gt; (<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>, <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\"><p>Simultaneously computes the sine and cosine of the number, <code>x</code>. Returns\n<code>(sin(x), cos(x))</code>.</p>\n<h5 id=\"unspecified-precision-18\"><a class=\"doc-anchor\" href=\"#unspecified-precision-18\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>(f32::sin(x), f32::cos(x))</code>. Note that this might change in the future.</p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = std::f32::consts::FRAC_PI_4;\n<span class=\"kw\">let </span>f = x.sin_cos();\n\n<span class=\"kw\">let </span>abs_difference_0 = (f.<span class=\"number\">0 </span>- x.sin()).abs();\n<span class=\"kw\">let </span>abs_difference_1 = (f.<span class=\"number\">1 </span>- x.cos()).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference_0 &lt;= f32::EPSILON);\n<span class=\"macro\">assert!</span>(abs_difference_1 &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_4;%0A++++let+f+=+x.sin_cos();%0A++++%0A++++let+abs_difference_0+=+(f.0+-+x.sin()).abs();%0A++++let+abs_difference_1+=+(f.1+-+x.cos()).abs();%0A++++%0A++++assert!(abs_difference_0+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_1+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.exp_m1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#963-965\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.exp_m1\" class=\"fn\">exp_m1</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>e^(self) - 1</code> in a way that is accurate even if the\nnumber is close to zero.</p>\n<h5 id=\"unspecified-precision-19\"><a class=\"doc-anchor\" href=\"#unspecified-precision-19\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>expm1f</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">1e-8_f32</span>;\n\n<span class=\"comment\">// for very small x, e^x is approximately 1 + x + x^2 / 2\n</span><span class=\"kw\">let </span>approx = x + x * x / <span class=\"number\">2.0</span>;\n<span class=\"kw\">let </span>abs_difference = (x.exp_m1() - approx).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt; <span class=\"number\">1e-10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1e-8_f32;%0A++++%0A++++//+for+very+small+x,+e%5Ex+is+approximately+1+%2B+x+%2B+x%5E2+/+2%0A++++let+approx+=+x+%2B+x+*+x+/+2.0;%0A++++let+abs_difference+=+(x.exp_m1()+-+approx).abs();%0A++++%0A++++assert!(abs_difference+%3C+1e-10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ln_1p\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#993-995\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.ln_1p\" class=\"fn\">ln_1p</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>ln(1+n)</code> (natural logarithm) more accurately than if\nthe operations were performed separately.</p>\n<h5 id=\"unspecified-precision-20\"><a class=\"doc-anchor\" href=\"#unspecified-precision-20\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>log1pf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">1e-8_f32</span>;\n\n<span class=\"comment\">// for very small x, ln(1 + x) is approximately x - x^2 / 2\n</span><span class=\"kw\">let </span>approx = x - x * x / <span class=\"number\">2.0</span>;\n<span class=\"kw\">let </span>abs_difference = (x.ln_1p() - approx).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt; <span class=\"number\">1e-10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1e-8_f32;%0A++++%0A++++//+for+very+small+x,+ln(1+%2B+x)+is+approximately+x+-+x%5E2+/+2%0A++++let+approx+=+x+-+x+*+x+/+2.0;%0A++++let+abs_difference+=+(x.ln_1p()+-+approx).abs();%0A++++%0A++++assert!(abs_difference+%3C+1e-10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sinh\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#1023-1025\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.sinh\" class=\"fn\">sinh</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Hyperbolic sine function.</p>\n<h5 id=\"unspecified-precision-21\"><a class=\"doc-anchor\" href=\"#unspecified-precision-21\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>sinhf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>e = std::f32::consts::E;\n<span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n\n<span class=\"kw\">let </span>f = x.sinh();\n<span class=\"comment\">// Solving sinh() at 1 gives `(e^2-1)/(2e)`\n</span><span class=\"kw\">let </span>g = ((e * e) - <span class=\"number\">1.0</span>) / (<span class=\"number\">2.0 </span>* e);\n<span class=\"kw\">let </span>abs_difference = (f - g).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++%0A++++let+f+=+x.sinh();%0A++++//+Solving+sinh()+at+1+gives+%60(e%5E2-1)/(2e)%60%0A++++let+g+=+((e+*+e)+-+1.0)+/+(2.0+*+e);%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cosh\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#1053-1055\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.cosh\" class=\"fn\">cosh</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Hyperbolic cosine function.</p>\n<h5 id=\"unspecified-precision-22\"><a class=\"doc-anchor\" href=\"#unspecified-precision-22\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>coshf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>e = std::f32::consts::E;\n<span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>f = x.cosh();\n<span class=\"comment\">// Solving cosh() at 1 gives this result\n</span><span class=\"kw\">let </span>g = ((e * e) + <span class=\"number\">1.0</span>) / (<span class=\"number\">2.0 </span>* e);\n<span class=\"kw\">let </span>abs_difference = (f - g).abs();\n\n<span class=\"comment\">// Same result\n</span><span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.cosh();%0A++++//+Solving+cosh()+at+1+gives+this+result%0A++++let+g+=+((e+*+e)+%2B+1.0)+/+(2.0+*+e);%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++//+Same+result%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.tanh\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#1083-1085\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.tanh\" class=\"fn\">tanh</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Hyperbolic tangent function.</p>\n<h5 id=\"unspecified-precision-23\"><a class=\"doc-anchor\" href=\"#unspecified-precision-23\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>tanhf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>e = std::f32::consts::E;\n<span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n\n<span class=\"kw\">let </span>f = x.tanh();\n<span class=\"comment\">// Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n</span><span class=\"kw\">let </span>g = (<span class=\"number\">1.0 </span>- e.powi(-<span class=\"number\">2</span>)) / (<span class=\"number\">1.0 </span>+ e.powi(-<span class=\"number\">2</span>));\n<span class=\"kw\">let </span>abs_difference = (f - g).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++%0A++++let+f+=+x.tanh();%0A++++//+Solving+tanh()+at+1+gives+%60(1+-+e%5E(-2))/(1+%2B+e%5E(-2))%60%0A++++let+g+=+(1.0+-+e.powi(-2))+/+(1.0+%2B+e.powi(-2));%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.asinh\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#1109-1113\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.asinh\" class=\"fn\">asinh</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Inverse hyperbolic sine function.</p>\n<h5 id=\"unspecified-precision-24\"><a class=\"doc-anchor\" href=\"#unspecified-precision-24\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>f = x.sinh().asinh();\n\n<span class=\"kw\">let </span>abs_difference = (f - x).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.sinh().asinh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.acosh\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#1137-1143\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.acosh\" class=\"fn\">acosh</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Inverse hyperbolic cosine function.</p>\n<h5 id=\"unspecified-precision-25\"><a class=\"doc-anchor\" href=\"#unspecified-precision-25\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-38\"><a class=\"doc-anchor\" href=\"#examples-38\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>f = x.cosh().acosh();\n\n<span class=\"kw\">let </span>abs_difference = (f - x).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.cosh().acosh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.atanh\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../src/std/f32.rs.html#1167-1169\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.atanh\" class=\"fn\">atanh</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Inverse hyperbolic tangent function.</p>\n<h5 id=\"unspecified-precision-26\"><a class=\"doc-anchor\" href=\"#unspecified-precision-26\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.</p>\n<h5 id=\"examples-39\"><a class=\"doc-anchor\" href=\"#examples-39\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>e = std::f32::consts::E;\n<span class=\"kw\">let </span>f = e.tanh().atanh();\n\n<span class=\"kw\">let </span>abs_difference = (f - e).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= <span class=\"number\">1e-5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+f+=+e.tanh().atanh();%0A++++%0A++++let+abs_difference+=+(f+-+e).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gamma\" class=\"method\"><a class=\"src rightside\" href=\"../src/std/f32.rs.html#1194-1196\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.gamma\" class=\"fn\">gamma</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>float_gamma</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/99842\">#99842</a>)</span></div></span></summary><div class=\"docblock\"><p>Gamma function.</p>\n<h5 id=\"unspecified-precision-27\"><a class=\"doc-anchor\" href=\"#unspecified-precision-27\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>tgammaf</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-40\"><a class=\"doc-anchor\" href=\"#examples-40\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(float_gamma)]\n</span><span class=\"kw\">let </span>x = <span class=\"number\">5.0f32</span>;\n\n<span class=\"kw\">let </span>abs_difference = (x.gamma() - <span class=\"number\">24.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_gamma)%5D%0Afn+main()+%7B%0A++++let+x+=+5.0f32;%0A++++%0A++++let+abs_difference+=+(x.gamma()+-+24.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ln_gamma\" class=\"method\"><a class=\"src rightside\" href=\"../src/std/f32.rs.html#1223-1227\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.ln_gamma\" class=\"fn\">ln_gamma</a>(self) -&gt; (<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>, <a class=\"primitive\" href=\"primitive.i32.html\">i32</a>)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>float_gamma</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/99842\">#99842</a>)</span></div></span></summary><div class=\"docblock\"><p>Natural logarithm of the absolute value of the gamma function</p>\n<p>The integer part of the tuple indicates the sign of the gamma function.</p>\n<h5 id=\"unspecified-precision-28\"><a class=\"doc-anchor\" href=\"#unspecified-precision-28\">§</a>Unspecified precision</h5>\n<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\ncan even differ within the same execution from one invocation to the next.\nThis function currently corresponds to the <code>lgamma_r</code> from libc on Unix\nand Windows. Note that this might change in the future.</p>\n<h5 id=\"examples-41\"><a class=\"doc-anchor\" href=\"#examples-41\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(float_gamma)]\n</span><span class=\"kw\">let </span>x = <span class=\"number\">2.0f32</span>;\n\n<span class=\"kw\">let </span>abs_difference = (x.ln_gamma().<span class=\"number\">0 </span>- <span class=\"number\">0.0</span>).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_gamma)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0f32;%0A++++%0A++++let+abs_difference+=+(x.ln_gamma().0+-+0.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-f32-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#384\">source</a><a href=\"#impl-f32-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.RADIX\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#387\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.RADIX\" class=\"constant\">RADIX</a>: <a class=\"primitive\" href=\"primitive.u32.html\">u32</a> = 2u32</h4></section></summary><div class=\"docblock\"><p>The radix or base of the internal representation of <code>f32</code>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MANTISSA_DIGITS\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#391\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MANTISSA_DIGITS\" class=\"constant\">MANTISSA_DIGITS</a>: <a class=\"primitive\" href=\"primitive.u32.html\">u32</a> = 24u32</h4></section></summary><div class=\"docblock\"><p>Number of significant digits in base 2.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.DIGITS\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#402\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.DIGITS\" class=\"constant\">DIGITS</a>: <a class=\"primitive\" href=\"primitive.u32.html\">u32</a> = 6u32</h4></section></summary><div class=\"docblock\"><p>Approximate number of significant digits in base 10.</p>\n<p>This is the maximum <i>x</i> such that any decimal number with <i>x</i>\nsignificant digits can be converted to <code>f32</code> and back without loss.</p>\n<p>Equal to floor(log<sub>10</sub>&nbsp;2<sup><a href=\"primitive.f32.html#associatedconstant.MANTISSA_DIGITS\" title=\"associated constant f32::MANTISSA_DIGITS\"><code>MANTISSA_DIGITS</code></a>&nbsp;−&nbsp;1</sup>).</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.EPSILON\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#413\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.EPSILON\" class=\"constant\">EPSILON</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = 1.1920929E-7f32</h4></section></summary><div class=\"docblock\"><p><a href=\"https://en.wikipedia.org/wiki/Machine_epsilon\">Machine epsilon</a> value for <code>f32</code>.</p>\n<p>This is the difference between <code>1.0</code> and the next larger representable number.</p>\n<p>Equal to 2<sup>1&nbsp;−&nbsp;<a href=\"primitive.f32.html#associatedconstant.MANTISSA_DIGITS\" title=\"associated constant f32::MANTISSA_DIGITS\"><code>MANTISSA_DIGITS</code></a></sup>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MIN\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#421\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MIN\" class=\"constant\">MIN</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = -3.40282347E+38f32</h4></section></summary><div class=\"docblock\"><p>Smallest finite <code>f32</code> value.</p>\n<p>Equal to −<a href=\"primitive.f32.html#associatedconstant.MAX\" title=\"associated constant f32::MAX\"><code>MAX</code></a>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MIN_POSITIVE\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#428\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MIN_POSITIVE\" class=\"constant\">MIN_POSITIVE</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = 1.17549435E-38f32</h4></section></summary><div class=\"docblock\"><p>Smallest positive normal <code>f32</code> value.</p>\n<p>Equal to 2<sup><a href=\"primitive.f32.html#associatedconstant.MIN_EXP\" title=\"associated constant f32::MIN_EXP\"><code>MIN_EXP</code></a>&nbsp;−&nbsp;1</sup>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MAX\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#437\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MAX\" class=\"constant\">MAX</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = 3.40282347E+38f32</h4></section></summary><div class=\"docblock\"><p>Largest finite <code>f32</code> value.</p>\n<p>Equal to\n(1&nbsp;−&nbsp;2<sup>−<a href=\"primitive.f32.html#associatedconstant.MANTISSA_DIGITS\" title=\"associated constant f32::MANTISSA_DIGITS\"><code>MANTISSA_DIGITS</code></a></sup>)&nbsp;2<sup><a href=\"primitive.f32.html#associatedconstant.MAX_EXP\" title=\"associated constant f32::MAX_EXP\"><code>MAX_EXP</code></a></sup>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MIN_EXP\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#444\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MIN_EXP\" class=\"constant\">MIN_EXP</a>: <a class=\"primitive\" href=\"primitive.i32.html\">i32</a> = -125i32</h4></section></summary><div class=\"docblock\"><p>One greater than the minimum possible normal power of 2 exponent.</p>\n<p>If <i>x</i>&nbsp;=&nbsp;<code>MIN_EXP</code>, then normal numbers\n≥&nbsp;0.5&nbsp;×&nbsp;2<sup><i>x</i></sup>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MAX_EXP\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#450\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MAX_EXP\" class=\"constant\">MAX_EXP</a>: <a class=\"primitive\" href=\"primitive.i32.html\">i32</a> = 128i32</h4></section></summary><div class=\"docblock\"><p>Maximum possible power of 2 exponent.</p>\n<p>If <i>x</i>&nbsp;=&nbsp;<code>MAX_EXP</code>, then normal numbers\n&lt;&nbsp;1&nbsp;×&nbsp;2<sup><i>x</i></sup>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MIN_10_EXP\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#458\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MIN_10_EXP\" class=\"constant\">MIN_10_EXP</a>: <a class=\"primitive\" href=\"primitive.i32.html\">i32</a> = -37i32</h4></section></summary><div class=\"docblock\"><p>Minimum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p>\n<p>Equal to ceil(log<sub>10</sub>&nbsp;<a href=\"primitive.f32.html#associatedconstant.MIN_POSITIVE\" title=\"associated constant f32::MIN_POSITIVE\"><code>MIN_POSITIVE</code></a>).</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.MAX_10_EXP\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#465\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.MAX_10_EXP\" class=\"constant\">MAX_10_EXP</a>: <a class=\"primitive\" href=\"primitive.i32.html\">i32</a> = 38i32</h4></section></summary><div class=\"docblock\"><p>Maximum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p>\n<p>Equal to floor(log<sub>10</sub>&nbsp;<a href=\"primitive.f32.html#associatedconstant.MAX\" title=\"associated constant f32::MAX\"><code>MAX</code></a>).</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.NAN\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#480\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.NAN\" class=\"constant\">NAN</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = NaN_f32</h4></section></summary><div class=\"docblock\"><p>Not a Number (NaN).</p>\n<p>Note that IEEE 754 doesn’t define just a single NaN value;\na plethora of bit patterns are considered to be NaN.\nFurthermore, the standard makes a difference\nbetween a “signaling” and a “quiet” NaN,\nand allows inspecting its “payload” (the unspecified bits in the bit pattern).\nThis constant isn’t guaranteed to equal to any specific NaN bitpattern,\nand the stability of its representation over Rust versions\nand target platforms isn’t guaranteed.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.INFINITY\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#483\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.INFINITY\" class=\"constant\">INFINITY</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = +Inf_f32</h4></section></summary><div class=\"docblock\"><p>Infinity (∞).</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedconstant.NEG_INFINITY\" class=\"associatedconstant\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#486\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.NEG_INFINITY\" class=\"constant\">NEG_INFINITY</a>: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a> = -Inf_f32</h4></section></summary><div class=\"docblock\"><p>Negative infinity (−∞).</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_nan\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#502\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_nan\" class=\"fn\">is_nan</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if this value is NaN.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>nan = f32::NAN;\n<span class=\"kw\">let </span>f = <span class=\"number\">7.0_f32</span>;\n\n<span class=\"macro\">assert!</span>(nan.is_nan());\n<span class=\"macro\">assert!</span>(!f.is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nan+=+f32::NAN;%0A++++let+f+=+7.0_f32;%0A++++%0A++++assert!(nan.is_nan());%0A++++assert!(!f.is_nan());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_infinite\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#535\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_infinite\" class=\"fn\">is_infinite</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if this value is positive infinity or negative infinity, and\n<code>false</code> otherwise.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">7.0f32</span>;\n<span class=\"kw\">let </span>inf = f32::INFINITY;\n<span class=\"kw\">let </span>neg_inf = f32::NEG_INFINITY;\n<span class=\"kw\">let </span>nan = f32::NAN;\n\n<span class=\"macro\">assert!</span>(!f.is_infinite());\n<span class=\"macro\">assert!</span>(!nan.is_infinite());\n\n<span class=\"macro\">assert!</span>(inf.is_infinite());\n<span class=\"macro\">assert!</span>(neg_inf.is_infinite());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+inf+=+f32::INFINITY;%0A++++let+neg_inf+=+f32::NEG_INFINITY;%0A++++let+nan+=+f32::NAN;%0A++++%0A++++assert!(!f.is_infinite());%0A++++assert!(!nan.is_infinite());%0A++++%0A++++assert!(inf.is_infinite());%0A++++assert!(neg_inf.is_infinite());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_finite\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#560\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_finite\" class=\"fn\">is_finite</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if this number is neither infinite nor NaN.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">7.0f32</span>;\n<span class=\"kw\">let </span>inf = f32::INFINITY;\n<span class=\"kw\">let </span>neg_inf = f32::NEG_INFINITY;\n<span class=\"kw\">let </span>nan = f32::NAN;\n\n<span class=\"macro\">assert!</span>(f.is_finite());\n\n<span class=\"macro\">assert!</span>(!nan.is_finite());\n<span class=\"macro\">assert!</span>(!inf.is_finite());\n<span class=\"macro\">assert!</span>(!neg_inf.is_finite());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+inf+=+f32::INFINITY;%0A++++let+neg_inf+=+f32::NEG_INFINITY;%0A++++let+nan+=+f32::NAN;%0A++++%0A++++assert!(f.is_finite());%0A++++%0A++++assert!(!nan.is_finite());%0A++++assert!(!inf.is_finite());%0A++++assert!(!neg_inf.is_finite());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_subnormal\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.53.0, const unstable\">1.53.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#588\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_subnormal\" class=\"fn\">is_subnormal</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the number is <a href=\"https://en.wikipedia.org/wiki/Denormal_number\">subnormal</a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>min = f32::MIN_POSITIVE; <span class=\"comment\">// 1.17549435e-38f32\n</span><span class=\"kw\">let </span>max = f32::MAX;\n<span class=\"kw\">let </span>lower_than_min = <span class=\"number\">1.0e-40_f32</span>;\n<span class=\"kw\">let </span>zero = <span class=\"number\">0.0_f32</span>;\n\n<span class=\"macro\">assert!</span>(!min.is_subnormal());\n<span class=\"macro\">assert!</span>(!max.is_subnormal());\n\n<span class=\"macro\">assert!</span>(!zero.is_subnormal());\n<span class=\"macro\">assert!</span>(!f32::NAN.is_subnormal());\n<span class=\"macro\">assert!</span>(!f32::INFINITY.is_subnormal());\n<span class=\"comment\">// Values between `0` and `min` are Subnormal.\n</span><span class=\"macro\">assert!</span>(lower_than_min.is_subnormal());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+min+=+f32::MIN_POSITIVE;+//+1.17549435e-38f32%0A++++let+max+=+f32::MAX;%0A++++let+lower_than_min+=+1.0e-40_f32;%0A++++let+zero+=+0.0_f32;%0A++++%0A++++assert!(!min.is_subnormal());%0A++++assert!(!max.is_subnormal());%0A++++%0A++++assert!(!zero.is_subnormal());%0A++++assert!(!f32::NAN.is_subnormal());%0A++++assert!(!f32::INFINITY.is_subnormal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(lower_than_min.is_subnormal());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_normal\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#615\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_normal\" class=\"fn\">is_normal</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the number is neither zero, infinite,\n<a href=\"https://en.wikipedia.org/wiki/Denormal_number\">subnormal</a>, or NaN.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>min = f32::MIN_POSITIVE; <span class=\"comment\">// 1.17549435e-38f32\n</span><span class=\"kw\">let </span>max = f32::MAX;\n<span class=\"kw\">let </span>lower_than_min = <span class=\"number\">1.0e-40_f32</span>;\n<span class=\"kw\">let </span>zero = <span class=\"number\">0.0_f32</span>;\n\n<span class=\"macro\">assert!</span>(min.is_normal());\n<span class=\"macro\">assert!</span>(max.is_normal());\n\n<span class=\"macro\">assert!</span>(!zero.is_normal());\n<span class=\"macro\">assert!</span>(!f32::NAN.is_normal());\n<span class=\"macro\">assert!</span>(!f32::INFINITY.is_normal());\n<span class=\"comment\">// Values between `0` and `min` are Subnormal.\n</span><span class=\"macro\">assert!</span>(!lower_than_min.is_normal());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+min+=+f32::MIN_POSITIVE;+//+1.17549435e-38f32%0A++++let+max+=+f32::MAX;%0A++++let+lower_than_min+=+1.0e-40_f32;%0A++++let+zero+=+0.0_f32;%0A++++%0A++++assert!(min.is_normal());%0A++++assert!(max.is_normal());%0A++++%0A++++assert!(!zero.is_normal());%0A++++assert!(!f32::NAN.is_normal());%0A++++assert!(!f32::INFINITY.is_normal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(!lower_than_min.is_normal());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.classify\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#634\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.classify\" class=\"fn\">classify</a>(self) -&gt; <a class=\"enum\" href=\"num/enum.FpCategory.html\" title=\"enum std::num::FpCategory\">FpCategory</a></h4></section></summary><div class=\"docblock\"><p>Returns the floating point category of the number. If only one property\nis going to be tested, it is generally faster to use the specific\npredicate instead.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::num::FpCategory;\n\n<span class=\"kw\">let </span>num = <span class=\"number\">12.4_f32</span>;\n<span class=\"kw\">let </span>inf = f32::INFINITY;\n\n<span class=\"macro\">assert_eq!</span>(num.classify(), FpCategory::Normal);\n<span class=\"macro\">assert_eq!</span>(inf.classify(), FpCategory::Infinite);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::FpCategory;%0A++++%0A++++let+num+=+12.4_f32;%0A++++let+inf+=+f32::INFINITY;%0A++++%0A++++assert_eq!(num.classify(),+FpCategory::Normal);%0A++++assert_eq!(inf.classify(),+FpCategory::Infinite);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_sign_positive\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#727\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_sign_positive\" class=\"fn\">is_sign_positive</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, NaNs with\npositive sign bit and positive infinity. Note that IEEE 754 doesn’t assign any\nmeaning to the sign bit in case of a NaN, and as Rust doesn’t guarantee that\nthe bit pattern of NaNs are conserved over arithmetic operations, the result of\n<code>is_sign_positive</code> on a NaN might produce an unexpected result in some cases.\nSee <a href=\"primitive.f32.html\" title=\"primitive f32\">explanation of NaN as a special value</a> for more info.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">7.0_f32</span>;\n<span class=\"kw\">let </span>g = -<span class=\"number\">7.0_f32</span>;\n\n<span class=\"macro\">assert!</span>(f.is_sign_positive());\n<span class=\"macro\">assert!</span>(!g.is_sign_positive());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0_f32;%0A++++let+g+=+-7.0_f32;%0A++++%0A++++assert!(f.is_sign_positive());%0A++++assert!(!g.is_sign_positive());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_sign_negative\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72505\" title=\"Tracking issue for const_float_classify\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#749\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_sign_negative\" class=\"fn\">is_sign_negative</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, NaNs with\nnegative sign bit and negative infinity. Note that IEEE 754 doesn’t assign any\nmeaning to the sign bit in case of a NaN, and as Rust doesn’t guarantee that\nthe bit pattern of NaNs are conserved over arithmetic operations, the result of\n<code>is_sign_negative</code> on a NaN might produce an unexpected result in some cases.\nSee <a href=\"primitive.f32.html\" title=\"primitive f32\">explanation of NaN as a special value</a> for more info.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>f = <span class=\"number\">7.0f32</span>;\n<span class=\"kw\">let </span>g = -<span class=\"number\">7.0f32</span>;\n\n<span class=\"macro\">assert!</span>(!f.is_sign_negative());\n<span class=\"macro\">assert!</span>(g.is_sign_negative());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+g+=+-7.0f32;%0A++++%0A++++assert!(!f.is_sign_negative());%0A++++assert!(g.is_sign_negative());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.next_up\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#784\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.next_up\" class=\"fn\">next_up</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>float_next_up_down</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/91399\">#91399</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the least number greater than <code>self</code>.</p>\n<p>Let <code>TINY</code> be the smallest representable positive <code>f32</code>. Then,</p>\n<ul>\n<li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li>\n<li>if <code>self</code> is <a href=\"primitive.f32.html#associatedconstant.NEG_INFINITY\" title=\"associated constant f32::NEG_INFINITY\"><code>NEG_INFINITY</code></a>, this returns <a href=\"primitive.f32.html#associatedconstant.MIN\" title=\"associated constant f32::MIN\"><code>MIN</code></a>;</li>\n<li>if <code>self</code> is <code>-TINY</code>, this returns -0.0;</li>\n<li>if <code>self</code> is -0.0 or +0.0, this returns <code>TINY</code>;</li>\n<li>if <code>self</code> is <a href=\"primitive.f32.html#associatedconstant.MAX\" title=\"associated constant f32::MAX\"><code>MAX</code></a> or <a href=\"primitive.f32.html#associatedconstant.INFINITY\" title=\"associated constant f32::INFINITY\"><code>INFINITY</code></a>, this returns <a href=\"primitive.f32.html#associatedconstant.INFINITY\" title=\"associated constant f32::INFINITY\"><code>INFINITY</code></a>;</li>\n<li>otherwise the unique least value greater than <code>self</code> is returned.</li>\n</ul>\n<p>The identity <code>x.next_up() == -(-x).next_down()</code> holds for all non-NaN <code>x</code>. When <code>x</code>\nis finite <code>x == x.next_up().next_down()</code> also holds.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(float_next_up_down)]\n</span><span class=\"comment\">// f32::EPSILON is the difference between 1.0 and the next number up.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">1.0f32</span>.next_up(), <span class=\"number\">1.0 </span>+ f32::EPSILON);\n<span class=\"comment\">// But not for most numbers.\n</span><span class=\"macro\">assert!</span>(<span class=\"number\">0.1f32</span>.next_up() &lt; <span class=\"number\">0.1 </span>+ f32::EPSILON);\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">16777216f32</span>.next_up(), <span class=\"number\">16777218.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_next_up_down)%5D%0A//+f32::EPSILON+is+the+difference+between+1.0+and+the+next+number+up.%0Afn+main()+%7B%0A++++assert_eq!(1.0f32.next_up(),+1.0+%2B+f32::EPSILON);%0A++++//+But+not+for+most+numbers.%0A++++assert!(0.1f32.next_up()+%3C+0.1+%2B+f32::EPSILON);%0A++++assert_eq!(16777216f32.next_up(),+16777218.0);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.next_down\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#834\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.next_down\" class=\"fn\">next_down</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>float_next_up_down</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/91399\">#91399</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the greatest number less than <code>self</code>.</p>\n<p>Let <code>TINY</code> be the smallest representable positive <code>f32</code>. Then,</p>\n<ul>\n<li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li>\n<li>if <code>self</code> is <a href=\"primitive.f32.html#associatedconstant.INFINITY\" title=\"associated constant f32::INFINITY\"><code>INFINITY</code></a>, this returns <a href=\"primitive.f32.html#associatedconstant.MAX\" title=\"associated constant f32::MAX\"><code>MAX</code></a>;</li>\n<li>if <code>self</code> is <code>TINY</code>, this returns 0.0;</li>\n<li>if <code>self</code> is -0.0 or +0.0, this returns <code>-TINY</code>;</li>\n<li>if <code>self</code> is <a href=\"primitive.f32.html#associatedconstant.MIN\" title=\"associated constant f32::MIN\"><code>MIN</code></a> or <a href=\"primitive.f32.html#associatedconstant.NEG_INFINITY\" title=\"associated constant f32::NEG_INFINITY\"><code>NEG_INFINITY</code></a>, this returns <a href=\"primitive.f32.html#associatedconstant.NEG_INFINITY\" title=\"associated constant f32::NEG_INFINITY\"><code>NEG_INFINITY</code></a>;</li>\n<li>otherwise the unique greatest value less than <code>self</code> is returned.</li>\n</ul>\n<p>The identity <code>x.next_down() == -(-x).next_up()</code> holds for all non-NaN <code>x</code>. When <code>x</code>\nis finite <code>x == x.next_down().next_up()</code> also holds.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(float_next_up_down)]\n</span><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"comment\">// Clamp value into range [0, 1).\n</span><span class=\"kw\">let </span>clamped = x.clamp(<span class=\"number\">0.0</span>, <span class=\"number\">1.0f32</span>.next_down());\n<span class=\"macro\">assert!</span>(clamped &lt; <span class=\"number\">1.0</span>);\n<span class=\"macro\">assert_eq!</span>(clamped.next_up(), <span class=\"number\">1.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_next_up_down)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++//+Clamp+value+into+range+%5B0,+1).%0A++++let+clamped+=+x.clamp(0.0,+1.0f32.next_down());%0A++++assert!(clamped+%3C+1.0);%0A++++assert_eq!(clamped.next_up(),+1.0);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.recip\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#867\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.recip\" class=\"fn\">recip</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Takes the reciprocal (inverse) of a number, <code>1/x</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">2.0_f32</span>;\n<span class=\"kw\">let </span>abs_difference = (x.recip() - (<span class=\"number\">1.0 </span>/ x)).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.recip()+-+(1.0+/+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_degrees\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#884\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_degrees\" class=\"fn\">to_degrees</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts radians to degrees.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>angle = std::f32::consts::PI;\n\n<span class=\"kw\">let </span>abs_difference = (angle.to_degrees() - <span class=\"number\">180.0</span>).abs();\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+angle+=+std::f32::consts::PI;%0A++++%0A++++let+abs_difference+=+(angle.to_degrees()+-+180.0).abs();%0A++++%23%5Bcfg(any(not(target_arch+=+%22x86%22),+target_feature+=+%22sse2%22))%5D%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_radians\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#903\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_radians\" class=\"fn\">to_radians</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts degrees to radians.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>angle = <span class=\"number\">180.0f32</span>;\n\n<span class=\"kw\">let </span>abs_difference = (angle.to_radians() - std::f32::consts::PI).abs();\n\n<span class=\"macro\">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+angle+=+180.0f32;%0A++++%0A++++let+abs_difference+=+(angle.to_radians()+-+std::f32::consts::PI).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#924\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.max\" class=\"fn\">max</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the maximum of the two numbers, ignoring NaN.</p>\n<p>If one of the arguments is NaN, then the other argument is returned.\nThis follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs;\nthis function handles all NaNs the same way and avoids maxNum’s problems with associativity.\nThis also matches the behavior of libm’s fmax.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>y = <span class=\"number\">2.0f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(x.max(y), y);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.max(y),+y);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#944\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.min\" class=\"fn\">min</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the minimum of the two numbers, ignoring NaN.</p>\n<p>If one of the arguments is NaN, then the other argument is returned.\nThis follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs;\nthis function handles all NaNs the same way and avoids minNum’s problems with associativity.\nThis also matches the behavior of libm’s fmin.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>y = <span class=\"number\">2.0f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(x.min(y), x);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.min(y),+x);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.maximum\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#971\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.maximum\" class=\"fn\">maximum</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>float_minimum_maximum</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/91079\">#91079</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the maximum of the two numbers, propagating NaN.</p>\n<p>This returns NaN when <em>either</em> argument is NaN, as opposed to\n<a href=\"primitive.f32.html#method.max\" title=\"method f32::max\"><code>f32::max</code></a> which only returns NaN when <em>both</em> arguments are NaN.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(float_minimum_maximum)]\n</span><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>y = <span class=\"number\">2.0f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(x.maximum(y), y);\n<span class=\"macro\">assert!</span>(x.maximum(f32::NAN).is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.maximum(y),+y);%0A++++assert!(x.maximum(f32::NAN).is_nan());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\nof the two numbers. For this operation, -0.0 is considered to be less than +0.0.\nNote that this follows the semantics specified in IEEE 754-2019.</p>\n<p>Also note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN\noperand is conserved; see <a href=\"primitive.f32.html\" title=\"primitive f32\">explanation of NaN as a special value</a> for more info.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.minimum\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1006\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.minimum\" class=\"fn\">minimum</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>float_minimum_maximum</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/91079\">#91079</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns the minimum of the two numbers, propagating NaN.</p>\n<p>This returns NaN when <em>either</em> argument is NaN, as opposed to\n<a href=\"primitive.f32.html#method.min\" title=\"method f32::min\"><code>f32::min</code></a> which only returns NaN when <em>both</em> arguments are NaN.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(float_minimum_maximum)]\n</span><span class=\"kw\">let </span>x = <span class=\"number\">1.0f32</span>;\n<span class=\"kw\">let </span>y = <span class=\"number\">2.0f32</span>;\n\n<span class=\"macro\">assert_eq!</span>(x.minimum(y), x);\n<span class=\"macro\">assert!</span>(x.minimum(f32::NAN).is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.minimum(y),+x);%0A++++assert!(x.minimum(f32::NAN).is_nan());%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n<p>If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\nof the two numbers. For this operation, -0.0 is considered to be less than +0.0.\nNote that this follows the semantics specified in IEEE 754-2019.</p>\n<p>Also note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN\noperand is conserved; see <a href=\"primitive.f32.html\" title=\"primitive f32\">explanation of NaN as a special value</a> for more info.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.midpoint\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1032\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.midpoint\" class=\"fn\">midpoint</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>num_midpoint</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/110840\">#110840</a>)</span></div></span></summary><div class=\"docblock\"><p>Calculates the middle point of <code>self</code> and <code>rhs</code>.</p>\n<p>This returns NaN when <em>either</em> argument is NaN or if a combination of\n+inf and -inf is provided as arguments.</p>\n<h5 id=\"examples-42\"><a class=\"doc-anchor\" href=\"#examples-42\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(num_midpoint)]\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">1f32</span>.midpoint(<span class=\"number\">4.0</span>), <span class=\"number\">2.5</span>);\n<span class=\"macro\">assert_eq!</span>((-<span class=\"number\">5.5f32</span>).midpoint(<span class=\"number\">8.0</span>), <span class=\"number\">1.25</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(num_midpoint)%5D%0Afn+main()+%7B%0A++++assert_eq!(1f32.midpoint(4.0),+2.5);%0A++++assert_eq!((-5.5f32).midpoint(8.0),+1.25);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_int_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.44.0\">1.44.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1096-1098\">source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"#method.to_int_unchecked\" class=\"fn\">to_int_unchecked</a>&lt;Int&gt;(self) -&gt; Int<div class=\"where\">where\n    <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>: <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;Int&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Rounds toward zero and converts to any primitive integer type,\nassuming that the value is finite and fits in that type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>value = <span class=\"number\">4.6_f32</span>;\n<span class=\"kw\">let </span>rounded = <span class=\"kw\">unsafe </span>{ value.to_int_unchecked::&lt;u16&gt;() };\n<span class=\"macro\">assert_eq!</span>(rounded, <span class=\"number\">4</span>);\n\n<span class=\"kw\">let </span>value = -<span class=\"number\">128.9_f32</span>;\n<span class=\"kw\">let </span>rounded = <span class=\"kw\">unsafe </span>{ value.to_int_unchecked::&lt;i8&gt;() };\n<span class=\"macro\">assert_eq!</span>(rounded, i8::MIN);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+4.6_f32;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Cu16%3E()+%7D;%0A++++assert_eq!(rounded,+4);%0A++++%0A++++let+value+=+-128.9_f32;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Ci8%3E()+%7D;%0A++++assert_eq!(rounded,+i8::MIN);%0A%7D&amp;edition=2021\">Run</a></div>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>The value must:</p>\n<ul>\n<li>Not be <code>NaN</code></li>\n<li>Not be infinite</li>\n<li>Be representable in the return type <code>Int</code>, after truncating off its fractional part</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_bits\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0, const unstable\">1.20.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1127\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_bits\" class=\"fn\">to_bits</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.u32.html\">u32</a></h4></section></summary><div class=\"docblock\"><p>Raw transmutation to <code>u32</code>.</p>\n<p>This is currently identical to <code>transmute::&lt;f32, u32&gt;(self)</code> on all platforms.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<p>Note that this function is distinct from <code>as</code> casting, which attempts to\npreserve the <em>numeric</em> value, and not the bitwise value.</p>\n<h5 id=\"examples-43\"><a class=\"doc-anchor\" href=\"#examples-43\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_ne!</span>((<span class=\"number\">1f32</span>).to_bits(), <span class=\"number\">1f32 </span><span class=\"kw\">as </span>u32); <span class=\"comment\">// to_bits() is not casting!\n</span><span class=\"macro\">assert_eq!</span>((<span class=\"number\">12.5f32</span>).to_bits(), <span class=\"number\">0x41480000</span>);\n</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_ne!((1f32).to_bits(),+1f32+as+u32);+//+to_bits()+is+not+casting!%0A++++assert_eq!((12.5f32).to_bits(),+0x41480000);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_bits\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0, const unstable\">1.20.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1216\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_bits\" class=\"fn\">from_bits</a>(v: <a class=\"primitive\" href=\"primitive.u32.html\">u32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Raw transmutation from <code>u32</code>.</p>\n<p>This is currently identical to <code>transmute::&lt;u32, f32&gt;(v)</code> on all platforms.\nIt turns out this is incredibly portable, for two reasons:</p>\n<ul>\n<li>Floats and Ints have the same endianness on all supported platforms.</li>\n<li>IEEE 754 very precisely specifies the bit layout of floats.</li>\n</ul>\n<p>However there is one caveat: prior to the 2008 version of IEEE 754, how\nto interpret the NaN signaling bit wasn’t actually specified. Most platforms\n(notably x86 and ARM) picked the interpretation that was ultimately\nstandardized in 2008, but some didn’t (notably MIPS). As a result, all\nsignaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</p>\n<p>Rather than trying to preserve signaling-ness cross-platform, this\nimplementation favors preserving the exact bits. This means that\nany payloads encoded in NaNs will be preserved even if the result of\nthis method is sent over the network from an x86 machine to a MIPS one.</p>\n<p>If the results of this method are only manipulated by the same\narchitecture that produced them, then there is no portability concern.</p>\n<p>If the input isn’t NaN, then there is no portability concern.</p>\n<p>If you don’t care about signalingness (very likely), then there is no\nportability concern.</p>\n<p>Note that this function is distinct from <code>as</code> casting, which attempts to\npreserve the <em>numeric</em> value, and not the bitwise value.</p>\n<h5 id=\"examples-44\"><a class=\"doc-anchor\" href=\"#examples-44\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = f32::from_bits(<span class=\"number\">0x41480000</span>);\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"number\">12.5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+f32::from_bits(0x41480000);%0A++++assert_eq!(v,+12.5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_be_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0, const unstable\">1.40.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1284\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_be_bytes\" class=\"fn\">to_be_bytes</a>(self) -&gt; [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"primitive.array.html\">4</a>]</h4></section></summary><div class=\"docblock\"><p>Return the memory representation of this floating point number as a byte array in\nbig-endian (network) byte order.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<h5 id=\"examples-45\"><a class=\"doc-anchor\" href=\"#examples-45\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bytes = <span class=\"number\">12.5f32</span>.to_be_bytes();\n<span class=\"macro\">assert_eq!</span>(bytes, [<span class=\"number\">0x41</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_be_bytes();%0A++++assert_eq!(bytes,+%5B0x41,+0x48,+0x00,+0x00%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_le_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0, const unstable\">1.40.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1305\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_le_bytes\" class=\"fn\">to_le_bytes</a>(self) -&gt; [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"primitive.array.html\">4</a>]</h4></section></summary><div class=\"docblock\"><p>Return the memory representation of this floating point number as a byte array in\nlittle-endian byte order.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<h5 id=\"examples-46\"><a class=\"doc-anchor\" href=\"#examples-46\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bytes = <span class=\"number\">12.5f32</span>.to_le_bytes();\n<span class=\"macro\">assert_eq!</span>(bytes, [<span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x41</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_le_bytes();%0A++++assert_eq!(bytes,+%5B0x00,+0x00,+0x48,+0x41%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_ne_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0, const unstable\">1.40.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1339\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.to_ne_bytes\" class=\"fn\">to_ne_bytes</a>(self) -&gt; [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"primitive.array.html\">4</a>]</h4></section></summary><div class=\"docblock\"><p>Return the memory representation of this floating point number as a byte array in\nnative byte order.</p>\n<p>As the target platform’s native endianness is used, portable code\nshould use <a href=\"primitive.f32.html#method.to_be_bytes\" title=\"method f32::to_be_bytes\"><code>to_be_bytes</code></a> or <a href=\"primitive.f32.html#method.to_le_bytes\" title=\"method f32::to_le_bytes\"><code>to_le_bytes</code></a>, as appropriate, instead.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<h5 id=\"examples-47\"><a class=\"doc-anchor\" href=\"#examples-47\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>bytes = <span class=\"number\">12.5f32</span>.to_ne_bytes();\n<span class=\"macro\">assert_eq!</span>(\n    bytes,\n    <span class=\"kw\">if </span><span class=\"macro\">cfg!</span>(target_endian = <span class=\"string\">\"big\"</span>) {\n        [<span class=\"number\">0x41</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>]\n    } <span class=\"kw\">else </span>{\n        [<span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x41</span>]\n    }\n);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_ne_bytes();%0A++++assert_eq!(%0A++++++++bytes,%0A++++++++if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++++++%5B0x41,+0x48,+0x00,+0x00%5D%0A++++++++%7D+else+%7B%0A++++++++++++%5B0x00,+0x00,+0x48,+0x41%5D%0A++++++++%7D%0A++++);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_be_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0, const unstable\">1.40.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1358\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_be_bytes\" class=\"fn\">from_be_bytes</a>(bytes: [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"primitive.array.html\">4</a>]) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Create a floating point value from its representation as a byte array in big endian.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<h5 id=\"examples-48\"><a class=\"doc-anchor\" href=\"#examples-48\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>value = f32::from_be_bytes([<span class=\"number\">0x41</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>]);\n<span class=\"macro\">assert_eq!</span>(value, <span class=\"number\">12.5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_be_bytes(%5B0x41,+0x48,+0x00,+0x00%5D);%0A++++assert_eq!(value,+12.5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_le_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0, const unstable\">1.40.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1377\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_le_bytes\" class=\"fn\">from_le_bytes</a>(bytes: [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"primitive.array.html\">4</a>]) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Create a floating point value from its representation as a byte array in little endian.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<h5 id=\"examples-49\"><a class=\"doc-anchor\" href=\"#examples-49\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>value = f32::from_le_bytes([<span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x41</span>]);\n<span class=\"macro\">assert_eq!</span>(value, <span class=\"number\">12.5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_le_bytes(%5B0x00,+0x00,+0x48,+0x41%5D);%0A++++assert_eq!(value,+12.5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_ne_bytes\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0, const unstable\">1.40.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/72447\" title=\"Tracking issue for const_float_bits_conv\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1407\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.from_ne_bytes\" class=\"fn\">from_ne_bytes</a>(bytes: [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>; <a class=\"primitive\" href=\"primitive.array.html\">4</a>]) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Create a floating point value from its representation as a byte array in native endian.</p>\n<p>As the target platform’s native endianness is used, portable code\nlikely wants to use <a href=\"primitive.f32.html#method.from_be_bytes\" title=\"associated function f32::from_be_bytes\"><code>from_be_bytes</code></a> or <a href=\"primitive.f32.html#method.from_le_bytes\" title=\"associated function f32::from_le_bytes\"><code>from_le_bytes</code></a>, as\nappropriate instead.</p>\n<p>See <a href=\"primitive.f32.html#method.from_bits\" title=\"associated function f32::from_bits\"><code>from_bits</code></a> for some discussion of the\nportability of this operation (there are almost no issues).</p>\n<h5 id=\"examples-50\"><a class=\"doc-anchor\" href=\"#examples-50\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>value = f32::from_ne_bytes(<span class=\"kw\">if </span><span class=\"macro\">cfg!</span>(target_endian = <span class=\"string\">\"big\"</span>) {\n    [<span class=\"number\">0x41</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>]\n} <span class=\"kw\">else </span>{\n    [<span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x41</span>]\n});\n<span class=\"macro\">assert_eq!</span>(value, <span class=\"number\">12.5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_ne_bytes(if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++%5B0x41,+0x48,+0x00,+0x00%5D%0A++++%7D+else+%7B%0A++++++++%5B0x00,+0x00,+0x48,+0x41%5D%0A++++%7D);%0A++++assert_eq!(value,+12.5);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.total_cmp\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.62.0\">1.62.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1473\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.total_cmp\" class=\"fn\">total_cmp</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"enum\" href=\"cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\"><p>Return the ordering between <code>self</code> and <code>other</code>.</p>\n<p>Unlike the standard partial comparison between floating point numbers,\nthis comparison always produces an ordering in accordance to\nthe <code>totalOrder</code> predicate as defined in the IEEE 754 (2008 revision)\nfloating point standard. The values are ordered in the following sequence:</p>\n<ul>\n<li>negative quiet NaN</li>\n<li>negative signaling NaN</li>\n<li>negative infinity</li>\n<li>negative numbers</li>\n<li>negative subnormal numbers</li>\n<li>negative zero</li>\n<li>positive zero</li>\n<li>positive subnormal numbers</li>\n<li>positive numbers</li>\n<li>positive infinity</li>\n<li>positive signaling NaN</li>\n<li>positive quiet NaN.</li>\n</ul>\n<p>The ordering established by this function does not always agree with the\n<a href=\"cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a> and <a href=\"cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\"><code>PartialEq</code></a> implementations of <code>f32</code>. For example,\nthey consider negative and positive zero equal, while <code>total_cmp</code>\ndoesn’t.</p>\n<p>The interpretation of the signaling NaN bit follows the definition in\nthe IEEE 754 standard, which may not match the interpretation by some of\nthe older, non-conformant (e.g. MIPS) hardware implementations.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">struct </span>GoodBoy {\n    name: String,\n    weight: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bois = <span class=\"macro\">vec!</span>[\n    GoodBoy { name: <span class=\"string\">\"Pucci\"</span>.to_owned(), weight: <span class=\"number\">0.1 </span>},\n    GoodBoy { name: <span class=\"string\">\"Woofer\"</span>.to_owned(), weight: <span class=\"number\">99.0 </span>},\n    GoodBoy { name: <span class=\"string\">\"Yapper\"</span>.to_owned(), weight: <span class=\"number\">10.0 </span>},\n    GoodBoy { name: <span class=\"string\">\"Chonk\"</span>.to_owned(), weight: f32::INFINITY },\n    GoodBoy { name: <span class=\"string\">\"Abs. Unit\"</span>.to_owned(), weight: f32::NAN },\n    GoodBoy { name: <span class=\"string\">\"Floaty\"</span>.to_owned(), weight: -<span class=\"number\">5.0 </span>},\n];\n\nbois.sort_by(|a, b| a.weight.total_cmp(<span class=\"kw-2\">&amp;</span>b.weight));\n\n<span class=\"comment\">// `f32::NAN` could be positive or negative, which will affect the sort order.\n</span><span class=\"kw\">if </span>f32::NAN.is_sign_negative() {\n    <span class=\"macro\">assert!</span>(bois.into_iter().map(|b| b.weight)\n        .zip([f32::NAN, -<span class=\"number\">5.0</span>, <span class=\"number\">0.1</span>, <span class=\"number\">10.0</span>, <span class=\"number\">99.0</span>, f32::INFINITY].iter())\n        .all(|(a, b)| a.to_bits() == b.to_bits()))\n} <span class=\"kw\">else </span>{\n    <span class=\"macro\">assert!</span>(bois.into_iter().map(|b| b.weight)\n        .zip([-<span class=\"number\">5.0</span>, <span class=\"number\">0.1</span>, <span class=\"number\">10.0</span>, <span class=\"number\">99.0</span>, f32::INFINITY, f32::NAN].iter())\n        .all(|(a, b)| a.to_bits() == b.to_bits()))\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+GoodBoy+%7B%0A++++++++name:+String,%0A++++++++weight:+f32,%0A++++%7D%0A++++%0A++++let+mut+bois+=+vec!%5B%0A++++++++GoodBoy+%7B+name:+%22Pucci%22.to_owned(),+weight:+0.1+%7D,%0A++++++++GoodBoy+%7B+name:+%22Woofer%22.to_owned(),+weight:+99.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Yapper%22.to_owned(),+weight:+10.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Chonk%22.to_owned(),+weight:+f32::INFINITY+%7D,%0A++++++++GoodBoy+%7B+name:+%22Abs.+Unit%22.to_owned(),+weight:+f32::NAN+%7D,%0A++++++++GoodBoy+%7B+name:+%22Floaty%22.to_owned(),+weight:+-5.0+%7D,%0A++++%5D;%0A++++%0A++++bois.sort_by(%7Ca,+b%7C+a.weight.total_cmp(%26b.weight));%0A++++%0A++++//+%60f32::NAN%60+could+be+positive+or+negative,+which+will+affect+the+sort+order.%0A++++if+f32::NAN.is_sign_negative()+%7B%0A++++++++assert!(bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5Bf32::NAN,+-5.0,+0.1,+10.0,+99.0,+f32::INFINITY%5D.iter())%0A++++++++++++.all(%7C(a,+b)%7C+a.to_bits()+==+b.to_bits()))%0A++++%7D+else+%7B%0A++++++++assert!(bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5B-5.0,+0.1,+10.0,+99.0,+f32::INFINITY,+f32::NAN%5D.iter())%0A++++++++++++.all(%7C(a,+b)%7C+a.to_bits()+==+b.to_bits()))%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/f32.rs.html#1528\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.clamp\" class=\"fn\">clamp</a>(self, min: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>, max: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Restrict a value to a certain interval unless it is NaN.</p>\n<p>Returns <code>max</code> if <code>self</code> is greater than <code>max</code>, and <code>min</code> if <code>self</code> is\nless than <code>min</code>. Otherwise this returns <code>self</code>.</p>\n<p>Note that this function returns NaN if the initial value was NaN as\nwell.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>Panics if <code>min &gt; max</code>, <code>min</code> is NaN, or <code>max</code> is NaN.</p>\n<h5 id=\"examples-51\"><a class=\"doc-anchor\" href=\"#examples-51\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>((-<span class=\"number\">3.0f32</span>).clamp(-<span class=\"number\">2.0</span>, <span class=\"number\">1.0</span>) == -<span class=\"number\">2.0</span>);\n<span class=\"macro\">assert!</span>((<span class=\"number\">0.0f32</span>).clamp(-<span class=\"number\">2.0</span>, <span class=\"number\">1.0</span>) == <span class=\"number\">0.0</span>);\n<span class=\"macro\">assert!</span>((<span class=\"number\">2.0f32</span>).clamp(-<span class=\"number\">2.0</span>, <span class=\"number\">1.0</span>) == <span class=\"number\">1.0</span>);\n<span class=\"macro\">assert!</span>((f32::NAN).clamp(-<span class=\"number\">2.0</span>, <span class=\"number\">1.0</span>).is_nan());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!((-3.0f32).clamp(-2.0,+1.0)+==+-2.0);%0A++++assert!((0.0f32).clamp(-2.0,+1.0)+==+0.0);%0A++++assert!((2.0f32).clamp(-2.0,+1.0)+==+1.0);%0A++++assert!((f32::NAN).clamp(-2.0,+1.0).is_nan());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Add%3C%26f32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a></span><a href=\"#impl-Add%3C%26f32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-11\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-11\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Add.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Add.html#associatedtype.Output\" title=\"type std::ops::Add::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>+</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a><a href=\"#method.add-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Add.html#tymethod.add\" class=\"fn\">add</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Add.html#associatedtype.Output\" title=\"type std::ops::Add::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>+</code> operation. <a href=\"ops/trait.Add.html#tymethod.add\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Add%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a></span><a href=\"#impl-Add%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-10\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-10\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Add.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Add.html#associatedtype.Output\" title=\"type std::ops::Add::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>+</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a><a href=\"#method.add\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Add.html#tymethod.add\" class=\"fn\">add</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Add.html#associatedtype.Output\" title=\"type std::ops::Add::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>+</code> operation. <a href=\"ops/trait.Add.html#tymethod.add\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Add%3Cf32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a></span><a href=\"#impl-Add%3Cf32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-12\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-12\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Add.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Add.html#associatedtype.Output\" title=\"type std::ops::Add::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>+</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a><a href=\"#method.add-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Add.html#tymethod.add\" class=\"fn\">add</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Add.html#associatedtype.Output\" title=\"type std::ops::Add::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>+</code> operation. <a href=\"ops/trait.Add.html#tymethod.add\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Add-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/90080\" title=\"Tracking issue for const_ops\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a></span><a href=\"#impl-Add-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Add.html\" title=\"trait std::ops::Add\">Add</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-13\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-13\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Add.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>+</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112\">source</a><a href=\"#method.add-3\" class=\"anchor\">§</a><h4 class=\"code-header\">const fn <a href=\"ops/trait.Add.html#tymethod.add\" class=\"fn\">add</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Performs the <code>+</code> operation. <a href=\"ops/trait.Add.html#tymethod.add\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AddAssign%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.22.0\">1.22.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768\">source</a></span><a href=\"#impl-AddAssign%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.AddAssign.html\" title=\"trait std::ops::AddAssign\">AddAssign</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768\">source</a><a href=\"#method.add_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.AddAssign.html#tymethod.add_assign\" class=\"fn\">add_assign</a>(&amp;mut self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>+=</code> operation. <a href=\"ops/trait.AddAssign.html#tymethod.add_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AddAssign-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768\">source</a></span><a href=\"#impl-AddAssign-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.AddAssign.html\" title=\"trait std::ops::AddAssign\">AddAssign</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.add_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768\">source</a><a href=\"#method.add_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.AddAssign.html#tymethod.add_assign\" class=\"fn\">add_assign</a>(&amp;mut self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>+=</code> operation. <a href=\"ops/trait.AddAssign.html#tymethod.add_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#227-232\">source</a></span><a href=\"#impl-Clone-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#227-232\">source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Returns a copy of the value. <a href=\"clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class=\"docblock\">Performs copy-assignment from <code>source</code>. <a href=\"clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a></span><a href=\"#impl-Debug-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a><a href=\"#method.fmt-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.unit.html\">()</a>, <a class=\"struct\" href=\"fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/default.rs.html#182\">source</a></span><a href=\"#impl-Default-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/default.rs.html#182\">source</a><a href=\"#method.default\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Returns the default value of <code>0.0</code></p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Display-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a></span><a href=\"#impl-Display-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a><a href=\"#method.fmt-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"fmt/trait.Display.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.unit.html\">()</a>, <a class=\"struct\" href=\"fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"fmt/trait.Display.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Div%3C%26f32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a></span><a href=\"#impl-Div%3C%26f32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-14\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-14\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Div.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Div.html#associatedtype.Output\" title=\"type std::ops::Div::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>/</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a><a href=\"#method.div\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Div.html#tymethod.div\" class=\"fn\">div</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Div.html#associatedtype.Output\" title=\"type std::ops::Div::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>/</code> operation. <a href=\"ops/trait.Div.html#tymethod.div\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Div%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a></span><a href=\"#impl-Div%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-17\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-17\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Div.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Div.html#associatedtype.Output\" title=\"type std::ops::Div::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>/</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a><a href=\"#method.div-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Div.html#tymethod.div\" class=\"fn\">div</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Div.html#associatedtype.Output\" title=\"type std::ops::Div::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>/</code> operation. <a href=\"ops/trait.Div.html#tymethod.div\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Div%3Cf32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a></span><a href=\"#impl-Div%3Cf32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-16\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-16\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Div.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Div.html#associatedtype.Output\" title=\"type std::ops::Div::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>/</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a><a href=\"#method.div-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Div.html#tymethod.div\" class=\"fn\">div</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Div.html#associatedtype.Output\" title=\"type std::ops::Div::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>/</code> operation. <a href=\"ops/trait.Div.html#tymethod.div\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Div-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a></span><a href=\"#impl-Div-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Div.html\" title=\"trait std::ops::Div\">Div</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-15\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-15\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Div.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>/</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509\">source</a><a href=\"#method.div-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Div.html#tymethod.div\" class=\"fn\">div</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Performs the <code>/</code> operation. <a href=\"ops/trait.Div.html#tymethod.div\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-DivAssign%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.22.0\">1.22.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950\">source</a></span><a href=\"#impl-DivAssign%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.DivAssign.html\" title=\"trait std::ops::DivAssign\">DivAssign</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950\">source</a><a href=\"#method.div_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.DivAssign.html#tymethod.div_assign\" class=\"fn\">div_assign</a>(&amp;mut self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>/=</code> operation. <a href=\"ops/trait.DivAssign.html#tymethod.div_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-DivAssign-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950\">source</a></span><a href=\"#impl-DivAssign-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.DivAssign.html\" title=\"trait std::ops::DivAssign\">DivAssign</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.div_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950\">source</a><a href=\"#method.div_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.DivAssign.html#tymethod.div_assign\" class=\"fn\">div_assign</a>(&amp;mut self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>/=</code> operation. <a href=\"ops/trait.DivAssign.html#tymethod.div_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cbool%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.68.0\">1.68.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#201\">source</a></span><a href=\"#impl-From%3Cbool%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.bool.html\">bool</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-6\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#201\">source</a><a href=\"#method.from-6\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.bool.html\">bool</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts a <a href=\"primitive.bool.html\" title=\"primitive bool\"><code>bool</code></a> to <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> losslessly.\nThe resulting value is positive <code>0.0</code> for <code>false</code> and <code>1.0</code> for <code>true</code> values.</p>\n<h5 id=\"examples-52\"><a class=\"doc-anchor\" href=\"#examples-52\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x: f32 = <span class=\"bool-val\">false</span>.into();\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"number\">0.0</span>);\n<span class=\"macro\">assert!</span>(x.is_sign_positive());\n\n<span class=\"kw\">let </span>y: f32 = <span class=\"bool-val\">true</span>.into();\n<span class=\"macro\">assert_eq!</span>(y, <span class=\"number\">1.0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+false.into();%0A++++assert_eq!(x,+0.0);%0A++++assert!(x.is_sign_positive());%0A++++%0A++++let+y:+f32+=+true.into();%0A++++assert_eq!(y,+1.0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cf32%3E-for-f128\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#173\">source</a></span><a href=\"#impl-From%3Cf32%3E-for-f128\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f128.html\">f128</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-4\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#173\">source</a><a href=\"#method.from-4\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f128.html\">f128</a></h4></section></summary><div class=\"docblock\"><p>Converts <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> to <a href=\"primitive.f128.html\" title=\"primitive f128\"><code>f128</code></a> losslessly.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cf32%3E-for-f64\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#172\">source</a></span><a href=\"#impl-From%3Cf32%3E-for-f64\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f64.html\">f64</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-5\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#172\">source</a><a href=\"#method.from-5\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f64.html\">f64</a></h4></section></summary><div class=\"docblock\"><p>Converts <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> to <a href=\"primitive.f64.html\" title=\"primitive f64\"><code>f64</code></a> losslessly.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Ci16%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#156\">source</a></span><a href=\"#impl-From%3Ci16%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.i16.html\">i16</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#156\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.i16.html\">i16</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts <a href=\"primitive.i16.html\" title=\"primitive i16\"><code>i16</code></a> to <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> losslessly.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Ci8%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#154\">source</a></span><a href=\"#impl-From%3Ci8%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.i8.html\">i8</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#154\">source</a><a href=\"#method.from-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.i8.html\">i8</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts <a href=\"primitive.i8.html\" title=\"primitive i8\"><code>i8</code></a> to <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> losslessly.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cu16%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#163\">source</a></span><a href=\"#impl-From%3Cu16%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.u16.html\">u16</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#163\">source</a><a href=\"#method.from-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.u16.html\">u16</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts <a href=\"primitive.u16.html\" title=\"primitive u16\"><code>u16</code></a> to <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> losslessly.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3Cu8%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#161\">source</a></span><a href=\"#impl-From%3Cu8%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#161\">source</a><a href=\"#method.from-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(small: <a class=\"primitive\" href=\"primitive.u8.html\">u8</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\"><p>Converts <a href=\"primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a> to <a href=\"primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> losslessly.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromStr-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/dec2flt/mod.rs.html#163\">source</a></span><a href=\"#impl-FromStr-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"str/trait.FromStr.html\" title=\"trait std::str::FromStr\">FromStr</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_str\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/num/dec2flt/mod.rs.html#163\">source</a><a href=\"#method.from_str\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"str/trait.FromStr.html#tymethod.from_str\" class=\"fn\">from_str</a>(src: &amp;<a class=\"primitive\" href=\"primitive.str.html\">str</a>) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>, <a class=\"struct\" href=\"num/struct.ParseFloatError.html\" title=\"struct std::num::ParseFloatError\">ParseFloatError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a string in base 10 to a float.\nAccepts an optional decimal exponent.</p>\n<p>This function accepts strings such as</p>\n<ul>\n<li>‘3.14’</li>\n<li>‘-3.14’</li>\n<li>‘2.5E10’, or equivalently, ‘2.5e10’</li>\n<li>‘2.5E-10’</li>\n<li>‘5.’</li>\n<li>‘.5’, or, equivalently, ‘0.5’</li>\n<li>‘inf’, ‘-inf’, ‘+infinity’, ‘NaN’</li>\n</ul>\n<p>Note that alphabetical characters are not case-sensitive.</p>\n<p>Leading and trailing whitespace represent an error.</p>\n<h5 id=\"grammar\"><a class=\"doc-anchor\" href=\"#grammar\">§</a>Grammar</h5>\n<p>All strings that adhere to the following <a href=\"https://www.w3.org/TR/REC-xml/#sec-notation\">EBNF</a> grammar when\nlowercased will result in an <a href=\"result/enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> being returned:</p>\n<div class=\"example-wrap\"><pre class=\"language-txt\"><code>Float  ::= Sign? ( 'inf' | 'infinity' | 'nan' | Number )\nNumber ::= ( Digit+ |\n             Digit+ '.' Digit* |\n             Digit* '.' Digit+ ) Exp?\nExp    ::= 'e' Sign? Digit+\nSign   ::= [+-]\nDigit  ::= [0-9]\n</code></pre></div><h5 id=\"arguments\"><a class=\"doc-anchor\" href=\"#arguments\">§</a>Arguments</h5>\n<ul>\n<li>src - A string</li>\n</ul>\n<h5 id=\"return-value\"><a class=\"doc-anchor\" href=\"#return-value\">§</a>Return value</h5>\n<p><code>Err(ParseFloatError)</code> if the string did not represent a valid\nnumber. Otherwise, <code>Ok(n)</code> where <code>n</code> is the closest\nrepresentable floating-point number to the number represented\nby <code>src</code> (following the same rules for rounding as for the\nresults of primitive operations).</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Err\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Err\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"str/trait.FromStr.html#associatedtype.Err\" class=\"associatedtype\">Err</a> = <a class=\"struct\" href=\"num/struct.ParseFloatError.html\" title=\"struct std::num::ParseFloatError\">ParseFloatError</a></h4></section></summary><div class=\"docblock\">The associated error which can be returned from parsing.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-LowerExp-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a></span><a href=\"#impl-LowerExp-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"fmt/trait.LowerExp.html\" title=\"trait std::fmt::LowerExp\">LowerExp</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"fmt/trait.LowerExp.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.unit.html\">()</a>, <a class=\"struct\" href=\"fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"fmt/trait.LowerExp.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Mul%3C%26f32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a></span><a href=\"#impl-Mul%3C%26f32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-2\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Mul.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Mul.html#associatedtype.Output\" title=\"type std::ops::Mul::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>*</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a><a href=\"#method.mul-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Mul.html#tymethod.mul\" class=\"fn\">mul</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Mul.html#associatedtype.Output\" title=\"type std::ops::Mul::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>*</code> operation. <a href=\"ops/trait.Mul.html#tymethod.mul\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Mul%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a></span><a href=\"#impl-Mul%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Mul.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Mul.html#associatedtype.Output\" title=\"type std::ops::Mul::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>*</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a><a href=\"#method.mul\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Mul.html#tymethod.mul\" class=\"fn\">mul</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Mul.html#associatedtype.Output\" title=\"type std::ops::Mul::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>*</code> operation. <a href=\"ops/trait.Mul.html#tymethod.mul\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Mul%3Cf32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a></span><a href=\"#impl-Mul%3Cf32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-3\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-3\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Mul.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Mul.html#associatedtype.Output\" title=\"type std::ops::Mul::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>*</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a><a href=\"#method.mul-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Mul.html#tymethod.mul\" class=\"fn\">mul</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Mul.html#associatedtype.Output\" title=\"type std::ops::Mul::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>*</code> operation. <a href=\"ops/trait.Mul.html#tymethod.mul\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Mul-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a></span><a href=\"#impl-Mul-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Mul.html\" title=\"trait std::ops::Mul\">Mul</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Mul.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>*</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351\">source</a><a href=\"#method.mul-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Mul.html#tymethod.mul\" class=\"fn\">mul</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Performs the <code>*</code> operation. <a href=\"ops/trait.Mul.html#tymethod.mul\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-MulAssign%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.22.0\">1.22.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893\">source</a></span><a href=\"#impl-MulAssign%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.MulAssign.html\" title=\"trait std::ops::MulAssign\">MulAssign</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893\">source</a><a href=\"#method.mul_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.MulAssign.html#tymethod.mul_assign\" class=\"fn\">mul_assign</a>(&amp;mut self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>*=</code> operation. <a href=\"ops/trait.MulAssign.html#tymethod.mul_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-MulAssign-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893\">source</a></span><a href=\"#impl-MulAssign-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.MulAssign.html\" title=\"trait std::ops::MulAssign\">MulAssign</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.mul_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893\">source</a><a href=\"#method.mul_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.MulAssign.html#tymethod.mul_assign\" class=\"fn\">mul_assign</a>(&amp;mut self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>*=</code> operation. <a href=\"ops/trait.MulAssign.html#tymethod.mul_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Neg-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701\">source</a></span><a href=\"#impl-Neg-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Neg.html\" title=\"trait std::ops::Neg\">Neg</a> for &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-5\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-5\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Neg.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Neg.html\" title=\"trait std::ops::Neg\">Neg</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Neg.html#associatedtype.Output\" title=\"type std::ops::Neg::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>-</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.neg-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701\">source</a><a href=\"#method.neg-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Neg.html#tymethod.neg\" class=\"fn\">neg</a>(self) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Neg.html\" title=\"trait std::ops::Neg\">Neg</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Neg.html#associatedtype.Output\" title=\"type std::ops::Neg::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the unary <code>-</code> operation. <a href=\"ops/trait.Neg.html#tymethod.neg\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Neg-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701\">source</a></span><a href=\"#impl-Neg-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Neg.html\" title=\"trait std::ops::Neg\">Neg</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-4\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-4\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Neg.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>-</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.neg\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701\">source</a><a href=\"#method.neg\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Neg.html#tymethod.neg\" class=\"fn\">neg</a>(self) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Performs the unary <code>-</code> operation. <a href=\"ops/trait.Neg.html#tymethod.neg\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/92391\" title=\"Tracking issue for const_cmp\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502\">source</a></span><a href=\"#impl-PartialEq-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502\">source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">const fn <a href=\"cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502\">source</a><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">const fn <a href=\"cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554\">source</a></span><a href=\"#impl-PartialOrd-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"enum\" href=\"option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554\">source</a><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554\">source</a><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554\">source</a><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554\">source</a><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Product%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a></span><a href=\"#impl-Product%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Product.html\" title=\"trait std::iter::Product\">Product</a>&lt;&amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.product\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a><a href=\"#method.product\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"iter/trait.Product.html#tymethod.product\" class=\"fn\">product</a>&lt;I&gt;(iter: I) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Method which takes an iterator and generates <code>Self</code> from the elements by\nmultiplying the items.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Product-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a></span><a href=\"#impl-Product-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"iter/trait.Product.html\" title=\"trait std::iter::Product\">Product</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.product-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a><a href=\"#method.product-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"iter/trait.Product.html#tymethod.product\" class=\"fn\">product</a>&lt;I&gt;(iter: I) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Method which takes an iterator and generates <code>Self</code> from the elements by\nmultiplying the items.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rem%3C%26f32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a></span><a href=\"#impl-Rem%3C%26f32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-19\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-19\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Rem.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Rem.html#associatedtype.Output\" title=\"type std::ops::Rem::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>%</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a><a href=\"#method.rem-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Rem.html#tymethod.rem\" class=\"fn\">rem</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Rem.html#associatedtype.Output\" title=\"type std::ops::Rem::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>%</code> operation. <a href=\"ops/trait.Rem.html#tymethod.rem\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rem%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a></span><a href=\"#impl-Rem%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-18\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-18\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Rem.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Rem.html#associatedtype.Output\" title=\"type std::ops::Rem::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>%</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a><a href=\"#method.rem\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Rem.html#tymethod.rem\" class=\"fn\">rem</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Rem.html#associatedtype.Output\" title=\"type std::ops::Rem::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>%</code> operation. <a href=\"ops/trait.Rem.html#tymethod.rem\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rem%3Cf32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a></span><a href=\"#impl-Rem%3Cf32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-21\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-21\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Rem.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Rem.html#associatedtype.Output\" title=\"type std::ops::Rem::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>%</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a><a href=\"#method.rem-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Rem.html#tymethod.rem\" class=\"fn\">rem</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Rem.html#associatedtype.Output\" title=\"type std::ops::Rem::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>%</code> operation. <a href=\"ops/trait.Rem.html#tymethod.rem\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Rem-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a></span><a href=\"#impl-Rem-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Rem.html\" title=\"trait std::ops::Rem\">Rem</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"docblock\"><p>The remainder from the division of two floats.</p>\n<p>The remainder has the same sign as the dividend and is computed as:\n<code>x - (x / y).trunc() * y</code>.</p>\n<h4 id=\"examples-53\"><a class=\"doc-anchor\" href=\"#examples-53\">§</a>Examples</h4>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x: f32 = <span class=\"number\">50.50</span>;\n<span class=\"kw\">let </span>y: f32 = <span class=\"number\">8.125</span>;\n<span class=\"kw\">let </span>remainder = x - (x / y).trunc() * y;\n\n<span class=\"comment\">// The answer to both operations is 1.75\n</span><span class=\"macro\">assert_eq!</span>(x % y, remainder);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+50.50;%0A++++let+y:+f32+=+8.125;%0A++++let+remainder+=+x+-+(x+/+y).trunc()+*+y;%0A++++%0A++++//+The+answer+to+both+operations+is+1.75%0A++++assert_eq!(x+%25+y,+remainder);%0A%7D&amp;edition=2021\">Run</a></div>\n</div><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-20\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-20\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Rem.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>%</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626\">source</a><a href=\"#method.rem-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Rem.html#tymethod.rem\" class=\"fn\">rem</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Performs the <code>%</code> operation. <a href=\"ops/trait.Rem.html#tymethod.rem\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-RemAssign%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.22.0\">1.22.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011\">source</a></span><a href=\"#impl-RemAssign%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.RemAssign.html\" title=\"trait std::ops::RemAssign\">RemAssign</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011\">source</a><a href=\"#method.rem_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.RemAssign.html#tymethod.rem_assign\" class=\"fn\">rem_assign</a>(&amp;mut self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>%=</code> operation. <a href=\"ops/trait.RemAssign.html#tymethod.rem_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-RemAssign-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011\">source</a></span><a href=\"#impl-RemAssign-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.RemAssign.html\" title=\"trait std::ops::RemAssign\">RemAssign</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.rem_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011\">source</a><a href=\"#method.rem_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.RemAssign.html#tymethod.rem_assign\" class=\"fn\">rem_assign</a>(&amp;mut self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>%=</code> operation. <a href=\"ops/trait.RemAssign.html#tymethod.rem_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-SimdElement-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/vector.rs.html#1158\">source</a><a href=\"#impl-SimdElement-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"simd/trait.SimdElement.html\" title=\"trait std::simd::SimdElement\">SimdElement</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Mask\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Mask\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"simd/trait.SimdElement.html#associatedtype.Mask\" class=\"associatedtype\">Mask</a> = <a class=\"primitive\" href=\"primitive.i32.html\">i32</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/86656\">#86656</a>)</span></div></span><div class=\"docblock\">The mask element type corresponding to this element type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Sub%3C%26f32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a></span><a href=\"#impl-Sub%3C%26f32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-7\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-7\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Sub.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Sub.html#associatedtype.Output\" title=\"type std::ops::Sub::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>-</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sub-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a><a href=\"#method.sub-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Sub.html#tymethod.sub\" class=\"fn\">sub</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Sub.html#associatedtype.Output\" title=\"type std::ops::Sub::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>-</code> operation. <a href=\"ops/trait.Sub.html#tymethod.sub\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Sub%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a></span><a href=\"#impl-Sub%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-9\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-9\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Sub.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Sub.html#associatedtype.Output\" title=\"type std::ops::Sub::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>-</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sub-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a><a href=\"#method.sub-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Sub.html#tymethod.sub\" class=\"fn\">sub</a>(self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Sub.html#associatedtype.Output\" title=\"type std::ops::Sub::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>-</code> operation. <a href=\"ops/trait.Sub.html#tymethod.sub\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Sub%3Cf32%3E-for-%26f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a></span><a href=\"#impl-Sub%3Cf32%3E-for-%26f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-8\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-8\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Sub.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Sub.html#associatedtype.Output\" title=\"type std::ops::Sub::Output\">Output</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>-</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sub-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a><a href=\"#method.sub-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Sub.html#tymethod.sub\" class=\"fn\">sub</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; &lt;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a> as <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a>&gt;::<a class=\"associatedtype\" href=\"ops/trait.Sub.html#associatedtype.Output\" title=\"type std::ops::Sub::Output\">Output</a></h4></section></summary><div class=\"docblock\">Performs the <code>-</code> operation. <a href=\"ops/trait.Sub.html#tymethod.sub\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Sub-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a></span><a href=\"#impl-Sub-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.Sub.html\" title=\"trait std::ops::Sub\">Sub</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output-6\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output-6\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"ops/trait.Sub.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">The resulting type after applying the <code>-</code> operator.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sub\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221\">source</a><a href=\"#method.sub\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.Sub.html#tymethod.sub\" class=\"fn\">sub</a>(self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h4></section></summary><div class=\"docblock\">Performs the <code>-</code> operation. <a href=\"ops/trait.Sub.html#tymethod.sub\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-SubAssign%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.22.0\">1.22.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835\">source</a></span><a href=\"#impl-SubAssign%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.SubAssign.html\" title=\"trait std::ops::SubAssign\">SubAssign</a>&lt;&amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sub_assign\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835\">source</a><a href=\"#method.sub_assign\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.SubAssign.html#tymethod.sub_assign\" class=\"fn\">sub_assign</a>(&amp;mut self, other: &amp;<a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>-=</code> operation. <a href=\"ops/trait.SubAssign.html#tymethod.sub_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-SubAssign-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.8.0\">1.8.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835\">source</a></span><a href=\"#impl-SubAssign-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"ops/trait.SubAssign.html\" title=\"trait std::ops::SubAssign\">SubAssign</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sub_assign-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835\">source</a><a href=\"#method.sub_assign-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"ops/trait.SubAssign.html#tymethod.sub_assign\" class=\"fn\">sub_assign</a>(&amp;mut self, other: <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>)</h4></section></summary><div class=\"docblock\">Performs the <code>-=</code> operation. <a href=\"ops/trait.SubAssign.html#tymethod.sub_assign\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Sum%3C%26f32%3E-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a></span><a href=\"#impl-Sum%3C%26f32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Sum.html\" title=\"trait std::iter::Sum\">Sum</a>&lt;&amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sum\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a><a href=\"#method.sum\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"iter/trait.Sum.html#tymethod.sum\" class=\"fn\">sum</a>&lt;I&gt;(iter: I) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = &amp;'a <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Method which takes an iterator and generates <code>Self</code> from the elements by\n“summing up” the items.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Sum-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a></span><a href=\"#impl-Sum-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"iter/trait.Sum.html\" title=\"trait std::iter::Sum\">Sum</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.sum-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150\">source</a><a href=\"#method.sum-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"iter/trait.Sum.html#tymethod.sum\" class=\"fn\">sum</a>&lt;I&gt;(iter: I) -&gt; <a class=\"primitive\" href=\"primitive.f32.html\">f32</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a>&lt;Item = <a class=\"primitive\" href=\"primitive.f32.html\">f32</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Method which takes an iterator and generates <code>Self</code> from the elements by\n“summing up” the items.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-UpperExp-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a></span><a href=\"#impl-UpperExp-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"fmt/trait.UpperExp.html\" title=\"trait std::fmt::UpperExp\">UpperExp</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt-3\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#229\">source</a><a href=\"#method.fmt-3\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"fmt/trait.UpperExp.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"primitive.unit.html\">()</a>, <a class=\"struct\" href=\"fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"fmt/trait.UpperExp.html#tymethod.fmt\">Read more</a></div></details></div></details><section id=\"impl-Copy-for-f32\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/marker.rs.html#420-430\">source</a></span><a href=\"#impl-Copy-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Ci128%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Ci128%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.i128.html\">i128</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Ci16%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Ci16%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.i16.html\">i16</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Ci32%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Ci32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.i32.html\">i32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Ci64%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Ci64%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.i64.html\">i64</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Ci8%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Ci8%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.i8.html\">i8</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cisize%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cisize%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.isize.html\">isize</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cu128%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cu128%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.u128.html\">u128</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cu16%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cu16%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.u16.html\">u16</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cu32%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cu32%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.u32.html\">u32</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cu64%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cu64%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.u64.html\">u64</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cu8%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cu8%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-FloatToInt%3Cusize%3E-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#38\">source</a><a href=\"#impl-FloatToInt%3Cusize%3E-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"convert/trait.FloatToInt.html\" title=\"trait std::convert::FloatToInt\">FloatToInt</a>&lt;<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>&gt; for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-SimdCast-for-f32\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/cast.rs.html#48\">source</a><a href=\"#impl-SimdCast-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"simd/trait.SimdCast.html\" title=\"trait std::simd::SimdCast\">SimdCast</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-f32\" class=\"impl\"><a href=\"#impl-Freeze-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-RefUnwindSafe-for-f32\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-Send-for-f32\" class=\"impl\"><a href=\"#impl-Send-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-Sync-for-f32\" class=\"impl\"><a href=\"#impl-Sync-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-Unpin-for-f32\" class=\"impl\"><a href=\"#impl-Unpin-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section><section id=\"impl-UnwindSafe-for-f32\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-f32\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"primitive\" href=\"primitive.f32.html\">f32</a></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-7\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-7\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToString-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2552\">source</a><a href=\"#impl-ToString-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"string/trait.ToString.html\" title=\"trait std::string::ToString\">ToString</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"fmt/trait.Display.html\" title=\"trait std::fmt::Display\">Display</a> + ?<a class=\"trait\" href=\"marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_string\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2558\">source</a><a href=\"#method.to_string\" class=\"anchor\">§</a><h4 class=\"code-header\">default fn <a href=\"string/trait.ToString.html#tymethod.to_string\" class=\"fn\">to_string</a>(&amp;self) -&gt; <a class=\"struct\" href=\"string/struct.String.html\" title=\"struct std::string::String\">String</a></h4></section></summary><div class=\"docblock\">Converts the given value to a <code>String</code>. <a href=\"string/trait.ToString.html#tymethod.to_string\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:09:56.654Z"
}