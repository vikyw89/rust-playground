{
	"title": "std::collections - Rust",
	"url": "https://doc.rust-lang.org/stable/std/collections/index.html",
	"markdown": "# std::collections - Rust\n\nExpand description\n\nCollection types.\n\nRust’s standard collection library provides efficient implementations of the most common general purpose programming data structures. By using the standard implementations, it should be possible for two libraries to communicate without significant data conversion.\n\nTo get this out of the way: you should probably just use [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") or [`HashMap`](hash_map/struct.HashMap.html \"struct std::collections::hash_map::HashMap\"). These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline _niche_ in comparison. Even when `Vec` and `HashMap` are technically suboptimal, they’re probably a good enough choice to get started.\n\nRust’s collections can be grouped into four major categories:\n\n-   Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n-   Maps: [`HashMap`](hash_map/struct.HashMap.html \"struct std::collections::hash_map::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n-   Sets: [`HashSet`](hash_set/struct.HashSet.html \"struct std::collections::hash_set::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n-   Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")\n\n## [§](#when-should-you-use-which-collection)When Should You Use Which Collection?\n\nThese are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.\n\n#### [§](#use-a-vec-when)Use a `Vec` when:\n\n-   You want to collect items up to be processed or sent elsewhere later, and don’t care about any properties of the actual values being stored.\n-   You want a sequence of elements in a particular order, and will only be appending to (or near) the end.\n-   You want a stack.\n-   You want a resizable array.\n-   You want a heap-allocated array.\n\n#### [§](#use-a-vecdeque-when)Use a `VecDeque` when:\n\n-   You want a [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") that supports efficient insertion at both ends of the sequence.\n-   You want a queue.\n-   You want a double-ended queue (deque).\n\n#### [§](#use-a-linkedlist-when)Use a `LinkedList` when:\n\n-   You want a [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") or [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") of unknown size, and can’t tolerate amortization.\n-   You want to efficiently split and append lists.\n-   You are _absolutely_ certain you _really_, _truly_, want a doubly linked list.\n\n#### [§](#use-a-hashmap-when)Use a `HashMap` when:\n\n-   You want to associate arbitrary keys with an arbitrary value.\n-   You want a cache.\n-   You want a map, with no extra functionality.\n\n#### [§](#use-a-btreemap-when)Use a `BTreeMap` when:\n\n-   You want a map sorted by its keys.\n-   You want to be able to get a range of entries on-demand.\n-   You’re interested in what the smallest or largest key-value pair is.\n-   You want to find the largest or smallest key that is smaller or larger than something.\n\n#### [§](#use-the-set-variant-of-any-of-these-maps-when)Use the `Set` variant of any of these `Map`s when:\n\n-   You just want to remember which keys you’ve seen.\n-   There is no meaningful value to associate with your keys.\n-   You just want a set.\n\n#### [§](#use-a-binaryheap-when)Use a `BinaryHeap` when:\n\n-   You want to store a bunch of elements, but only ever want to process the “biggest” or “most important” one at any given time.\n-   You want a priority queue.\n\n## [§](#performance)Performance\n\nChoosing the right collection for the job requires an understanding of what each collection is good at. Here we briefly summarize the performance of different collections for certain important operations. For further details, see each type’s documentation, and note that the names of actual methods may differ from the tables below on certain collections.\n\nThroughout the documentation, we will follow a few conventions. For all operations, the collection’s size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an _amortized_ cost are suffixed with a `*`. Operations with an _expected_ cost are suffixed with a `~`.\n\nAll amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take _O_(_n_) time. Our collections never automatically shrink, so removal operations aren’t amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.\n\nOnly [`HashMap`](hash_map/struct.HashMap.html \"struct std::collections::hash_map::HashMap\") has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for [`HashMap`](hash_map/struct.HashMap.html \"struct std::collections::hash_map::HashMap\") to experience worse performance.\n\n### [§](#sequences)Sequences\n\n|  | get(i) | insert(i) | remove(i) | append | split\\_off(i) |\n| --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | _O_(1) | _O_(_n_\\-_i_)\\* | _O_(_n_\\-_i_) | _O_(_m_)\\* | _O_(_n_\\-_i_) |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | _O_(1) | _O_(min(_i_, _n_\\-_i_))\\* | _O_(min(_i_, _n_\\-_i_)) | _O_(_m_)\\* | _O_(min(_i_, _n_\\-_i_)) |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | _O_(min(_i_, _n_\\-_i_)) | _O_(min(_i_, _n_\\-_i_)) | _O_(min(_i_, _n_\\-_i_)) | _O_(1) | _O_(min(_i_, _n_\\-_i_)) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").\n\n### [§](#maps)Maps\n\nFor Sets, all operations have the cost of the equivalent Map operation.\n\n|  | get | insert | remove | range | append |\n| --- | --- | --- | --- | --- | --- |\n| [`HashMap`](hash_map/struct.HashMap.html \"struct std::collections::hash_map::HashMap\") | _O_(1)~ | _O_(1)~\\* | _O_(1)~ | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | _O_(log(_n_)) | _O_(log(_n_)) | _O_(log(_n_)) | _O_(log(_n_)) | _O_(_n_+_m_) |\n\n## [§](#correct-and-efficient-usage-of-collections)Correct and Efficient Usage of Collections\n\nOf course, knowing which collection is the right one for the job doesn’t instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you’re interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.\n\n### [§](#capacity-management)Capacity Management\n\nMany collections provide several constructors and methods that refer to “capacity”. These collections are generally built on top of an array. Optimally, this array would be exactly the right size to fit only the elements stored in the collection, but for the collection to do this would be very inefficient. If the backing array was exactly the right size at all times, then every time an element is inserted, the collection would have to grow the array to fit it. Due to the way memory is allocated and managed on most computers, this would almost surely require allocating an entirely new array and copying every single element from the old one into the new one. Hopefully you can see that this wouldn’t be very efficient to do on every operation.\n\nMost collections therefore use an _amortized_ allocation strategy. They generally let themselves have a fair amount of unoccupied space so that they only have to grow on occasion. When they do grow, they allocate a substantially larger array to move the elements into so that it will take a while for another grow to be required. While this strategy is great in general, it would be even better if the collection _never_ had to resize its backing array. Unfortunately, the collection itself doesn’t have enough information to do this itself. Therefore, it is up to us programmers to give it hints.\n\nAny `with_capacity` constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use `with_capacity` when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.\n\nWhen anticipating a large influx of elements, the `reserve` family of methods can be used to hint to the collection how much room it should make for the coming items. As with `with_capacity`, the precise behavior of these methods will be specific to the collection of interest.\n\nFor optimal performance, collections will generally avoid shrinking themselves. If you believe that a collection will not soon contain any more elements, or just really need the memory, the `shrink_to_fit` method prompts the collection to shrink the backing array to the minimum size capable of holding its elements.\n\nFinally, if ever you’re interested in what the actual capacity of the collection is, most collections provide a `capacity` method to query this information on demand. This can be useful for debugging purposes, or for use with the `reserve` methods.\n\n### [§](#iterators)Iterators\n\n[Iterators](../iter/index.html \"mod std::iter\") are a powerful and robust mechanism used throughout Rust’s standard libraries. Iterators provide a sequence of values in a generic, safe, efficient and convenient way. The contents of an iterator are usually _lazily_ evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them. Iterators are primarily consumed using a `for` loop, although many functions also take iterators where a collection or sequence of values is desired.\n\nAll of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are `iter`, `iter_mut`, and `into_iter`. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.\n\n`iter` provides an iterator of immutable references to all the contents of a collection in the most “natural” order. For sequence collections like [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), this means the items will be yielded in increasing order of index starting at 0. For ordered collections like [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\"), this means that the items will be yielded in sorted order. For unordered collections like [`HashMap`](hash_map/struct.HashMap.html \"struct std::collections::hash_map::HashMap\"), the items will be yielded in whatever order the internal representation made most convenient. This is great for reading through all the contents of the collection.\n\n```\nlet vec = vec![1, 2, 3, 4];\nfor x in vec.iter() {\n   println!(\"vec contained {x:?}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+vec+=+vec!%5B1,+2,+3,+4%5D;%0A++++for+x+in+vec.iter()+%7B%0A+++++++println!(%22vec+contained+%7Bx:?%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n`iter_mut` provides an iterator of _mutable_ references in the same order as `iter`. This is great for mutating all the contents of the collection.\n\n```\nlet mut vec = vec![1, 2, 3, 4];\nfor x in vec.iter_mut() {\n   *x += 1;\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+vec+=+vec!%5B1,+2,+3,+4%5D;%0A++++for+x+in+vec.iter_mut()+%7B%0A+++++++*x+%2B=+1;%0A++++%7D%0A%7D&edition=2021)\n\n`into_iter` transforms the actual collection into an iterator over its contents by-value. This is great when the collection itself is no longer needed, and the values are needed elsewhere. Using `extend` with `into_iter` is the main way that contents of one collection are moved into another. `extend` automatically calls `into_iter`, and takes any `T: [IntoIterator](../iter/trait.IntoIterator.html \"trait std::iter::IntoIterator\")`. Calling `collect` on an iterator itself is also a great way to convert one collection into another. Both of these methods should internally use the capacity management tools discussed in the previous section to do this as efficiently as possible.\n\n```\nlet mut vec1 = vec![1, 2, 3, 4];\nlet vec2 = vec![10, 20, 30, 40];\nvec1.extend(vec2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+vec1+=+vec!%5B1,+2,+3,+4%5D;%0A++++let+vec2+=+vec!%5B10,+20,+30,+40%5D;%0A++++vec1.extend(vec2);%0A%7D&edition=2021)\n\n```\nuse std::collections::VecDeque;\n\nlet vec = [1, 2, 3, 4];\nlet buf: VecDeque<_> = vec.into_iter().collect();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::VecDeque;%0A++++%0A++++let+vec+=+%5B1,+2,+3,+4%5D;%0A++++let+buf:+VecDeque%3C_%3E+=+vec.into_iter().collect();%0A%7D&edition=2021)\n\nIterators also provide a series of _adapter_ methods for performing common threads to sequences. Among the adapters are functional favorites like `map`, `fold`, `skip` and `take`. Of particular interest to collections is the `rev` adapter, which reverses any iterator that supports this operation. Most collections provide reversible iterators as the way to iterate over them in reverse order.\n\n```\nlet vec = vec![1, 2, 3, 4];\nfor x in vec.iter().rev() {\n   println!(\"vec contained {x:?}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+vec+=+vec!%5B1,+2,+3,+4%5D;%0A++++for+x+in+vec.iter().rev()+%7B%0A+++++++println!(%22vec+contained+%7Bx:?%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nSeveral other collection methods also return iterators to yield a sequence of results but avoid allocating an entire collection to store the result in. This provides maximum flexibility as [`collect`](about:blank/iter/trait.Iterator.html#method.collect \"method std::iter::Iterator::collect\") or [`extend`](about:blank/iter/trait.Extend.html#tymethod.extend \"method std::iter::Extend::extend\") can be called to “pipe” the sequence into any collection if desired. Otherwise, the sequence can be looped over with a `for` loop. The iterator can also be discarded after partial use, preventing the computation of the unused items.\n\n### [§](#entries)Entries\n\nThe `entry` API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a `find` followed by an `insert`, effectively duplicating the search effort on each insertion.\n\nWhen a user calls `map.entry(key)`, the map will search for the key and then yield a variant of the `Entry` enum.\n\nIf a `Vacant(entry)` is yielded, then the key _was not_ found. In this case the only valid operation is to `insert` a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.\n\nIf an `Occupied(entry)` is yielded, then the key _was_ found. In this case, the user has several options: they can `get`, `insert` or `remove` the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant `insert` case.\n\n#### [§](#examples)Examples\n\nHere are the two primary ways in which `entry` is used. First, a simple example where the logic performed on the values is trivial.\n\n##### [§](#counting-the-number-of-times-each-character-in-a-string-occurs)Counting the number of times each character in a string occurs\n\n```\nuse std::collections::btree_map::BTreeMap;\n\nlet mut count = BTreeMap::new();\nlet message = \"she sells sea shells by the sea shore\";\n\nfor c in message.chars() {\n    *count.entry(c).or_insert(0) += 1;\n}\n\nassert_eq!(count.get(&'s'), Some(&8));\n\nprintln!(\"Number of occurrences of each character\");\nfor (char, count) in &count {\n    println!(\"{char}: {count}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::btree_map::BTreeMap;%0A++++%0A++++let+mut+count+=+BTreeMap::new();%0A++++let+message+=+%22she+sells+sea+shells+by+the+sea+shore%22;%0A++++%0A++++for+c+in+message.chars()+%7B%0A++++++++*count.entry(c).or_insert(0)+%2B=+1;%0A++++%7D%0A++++%0A++++assert_eq!(count.get(%26%27s%27),+Some(%268));%0A++++%0A++++println!(%22Number+of+occurrences+of+each+character%22);%0A++++for+(char,+count)+in+%26count+%7B%0A++++++++println!(%22%7Bchar%7D:+%7Bcount%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nWhen the logic to be performed on the value is more complex, we may simply use the `entry` API to ensure that the value is initialized and perform the logic afterwards.\n\n##### [§](#tracking-the-inebriation-of-customers-at-a-bar)Tracking the inebriation of customers at a bar\n\n```\nuse std::collections::btree_map::BTreeMap;\n\n// A client of the bar. They have a blood alcohol level.\nstruct Person { blood_alcohol: f32 }\n\n// All the orders made to the bar, by client ID.\nlet orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];\n\n// Our clients.\nlet mut blood_alcohol = BTreeMap::new();\n\nfor id in orders {\n    // If this is the first time we've seen this customer, initialize them\n    // with no blood alcohol. Otherwise, just retrieve them.\n    let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });\n\n    // Reduce their blood alcohol level. It takes time to order and drink a beer!\n    person.blood_alcohol *= 0.9;\n\n    // Check if they're sober enough to have another beer.\n    if person.blood_alcohol > 0.3 {\n        // Too drunk... for now.\n        println!(\"Sorry {id}, I have to cut you off\");\n    } else {\n        // Have another!\n        person.blood_alcohol += 0.1;\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::btree_map::BTreeMap;%0A++++%0A++++//+A+client+of+the+bar.+They+have+a+blood+alcohol+level.%0A++++struct+Person+%7B+blood_alcohol:+f32+%7D%0A++++%0A++++//+All+the+orders+made+to+the+bar,+by+client+ID.%0A++++let+orders+=+vec!%5B1,+2,+1,+2,+3,+4,+1,+2,+2,+3,+4,+1,+1,+1%5D;%0A++++%0A++++//+Our+clients.%0A++++let+mut+blood_alcohol+=+BTreeMap::new();%0A++++%0A++++for+id+in+orders+%7B%0A++++++++//+If+this+is+the+first+time+we%27ve+seen+this+customer,+initialize+them%0A++++++++//+with+no+blood+alcohol.+Otherwise,+just+retrieve+them.%0A++++++++let+person+=+blood_alcohol.entry(id).or_insert(Person+%7B+blood_alcohol:+0.0+%7D);%0A++++%0A++++++++//+Reduce+their+blood+alcohol+level.+It+takes+time+to+order+and+drink+a+beer!%0A++++++++person.blood_alcohol+*=+0.9;%0A++++%0A++++++++//+Check+if+they%27re+sober+enough+to+have+another+beer.%0A++++++++if+person.blood_alcohol+%3E+0.3+%7B%0A++++++++++++//+Too+drunk...+for+now.%0A++++++++++++println!(%22Sorry+%7Bid%7D,+I+have+to+cut+you+off%22);%0A++++++++%7D+else+%7B%0A++++++++++++//+Have+another!%0A++++++++++++person.blood_alcohol+%2B=+0.1;%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n## [§](#insert-and-complex-keys)Insert and complex keys\n\nIf we have a more complex key, calls to `insert` will not update the value of the key. For example:\n\n```\nuse std::cmp::Ordering;\nuse std::collections::BTreeMap;\nuse std::hash::{Hash, Hasher};\n\n#[derive(Debug)]\nstruct Foo {\n    a: u32,\n    b: &'static str,\n}\n\n// we will compare `Foo`s by their `a` value only.\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool { self.a == other.a }\n}\n\nimpl Eq for Foo {}\n\n// we will hash `Foo`s by their `a` value only.\nimpl Hash for Foo {\n    fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }\n}\n\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }\n}\n\nimpl Ord for Foo {\n    fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }\n}\n\nlet mut map = BTreeMap::new();\nmap.insert(Foo { a: 1, b: \"baz\" }, 99);\n\n// We already have a Foo with an a of 1, so this will be updating the value.\nmap.insert(Foo { a: 1, b: \"xyz\" }, 100);\n\n// The value has been updated...\nassert_eq!(map.values().next().unwrap(), &100);\n\n// ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\nassert_eq!(map.keys().next().unwrap().b, \"baz\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++use+std::collections::BTreeMap;%0A++++use+std::hash::%7BHash,+Hasher%7D;%0A++++%0A++++%23%5Bderive(Debug)%5D%0A++++struct+Foo+%7B%0A++++++++a:+u32,%0A++++++++b:+%26%27static+str,%0A++++%7D%0A++++%0A++++//+we+will+compare+%60Foo%60s+by+their+%60a%60+value+only.%0A++++impl+PartialEq+for+Foo+%7B%0A++++++++fn+eq(%26self,+other:+%26Self)+-%3E+bool+%7B+self.a+==+other.a+%7D%0A++++%7D%0A++++%0A++++impl+Eq+for+Foo+%7B%7D%0A++++%0A++++//+we+will+hash+%60Foo%60s+by+their+%60a%60+value+only.%0A++++impl+Hash+for+Foo+%7B%0A++++++++fn+hash%3CH:+Hasher%3E(%26self,+h:+%26mut+H)+%7B+self.a.hash(h);+%7D%0A++++%7D%0A++++%0A++++impl+PartialOrd+for+Foo+%7B%0A++++++++fn+partial_cmp(%26self,+other:+%26Self)+-%3E+Option%3COrdering%3E+%7B+self.a.partial_cmp(%26other.a)+%7D%0A++++%7D%0A++++%0A++++impl+Ord+for+Foo+%7B%0A++++++++fn+cmp(%26self,+other:+%26Self)+-%3E+Ordering+%7B+self.a.cmp(%26other.a)+%7D%0A++++%7D%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(Foo+%7B+a:+1,+b:+%22baz%22+%7D,+99);%0A++++%0A++++//+We+already+have+a+Foo+with+an+a+of+1,+so+this+will+be+updating+the+value.%0A++++map.insert(Foo+%7B+a:+1,+b:+%22xyz%22+%7D,+100);%0A++++%0A++++//+The+value+has+been+updated...%0A++++assert_eq!(map.values().next().unwrap(),+%26100);%0A++++%0A++++//+...but+the+key+hasn%27t+changed.+b+is+still+%22baz%22,+not+%22xyz%22.%0A++++assert_eq!(map.keys().next().unwrap().b,+%22baz%22);%0A%7D&edition=2021)\n\n-   A priority queue implemented with a binary heap.\n    \n-   An ordered map based on a B-Tree.\n    \n-   An ordered set based on a B-Tree.\n    \n-   A hash map implemented with quadratic probing and SIMD lookup.\n    \n-   A hash set implemented as a `HashMap` where the value is `()`.\n    \n-   A doubly-linked list with owned nodes.\n    \n-   A double-ended queue (deque) implemented with a growable ring buffer.\n    \n\n-   An ordered map based on a [B-Tree](https://en.wikipedia.org/wiki/B-tree).\n    \n-   An ordered set based on a B-Tree.\n    \n-   A priority queue implemented with a binary heap.\n    \n-   A [hash map](about:blank/index.html#use-a-hashmap-when \"mod std::collections\") implemented with quadratic probing and SIMD lookup.\n    \n-   A [hash set](about:blank/index.html#use-the-set-variant-of-any-of-these-maps-when \"mod std::collections\") implemented as a `HashMap` where the value is `()`.\n    \n-   A doubly-linked list with owned nodes.\n    \n-   The error type for `try_reserve` methods.\n    \n-   A double-ended queue implemented with a growable ring buffer.\n    \n\n-   Details of the allocation that caused a `TryReserveError`",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Collection types.\"><title>std::collections - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module collections</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module collections</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#modules\">Modules</a></li><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">collections</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/collections/mod.rs.html#1-454\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Collection types.</p>\n<p>Rust’s standard collection library provides efficient implementations of the\nmost common general purpose programming data structures. By using the\nstandard implementations, it should be possible for two libraries to\ncommunicate without significant data conversion.</p>\n<p>To get this out of the way: you should probably just use <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a> or <a href=\"hash_map/struct.HashMap.html\" title=\"struct std::collections::hash_map::HashMap\"><code>HashMap</code></a>.\nThese two collections cover most use cases for generic data storage and\nprocessing. They are exceptionally good at doing what they do. All the other\ncollections in the standard library have specific use cases where they are\nthe optimal choice, but these cases are borderline <em>niche</em> in comparison.\nEven when <code>Vec</code> and <code>HashMap</code> are technically suboptimal, they’re probably a\ngood enough choice to get started.</p>\n<p>Rust’s collections can be grouped into four major categories:</p>\n<ul>\n<li>Sequences: <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a>, <a href=\"struct.VecDeque.html\" title=\"struct std::collections::VecDeque\"><code>VecDeque</code></a>, <a href=\"struct.LinkedList.html\" title=\"struct std::collections::LinkedList\"><code>LinkedList</code></a></li>\n<li>Maps: <a href=\"hash_map/struct.HashMap.html\" title=\"struct std::collections::hash_map::HashMap\"><code>HashMap</code></a>, <a href=\"struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\"><code>BTreeMap</code></a></li>\n<li>Sets: <a href=\"hash_set/struct.HashSet.html\" title=\"struct std::collections::hash_set::HashSet\"><code>HashSet</code></a>, <a href=\"struct.BTreeSet.html\" title=\"struct std::collections::BTreeSet\"><code>BTreeSet</code></a></li>\n<li>Misc: <a href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\"><code>BinaryHeap</code></a></li>\n</ul>\n<h2 id=\"when-should-you-use-which-collection\"><a class=\"doc-anchor\" href=\"#when-should-you-use-which-collection\">§</a>When Should You Use Which Collection?</h2>\n<p>These are fairly high-level and quick break-downs of when each collection\nshould be considered. Detailed discussions of strengths and weaknesses of\nindividual collections can be found on their own documentation pages.</p>\n<h4 id=\"use-a-vec-when\"><a class=\"doc-anchor\" href=\"#use-a-vec-when\">§</a>Use a <code>Vec</code> when:</h4>\n<ul>\n<li>You want to collect items up to be processed or sent elsewhere later, and\ndon’t care about any properties of the actual values being stored.</li>\n<li>You want a sequence of elements in a particular order, and will only be\nappending to (or near) the end.</li>\n<li>You want a stack.</li>\n<li>You want a resizable array.</li>\n<li>You want a heap-allocated array.</li>\n</ul>\n<h4 id=\"use-a-vecdeque-when\"><a class=\"doc-anchor\" href=\"#use-a-vecdeque-when\">§</a>Use a <code>VecDeque</code> when:</h4>\n<ul>\n<li>You want a <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a> that supports efficient insertion at both ends of the\nsequence.</li>\n<li>You want a queue.</li>\n<li>You want a double-ended queue (deque).</li>\n</ul>\n<h4 id=\"use-a-linkedlist-when\"><a class=\"doc-anchor\" href=\"#use-a-linkedlist-when\">§</a>Use a <code>LinkedList</code> when:</h4>\n<ul>\n<li>You want a <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a> or <a href=\"struct.VecDeque.html\" title=\"struct std::collections::VecDeque\"><code>VecDeque</code></a> of unknown size, and can’t tolerate\namortization.</li>\n<li>You want to efficiently split and append lists.</li>\n<li>You are <em>absolutely</em> certain you <em>really</em>, <em>truly</em>, want a doubly linked\nlist.</li>\n</ul>\n<h4 id=\"use-a-hashmap-when\"><a class=\"doc-anchor\" href=\"#use-a-hashmap-when\">§</a>Use a <code>HashMap</code> when:</h4>\n<ul>\n<li>You want to associate arbitrary keys with an arbitrary value.</li>\n<li>You want a cache.</li>\n<li>You want a map, with no extra functionality.</li>\n</ul>\n<h4 id=\"use-a-btreemap-when\"><a class=\"doc-anchor\" href=\"#use-a-btreemap-when\">§</a>Use a <code>BTreeMap</code> when:</h4>\n<ul>\n<li>You want a map sorted by its keys.</li>\n<li>You want to be able to get a range of entries on-demand.</li>\n<li>You’re interested in what the smallest or largest key-value pair is.</li>\n<li>You want to find the largest or smallest key that is smaller or larger\nthan something.</li>\n</ul>\n<h4 id=\"use-the-set-variant-of-any-of-these-maps-when\"><a class=\"doc-anchor\" href=\"#use-the-set-variant-of-any-of-these-maps-when\">§</a>Use the <code>Set</code> variant of any of these <code>Map</code>s when:</h4>\n<ul>\n<li>You just want to remember which keys you’ve seen.</li>\n<li>There is no meaningful value to associate with your keys.</li>\n<li>You just want a set.</li>\n</ul>\n<h4 id=\"use-a-binaryheap-when\"><a class=\"doc-anchor\" href=\"#use-a-binaryheap-when\">§</a>Use a <code>BinaryHeap</code> when:</h4>\n<ul>\n<li>You want to store a bunch of elements, but only ever want to process the\n“biggest” or “most important” one at any given time.</li>\n<li>You want a priority queue.</li>\n</ul>\n<h2 id=\"performance\"><a class=\"doc-anchor\" href=\"#performance\">§</a>Performance</h2>\n<p>Choosing the right collection for the job requires an understanding of what\neach collection is good at. Here we briefly summarize the performance of\ndifferent collections for certain important operations. For further details,\nsee each type’s documentation, and note that the names of actual methods may\ndiffer from the tables below on certain collections.</p>\n<p>Throughout the documentation, we will follow a few conventions. For all\noperations, the collection’s size is denoted by n. If another collection is\ninvolved in the operation, it contains m elements. Operations which have an\n<em>amortized</em> cost are suffixed with a <code>*</code>. Operations with an <em>expected</em>\ncost are suffixed with a <code>~</code>.</p>\n<p>All amortized costs are for the potential need to resize when capacity is\nexhausted. If a resize occurs it will take <em>O</em>(<em>n</em>) time. Our collections never\nautomatically shrink, so removal operations aren’t amortized. Over a\nsufficiently large series of operations, the average cost per operation will\ndeterministically equal the given cost.</p>\n<p>Only <a href=\"hash_map/struct.HashMap.html\" title=\"struct std::collections::hash_map::HashMap\"><code>HashMap</code></a> has expected costs, due to the probabilistic nature of hashing.\nIt is theoretically possible, though very unlikely, for <a href=\"hash_map/struct.HashMap.html\" title=\"struct std::collections::hash_map::HashMap\"><code>HashMap</code></a> to\nexperience worse performance.</p>\n<h3 id=\"sequences\"><a class=\"doc-anchor\" href=\"#sequences\">§</a>Sequences</h3><div><table><thead><tr><th></th><th>get(i)</th><th>insert(i)</th><th>remove(i)</th><th>append</th><th>split_off(i)</th></tr></thead><tbody>\n<tr><td><a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a></td><td><em>O</em>(1)</td><td><em>O</em>(<em>n</em>-<em>i</em>)*</td><td><em>O</em>(<em>n</em>-<em>i</em>)</td><td><em>O</em>(<em>m</em>)*</td><td><em>O</em>(<em>n</em>-<em>i</em>)</td></tr>\n<tr><td><a href=\"struct.VecDeque.html\" title=\"struct std::collections::VecDeque\"><code>VecDeque</code></a></td><td><em>O</em>(1)</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))*</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(<em>m</em>)*</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td></tr>\n<tr><td><a href=\"struct.LinkedList.html\" title=\"struct std::collections::LinkedList\"><code>LinkedList</code></a></td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(1)</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td></tr>\n</tbody></table>\n</div>\n<p>Note that where ties occur, <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a> is generally going to be faster than <a href=\"struct.VecDeque.html\" title=\"struct std::collections::VecDeque\"><code>VecDeque</code></a>, and\n<a href=\"struct.VecDeque.html\" title=\"struct std::collections::VecDeque\"><code>VecDeque</code></a> is generally going to be faster than <a href=\"struct.LinkedList.html\" title=\"struct std::collections::LinkedList\"><code>LinkedList</code></a>.</p>\n<h3 id=\"maps\"><a class=\"doc-anchor\" href=\"#maps\">§</a>Maps</h3>\n<p>For Sets, all operations have the cost of the equivalent Map operation.</p>\n<div><table><thead><tr><th></th><th>get</th><th>insert</th><th>remove</th><th>range</th><th>append</th></tr></thead><tbody>\n<tr><td><a href=\"hash_map/struct.HashMap.html\" title=\"struct std::collections::hash_map::HashMap\"><code>HashMap</code></a></td><td><em>O</em>(1)~</td><td><em>O</em>(1)~*</td><td><em>O</em>(1)~</td><td>N/A</td><td>N/A</td></tr>\n<tr><td><a href=\"struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\"><code>BTreeMap</code></a></td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(<em>n</em>+<em>m</em>)</td></tr>\n</tbody></table>\n</div><h2 id=\"correct-and-efficient-usage-of-collections\"><a class=\"doc-anchor\" href=\"#correct-and-efficient-usage-of-collections\">§</a>Correct and Efficient Usage of Collections</h2>\n<p>Of course, knowing which collection is the right one for the job doesn’t\ninstantly permit you to use it correctly. Here are some quick tips for\nefficient and correct usage of the standard collections in general. If\nyou’re interested in how to use a specific collection in particular, consult\nits documentation for detailed discussion and code examples.</p>\n<h3 id=\"capacity-management\"><a class=\"doc-anchor\" href=\"#capacity-management\">§</a>Capacity Management</h3>\n<p>Many collections provide several constructors and methods that refer to\n“capacity”. These collections are generally built on top of an array.\nOptimally, this array would be exactly the right size to fit only the\nelements stored in the collection, but for the collection to do this would\nbe very inefficient. If the backing array was exactly the right size at all\ntimes, then every time an element is inserted, the collection would have to\ngrow the array to fit it. Due to the way memory is allocated and managed on\nmost computers, this would almost surely require allocating an entirely new\narray and copying every single element from the old one into the new one.\nHopefully you can see that this wouldn’t be very efficient to do on every\noperation.</p>\n<p>Most collections therefore use an <em>amortized</em> allocation strategy. They\ngenerally let themselves have a fair amount of unoccupied space so that they\nonly have to grow on occasion. When they do grow, they allocate a\nsubstantially larger array to move the elements into so that it will take a\nwhile for another grow to be required. While this strategy is great in\ngeneral, it would be even better if the collection <em>never</em> had to resize its\nbacking array. Unfortunately, the collection itself doesn’t have enough\ninformation to do this itself. Therefore, it is up to us programmers to give\nit hints.</p>\n<p>Any <code>with_capacity</code> constructor will instruct the collection to allocate\nenough space for the specified number of elements. Ideally this will be for\nexactly that many elements, but some implementation details may prevent\nthis. See collection-specific documentation for details. In general, use\n<code>with_capacity</code> when you know exactly how many elements will be inserted, or\nat least have a reasonable upper-bound on that number.</p>\n<p>When anticipating a large influx of elements, the <code>reserve</code> family of\nmethods can be used to hint to the collection how much room it should make\nfor the coming items. As with <code>with_capacity</code>, the precise behavior of\nthese methods will be specific to the collection of interest.</p>\n<p>For optimal performance, collections will generally avoid shrinking\nthemselves. If you believe that a collection will not soon contain any more\nelements, or just really need the memory, the <code>shrink_to_fit</code> method prompts\nthe collection to shrink the backing array to the minimum size capable of\nholding its elements.</p>\n<p>Finally, if ever you’re interested in what the actual capacity of the\ncollection is, most collections provide a <code>capacity</code> method to query this\ninformation on demand. This can be useful for debugging purposes, or for\nuse with the <code>reserve</code> methods.</p>\n<h3 id=\"iterators\"><a class=\"doc-anchor\" href=\"#iterators\">§</a>Iterators</h3>\n<p><a href=\"../iter/index.html\" title=\"mod std::iter\">Iterators</a>\nare a powerful and robust mechanism used throughout Rust’s\nstandard libraries. Iterators provide a sequence of values in a generic,\nsafe, efficient and convenient way. The contents of an iterator are usually\n<em>lazily</em> evaluated, so that only the values that are actually needed are\never actually produced, and no allocation need be done to temporarily store\nthem. Iterators are primarily consumed using a <code>for</code> loop, although many\nfunctions also take iterators where a collection or sequence of values is\ndesired.</p>\n<p>All of the standard collections provide several iterators for performing\nbulk manipulation of their contents. The three primary iterators almost\nevery collection should provide are <code>iter</code>, <code>iter_mut</code>, and <code>into_iter</code>.\nSome of these are not provided on collections where it would be unsound or\nunreasonable to provide them.</p>\n<p><code>iter</code> provides an iterator of immutable references to all the contents of a\ncollection in the most “natural” order. For sequence collections like <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec</code></a>,\nthis means the items will be yielded in increasing order of index starting\nat 0. For ordered collections like <a href=\"struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\"><code>BTreeMap</code></a>, this means that the items\nwill be yielded in sorted order. For unordered collections like <a href=\"hash_map/struct.HashMap.html\" title=\"struct std::collections::hash_map::HashMap\"><code>HashMap</code></a>,\nthe items will be yielded in whatever order the internal representation made\nmost convenient. This is great for reading through all the contents of the\ncollection.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>vec = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>vec.iter() {\n   <span class=\"macro\">println!</span>(<span class=\"string\">\"vec contained {x:?}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+vec+=+vec!%5B1,+2,+3,+4%5D;%0A++++for+x+in+vec.iter()+%7B%0A+++++++println!(%22vec+contained+%7Bx:?%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>iter_mut</code> provides an iterator of <em>mutable</em> references in the same order as\n<code>iter</code>. This is great for mutating all the contents of the collection.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>vec.iter_mut() {\n   <span class=\"kw-2\">*</span>x += <span class=\"number\">1</span>;\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+vec+=+vec!%5B1,+2,+3,+4%5D;%0A++++for+x+in+vec.iter_mut()+%7B%0A+++++++*x+%2B=+1;%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>into_iter</code> transforms the actual collection into an iterator over its\ncontents by-value. This is great when the collection itself is no longer\nneeded, and the values are needed elsewhere. Using <code>extend</code> with <code>into_iter</code>\nis the main way that contents of one collection are moved into another.\n<code>extend</code> automatically calls <code>into_iter</code>, and takes any <code>T: <a href=\"../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a></code>.\nCalling <code>collect</code> on an iterator itself is also a great way to convert one\ncollection into another. Both of these methods should internally use the\ncapacity management tools discussed in the previous section to do this as\nefficiently as possible.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>vec1 = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span>vec2 = <span class=\"macro\">vec!</span>[<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];\nvec1.extend(vec2);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+vec1+=+vec!%5B1,+2,+3,+4%5D;%0A++++let+vec2+=+vec!%5B10,+20,+30,+40%5D;%0A++++vec1.extend(vec2);%0A%7D&amp;edition=2021\">Run</a></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::VecDeque;\n\n<span class=\"kw\">let </span>vec = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span>buf: VecDeque&lt;<span class=\"kw\">_</span>&gt; = vec.into_iter().collect();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::VecDeque;%0A++++%0A++++let+vec+=+%5B1,+2,+3,+4%5D;%0A++++let+buf:+VecDeque%3C_%3E+=+vec.into_iter().collect();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Iterators also provide a series of <em>adapter</em> methods for performing common\nthreads to sequences. Among the adapters are functional favorites like <code>map</code>,\n<code>fold</code>, <code>skip</code> and <code>take</code>. Of particular interest to collections is the\n<code>rev</code> adapter, which reverses any iterator that supports this operation. Most\ncollections provide reversible iterators as the way to iterate over them in\nreverse order.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>vec = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">for </span>x <span class=\"kw\">in </span>vec.iter().rev() {\n   <span class=\"macro\">println!</span>(<span class=\"string\">\"vec contained {x:?}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+vec+=+vec!%5B1,+2,+3,+4%5D;%0A++++for+x+in+vec.iter().rev()+%7B%0A+++++++println!(%22vec+contained+%7Bx:?%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Several other collection methods also return iterators to yield a sequence\nof results but avoid allocating an entire collection to store the result in.\nThis provides maximum flexibility as\n<a href=\"../iter/trait.Iterator.html#method.collect\" title=\"method std::iter::Iterator::collect\"><code>collect</code></a> or\n<a href=\"../iter/trait.Extend.html#tymethod.extend\" title=\"method std::iter::Extend::extend\"><code>extend</code></a> can be called to\n“pipe” the sequence into any collection if desired. Otherwise, the sequence\ncan be looped over with a <code>for</code> loop. The iterator can also be discarded\nafter partial use, preventing the computation of the unused items.</p>\n<h3 id=\"entries\"><a class=\"doc-anchor\" href=\"#entries\">§</a>Entries</h3>\n<p>The <code>entry</code> API is intended to provide an efficient mechanism for\nmanipulating the contents of a map conditionally on the presence of a key or\nnot. The primary motivating use case for this is to provide efficient\naccumulator maps. For instance, if one wishes to maintain a count of the\nnumber of times each key has been seen, they will have to perform some\nconditional logic on whether this is the first time the key has been seen or\nnot. Normally, this would require a <code>find</code> followed by an <code>insert</code>,\neffectively duplicating the search effort on each insertion.</p>\n<p>When a user calls <code>map.entry(key)</code>, the map will search for the key and\nthen yield a variant of the <code>Entry</code> enum.</p>\n<p>If a <code>Vacant(entry)</code> is yielded, then the key <em>was not</em> found. In this case\nthe only valid operation is to <code>insert</code> a value into the entry. When this is\ndone, the vacant entry is consumed and converted into a mutable reference to\nthe value that was inserted. This allows for further manipulation of the\nvalue beyond the lifetime of the search itself. This is useful if complex\nlogic needs to be performed on the value regardless of whether the value was\njust inserted.</p>\n<p>If an <code>Occupied(entry)</code> is yielded, then the key <em>was</em> found. In this case,\nthe user has several options: they can <code>get</code>, <code>insert</code> or <code>remove</code> the\nvalue of the occupied entry. Additionally, they can convert the occupied\nentry into a mutable reference to its value, providing symmetry to the\nvacant <code>insert</code> case.</p>\n<h4 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h4>\n<p>Here are the two primary ways in which <code>entry</code> is used. First, a simple\nexample where the logic performed on the values is trivial.</p>\n<h5 id=\"counting-the-number-of-times-each-character-in-a-string-occurs\"><a class=\"doc-anchor\" href=\"#counting-the-number-of-times-each-character-in-a-string-occurs\">§</a>Counting the number of times each character in a string occurs</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::btree_map::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = BTreeMap::new();\n<span class=\"kw\">let </span>message = <span class=\"string\">\"she sells sea shells by the sea shore\"</span>;\n\n<span class=\"kw\">for </span>c <span class=\"kw\">in </span>message.chars() {\n    <span class=\"kw-2\">*</span>count.entry(c).or_insert(<span class=\"number\">0</span>) += <span class=\"number\">1</span>;\n}\n\n<span class=\"macro\">assert_eq!</span>(count.get(<span class=\"kw-2\">&amp;</span><span class=\"string\">'s'</span>), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">8</span>));\n\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Number of occurrences of each character\"</span>);\n<span class=\"kw\">for </span>(char, count) <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>count {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{char}: {count}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::btree_map::BTreeMap;%0A++++%0A++++let+mut+count+=+BTreeMap::new();%0A++++let+message+=+%22she+sells+sea+shells+by+the+sea+shore%22;%0A++++%0A++++for+c+in+message.chars()+%7B%0A++++++++*count.entry(c).or_insert(0)+%2B=+1;%0A++++%7D%0A++++%0A++++assert_eq!(count.get(%26's'),+Some(%268));%0A++++%0A++++println!(%22Number+of+occurrences+of+each+character%22);%0A++++for+(char,+count)+in+%26count+%7B%0A++++++++println!(%22%7Bchar%7D:+%7Bcount%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>When the logic to be performed on the value is more complex, we may simply\nuse the <code>entry</code> API to ensure that the value is initialized and perform the\nlogic afterwards.</p>\n<h5 id=\"tracking-the-inebriation-of-customers-at-a-bar\"><a class=\"doc-anchor\" href=\"#tracking-the-inebriation-of-customers-at-a-bar\">§</a>Tracking the inebriation of customers at a bar</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::btree_map::BTreeMap;\n\n<span class=\"comment\">// A client of the bar. They have a blood alcohol level.\n</span><span class=\"kw\">struct </span>Person { blood_alcohol: f32 }\n\n<span class=\"comment\">// All the orders made to the bar, by client ID.\n</span><span class=\"kw\">let </span>orders = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>];\n\n<span class=\"comment\">// Our clients.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>blood_alcohol = BTreeMap::new();\n\n<span class=\"kw\">for </span>id <span class=\"kw\">in </span>orders {\n    <span class=\"comment\">// If this is the first time we've seen this customer, initialize them\n    // with no blood alcohol. Otherwise, just retrieve them.\n    </span><span class=\"kw\">let </span>person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: <span class=\"number\">0.0 </span>});\n\n    <span class=\"comment\">// Reduce their blood alcohol level. It takes time to order and drink a beer!\n    </span>person.blood_alcohol <span class=\"kw-2\">*</span>= <span class=\"number\">0.9</span>;\n\n    <span class=\"comment\">// Check if they're sober enough to have another beer.\n    </span><span class=\"kw\">if </span>person.blood_alcohol &gt; <span class=\"number\">0.3 </span>{\n        <span class=\"comment\">// Too drunk... for now.\n        </span><span class=\"macro\">println!</span>(<span class=\"string\">\"Sorry {id}, I have to cut you off\"</span>);\n    } <span class=\"kw\">else </span>{\n        <span class=\"comment\">// Have another!\n        </span>person.blood_alcohol += <span class=\"number\">0.1</span>;\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::btree_map::BTreeMap;%0A++++%0A++++//+A+client+of+the+bar.+They+have+a+blood+alcohol+level.%0A++++struct+Person+%7B+blood_alcohol:+f32+%7D%0A++++%0A++++//+All+the+orders+made+to+the+bar,+by+client+ID.%0A++++let+orders+=+vec!%5B1,+2,+1,+2,+3,+4,+1,+2,+2,+3,+4,+1,+1,+1%5D;%0A++++%0A++++//+Our+clients.%0A++++let+mut+blood_alcohol+=+BTreeMap::new();%0A++++%0A++++for+id+in+orders+%7B%0A++++++++//+If+this+is+the+first+time+we've+seen+this+customer,+initialize+them%0A++++++++//+with+no+blood+alcohol.+Otherwise,+just+retrieve+them.%0A++++++++let+person+=+blood_alcohol.entry(id).or_insert(Person+%7B+blood_alcohol:+0.0+%7D);%0A++++%0A++++++++//+Reduce+their+blood+alcohol+level.+It+takes+time+to+order+and+drink+a+beer!%0A++++++++person.blood_alcohol+*=+0.9;%0A++++%0A++++++++//+Check+if+they're+sober+enough+to+have+another+beer.%0A++++++++if+person.blood_alcohol+%3E+0.3+%7B%0A++++++++++++//+Too+drunk...+for+now.%0A++++++++++++println!(%22Sorry+%7Bid%7D,+I+have+to+cut+you+off%22);%0A++++++++%7D+else+%7B%0A++++++++++++//+Have+another!%0A++++++++++++person.blood_alcohol+%2B=+0.1;%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"insert-and-complex-keys\"><a class=\"doc-anchor\" href=\"#insert-and-complex-keys\">§</a>Insert and complex keys</h2>\n<p>If we have a more complex key, calls to <code>insert</code> will\nnot update the value of the key. For example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cmp::Ordering;\n<span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::hash::{Hash, Hasher};\n\n<span class=\"attr\">#[derive(Debug)]\n</span><span class=\"kw\">struct </span>Foo {\n    a: u32,\n    b: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span>str,\n}\n\n<span class=\"comment\">// we will compare `Foo`s by their `a` value only.\n</span><span class=\"kw\">impl </span>PartialEq <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>eq(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, other: <span class=\"kw-2\">&amp;</span><span class=\"self\">Self</span>) -&gt; bool { <span class=\"self\">self</span>.a == other.a }\n}\n\n<span class=\"kw\">impl </span>Eq <span class=\"kw\">for </span>Foo {}\n\n<span class=\"comment\">// we will hash `Foo`s by their `a` value only.\n</span><span class=\"kw\">impl </span>Hash <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>hash&lt;H: Hasher&gt;(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, h: <span class=\"kw-2\">&amp;mut </span>H) { <span class=\"self\">self</span>.a.hash(h); }\n}\n\n<span class=\"kw\">impl </span>PartialOrd <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>partial_cmp(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, other: <span class=\"kw-2\">&amp;</span><span class=\"self\">Self</span>) -&gt; <span class=\"prelude-ty\">Option</span>&lt;Ordering&gt; { <span class=\"self\">self</span>.a.partial_cmp(<span class=\"kw-2\">&amp;</span>other.a) }\n}\n\n<span class=\"kw\">impl </span>Ord <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>cmp(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, other: <span class=\"kw-2\">&amp;</span><span class=\"self\">Self</span>) -&gt; Ordering { <span class=\"self\">self</span>.a.cmp(<span class=\"kw-2\">&amp;</span>other.a) }\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(Foo { a: <span class=\"number\">1</span>, b: <span class=\"string\">\"baz\" </span>}, <span class=\"number\">99</span>);\n\n<span class=\"comment\">// We already have a Foo with an a of 1, so this will be updating the value.\n</span>map.insert(Foo { a: <span class=\"number\">1</span>, b: <span class=\"string\">\"xyz\" </span>}, <span class=\"number\">100</span>);\n\n<span class=\"comment\">// The value has been updated...\n</span><span class=\"macro\">assert_eq!</span>(map.values().next().unwrap(), <span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>);\n\n<span class=\"comment\">// ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n</span><span class=\"macro\">assert_eq!</span>(map.keys().next().unwrap().b, <span class=\"string\">\"baz\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cmp::Ordering;%0A++++use+std::collections::BTreeMap;%0A++++use+std::hash::%7BHash,+Hasher%7D;%0A++++%0A++++%23%5Bderive(Debug)%5D%0A++++struct+Foo+%7B%0A++++++++a:+u32,%0A++++++++b:+%26'static+str,%0A++++%7D%0A++++%0A++++//+we+will+compare+%60Foo%60s+by+their+%60a%60+value+only.%0A++++impl+PartialEq+for+Foo+%7B%0A++++++++fn+eq(%26self,+other:+%26Self)+-%3E+bool+%7B+self.a+==+other.a+%7D%0A++++%7D%0A++++%0A++++impl+Eq+for+Foo+%7B%7D%0A++++%0A++++//+we+will+hash+%60Foo%60s+by+their+%60a%60+value+only.%0A++++impl+Hash+for+Foo+%7B%0A++++++++fn+hash%3CH:+Hasher%3E(%26self,+h:+%26mut+H)+%7B+self.a.hash(h);+%7D%0A++++%7D%0A++++%0A++++impl+PartialOrd+for+Foo+%7B%0A++++++++fn+partial_cmp(%26self,+other:+%26Self)+-%3E+Option%3COrdering%3E+%7B+self.a.partial_cmp(%26other.a)+%7D%0A++++%7D%0A++++%0A++++impl+Ord+for+Foo+%7B%0A++++++++fn+cmp(%26self,+other:+%26Self)+-%3E+Ordering+%7B+self.a.cmp(%26other.a)+%7D%0A++++%7D%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(Foo+%7B+a:+1,+b:+%22baz%22+%7D,+99);%0A++++%0A++++//+We+already+have+a+Foo+with+an+a+of+1,+so+this+will+be+updating+the+value.%0A++++map.insert(Foo+%7B+a:+1,+b:+%22xyz%22+%7D,+100);%0A++++%0A++++//+The+value+has+been+updated...%0A++++assert_eq!(map.values().next().unwrap(),+%26100);%0A++++%0A++++//+...but+the+key+hasn't+changed.+b+is+still+%22baz%22,+not+%22xyz%22.%0A++++assert_eq!(map.keys().next().unwrap().b,+%22baz%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"modules\" class=\"section-header\">Modules<a href=\"#modules\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"mod\" href=\"binary_heap/index.html\" title=\"mod std::collections::binary_heap\">binary_heap</a></div><div class=\"desc docblock-short\">A priority queue implemented with a binary heap.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"btree_map/index.html\" title=\"mod std::collections::btree_map\">btree_map</a></div><div class=\"desc docblock-short\">An ordered map based on a B-Tree.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"btree_set/index.html\" title=\"mod std::collections::btree_set\">btree_set</a></div><div class=\"desc docblock-short\">An ordered set based on a B-Tree.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"hash_map/index.html\" title=\"mod std::collections::hash_map\">hash_map</a></div><div class=\"desc docblock-short\">A hash map implemented with quadratic probing and SIMD lookup.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"hash_set/index.html\" title=\"mod std::collections::hash_set\">hash_set</a></div><div class=\"desc docblock-short\">A hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"linked_list/index.html\" title=\"mod std::collections::linked_list\">linked_list</a></div><div class=\"desc docblock-short\">A doubly-linked list with owned nodes.</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"vec_deque/index.html\" title=\"mod std::collections::vec_deque\">vec_deque</a></div><div class=\"desc docblock-short\">A double-ended queue (deque) implemented with a growable ring buffer.</div></li></ul><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a></div><div class=\"desc docblock-short\">An ordered map based on a <a href=\"https://en.wikipedia.org/wiki/B-tree\">B-Tree</a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BTreeSet.html\" title=\"struct std::collections::BTreeSet\">BTreeSet</a></div><div class=\"desc docblock-short\">An ordered set based on a B-Tree.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BinaryHeap.html\" title=\"struct std::collections::BinaryHeap\">BinaryHeap</a></div><div class=\"desc docblock-short\">A priority queue implemented with a binary heap.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.HashMap.html\" title=\"struct std::collections::HashMap\">HashMap</a></div><div class=\"desc docblock-short\">A <a href=\"index.html#use-a-hashmap-when\" title=\"mod std::collections\">hash map</a> implemented with quadratic probing and SIMD lookup.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.HashSet.html\" title=\"struct std::collections::HashSet\">HashSet</a></div><div class=\"desc docblock-short\">A <a href=\"index.html#use-the-set-variant-of-any-of-these-maps-when\" title=\"mod std::collections\">hash set</a> implemented as a <code>HashMap</code> where the value is <code>()</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.LinkedList.html\" title=\"struct std::collections::LinkedList\">LinkedList</a></div><div class=\"desc docblock-short\">A doubly-linked list with owned nodes.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.TryReserveError.html\" title=\"struct std::collections::TryReserveError\">TryReserveError</a></div><div class=\"desc docblock-short\">The error type for <code>try_reserve</code> methods.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.VecDeque.html\" title=\"struct std::collections::VecDeque\">VecDeque</a></div><div class=\"desc docblock-short\">A double-ended queue implemented with a growable ring buffer.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.TryReserveErrorKind.html\" title=\"enum std::collections::TryReserveErrorKind\">TryReserveErrorKind</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Details of the allocation that caused a <code>TryReserveError</code></div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:09:11.670Z"
}