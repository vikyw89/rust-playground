{
	"title": "swap in std::ptr - Rust",
	"url": "https://doc.rust-lang.org/stable/std/ptr/fn.swap.html",
	"markdown": "# swap in std::ptr - Rust\n\n## Function [std](../index.html)::[ptr](index.html)::[swap](#)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/83163 \"Tracking issue for const_swap\")) · [source](https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#967) ·\n\n```\npub unsafe fn swap<T>(x: *mut T, y: *mut T)\n```\n\nExpand description\n\nSwaps the values at two mutable locations of the same type, without deinitializing either.\n\nBut for the following exceptions, this function is semantically equivalent to [`mem::swap`](../mem/fn.swap.html \"fn std::mem::swap\"):\n\n-   It operates on raw pointers instead of references. When references are available, [`mem::swap`](../mem/fn.swap.html \"fn std::mem::swap\") should be preferred.\n    \n-   The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from `x` will be used. This is demonstrated in the second example below.\n    \n-   The operation is “untyped” in the sense that data may be uninitialized or otherwise violate the requirements of `T`. The initialization state is preserved exactly.\n    \n\n## [§](#safety)Safety\n\nBehavior is undefined if any of the following conditions are violated:\n\n-   Both `x` and `y` must be [valid](about:blank/index.html#safety \"mod std::ptr\") for both reads and writes. They must remain valid even when the other pointer is written. (This means if the memory ranges overlap, the two pointers must not be subject to aliasing restrictions relative to each other.)\n    \n-   Both `x` and `y` must be properly aligned.\n    \n\nNote that even if `T` has size `0`, the pointers must be non-null and properly aligned.\n\n## [§](#examples)Examples\n\nSwapping two non-overlapping regions:\n\n```\nuse std::ptr;\n\nlet mut array = [0, 1, 2, 3];\n\nlet (x, y) = array.split_at_mut(2);\nlet x = x.as_mut_ptr().cast::<[u32; 2]>(); // this is `array[0..2]`\nlet y = y.as_mut_ptr().cast::<[u32; 2]>(); // this is `array[2..4]`\n\nunsafe {\n    ptr::swap(x, y);\n    assert_eq!([2, 3, 0, 1], array);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+mut+array+=+%5B0,+1,+2,+3%5D;%0A++++%0A++++let+(x,+y)+=+array.split_at_mut(2);%0A++++let+x+=+x.as_mut_ptr().cast::%3C%5Bu32;+2%5D%3E();+//+this+is+%60array%5B0..2%5D%60%0A++++let+y+=+y.as_mut_ptr().cast::%3C%5Bu32;+2%5D%3E();+//+this+is+%60array%5B2..4%5D%60%0A++++%0A++++unsafe+%7B%0A++++++++ptr::swap(x,+y);%0A++++++++assert_eq!(%5B2,+3,+0,+1%5D,+array);%0A++++%7D%0A%7D&edition=2021)\n\nSwapping two overlapping regions:\n\n```\nuse std::ptr;\n\nlet mut array: [i32; 4] = [0, 1, 2, 3];\n\nlet array_ptr: *mut i32 = array.as_mut_ptr();\n\nlet x = array_ptr as *mut [i32; 3]; // this is `array[0..3]`\nlet y = unsafe { array_ptr.add(1) } as *mut [i32; 3]; // this is `array[1..4]`\n\nunsafe {\n    ptr::swap(x, y);\n    // The indices `1..3` of the slice overlap between `x` and `y`.\n    // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n    // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n    // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n    // This implementation is defined to make the latter choice.\n    assert_eq!([1, 0, 1, 2], array);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+mut+array:+%5Bi32;+4%5D+=+%5B0,+1,+2,+3%5D;%0A++++%0A++++let+array_ptr:+*mut+i32+=+array.as_mut_ptr();%0A++++%0A++++let+x+=+array_ptr+as+*mut+%5Bi32;+3%5D;+//+this+is+%60array%5B0..3%5D%60%0A++++let+y+=+unsafe+%7B+array_ptr.add(1)+%7D+as+*mut+%5Bi32;+3%5D;+//+this+is+%60array%5B1..4%5D%60%0A++++%0A++++unsafe+%7B%0A++++++++ptr::swap(x,+y);%0A++++++++//+The+indices+%601..3%60+of+the+slice+overlap+between+%60x%60+and+%60y%60.%0A++++++++//+Reasonable+results+would+be+for+to+them+be+%60%5B2,+3%5D%60,+so+that+indices+%600..3%60+are%0A++++++++//+%60%5B1,+2,+3%5D%60+(matching+%60y%60+before+the+%60swap%60);+or+for+them+to+be+%60%5B0,+1%5D%60%0A++++++++//+so+that+indices+%601..4%60+are+%60%5B0,+1,+2%5D%60+(matching+%60x%60+before+the+%60swap%60).%0A++++++++//+This+implementation+is+defined+to+make+the+latter+choice.%0A++++++++assert_eq!(%5B1,+0,+1,+2%5D,+array);%0A++++%7D%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Swaps the values at two mutable locations of the same type, without deinitializing either.\"><title>swap in std::ptr - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::ptr</a></h2><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.addr_of.html\">addr_of</a></li><li><a href=\"macro.addr_of_mut.html\">addr_of_mut</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Alignment.html\">Alignment</a></li><li><a href=\"struct.DynMetadata.html\">DynMetadata</a></li><li><a href=\"struct.NonNull.html\">NonNull</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.Pointee.html\">Pointee</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.addr_eq.html\">addr_eq</a></li><li><a href=\"fn.copy.html\">copy</a></li><li><a href=\"fn.copy_nonoverlapping.html\">copy_nonoverlapping</a></li><li><a href=\"fn.dangling.html\">dangling</a></li><li><a href=\"fn.dangling_mut.html\">dangling_mut</a></li><li><a href=\"fn.drop_in_place.html\">drop_in_place</a></li><li><a href=\"fn.eq.html\">eq</a></li><li><a href=\"fn.from_mut.html\">from_mut</a></li><li><a href=\"fn.from_raw_parts.html\">from_raw_parts</a></li><li><a href=\"fn.from_raw_parts_mut.html\">from_raw_parts_mut</a></li><li><a href=\"fn.from_ref.html\">from_ref</a></li><li><a href=\"fn.hash.html\">hash</a></li><li><a href=\"fn.metadata.html\">metadata</a></li><li><a href=\"fn.null.html\">null</a></li><li><a href=\"fn.null_mut.html\">null_mut</a></li><li><a href=\"fn.read.html\">read</a></li><li><a href=\"fn.read_unaligned.html\">read_unaligned</a></li><li><a href=\"fn.read_volatile.html\">read_volatile</a></li><li><a href=\"fn.replace.html\">replace</a></li><li><a href=\"fn.slice_from_raw_parts.html\">slice_from_raw_parts</a></li><li><a href=\"fn.slice_from_raw_parts_mut.html\">slice_from_raw_parts_mut</a></li><li><a href=\"fn.swap.html\">swap</a></li><li><a href=\"fn.swap_nonoverlapping.html\">swap_nonoverlapping</a></li><li><a href=\"fn.with_exposed_provenance.html\">with_exposed_provenance</a></li><li><a href=\"fn.with_exposed_provenance_mut.html\">with_exposed_provenance_mut</a></li><li><a href=\"fn.without_provenance.html\">without_provenance</a></li><li><a href=\"fn.without_provenance_mut.html\">without_provenance_mut</a></li><li><a href=\"fn.write.html\">write</a></li><li><a href=\"fn.write_bytes.html\">write_bytes</a></li><li><a href=\"fn.write_unaligned.html\">write_unaligned</a></li><li><a href=\"fn.write_volatile.html\">write_volatile</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">ptr</a>::<wbr><a class=\"fn\" href=\"#\">swap</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/83163\" title=\"Tracking issue for const_swap\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#967\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub unsafe fn swap&lt;T&gt;(x: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut T</a>, y: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut T</a>)</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Swaps the values at two mutable locations of the same type, without\ndeinitializing either.</p>\n<p>But for the following exceptions, this function is semantically\nequivalent to <a href=\"../mem/fn.swap.html\" title=\"fn std::mem::swap\"><code>mem::swap</code></a>:</p>\n<ul>\n<li>\n<p>It operates on raw pointers instead of references. When references are\navailable, <a href=\"../mem/fn.swap.html\" title=\"fn std::mem::swap\"><code>mem::swap</code></a> should be preferred.</p>\n</li>\n<li>\n<p>The two pointed-to values may overlap. If the values do overlap, then the\noverlapping region of memory from <code>x</code> will be used. This is demonstrated\nin the second example below.</p>\n</li>\n<li>\n<p>The operation is “untyped” in the sense that data may be uninitialized or otherwise violate\nthe requirements of <code>T</code>. The initialization state is preserved exactly.</p>\n</li>\n</ul>\n<h2 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h2>\n<p>Behavior is undefined if any of the following conditions are violated:</p>\n<ul>\n<li>\n<p>Both <code>x</code> and <code>y</code> must be <a href=\"index.html#safety\" title=\"mod std::ptr\">valid</a> for both reads and writes. They must remain valid even when the\nother pointer is written. (This means if the memory ranges overlap, the two pointers must not\nbe subject to aliasing restrictions relative to each other.)</p>\n</li>\n<li>\n<p>Both <code>x</code> and <code>y</code> must be properly aligned.</p>\n</li>\n</ul>\n<p>Note that even if <code>T</code> has size <code>0</code>, the pointers must be non-null and properly aligned.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Swapping two non-overlapping regions:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::ptr;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>array = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>(x, y) = array.split_at_mut(<span class=\"number\">2</span>);\n<span class=\"kw\">let </span>x = x.as_mut_ptr().cast::&lt;[u32; <span class=\"number\">2</span>]&gt;(); <span class=\"comment\">// this is `array[0..2]`\n</span><span class=\"kw\">let </span>y = y.as_mut_ptr().cast::&lt;[u32; <span class=\"number\">2</span>]&gt;(); <span class=\"comment\">// this is `array[2..4]`\n\n</span><span class=\"kw\">unsafe </span>{\n    ptr::swap(x, y);\n    <span class=\"macro\">assert_eq!</span>([<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], array);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+mut+array+=+%5B0,+1,+2,+3%5D;%0A++++%0A++++let+(x,+y)+=+array.split_at_mut(2);%0A++++let+x+=+x.as_mut_ptr().cast::%3C%5Bu32;+2%5D%3E();+//+this+is+%60array%5B0..2%5D%60%0A++++let+y+=+y.as_mut_ptr().cast::%3C%5Bu32;+2%5D%3E();+//+this+is+%60array%5B2..4%5D%60%0A++++%0A++++unsafe+%7B%0A++++++++ptr::swap(x,+y);%0A++++++++assert_eq!(%5B2,+3,+0,+1%5D,+array);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Swapping two overlapping regions:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::ptr;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>array: [i32; <span class=\"number\">4</span>] = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>array_ptr: <span class=\"kw-2\">*mut </span>i32 = array.as_mut_ptr();\n\n<span class=\"kw\">let </span>x = array_ptr <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>[i32; <span class=\"number\">3</span>]; <span class=\"comment\">// this is `array[0..3]`\n</span><span class=\"kw\">let </span>y = <span class=\"kw\">unsafe </span>{ array_ptr.add(<span class=\"number\">1</span>) } <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>[i32; <span class=\"number\">3</span>]; <span class=\"comment\">// this is `array[1..4]`\n\n</span><span class=\"kw\">unsafe </span>{\n    ptr::swap(x, y);\n    <span class=\"comment\">// The indices `1..3` of the slice overlap between `x` and `y`.\n    // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n    // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n    // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n    // This implementation is defined to make the latter choice.\n    </span><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], array);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+mut+array:+%5Bi32;+4%5D+=+%5B0,+1,+2,+3%5D;%0A++++%0A++++let+array_ptr:+*mut+i32+=+array.as_mut_ptr();%0A++++%0A++++let+x+=+array_ptr+as+*mut+%5Bi32;+3%5D;+//+this+is+%60array%5B0..3%5D%60%0A++++let+y+=+unsafe+%7B+array_ptr.add(1)+%7D+as+*mut+%5Bi32;+3%5D;+//+this+is+%60array%5B1..4%5D%60%0A++++%0A++++unsafe+%7B%0A++++++++ptr::swap(x,+y);%0A++++++++//+The+indices+%601..3%60+of+the+slice+overlap+between+%60x%60+and+%60y%60.%0A++++++++//+Reasonable+results+would+be+for+to+them+be+%60%5B2,+3%5D%60,+so+that+indices+%600..3%60+are%0A++++++++//+%60%5B1,+2,+3%5D%60+(matching+%60y%60+before+the+%60swap%60);+or+for+them+to+be+%60%5B0,+1%5D%60%0A++++++++//+so+that+indices+%601..4%60+are+%60%5B0,+1,+2%5D%60+(matching+%60x%60+before+the+%60swap%60).%0A++++++++//+This+implementation+is+defined+to+make+the+latter+choice.%0A++++++++assert_eq!(%5B1,+0,+1,+2%5D,+array);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:21:35.131Z"
}