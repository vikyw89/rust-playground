{
	"title": "forget in std::mem - Rust",
	"url": "https://doc.rust-lang.org/stable/std/mem/fn.forget.html",
	"markdown": "# forget in std::mem - Rust\n\n## Function [std](../index.html)::[mem](index.html)::[forget](#)\n\n1.0.0 (const: 1.46.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/mod.rs.html#148) ·\n\n```\npub const fn forget<T>(t: T)\n```\n\nExpand description\n\nTakes ownership and “forgets” about the value **without running its destructor**.\n\nAny resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.\n\n-   If you want to leak memory, see [`Box::leak`](about:blank/std/boxed/struct.Box.html#method.leak).\n-   If you want to obtain a raw pointer to the memory, see [`Box::into_raw`](about:blank/std/boxed/struct.Box.html#method.into_raw).\n-   If you want to dispose of a value properly, running its destructor, see [`mem::drop`](fn.drop.html \"fn std::mem::drop\").\n\n## [§](#safety)Safety\n\n`forget` is not marked as `unsafe`, because Rust’s safety guarantees do not include a guarantee that destructors will always run. For example, a program can create a reference cycle using [`Rc`](../../std/rc/struct.Rc.html), or call [`process::exit`](../../std/process/fn.exit.html) to exit without running destructors. Thus, allowing `mem::forget` from safe code does not fundamentally change Rust’s safety guarantees.\n\nThat said, leaking resources such as memory or I/O objects is usually undesirable. The need comes up in some specialized use cases for FFI or unsafe code, but even then, [`ManuallyDrop`](struct.ManuallyDrop.html \"struct std::mem::ManuallyDrop\") is typically preferred.\n\nBecause forgetting a value is allowed, any `unsafe` code you write must allow for this possibility. You cannot return a value and expect that the caller will necessarily run the value’s destructor.\n\n## [§](#examples)Examples\n\nThe canonical safe use of `mem::forget` is to circumvent a value’s destructor implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim the space taken by the variable but never close the underlying system resource:\n\n```\nuse std::mem;\nuse std::fs::File;\n\nlet file = File::open(\"foo.txt\").unwrap();\nmem::forget(file);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++use+std::fs::File;%0A++++%0A++++let+file+=+File::open(%22foo.txt%22).unwrap();%0A++++mem::forget(file);%0A%7D&edition=2021)\n\nThis is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.\n\n## [§](#relationship-with-manuallydrop)Relationship with `ManuallyDrop`\n\nWhile `mem::forget` can also be used to transfer _memory_ ownership, doing so is error-prone. [`ManuallyDrop`](struct.ManuallyDrop.html \"struct std::mem::ManuallyDrop\") should be used instead. Consider, for example, this code:\n\n```\nuse std::mem;\n\nlet mut v = vec![65, 122];\n// Build a `String` using the contents of `v`\nlet s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n// leak `v` because its memory is now managed by `s`\nmem::forget(v);  // ERROR - v is invalid and must not be passed to a function\nassert_eq!(s, \"Az\");\n// `s` is implicitly dropped and its memory deallocated.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++let+mut+v+=+vec!%5B65,+122%5D;%0A++++//+Build+a+%60String%60+using+the+contents+of+%60v%60%0A++++let+s+=+unsafe+%7B+String::from_raw_parts(v.as_mut_ptr(),+v.len(),+v.capacity())+%7D;%0A++++//+leak+%60v%60+because+its+memory+is+now+managed+by+%60s%60%0A++++mem::forget(v);++//+ERROR+-+v+is+invalid+and+must+not+be+passed+to+a+function%0A++++assert_eq!(s,+%22Az%22);%0A++++//+%60s%60+is+implicitly+dropped+and+its+memory+deallocated.%0A%7D&edition=2021)\n\nThere are two issues with the above example:\n\n-   If more code were added between the construction of `String` and the invocation of `mem::forget()`, a panic within it would cause a double free because the same memory is handled by both `v` and `s`.\n-   After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`, the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won’t inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned. Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.\n\nSwitching to `ManuallyDrop` avoids both issues:\n\n```\nuse std::mem::ManuallyDrop;\n\nlet v = vec![65, 122];\n// Before we disassemble `v` into its raw parts, make sure it\n// does not get dropped!\nlet mut v = ManuallyDrop::new(v);\n// Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\nlet (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n// Finally, build a `String`.\nlet s = unsafe { String::from_raw_parts(ptr, len, cap) };\nassert_eq!(s, \"Az\");\n// `s` is implicitly dropped and its memory deallocated.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::ManuallyDrop;%0A++++%0A++++let+v+=+vec!%5B65,+122%5D;%0A++++//+Before+we+disassemble+%60v%60+into+its+raw+parts,+make+sure+it%0A++++//+does+not+get+dropped!%0A++++let+mut+v+=+ManuallyDrop::new(v);%0A++++//+Now+disassemble+%60v%60.+These+operations+cannot+panic,+so+there+cannot+be+a+leak.%0A++++let+(ptr,+len,+cap)+=+(v.as_mut_ptr(),+v.len(),+v.capacity());%0A++++//+Finally,+build+a+%60String%60.%0A++++let+s+=+unsafe+%7B+String::from_raw_parts(ptr,+len,+cap)+%7D;%0A++++assert_eq!(s,+%22Az%22);%0A++++//+%60s%60+is+implicitly+dropped+and+its+memory+deallocated.%0A%7D&edition=2021)\n\n`ManuallyDrop` robustly prevents double-free because we disable `v`’s destructor before doing anything else. `mem::forget()` doesn’t allow this because it consumes its argument, forcing us to call it only after extracting anything we need from `v`. Even if a panic were introduced between construction of `ManuallyDrop` and building the string (which cannot happen in the code as shown), it would result in a leak and not a double free. In other words, `ManuallyDrop` errs on the side of leaking instead of erring on the side of (double-)dropping.\n\nAlso, `ManuallyDrop` prevents us from having to “touch” `v` after transferring the ownership to `s` — the final step of interacting with `v` to dispose of it without running its destructor is entirely avoided.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Takes ownership and “forgets” about the value without running its destructor.\"><title>forget in std::mem - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::mem</a></h2><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.offset_of.html\">offset_of</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Assume.html\">Assume</a></li><li><a href=\"struct.Discriminant.html\">Discriminant</a></li><li><a href=\"struct.ManuallyDrop.html\">ManuallyDrop</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.BikeshedIntrinsicFrom.html\">BikeshedIntrinsicFrom</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.align_of.html\">align_of</a></li><li><a href=\"fn.align_of_val.html\">align_of_val</a></li><li><a href=\"fn.align_of_val_raw.html\">align_of_val_raw</a></li><li><a href=\"fn.copy.html\">copy</a></li><li><a href=\"fn.discriminant.html\">discriminant</a></li><li><a href=\"fn.drop.html\">drop</a></li><li><a href=\"fn.forget.html\">forget</a></li><li><a href=\"fn.forget_unsized.html\">forget_unsized</a></li><li><a href=\"fn.min_align_of.html\">min_align_of</a></li><li><a href=\"fn.min_align_of_val.html\">min_align_of_val</a></li><li><a href=\"fn.needs_drop.html\">needs_drop</a></li><li><a href=\"fn.replace.html\">replace</a></li><li><a href=\"fn.size_of.html\">size_of</a></li><li><a href=\"fn.size_of_val.html\">size_of_val</a></li><li><a href=\"fn.size_of_val_raw.html\">size_of_val_raw</a></li><li><a href=\"fn.swap.html\">swap</a></li><li><a href=\"fn.take.html\">take</a></li><li><a href=\"fn.transmute.html\">transmute</a></li><li><a href=\"fn.transmute_copy.html\">transmute_copy</a></li><li><a href=\"fn.uninitialized.html\">uninitialized</a></li><li><a href=\"fn.variant_count.html\">variant_count</a></li><li><a href=\"fn.zeroed.html\">zeroed</a></li></ul><h3><a href=\"index.html#unions\">Unions</a></h3><ul class=\"block union\"><li><a href=\"union.MaybeUninit.html\">MaybeUninit</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">mem</a>::<wbr><a class=\"fn\" href=\"#\">forget</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.46.0\">1.0.0 (const: 1.46.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/mod.rs.html#148\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub const fn forget&lt;T&gt;(t: T)</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Takes ownership and “forgets” about the value <strong>without running its destructor</strong>.</p>\n<p>Any resources the value manages, such as heap memory or a file handle, will linger\nforever in an unreachable state. However, it does not guarantee that pointers\nto this memory will remain valid.</p>\n<ul>\n<li>If you want to leak memory, see <a href=\"../../std/boxed/struct.Box.html#method.leak\"><code>Box::leak</code></a>.</li>\n<li>If you want to obtain a raw pointer to the memory, see <a href=\"../../std/boxed/struct.Box.html#method.into_raw\"><code>Box::into_raw</code></a>.</li>\n<li>If you want to dispose of a value properly, running its destructor, see\n<a href=\"fn.drop.html\" title=\"fn std::mem::drop\"><code>mem::drop</code></a>.</li>\n</ul>\n<h2 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h2>\n<p><code>forget</code> is not marked as <code>unsafe</code>, because Rust’s safety guarantees\ndo not include a guarantee that destructors will always run. For example,\na program can create a reference cycle using <a href=\"../../std/rc/struct.Rc.html\"><code>Rc</code></a>, or call\n<a href=\"../../std/process/fn.exit.html\"><code>process::exit</code></a> to exit without running destructors. Thus, allowing\n<code>mem::forget</code> from safe code does not fundamentally change Rust’s safety\nguarantees.</p>\n<p>That said, leaking resources such as memory or I/O objects is usually undesirable.\nThe need comes up in some specialized use cases for FFI or unsafe code, but even\nthen, <a href=\"struct.ManuallyDrop.html\" title=\"struct std::mem::ManuallyDrop\"><code>ManuallyDrop</code></a> is typically preferred.</p>\n<p>Because forgetting a value is allowed, any <code>unsafe</code> code you write must\nallow for this possibility. You cannot return a value and expect that the\ncaller will necessarily run the value’s destructor.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>The canonical safe use of <code>mem::forget</code> is to circumvent a value’s destructor\nimplemented by the <code>Drop</code> trait. For example, this will leak a <code>File</code>, i.e. reclaim\nthe space taken by the variable but never close the underlying system resource:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n<span class=\"kw\">use </span>std::fs::File;\n\n<span class=\"kw\">let </span>file = File::open(<span class=\"string\">\"foo.txt\"</span>).unwrap();\nmem::forget(file);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++use+std::fs::File;%0A++++%0A++++let+file+=+File::open(%22foo.txt%22).unwrap();%0A++++mem::forget(file);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This is useful when the ownership of the underlying resource was previously\ntransferred to code outside of Rust, for example by transmitting the raw\nfile descriptor to C code.</p>\n<h2 id=\"relationship-with-manuallydrop\"><a class=\"doc-anchor\" href=\"#relationship-with-manuallydrop\">§</a>Relationship with <code>ManuallyDrop</code></h2>\n<p>While <code>mem::forget</code> can also be used to transfer <em>memory</em> ownership, doing so is error-prone.\n<a href=\"struct.ManuallyDrop.html\" title=\"struct std::mem::ManuallyDrop\"><code>ManuallyDrop</code></a> should be used instead. Consider, for example, this code:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = <span class=\"macro\">vec!</span>[<span class=\"number\">65</span>, <span class=\"number\">122</span>];\n<span class=\"comment\">// Build a `String` using the contents of `v`\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n<span class=\"comment\">// leak `v` because its memory is now managed by `s`\n</span>mem::forget(v);  <span class=\"comment\">// ERROR - v is invalid and must not be passed to a function\n</span><span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"Az\"</span>);\n<span class=\"comment\">// `s` is implicitly dropped and its memory deallocated.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%0A++++let+mut+v+=+vec!%5B65,+122%5D;%0A++++//+Build+a+%60String%60+using+the+contents+of+%60v%60%0A++++let+s+=+unsafe+%7B+String::from_raw_parts(v.as_mut_ptr(),+v.len(),+v.capacity())+%7D;%0A++++//+leak+%60v%60+because+its+memory+is+now+managed+by+%60s%60%0A++++mem::forget(v);++//+ERROR+-+v+is+invalid+and+must+not+be+passed+to+a+function%0A++++assert_eq!(s,+%22Az%22);%0A++++//+%60s%60+is+implicitly+dropped+and+its+memory+deallocated.%0A%7D&amp;edition=2021\">Run</a></div>\n<p>There are two issues with the above example:</p>\n<ul>\n<li>If more code were added between the construction of <code>String</code> and the invocation of\n<code>mem::forget()</code>, a panic within it would cause a double free because the same memory\nis handled by both <code>v</code> and <code>s</code>.</li>\n<li>After calling <code>v.as_mut_ptr()</code> and transmitting the ownership of the data to <code>s</code>,\nthe <code>v</code> value is invalid. Even when a value is just moved to <code>mem::forget</code> (which won’t\ninspect it), some types have strict requirements on their values that\nmake them invalid when dangling or no longer owned. Using invalid values in any\nway, including passing them to or returning them from functions, constitutes\nundefined behavior and may break the assumptions made by the compiler.</li>\n</ul>\n<p>Switching to <code>ManuallyDrop</code> avoids both issues:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::ManuallyDrop;\n\n<span class=\"kw\">let </span>v = <span class=\"macro\">vec!</span>[<span class=\"number\">65</span>, <span class=\"number\">122</span>];\n<span class=\"comment\">// Before we disassemble `v` into its raw parts, make sure it\n// does not get dropped!\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = ManuallyDrop::new(v);\n<span class=\"comment\">// Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n</span><span class=\"kw\">let </span>(ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n<span class=\"comment\">// Finally, build a `String`.\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ String::from_raw_parts(ptr, len, cap) };\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"Az\"</span>);\n<span class=\"comment\">// `s` is implicitly dropped and its memory deallocated.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::mem::ManuallyDrop;%0A++++%0A++++let+v+=+vec!%5B65,+122%5D;%0A++++//+Before+we+disassemble+%60v%60+into+its+raw+parts,+make+sure+it%0A++++//+does+not+get+dropped!%0A++++let+mut+v+=+ManuallyDrop::new(v);%0A++++//+Now+disassemble+%60v%60.+These+operations+cannot+panic,+so+there+cannot+be+a+leak.%0A++++let+(ptr,+len,+cap)+=+(v.as_mut_ptr(),+v.len(),+v.capacity());%0A++++//+Finally,+build+a+%60String%60.%0A++++let+s+=+unsafe+%7B+String::from_raw_parts(ptr,+len,+cap)+%7D;%0A++++assert_eq!(s,+%22Az%22);%0A++++//+%60s%60+is+implicitly+dropped+and+its+memory+deallocated.%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>ManuallyDrop</code> robustly prevents double-free because we disable <code>v</code>’s destructor\nbefore doing anything else. <code>mem::forget()</code> doesn’t allow this because it consumes its\nargument, forcing us to call it only after extracting anything we need from <code>v</code>. Even\nif a panic were introduced between construction of <code>ManuallyDrop</code> and building the\nstring (which cannot happen in the code as shown), it would result in a leak and not a\ndouble free. In other words, <code>ManuallyDrop</code> errs on the side of leaking instead of\nerring on the side of (double-)dropping.</p>\n<p>Also, <code>ManuallyDrop</code> prevents us from having to “touch” <code>v</code> after transferring the\nownership to <code>s</code> — the final step of interacting with <code>v</code> to dispose of it without\nrunning its destructor is entirely avoided.</p>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:12:04.688Z"
}