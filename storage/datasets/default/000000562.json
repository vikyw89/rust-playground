{
	"title": "Allocator in std::alloc - Rust",
	"url": "https://doc.rust-lang.org/stable/std/alloc/trait.Allocator.html",
	"markdown": "# Allocator in std::alloc - Rust\n\n```\npub unsafe trait Allocator {\n    // Required methods\n    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;\n    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);\n\n    // Provided methods\n    fn allocate_zeroed(\n        &self,\n        layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> { ... }\n    unsafe fn grow(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> { ... }\n    unsafe fn grow_zeroed(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> { ... }\n    unsafe fn shrink(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> { ... }\n    fn by_ref(&self) -> &Self\n       where Self: Sized { ... }\n}\n```\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nExpand description\n\nAn implementation of `Allocator` can allocate, grow, shrink, and deallocate arbitrary blocks of data described via [`Layout`](struct.Layout.html \"struct std::alloc::Layout\").\n\n`Allocator` is designed to be implemented on ZSTs, references, or smart pointers because having an allocator like `MyAlloc([u8; N])` cannot be moved, without updating the pointers to the allocated memory.\n\nUnlike [`GlobalAlloc`](trait.GlobalAlloc.html \"trait std::alloc::GlobalAlloc\"), zero-sized allocations are allowed in `Allocator`. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as `libc::malloc`), this must be caught by the implementation.\n\n#### [¬ß](#currently-allocated-memory)Currently allocated memory\n\nSome of the methods require that a memory block be _currently allocated_ via an allocator. This means that:\n\n-   the starting address for that memory block was previously returned by [`allocate`](about:blank/trait.Allocator.html#tymethod.allocate \"method std::alloc::Allocator::allocate\"), [`grow`](about:blank/trait.Allocator.html#method.grow \"method std::alloc::Allocator::grow\"), or [`shrink`](about:blank/trait.Allocator.html#method.shrink \"method std::alloc::Allocator::shrink\"), and\n    \n-   the memory block has not been subsequently deallocated, where blocks are either deallocated directly by being passed to [`deallocate`](about:blank/trait.Allocator.html#tymethod.deallocate \"method std::alloc::Allocator::deallocate\") or were changed by being passed to [`grow`](about:blank/trait.Allocator.html#method.grow \"method std::alloc::Allocator::grow\") or [`shrink`](about:blank/trait.Allocator.html#method.shrink \"method std::alloc::Allocator::shrink\") that returns `Ok`. If `grow` or `shrink` have returned `Err`, the passed pointer remains valid.\n    \n\n#### [¬ß](#memory-fitting)Memory fitting\n\nSome of the methods require that a layout _fit_ a memory block. What it means for a layout to ‚Äúfit‚Äù a memory block means (or equivalently, for a memory block to ‚Äúfit‚Äù a layout) is that the following conditions must hold:\n\n-   The block must be allocated with the same alignment as [`layout.align()`](about:blank/struct.Layout.html#method.align \"method std::alloc::Layout::align\"), and\n    \n-   The provided [`layout.size()`](about:blank/struct.Layout.html#method.size \"method std::alloc::Layout::size\") must fall in the range `min ..= max`, where:\n    \n    -   `min` is the size of the layout most recently used to allocate the block, and\n    -   `max` is the latest actual size returned from [`allocate`](about:blank/trait.Allocator.html#tymethod.allocate \"method std::alloc::Allocator::allocate\"), [`grow`](about:blank/trait.Allocator.html#method.grow \"method std::alloc::Allocator::grow\"), or [`shrink`](about:blank/trait.Allocator.html#method.shrink \"method std::alloc::Allocator::shrink\").\n\n## [¬ß](#safety)Safety\n\n-   Memory blocks returned from an allocator that are [_currently allocated_](#currently-allocated-memory) must point to valid memory and retain their validity while they are [_currently allocated_](#currently-allocated-memory) and the shorter of:\n    \n    -   the borrow-checker lifetime of the allocator type itself.\n    -   as long as at least one of the instance and all of its clones has not been dropped.\n-   copying, cloning, or moving the allocator must not invalidate memory blocks returned from this allocator. A copied or cloned allocator must behave like the same allocator, and\n    \n-   any pointer to a memory block which is [_currently allocated_](#currently-allocated-memory) may be passed to any other method of the allocator.\n    \n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#136)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nAttempts to allocate a block of memory.\n\nOn success, returns a [`NonNull<[u8]>`](../ptr/struct.NonNull.html \"struct std::ptr::NonNull\") meeting the size and alignment guarantees of `layout`.\n\nThe returned block may have a larger size than specified by `layout.size()`, and may or may not have its contents initialized.\n\nThe returned block of memory remains valid as long as it is \\[_currently allocated_\\] and the shorter of:\n\n-   the borrow-checker lifetime of the allocator type itself.\n-   as long as at the allocator and all its clones has not been dropped.\n\n##### [¬ß](#errors)Errors\n\nReturning `Err` indicates that either memory is exhausted or `layout` does not meet allocator‚Äôs size or alignment constraints.\n\nImplementations are encouraged to return `Err` on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#169)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nDeallocates the memory referenced by `ptr`.\n\n##### [¬ß](#safety-1)Safety\n\n-   `ptr` must denote a block of memory [_currently allocated_](#currently-allocated-memory) via this allocator, and\n-   `layout` must [_fit_](#memory-fitting) that block of memory.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#153)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nBehaves like `allocate`, but also ensures that the returned memory is zero-initialized.\n\n##### [¬ß](#errors-1)Errors\n\nReturning `Err` indicates that either memory is exhausted or `layout` does not meet allocator‚Äôs size or alignment constraints.\n\nImplementations are encouraged to return `Err` on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#209-214)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nAttempts to extend the memory block.\n\nReturns a new [`NonNull<[u8]>`](../ptr/struct.NonNull.html \"struct std::ptr::NonNull\") containing a pointer and the actual size of the allocated memory. The pointer is suitable for holding data described by `new_layout`. To accomplish this, the allocator may extend the allocation referenced by `ptr` to fit the new layout.\n\nIf this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. Any access to the old `ptr` is Undefined Behavior, even if the allocation was grown in-place. The newly returned pointer is the only valid pointer for accessing this memory now.\n\nIf this method returns `Err`, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.\n\n##### [¬ß](#safety-2)Safety\n\n-   `ptr` must denote a block of memory [_currently allocated_](#currently-allocated-memory) via this allocator.\n-   `old_layout` must [_fit_](#memory-fitting) that block of memory (The `new_layout` argument need not fit it.).\n-   `new_layout.size()` must be greater than or equal to `old_layout.size()`.\n\nNote that `new_layout.align()` need not be the same as `old_layout.align()`.\n\n##### [¬ß](#errors-2)Errors\n\nReturns `Err` if the new layout does not meet the allocator‚Äôs size and alignment constraints of the allocator, or if growing otherwise fails.\n\nImplementations are encouraged to return `Err` on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#272-277)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nBehaves like `grow`, but also ensures that the new contents are set to zero before being returned.\n\nThe memory block will contain the following contents after a successful call to `grow_zeroed`:\n\n-   Bytes `0..old_layout.size()` are preserved from the original allocation.\n-   Bytes `old_layout.size()..old_size` will either be preserved or zeroed, depending on the allocator implementation. `old_size` refers to the size of the memory block prior to the `grow_zeroed` call, which may be larger than the size that was originally requested when it was allocated.\n-   Bytes `old_size..new_size` are zeroed. `new_size` refers to the size of the memory block returned by the `grow_zeroed` call.\n\n##### [¬ß](#safety-3)Safety\n\n-   `ptr` must denote a block of memory [_currently allocated_](#currently-allocated-memory) via this allocator.\n-   `old_layout` must [_fit_](#memory-fitting) that block of memory (The `new_layout` argument need not fit it.).\n-   `new_layout.size()` must be greater than or equal to `old_layout.size()`.\n\nNote that `new_layout.align()` need not be the same as `old_layout.align()`.\n\n##### [¬ß](#errors-3)Errors\n\nReturns `Err` if the new layout does not meet the allocator‚Äôs size and alignment constraints of the allocator, or if growing otherwise fails.\n\nImplementations are encouraged to return `Err` on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#336-341)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nAttempts to shrink the memory block.\n\nReturns a new [`NonNull<[u8]>`](../ptr/struct.NonNull.html \"struct std::ptr::NonNull\") containing a pointer and the actual size of the allocated memory. The pointer is suitable for holding data described by `new_layout`. To accomplish this, the allocator may shrink the allocation referenced by `ptr` to fit the new layout.\n\nIf this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. Any access to the old `ptr` is Undefined Behavior, even if the allocation was shrunk in-place. The newly returned pointer is the only valid pointer for accessing this memory now.\n\nIf this method returns `Err`, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.\n\n##### [¬ß](#safety-4)Safety\n\n-   `ptr` must denote a block of memory [_currently allocated_](#currently-allocated-memory) via this allocator.\n-   `old_layout` must [_fit_](#memory-fitting) that block of memory (The `new_layout` argument need not fit it.).\n-   `new_layout.size()` must be smaller than or equal to `old_layout.size()`.\n\nNote that `new_layout.align()` need not be the same as `old_layout.align()`.\n\n##### [¬ß](#errors-4)Errors\n\nReturns `Err` if the new layout does not meet the allocator‚Äôs size and alignment constraints of the allocator, or if shrinking otherwise fails.\n\nImplementations are encouraged to return `Err` on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#366-368)\n\nüî¨This is a nightly-only experimental API. (`allocator_api`¬†[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nCreates a ‚Äúby reference‚Äù adapter for this instance of `Allocator`.\n\nThe returned adapter also implements `Allocator` and will simply borrow this.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"An implementation of `Allocator` can allocate, grow, shrink, and deallocate arbitrary blocks of data described via `Layout`.\"><title>Allocator in std::alloc - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc trait\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Allocator</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Allocator</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#required-methods\">Required Methods</a></h3><ul class=\"block\"><li><a href=\"#tymethod.allocate\">allocate</a></li><li><a href=\"#tymethod.deallocate\">deallocate</a></li></ul><h3><a href=\"#provided-methods\">Provided Methods</a></h3><ul class=\"block\"><li><a href=\"#method.allocate_zeroed\">allocate_zeroed</a></li><li><a href=\"#method.by_ref\">by_ref</a></li><li><a href=\"#method.grow\">grow</a></li><li><a href=\"#method.grow_zeroed\">grow_zeroed</a></li><li><a href=\"#method.shrink\">shrink</a></li></ul><h3><a href=\"#implementors\">Implementors</a></h3></section><h2><a href=\"index.html\">In std::alloc</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AllocError.html\">AllocError</a></li><li><a href=\"struct.Global.html\">Global</a></li><li><a href=\"struct.Layout.html\">Layout</a></li><li><a href=\"struct.LayoutError.html\">LayoutError</a></li><li><a href=\"struct.System.html\">System</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.Allocator.html\">Allocator</a></li><li><a href=\"trait.GlobalAlloc.html\">GlobalAlloc</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.alloc.html\">alloc</a></li><li><a href=\"fn.alloc_zeroed.html\">alloc_zeroed</a></li><li><a href=\"fn.dealloc.html\">dealloc</a></li><li><a href=\"fn.handle_alloc_error.html\">handle_alloc_error</a></li><li><a href=\"fn.realloc.html\">realloc</a></li><li><a href=\"fn.set_alloc_error_hook.html\">set_alloc_error_hook</a></li><li><a href=\"fn.take_alloc_error_hook.html\">take_alloc_error_hook</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.LayoutErr.html\">LayoutErr</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‚ÄòS‚Äô or ‚Äò/‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Trait <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">alloc</a>::<wbr><a class=\"trait\" href=\"#\">Allocator</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#111\">source</a> ¬∑ <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>‚àí</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub unsafe trait Allocator {\n    // Required methods\n    fn <a href=\"#tymethod.allocate\" class=\"fn\">allocate</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;;\n<span class=\"item-spacer\"></span>    unsafe fn <a href=\"#tymethod.deallocate\" class=\"fn\">deallocate</a>(&amp;self, ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>);\n\n    // Provided methods\n    fn <a href=\"#method.allocate_zeroed\" class=\"fn\">allocate_zeroed</a>(\n        &amp;self,\n        layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    ) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    unsafe fn <a href=\"#method.grow\" class=\"fn\">grow</a>(\n        &amp;self,\n        ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;,\n        old_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n        new_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    ) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    unsafe fn <a href=\"#method.grow_zeroed\" class=\"fn\">grow_zeroed</a>(\n        &amp;self,\n        ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;,\n        old_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n        new_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    ) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    unsafe fn <a href=\"#method.shrink\" class=\"fn\">shrink</a>(\n        &amp;self,\n        ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;,\n        old_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n        new_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    ) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt; { ... }\n<span class=\"item-spacer\"></span>    fn <a href=\"#method.by_ref\" class=\"fn\">by_ref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Self</a>\n       <span class=\"where\">where Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a></span> { ... }\n}</code></pre><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>An implementation of <code>Allocator</code> can allocate, grow, shrink, and deallocate arbitrary blocks of\ndata described via <a href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\"><code>Layout</code></a>.</p>\n<p><code>Allocator</code> is designed to be implemented on ZSTs, references, or smart pointers because having\nan allocator like <code>MyAlloc([u8; N])</code> cannot be moved, without updating the pointers to the\nallocated memory.</p>\n<p>Unlike <a href=\"trait.GlobalAlloc.html\" title=\"trait std::alloc::GlobalAlloc\"><code>GlobalAlloc</code></a>, zero-sized allocations are allowed in <code>Allocator</code>. If an underlying\nallocator does not support this (like jemalloc) or return a null pointer (such as\n<code>libc::malloc</code>), this must be caught by the implementation.</p>\n<h4 id=\"currently-allocated-memory\"><a class=\"doc-anchor\" href=\"#currently-allocated-memory\">¬ß</a>Currently allocated memory</h4>\n<p>Some of the methods require that a memory block be <em>currently allocated</em> via an allocator. This\nmeans that:</p>\n<ul>\n<li>\n<p>the starting address for that memory block was previously returned by <a href=\"trait.Allocator.html#tymethod.allocate\" title=\"method std::alloc::Allocator::allocate\"><code>allocate</code></a>, <a href=\"trait.Allocator.html#method.grow\" title=\"method std::alloc::Allocator::grow\"><code>grow</code></a>, or\n<a href=\"trait.Allocator.html#method.shrink\" title=\"method std::alloc::Allocator::shrink\"><code>shrink</code></a>, and</p>\n</li>\n<li>\n<p>the memory block has not been subsequently deallocated, where blocks are either deallocated\ndirectly by being passed to <a href=\"trait.Allocator.html#tymethod.deallocate\" title=\"method std::alloc::Allocator::deallocate\"><code>deallocate</code></a> or were changed by being passed to <a href=\"trait.Allocator.html#method.grow\" title=\"method std::alloc::Allocator::grow\"><code>grow</code></a> or\n<a href=\"trait.Allocator.html#method.shrink\" title=\"method std::alloc::Allocator::shrink\"><code>shrink</code></a> that returns <code>Ok</code>. If <code>grow</code> or <code>shrink</code> have returned <code>Err</code>, the passed pointer\nremains valid.</p>\n</li>\n</ul>\n<h4 id=\"memory-fitting\"><a class=\"doc-anchor\" href=\"#memory-fitting\">¬ß</a>Memory fitting</h4>\n<p>Some of the methods require that a layout <em>fit</em> a memory block. What it means for a layout to\n‚Äúfit‚Äù a memory block means (or equivalently, for a memory block to ‚Äúfit‚Äù a layout) is that the\nfollowing conditions must hold:</p>\n<ul>\n<li>\n<p>The block must be allocated with the same alignment as <a href=\"struct.Layout.html#method.align\" title=\"method std::alloc::Layout::align\"><code>layout.align()</code></a>, and</p>\n</li>\n<li>\n<p>The provided <a href=\"struct.Layout.html#method.size\" title=\"method std::alloc::Layout::size\"><code>layout.size()</code></a> must fall in the range <code>min ..= max</code>, where:</p>\n<ul>\n<li><code>min</code> is the size of the layout most recently used to allocate the block, and</li>\n<li><code>max</code> is the latest actual size returned from <a href=\"trait.Allocator.html#tymethod.allocate\" title=\"method std::alloc::Allocator::allocate\"><code>allocate</code></a>, <a href=\"trait.Allocator.html#method.grow\" title=\"method std::alloc::Allocator::grow\"><code>grow</code></a>, or <a href=\"trait.Allocator.html#method.shrink\" title=\"method std::alloc::Allocator::shrink\"><code>shrink</code></a>.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">¬ß</a>Safety</h2>\n<ul>\n<li>\n<p>Memory blocks returned from an allocator that are <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> must point to\nvalid memory and retain their validity while they are <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> and the shorter\nof:</p>\n<ul>\n<li>the borrow-checker lifetime of the allocator type itself.</li>\n<li>as long as at least one of the instance and all of its clones has not been dropped.</li>\n</ul>\n</li>\n<li>\n<p>copying, cloning, or moving the allocator must not invalidate memory blocks returned from this\nallocator. A copied or cloned allocator must behave like the same allocator, and</p>\n</li>\n<li>\n<p>any pointer to a memory block which is <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> may be passed to any other\nmethod of the allocator.</p>\n</li>\n</ul>\n</div></details><h2 id=\"required-methods\" class=\"section-header\">Required Methods<a href=\"#required-methods\" class=\"anchor\">¬ß</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.allocate\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#136\">source</a><h4 class=\"code-header\">fn <a href=\"#tymethod.allocate\" class=\"fn\">allocate</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Attempts to allocate a block of memory.</p>\n<p>On success, returns a <a href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\"><code>NonNull&lt;[u8]&gt;</code></a> meeting the size and alignment guarantees of <code>layout</code>.</p>\n<p>The returned block may have a larger size than specified by <code>layout.size()</code>, and may or may\nnot have its contents initialized.</p>\n<p>The returned block of memory remains valid as long as it is [<em>currently allocated</em>] and the shorter of:</p>\n<ul>\n<li>the borrow-checker lifetime of the allocator type itself.</li>\n<li>as long as at the allocator and all its clones has not been dropped.</li>\n</ul>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">¬ß</a>Errors</h5>\n<p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet\nallocator‚Äôs size or alignment constraints.</p>\n<p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or\naborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement\nthis trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to an allocation error are encouraged to\ncall the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.deallocate\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#169\">source</a><h4 class=\"code-header\">unsafe fn <a href=\"#tymethod.deallocate\" class=\"fn\">deallocate</a>(&amp;self, ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Deallocates the memory referenced by <code>ptr</code>.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">¬ß</a>Safety</h5>\n<ul>\n<li><code>ptr</code> must denote a block of memory <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> via this allocator, and</li>\n<li><code>layout</code> must <a href=\"#memory-fitting\"><em>fit</em></a> that block of memory.</li>\n</ul>\n</div></details></div><h2 id=\"provided-methods\" class=\"section-header\">Provided Methods<a href=\"#provided-methods\" class=\"anchor\">¬ß</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.allocate_zeroed\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#153\">source</a><h4 class=\"code-header\">fn <a href=\"#method.allocate_zeroed\" class=\"fn\">allocate_zeroed</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Behaves like <code>allocate</code>, but also ensures that the returned memory is zero-initialized.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">¬ß</a>Errors</h5>\n<p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet\nallocator‚Äôs size or alignment constraints.</p>\n<p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or\naborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement\nthis trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to an allocation error are encouraged to\ncall the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.grow\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#209-214\">source</a><h4 class=\"code-header\">unsafe fn <a href=\"#method.grow\" class=\"fn\">grow</a>(\n    &amp;self,\n    ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;,\n    old_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    new_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Attempts to extend the memory block.</p>\n<p>Returns a new <a href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\"><code>NonNull&lt;[u8]&gt;</code></a> containing a pointer and the actual size of the allocated\nmemory. The pointer is suitable for holding data described by <code>new_layout</code>. To accomplish\nthis, the allocator may extend the allocation referenced by <code>ptr</code> to fit the new layout.</p>\n<p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been\ntransferred to this allocator. Any access to the old <code>ptr</code> is Undefined Behavior, even if the\nallocation was grown in-place. The newly returned pointer is the only valid pointer\nfor accessing this memory now.</p>\n<p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to\nthis allocator, and the contents of the memory block are unaltered.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">¬ß</a>Safety</h5>\n<ul>\n<li><code>ptr</code> must denote a block of memory <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> via this allocator.</li>\n<li><code>old_layout</code> must <a href=\"#memory-fitting\"><em>fit</em></a> that block of memory (The <code>new_layout</code> argument need not fit it.).</li>\n<li><code>new_layout.size()</code> must be greater than or equal to <code>old_layout.size()</code>.</li>\n</ul>\n<p>Note that <code>new_layout.align()</code> need not be the same as <code>old_layout.align()</code>.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">¬ß</a>Errors</h5>\n<p>Returns <code>Err</code> if the new layout does not meet the allocator‚Äôs size and alignment\nconstraints of the allocator, or if growing otherwise fails.</p>\n<p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or\naborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement\nthis trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to an allocation error are encouraged to\ncall the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.grow_zeroed\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#272-277\">source</a><h4 class=\"code-header\">unsafe fn <a href=\"#method.grow_zeroed\" class=\"fn\">grow_zeroed</a>(\n    &amp;self,\n    ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;,\n    old_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    new_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Behaves like <code>grow</code>, but also ensures that the new contents are set to zero before being\nreturned.</p>\n<p>The memory block will contain the following contents after a successful call to\n<code>grow_zeroed</code>:</p>\n<ul>\n<li>Bytes <code>0..old_layout.size()</code> are preserved from the original allocation.</li>\n<li>Bytes <code>old_layout.size()..old_size</code> will either be preserved or zeroed, depending on\nthe allocator implementation. <code>old_size</code> refers to the size of the memory block prior\nto the <code>grow_zeroed</code> call, which may be larger than the size that was originally\nrequested when it was allocated.</li>\n<li>Bytes <code>old_size..new_size</code> are zeroed. <code>new_size</code> refers to the size of the memory\nblock returned by the <code>grow_zeroed</code> call.</li>\n</ul>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">¬ß</a>Safety</h5>\n<ul>\n<li><code>ptr</code> must denote a block of memory <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> via this allocator.</li>\n<li><code>old_layout</code> must <a href=\"#memory-fitting\"><em>fit</em></a> that block of memory (The <code>new_layout</code> argument need not fit it.).</li>\n<li><code>new_layout.size()</code> must be greater than or equal to <code>old_layout.size()</code>.</li>\n</ul>\n<p>Note that <code>new_layout.align()</code> need not be the same as <code>old_layout.align()</code>.</p>\n<h5 id=\"errors-3\"><a class=\"doc-anchor\" href=\"#errors-3\">¬ß</a>Errors</h5>\n<p>Returns <code>Err</code> if the new layout does not meet the allocator‚Äôs size and alignment\nconstraints of the allocator, or if growing otherwise fails.</p>\n<p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or\naborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement\nthis trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to an allocation error are encouraged to\ncall the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.shrink\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#336-341\">source</a><h4 class=\"code-header\">unsafe fn <a href=\"#method.shrink\" class=\"fn\">shrink</a>(\n    &amp;self,\n    ptr: <a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>&gt;,\n    old_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    new_layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\">NonNull</a>&lt;[<a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>]&gt;, <a class=\"struct\" href=\"struct.AllocError.html\" title=\"struct std::alloc::AllocError\">AllocError</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Attempts to shrink the memory block.</p>\n<p>Returns a new <a href=\"../ptr/struct.NonNull.html\" title=\"struct std::ptr::NonNull\"><code>NonNull&lt;[u8]&gt;</code></a> containing a pointer and the actual size of the allocated\nmemory. The pointer is suitable for holding data described by <code>new_layout</code>. To accomplish\nthis, the allocator may shrink the allocation referenced by <code>ptr</code> to fit the new layout.</p>\n<p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been\ntransferred to this allocator. Any access to the old <code>ptr</code> is Undefined Behavior, even if the\nallocation was shrunk in-place. The newly returned pointer is the only valid pointer\nfor accessing this memory now.</p>\n<p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to\nthis allocator, and the contents of the memory block are unaltered.</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">¬ß</a>Safety</h5>\n<ul>\n<li><code>ptr</code> must denote a block of memory <a href=\"#currently-allocated-memory\"><em>currently allocated</em></a> via this allocator.</li>\n<li><code>old_layout</code> must <a href=\"#memory-fitting\"><em>fit</em></a> that block of memory (The <code>new_layout</code> argument need not fit it.).</li>\n<li><code>new_layout.size()</code> must be smaller than or equal to <code>old_layout.size()</code>.</li>\n</ul>\n<p>Note that <code>new_layout.align()</code> need not be the same as <code>old_layout.align()</code>.</p>\n<h5 id=\"errors-4\"><a class=\"doc-anchor\" href=\"#errors-4\">¬ß</a>Errors</h5>\n<p>Returns <code>Err</code> if the new layout does not meet the allocator‚Äôs size and alignment\nconstraints of the allocator, or if shrinking otherwise fails.</p>\n<p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or\naborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement\nthis trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to an allocation error are encouraged to\ncall the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.by_ref\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#366-368\">source</a><h4 class=\"code-header\">fn <a href=\"#method.by_ref\" class=\"fn\">by_ref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Self</a><div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates a ‚Äúby reference‚Äù adapter for this instance of <code>Allocator</code>.</p>\n<p>The returned adapter also implements <code>Allocator</code> and will simply borrow this.</p>\n</div></details></div><h2 id=\"implementors\" class=\"section-header\">Implementors<a href=\"#implementors\" class=\"anchor\">¬ß</a></h2><div id=\"implementors-list\"><section id=\"impl-Allocator-for-Global\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/alloc.rs.html#240\">source</a><a href=\"#impl-Allocator-for-Global\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> for <a class=\"struct\" href=\"struct.Global.html\" title=\"struct std::alloc::Global\">Global</a></h3></section><section id=\"impl-Allocator-for-System\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/alloc.rs.html#203-287\">source</a><a href=\"#impl-Allocator-for-System\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> for <a class=\"struct\" href=\"struct.System.html\" title=\"struct std::alloc::System\">System</a></h3></section><section id=\"impl-Allocator-for-%26A\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/mod.rs.html#375-377\">source</a><a href=\"#impl-Allocator-for-%26A\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"trait\" href=\"trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> for <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;A</a><div class=\"where\">where\n    A: <a class=\"trait\" href=\"trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></div><script src=\"../../trait.impl/core/alloc/trait.Allocator.js\" data-ignore-extern-crates=\"alloc\" async=\"\"></script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:12:16.151Z"
}