{
	"title": "absolute in std::path - Rust",
	"url": "https://doc.rust-lang.org/stable/std/path/fn.absolute.html",
	"markdown": "# absolute in std::path - Rust\n\n## Function [std](../index.html)::[path](index.html)::[absolute](#)\n\n1.79.0 · [source](about:blank/src/std/path.rs.html#3394-3401) ·\n\n```\npub fn absolute<P: AsRef<Path>>(path: P) -> Result<PathBuf>\n```\n\nExpand description\n\nMakes the path absolute without accessing the filesystem.\n\nIf the path is relative, the current directory is used as the base directory. All intermediate components will be resolved according to platforms-specific rules but unlike [`canonicalize`](../fs/fn.canonicalize.html \"fn std::fs::canonicalize\") this does not resolve symlinks and may succeed even if the path does not exist.\n\nIf the `path` is empty or getting the [current directory](../env/fn.current_dir.html \"fn std::env::current_dir\") fails then an error will be returned.\n\n## [§](#examples)Examples\n\n### [§](#posix-paths)POSIX paths\n\n```\nfn main() -> std::io::Result<()> {\n  use std::path::{self, Path};\n\n  // Relative to absolute\n  let absolute = path::absolute(\"foo/./bar\")?;\n  assert!(absolute.ends_with(\"foo/bar\"));\n\n  // Absolute to absolute\n  let absolute = path::absolute(\"/foo//test/.././bar.rs\")?;\n  assert_eq!(absolute, Path::new(\"/foo/test/../bar.rs\"));\n  Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Bcfg(unix)%5D%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++use+std::path::%7Bself,+Path%7D;%0A%0A++//+Relative+to+absolute%0A++let+absolute+=+path::absolute(%22foo/./bar%22)?;%0A++assert!(absolute.ends_with(%22foo/bar%22));%0A%0A++//+Absolute+to+absolute%0A++let+absolute+=+path::absolute(%22/foo//test/.././bar.rs%22)?;%0A++assert_eq!(absolute,+Path::new(%22/foo/test/../bar.rs%22));%0A++Ok(())%0A%7D%0A%23%5Bcfg(not(unix))%5D%0Afn+main()+%7B%7D&edition=2021)\n\nThe path is resolved using [POSIX semantics](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13) except that it stops short of resolving symlinks. This means it will keep `..` components and trailing slashes.\n\n### [§](#windows-paths)Windows paths\n\n```\nfn main() -> std::io::Result<()> {\n  use std::path::{self, Path};\n\n  // Relative to absolute\n  let absolute = path::absolute(\"foo/./bar\")?;\n  assert!(absolute.ends_with(r\"foo\\bar\"));\n\n  // Absolute to absolute\n  let absolute = path::absolute(r\"C:\\foo//test\\..\\./bar.rs\")?;\n\n  assert_eq!(absolute, Path::new(r\"C:\\foo\\bar.rs\"));\n  Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Bcfg(windows)%5D%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++use+std::path::%7Bself,+Path%7D;%0A%0A++//+Relative+to+absolute%0A++let+absolute+=+path::absolute(%22foo/./bar%22)?;%0A++assert!(absolute.ends_with(r%22foo%5Cbar%22));%0A%0A++//+Absolute+to+absolute%0A++let+absolute+=+path::absolute(r%22C:%5Cfoo//test%5C..%5C./bar.rs%22)?;%0A%0A++assert_eq!(absolute,+Path::new(r%22C:%5Cfoo%5Cbar.rs%22));%0A++Ok(())%0A%7D%0A%23%5Bcfg(not(windows))%5D%0Afn+main()+%7B%7D&edition=2021)\n\nFor verbatim paths this will simply return the path as given. For other paths this is currently equivalent to calling [`GetFullPathNameW`](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew).\n\nNote that this [may change in the future](about:blank/io/index.html#platform-specific-behavior \"mod std::io\").",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Makes the path absolute without accessing the filesystem.\"><title>absolute in std::path - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::path</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Ancestors.html\">Ancestors</a></li><li><a href=\"struct.Components.html\">Components</a></li><li><a href=\"struct.Display.html\">Display</a></li><li><a href=\"struct.Iter.html\">Iter</a></li><li><a href=\"struct.Path.html\">Path</a></li><li><a href=\"struct.PathBuf.html\">PathBuf</a></li><li><a href=\"struct.PrefixComponent.html\">PrefixComponent</a></li><li><a href=\"struct.StripPrefixError.html\">StripPrefixError</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.Component.html\">Component</a></li><li><a href=\"enum.Prefix.html\">Prefix</a></li></ul><h3><a href=\"index.html#constants\">Constants</a></h3><ul class=\"block constant\"><li><a href=\"constant.MAIN_SEPARATOR.html\">MAIN_SEPARATOR</a></li><li><a href=\"constant.MAIN_SEPARATOR_STR.html\">MAIN_SEPARATOR_STR</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.absolute.html\">absolute</a></li><li><a href=\"fn.is_separator.html\">is_separator</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">path</a>::<wbr><a class=\"fn\" href=\"#\">absolute</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.79.0\">1.79.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#3394-3401\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub fn absolute&lt;P: <a class=\"trait\" href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;&gt;(path: P) -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a>&gt;</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Makes the path absolute without accessing the filesystem.</p>\n<p>If the path is relative, the current directory is used as the base directory.\nAll intermediate components will be resolved according to platforms-specific\nrules but unlike <a href=\"../fs/fn.canonicalize.html\" title=\"fn std::fs::canonicalize\"><code>canonicalize</code></a> this does not\nresolve symlinks and may succeed even if the path does not exist.</p>\n<p>If the <code>path</code> is empty or getting the\n<a href=\"../env/fn.current_dir.html\" title=\"fn std::env::current_dir\">current directory</a> fails then an error will be\nreturned.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2><h3 id=\"posix-paths\"><a class=\"doc-anchor\" href=\"#posix-paths\">§</a>POSIX paths</h3>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n  <span class=\"kw\">use </span>std::path::{<span class=\"self\">self</span>, Path};\n\n  <span class=\"comment\">// Relative to absolute\n  </span><span class=\"kw\">let </span>absolute = path::absolute(<span class=\"string\">\"foo/./bar\"</span>)<span class=\"question-mark\">?</span>;\n  <span class=\"macro\">assert!</span>(absolute.ends_with(<span class=\"string\">\"foo/bar\"</span>));\n\n  <span class=\"comment\">// Absolute to absolute\n  </span><span class=\"kw\">let </span>absolute = path::absolute(<span class=\"string\">\"/foo//test/.././bar.rs\"</span>)<span class=\"question-mark\">?</span>;\n  <span class=\"macro\">assert_eq!</span>(absolute, Path::new(<span class=\"string\">\"/foo/test/../bar.rs\"</span>));\n  <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Bcfg(unix)%5D%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++use+std::path::%7Bself,+Path%7D;%0A%0A++//+Relative+to+absolute%0A++let+absolute+=+path::absolute(%22foo/./bar%22)?;%0A++assert!(absolute.ends_with(%22foo/bar%22));%0A%0A++//+Absolute+to+absolute%0A++let+absolute+=+path::absolute(%22/foo//test/.././bar.rs%22)?;%0A++assert_eq!(absolute,+Path::new(%22/foo/test/../bar.rs%22));%0A++Ok(())%0A%7D%0A%23%5Bcfg(not(unix))%5D%0Afn+main()+%7B%7D&amp;edition=2021\">Run</a></div>\n<p>The path is resolved using <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\">POSIX semantics</a> except that\nit stops short of resolving symlinks. This means it will keep <code>..</code>\ncomponents and trailing slashes.</p>\n<h3 id=\"windows-paths\"><a class=\"doc-anchor\" href=\"#windows-paths\">§</a>Windows paths</h3>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n  <span class=\"kw\">use </span>std::path::{<span class=\"self\">self</span>, Path};\n\n  <span class=\"comment\">// Relative to absolute\n  </span><span class=\"kw\">let </span>absolute = path::absolute(<span class=\"string\">\"foo/./bar\"</span>)<span class=\"question-mark\">?</span>;\n  <span class=\"macro\">assert!</span>(absolute.ends_with(<span class=\"string\">r\"foo\\bar\"</span>));\n\n  <span class=\"comment\">// Absolute to absolute\n  </span><span class=\"kw\">let </span>absolute = path::absolute(<span class=\"string\">r\"C:\\foo//test\\..\\./bar.rs\"</span>)<span class=\"question-mark\">?</span>;\n\n  <span class=\"macro\">assert_eq!</span>(absolute, Path::new(<span class=\"string\">r\"C:\\foo\\bar.rs\"</span>));\n  <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Bcfg(windows)%5D%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++use+std::path::%7Bself,+Path%7D;%0A%0A++//+Relative+to+absolute%0A++let+absolute+=+path::absolute(%22foo/./bar%22)?;%0A++assert!(absolute.ends_with(r%22foo%5Cbar%22));%0A%0A++//+Absolute+to+absolute%0A++let+absolute+=+path::absolute(r%22C:%5Cfoo//test%5C..%5C./bar.rs%22)?;%0A%0A++assert_eq!(absolute,+Path::new(r%22C:%5Cfoo%5Cbar.rs%22));%0A++Ok(())%0A%7D%0A%23%5Bcfg(not(windows))%5D%0Afn+main()+%7B%7D&amp;edition=2021\">Run</a></div>\n<p>For verbatim paths this will simply return the path as given. For other\npaths this is currently equivalent to calling\n<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew\"><code>GetFullPathNameW</code></a>.</p>\n<p>Note that this <a href=\"../io/index.html#platform-specific-behavior\" title=\"mod std::io\">may change in the future</a>.</p>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:24:12.273Z"
}