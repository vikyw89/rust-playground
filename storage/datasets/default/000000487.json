{
	"title": "AsMut in std::convert - Rust",
	"url": "https://doc.rust-lang.org/stable/std/convert/trait.AsMut.html",
	"markdown": "# AsMut in std::convert - Rust\n\n```\npub trait AsMut<T>where\n    T: ?Sized,{\n    // Required method\n    fn as_mut(&mut self) -> &mut T;\n}\n```\n\nExpand description\n\nUsed to do a cheap mutable-to-mutable reference conversion.\n\nThis trait is similar to [`AsRef`](trait.AsRef.html \"trait std::convert::AsRef\") but used for converting between mutable references. If you need to do a costly conversion it is better to implement [`From`](trait.From.html \"trait std::convert::From\") with type `&mut T` or write a custom function.\n\n**Note: This trait must not fail**. If the conversion can fail, use a dedicated method which returns an [`Option<T>`](../option/enum.Option.html \"enum std::option::Option\") or a [`Result<T, E>`](../result/enum.Result.html \"enum std::result::Result\").\n\n## [§](#generic-implementations)Generic Implementations\n\n`AsMut` auto-dereferences if the inner type is a mutable reference (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo` or `&mut &mut Foo`).\n\nNote that due to historic reasons, the above currently does not hold generally for all [mutably dereferenceable types](../ops/trait.DerefMut.html \"trait std::ops::DerefMut\"), e.g. `foo.as_mut()` will _not_ work the same as `Box::new(foo).as_mut()`. Instead, many smart pointers provide an `as_mut` implementation which simply returns a reference to the [pointed-to value](about:blank/ops/trait.Deref.html#associatedtype.Target \"associated type std::ops::Deref::Target\") (but do not perform a cheap reference-to-reference conversion for that value). However, [`AsMut::as_mut`](about:blank/trait.AsMut.html#tymethod.as_mut \"method std::convert::AsMut::as_mut\") should not be used for the sole purpose of mutable dereferencing; instead [‘`Deref` coercion’](about:blank/ops/trait.DerefMut.html#mutable-deref-coercion \"trait std::ops::DerefMut\") can be used:\n\n```\nlet mut x = Box::new(5i32);\n// Avoid this:\n// let y: &mut i32 = x.as_mut();\n// Better just write:\nlet y: &mut i32 = &mut x;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+x+=+Box::new(5i32);%0A++++//+Avoid+this:%0A++++//+let+y:+%26mut+i32+=+x.as_mut();%0A++++//+Better+just+write:%0A++++let+y:+%26mut+i32+=+%26mut+x;%0A%7D&edition=2021)\n\nTypes which implement [`DerefMut`](../ops/trait.DerefMut.html \"trait std::ops::DerefMut\") should consider to add an implementation of `AsMut<T>` as follows:\n\n```\nimpl<T> AsMut<T> for SomeType\nwhere\n    <SomeType as Deref>::Target: AsMut<T>,\n{\n    fn as_mut(&mut self) -> &mut T {\n        self.deref_mut().as_mut()\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+core::ops::%7BDeref,+DerefMut%7D;%0A++++struct+SomeType;%0A++++impl+Deref+for+SomeType+%7B%0A++++++++type+Target+=+%5Bu8%5D;%0A++++++++fn+deref(%26self)+-%3E+%26%5Bu8%5D+%7B%0A++++++++++++%26%5B%5D%0A++++++++%7D%0A++++%7D%0A++++impl+DerefMut+for+SomeType+%7B%0A++++++++fn+deref_mut(%26mut+self)+-%3E+%26mut+%5Bu8%5D+%7B%0A++++++++++++%26mut+%5B%5D%0A++++++++%7D%0A++++%7D%0A++++impl%3CT%3E+AsMut%3CT%3E+for+SomeType%0A++++where%0A++++++++%3CSomeType+as+Deref%3E::Target:+AsMut%3CT%3E,%0A++++%7B%0A++++++++fn+as_mut(%26mut+self)+-%3E+%26mut+T+%7B%0A++++++++++++self.deref_mut().as_mut()%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n## [§](#reflexivity)Reflexivity\n\nIdeally, `AsMut` would be reflexive, i.e. there would be an `impl<T: ?Sized> AsMut<T> for T` with [`as_mut`](about:blank/trait.AsMut.html#tymethod.as_mut \"method std::convert::AsMut::as_mut\") simply returning its argument unchanged. Such a blanket implementation is currently _not_ provided due to technical restrictions of Rust’s type system (it would be overlapping with another existing blanket implementation for `&mut T where T: AsMut<U>` which allows `AsMut` to auto-dereference, see “Generic Implementations” above).\n\nA trivial implementation of `AsMut<T> for T` must be added explicitly for a particular type `T` where needed or desired. Note, however, that not all types from `std` contain such an implementation, and those cannot be added by external code due to orphan rules.\n\n## [§](#examples)Examples\n\nUsing `AsMut` as trait bound for a generic function, we can accept all mutable references that can be converted to type `&mut T`. Unlike [dereference](../ops/trait.DerefMut.html \"trait std::ops::DerefMut\"), which has a single [target type](about:blank/ops/trait.Deref.html#associatedtype.Target \"associated type std::ops::Deref::Target\"), there can be multiple implementations of `AsMut` for a type. In particular, `Vec<T>` implements both `AsMut<Vec<T>>` and `AsMut<[T]>`.\n\nIn the following, the example functions `caesar` and `null_terminate` provide a generic interface which work with any type that can be converted by cheap mutable-to-mutable conversion into a byte slice (`[u8]`) or byte vector (`Vec<u8>`), respectively.\n\n```\nstruct Document {\n    info: String,\n    content: Vec<u8>,\n}\n\nimpl<T: ?Sized> AsMut<T> for Document\nwhere\n    Vec<u8>: AsMut<T>,\n{\n    fn as_mut(&mut self) -> &mut T {\n        self.content.as_mut()\n    }\n}\n\nfn caesar<T: AsMut<[u8]>>(data: &mut T, key: u8) {\n    for byte in data.as_mut() {\n        *byte = byte.wrapping_add(key);\n    }\n}\n\nfn null_terminate<T: AsMut<Vec<u8>>>(data: &mut T) {\n    // Using a non-generic inner function, which contains most of the\n    // functionality, helps to minimize monomorphization overhead.\n    fn doit(data: &mut Vec<u8>) {\n        let len = data.len();\n        if len == 0 || data[len-1] != 0 {\n            data.push(0);\n        }\n    }\n    doit(data.as_mut());\n}\n\nfn main() {\n    let mut v: Vec<u8> = vec![1, 2, 3];\n    caesar(&mut v, 5);\n    assert_eq!(v, [6, 7, 8]);\n    null_terminate(&mut v);\n    assert_eq!(v, [6, 7, 8, 0]);\n    let mut doc = Document {\n        info: String::from(\"Example\"),\n        content: vec![17, 19, 8],\n    };\n    caesar(&mut doc, 1);\n    assert_eq!(doc.content, [18, 20, 9]);\n    null_terminate(&mut doc);\n    assert_eq!(doc.content, [18, 20, 9, 0]);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Astruct+Document+%7B%0A++++info:+String,%0A++++content:+Vec%3Cu8%3E,%0A%7D%0A%0Aimpl%3CT:+?Sized%3E+AsMut%3CT%3E+for+Document%0Awhere%0A++++Vec%3Cu8%3E:+AsMut%3CT%3E,%0A%7B%0A++++fn+as_mut(%26mut+self)+-%3E+%26mut+T+%7B%0A++++++++self.content.as_mut()%0A++++%7D%0A%7D%0A%0Afn+caesar%3CT:+AsMut%3C%5Bu8%5D%3E%3E(data:+%26mut+T,+key:+u8)+%7B%0A++++for+byte+in+data.as_mut()+%7B%0A++++++++*byte+=+byte.wrapping_add(key);%0A++++%7D%0A%7D%0A%0Afn+null_terminate%3CT:+AsMut%3CVec%3Cu8%3E%3E%3E(data:+%26mut+T)+%7B%0A++++//+Using+a+non-generic+inner+function,+which+contains+most+of+the%0A++++//+functionality,+helps+to+minimize+monomorphization+overhead.%0A++++fn+doit(data:+%26mut+Vec%3Cu8%3E)+%7B%0A++++++++let+len+=+data.len();%0A++++++++if+len+==+0+%7C%7C+data%5Blen-1%5D+!=+0+%7B%0A++++++++++++data.push(0);%0A++++++++%7D%0A++++%7D%0A++++doit(data.as_mut());%0A%7D%0A%0Afn+main()+%7B%0A++++let+mut+v:+Vec%3Cu8%3E+=+vec!%5B1,+2,+3%5D;%0A++++caesar(%26mut+v,+5);%0A++++assert_eq!(v,+%5B6,+7,+8%5D);%0A++++null_terminate(%26mut+v);%0A++++assert_eq!(v,+%5B6,+7,+8,+0%5D);%0A++++let+mut+doc+=+Document+%7B%0A++++++++info:+String::from(%22Example%22),%0A++++++++content:+vec!%5B17,+19,+8%5D,%0A++++%7D;%0A++++caesar(%26mut+doc,+1);%0A++++assert_eq!(doc.content,+%5B18,+20,+9%5D);%0A++++null_terminate(%26mut+doc);%0A++++assert_eq!(doc.content,+%5B18,+20,+9,+0%5D);%0A%7D&edition=2021)\n\nNote, however, that APIs don’t need to be generic. In many cases taking a `&mut [u8]` or `&mut Vec<u8>`, for example, is the better choice (callers need to pass the correct type then).\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#372)\n\nConverts this type into a mutable reference of the (usually inferred) input type.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Used to do a cheap mutable-to-mutable reference conversion.\"><title>AsMut in std::convert - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc trait\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">AsMut</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">AsMut</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#required-methods\">Required Methods</a></h3><ul class=\"block\"><li><a href=\"#tymethod.as_mut\">as_mut</a></li></ul><h3><a href=\"#implementors\">Implementors</a></h3></section><h2><a href=\"index.html\">In std::convert</a></h2><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.Infallible.html\">Infallible</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.AsMut.html\">AsMut</a></li><li><a href=\"trait.AsRef.html\">AsRef</a></li><li><a href=\"trait.FloatToInt.html\">FloatToInt</a></li><li><a href=\"trait.From.html\">From</a></li><li><a href=\"trait.Into.html\">Into</a></li><li><a href=\"trait.TryFrom.html\">TryFrom</a></li><li><a href=\"trait.TryInto.html\">TryInto</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.identity.html\">identity</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Trait <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">convert</a>::<wbr><a class=\"trait\" href=\"#\">AsMut</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#369\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub trait AsMut&lt;T&gt;<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div>{\n    // Required method\n    fn <a href=\"#tymethod.as_mut\" class=\"fn\">as_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>;\n}</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Used to do a cheap mutable-to-mutable reference conversion.</p>\n<p>This trait is similar to <a href=\"trait.AsRef.html\" title=\"trait std::convert::AsRef\"><code>AsRef</code></a> but used for converting between mutable\nreferences. If you need to do a costly conversion it is better to\nimplement <a href=\"trait.From.html\" title=\"trait std::convert::From\"><code>From</code></a> with type <code>&amp;mut T</code> or write a custom function.</p>\n<p><strong>Note: This trait must not fail</strong>. If the conversion can fail, use a\ndedicated method which returns an <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a> or a <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>.</p>\n<h2 id=\"generic-implementations\"><a class=\"doc-anchor\" href=\"#generic-implementations\">§</a>Generic Implementations</h2>\n<p><code>AsMut</code> auto-dereferences if the inner type is a mutable reference\n(e.g.: <code>foo.as_mut()</code> will work the same if <code>foo</code> has type <code>&amp;mut Foo</code> or <code>&amp;mut &amp;mut Foo</code>).</p>\n<p>Note that due to historic reasons, the above currently does not hold generally for all\n<a href=\"../ops/trait.DerefMut.html\" title=\"trait std::ops::DerefMut\">mutably dereferenceable types</a>, e.g. <code>foo.as_mut()</code> will <em>not</em> work the same as\n<code>Box::new(foo).as_mut()</code>. Instead, many smart pointers provide an <code>as_mut</code> implementation which\nsimply returns a reference to the <a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"associated type std::ops::Deref::Target\">pointed-to value</a> (but do not perform a cheap\nreference-to-reference conversion for that value). However, <a href=\"trait.AsMut.html#tymethod.as_mut\" title=\"method std::convert::AsMut::as_mut\"><code>AsMut::as_mut</code></a> should not be\nused for the sole purpose of mutable dereferencing; instead <a href=\"../ops/trait.DerefMut.html#mutable-deref-coercion\" title=\"trait std::ops::DerefMut\">‘<code>Deref</code> coercion’</a> can be used:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Box::new(<span class=\"number\">5i32</span>);\n<span class=\"comment\">// Avoid this:\n// let y: &amp;mut i32 = x.as_mut();\n// Better just write:\n</span><span class=\"kw\">let </span>y: <span class=\"kw-2\">&amp;mut </span>i32 = <span class=\"kw-2\">&amp;mut </span>x;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+x+=+Box::new(5i32);%0A++++//+Avoid+this:%0A++++//+let+y:+%26mut+i32+=+x.as_mut();%0A++++//+Better+just+write:%0A++++let+y:+%26mut+i32+=+%26mut+x;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Types which implement <a href=\"../ops/trait.DerefMut.html\" title=\"trait std::ops::DerefMut\"><code>DerefMut</code></a> should consider to add an implementation of <code>AsMut&lt;T&gt;</code> as\nfollows:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl</span>&lt;T&gt; AsMut&lt;T&gt; <span class=\"kw\">for </span>SomeType\n<span class=\"kw\">where\n    </span>&lt;SomeType <span class=\"kw\">as </span>Deref&gt;::Target: AsMut&lt;T&gt;,\n{\n    <span class=\"kw\">fn </span>as_mut(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"kw-2\">&amp;mut </span>T {\n        <span class=\"self\">self</span>.deref_mut().as_mut()\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+core::ops::%7BDeref,+DerefMut%7D;%0A++++struct+SomeType;%0A++++impl+Deref+for+SomeType+%7B%0A++++++++type+Target+=+%5Bu8%5D;%0A++++++++fn+deref(%26self)+-%3E+%26%5Bu8%5D+%7B%0A++++++++++++%26%5B%5D%0A++++++++%7D%0A++++%7D%0A++++impl+DerefMut+for+SomeType+%7B%0A++++++++fn+deref_mut(%26mut+self)+-%3E+%26mut+%5Bu8%5D+%7B%0A++++++++++++%26mut+%5B%5D%0A++++++++%7D%0A++++%7D%0A++++impl%3CT%3E+AsMut%3CT%3E+for+SomeType%0A++++where%0A++++++++%3CSomeType+as+Deref%3E::Target:+AsMut%3CT%3E,%0A++++%7B%0A++++++++fn+as_mut(%26mut+self)+-%3E+%26mut+T+%7B%0A++++++++++++self.deref_mut().as_mut()%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"reflexivity\"><a class=\"doc-anchor\" href=\"#reflexivity\">§</a>Reflexivity</h2>\n<p>Ideally, <code>AsMut</code> would be reflexive, i.e. there would be an <code>impl&lt;T: ?Sized&gt; AsMut&lt;T&gt; for T</code>\nwith <a href=\"trait.AsMut.html#tymethod.as_mut\" title=\"method std::convert::AsMut::as_mut\"><code>as_mut</code></a> simply returning its argument unchanged.\nSuch a blanket implementation is currently <em>not</em> provided due to technical restrictions of\nRust’s type system (it would be overlapping with another existing blanket implementation for\n<code>&amp;mut T where T: AsMut&lt;U&gt;</code> which allows <code>AsMut</code> to auto-dereference, see “Generic\nImplementations” above).</p>\n<p>A trivial implementation of <code>AsMut&lt;T&gt; for T</code> must be added explicitly for a particular type <code>T</code>\nwhere needed or desired. Note, however, that not all types from <code>std</code> contain such an\nimplementation, and those cannot be added by external code due to orphan rules.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Using <code>AsMut</code> as trait bound for a generic function, we can accept all mutable references that\ncan be converted to type <code>&amp;mut T</code>. Unlike <a href=\"../ops/trait.DerefMut.html\" title=\"trait std::ops::DerefMut\">dereference</a>, which has a single <a href=\"../ops/trait.Deref.html#associatedtype.Target\" title=\"associated type std::ops::Deref::Target\">target type</a>,\nthere can be multiple implementations of <code>AsMut</code> for a type. In particular, <code>Vec&lt;T&gt;</code> implements\nboth <code>AsMut&lt;Vec&lt;T&gt;&gt;</code> and <code>AsMut&lt;[T]&gt;</code>.</p>\n<p>In the following, the example functions <code>caesar</code> and <code>null_terminate</code> provide a generic\ninterface which work with any type that can be converted by cheap mutable-to-mutable conversion\ninto a byte slice (<code>[u8]</code>) or byte vector (<code>Vec&lt;u8&gt;</code>), respectively.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">struct </span>Document {\n    info: String,\n    content: Vec&lt;u8&gt;,\n}\n\n<span class=\"kw\">impl</span>&lt;T: <span class=\"question-mark\">?</span>Sized&gt; AsMut&lt;T&gt; <span class=\"kw\">for </span>Document\n<span class=\"kw\">where\n    </span>Vec&lt;u8&gt;: AsMut&lt;T&gt;,\n{\n    <span class=\"kw\">fn </span>as_mut(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) -&gt; <span class=\"kw-2\">&amp;mut </span>T {\n        <span class=\"self\">self</span>.content.as_mut()\n    }\n}\n\n<span class=\"kw\">fn </span>caesar&lt;T: AsMut&lt;[u8]&gt;&gt;(data: <span class=\"kw-2\">&amp;mut </span>T, key: u8) {\n    <span class=\"kw\">for </span>byte <span class=\"kw\">in </span>data.as_mut() {\n        <span class=\"kw-2\">*</span>byte = byte.wrapping_add(key);\n    }\n}\n\n<span class=\"kw\">fn </span>null_terminate&lt;T: AsMut&lt;Vec&lt;u8&gt;&gt;&gt;(data: <span class=\"kw-2\">&amp;mut </span>T) {\n    <span class=\"comment\">// Using a non-generic inner function, which contains most of the\n    // functionality, helps to minimize monomorphization overhead.\n    </span><span class=\"kw\">fn </span>doit(data: <span class=\"kw-2\">&amp;mut </span>Vec&lt;u8&gt;) {\n        <span class=\"kw\">let </span>len = data.len();\n        <span class=\"kw\">if </span>len == <span class=\"number\">0 </span>|| data[len-<span class=\"number\">1</span>] != <span class=\"number\">0 </span>{\n            data.push(<span class=\"number\">0</span>);\n        }\n    }\n    doit(data.as_mut());\n}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v: Vec&lt;u8&gt; = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n    caesar(<span class=\"kw-2\">&amp;mut </span>v, <span class=\"number\">5</span>);\n    <span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>]);\n    null_terminate(<span class=\"kw-2\">&amp;mut </span>v);\n    <span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>]);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>doc = Document {\n        info: String::from(<span class=\"string\">\"Example\"</span>),\n        content: <span class=\"macro\">vec!</span>[<span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">8</span>],\n    };\n    caesar(<span class=\"kw-2\">&amp;mut </span>doc, <span class=\"number\">1</span>);\n    <span class=\"macro\">assert_eq!</span>(doc.content, [<span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">9</span>]);\n    null_terminate(<span class=\"kw-2\">&amp;mut </span>doc);\n    <span class=\"macro\">assert_eq!</span>(doc.content, [<span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>]);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Astruct+Document+%7B%0A++++info:+String,%0A++++content:+Vec%3Cu8%3E,%0A%7D%0A%0Aimpl%3CT:+?Sized%3E+AsMut%3CT%3E+for+Document%0Awhere%0A++++Vec%3Cu8%3E:+AsMut%3CT%3E,%0A%7B%0A++++fn+as_mut(%26mut+self)+-%3E+%26mut+T+%7B%0A++++++++self.content.as_mut()%0A++++%7D%0A%7D%0A%0Afn+caesar%3CT:+AsMut%3C%5Bu8%5D%3E%3E(data:+%26mut+T,+key:+u8)+%7B%0A++++for+byte+in+data.as_mut()+%7B%0A++++++++*byte+=+byte.wrapping_add(key);%0A++++%7D%0A%7D%0A%0Afn+null_terminate%3CT:+AsMut%3CVec%3Cu8%3E%3E%3E(data:+%26mut+T)+%7B%0A++++//+Using+a+non-generic+inner+function,+which+contains+most+of+the%0A++++//+functionality,+helps+to+minimize+monomorphization+overhead.%0A++++fn+doit(data:+%26mut+Vec%3Cu8%3E)+%7B%0A++++++++let+len+=+data.len();%0A++++++++if+len+==+0+%7C%7C+data%5Blen-1%5D+!=+0+%7B%0A++++++++++++data.push(0);%0A++++++++%7D%0A++++%7D%0A++++doit(data.as_mut());%0A%7D%0A%0Afn+main()+%7B%0A++++let+mut+v:+Vec%3Cu8%3E+=+vec!%5B1,+2,+3%5D;%0A++++caesar(%26mut+v,+5);%0A++++assert_eq!(v,+%5B6,+7,+8%5D);%0A++++null_terminate(%26mut+v);%0A++++assert_eq!(v,+%5B6,+7,+8,+0%5D);%0A++++let+mut+doc+=+Document+%7B%0A++++++++info:+String::from(%22Example%22),%0A++++++++content:+vec!%5B17,+19,+8%5D,%0A++++%7D;%0A++++caesar(%26mut+doc,+1);%0A++++assert_eq!(doc.content,+%5B18,+20,+9%5D);%0A++++null_terminate(%26mut+doc);%0A++++assert_eq!(doc.content,+%5B18,+20,+9,+0%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note, however, that APIs don’t need to be generic. In many cases taking a <code>&amp;mut [u8]</code> or\n<code>&amp;mut Vec&lt;u8&gt;</code>, for example, is the better choice (callers need to pass the correct type then).</p>\n</div></details><h2 id=\"required-methods\" class=\"section-header\">Required Methods<a href=\"#required-methods\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.as_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#372\">source</a></span><h4 class=\"code-header\">fn <a href=\"#tymethod.as_mut\" class=\"fn\">as_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Converts this type into a mutable reference of the (usually inferred) input type.</p>\n</div></details></div><h2 id=\"implementors\" class=\"section-header\">Implementors<a href=\"#implementors\" class=\"anchor\">§</a></h2><div id=\"implementors-list\"><section id=\"impl-AsMut%3Cstr%3E-for-str\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#846\">source</a></span><a href=\"#impl-AsMut%3Cstr%3E-for-str\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"primitive\" href=\"../primitive.str.html\">str</a></h3></section><section id=\"impl-AsMut%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.43.0\">1.43.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2692\">source</a></span><a href=\"#impl-AsMut%3Cstr%3E-for-String\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-AsMut%3C%5BT%5D%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#830\">source</a></span><a href=\"#impl-AsMut%3C%5BT%5D%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a></h3></section><section id=\"impl-AsMut%3C%5BT%5D%3E-for-Vec%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/vec/mod.rs.html#3326\">source</a></span><a href=\"#impl-AsMut%3C%5BT%5D%3E-for-Vec%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><section id=\"impl-AsMut%3CVec%3CT,+A%3E%3E-for-Vec%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/vec/mod.rs.html#3312\">source</a></span><a href=\"#impl-AsMut%3CVec%3CT,+A%3E%3E-for-Vec%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;&gt; for <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><section id=\"impl-AsMut%3CT%3E-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0\">1.5.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2274\">source</a></span><a href=\"#impl-AsMut%3CT%3E-for-Box%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;T&gt; for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-AsMut%3CU%3E-for-%26mut+T\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#728-730\">source</a></span><a href=\"#impl-AsMut%3CU%3E-for-%26mut+T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;U&gt; for <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;U&gt; + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    U: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-AsMut%3C%5BT;+N%5D%3E-for-Simd%3CT,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/vector.rs.html#984-987\">source</a><a href=\"#impl-AsMut%3C%5BT;+N%5D%3E-for-Simd%3CT,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a>&gt; for <a class=\"struct\" href=\"../simd/prelude/struct.Simd.html\" title=\"struct std::simd::prelude::Simd\">Simd</a>&lt;T, N&gt;<div class=\"where\">where\n    <a class=\"struct\" href=\"../simd/struct.LaneCount.html\" title=\"struct std::simd::LaneCount\">LaneCount</a>&lt;N&gt;: <a class=\"trait\" href=\"../simd/trait.SupportedLaneCount.html\" title=\"trait std::simd::SupportedLaneCount\">SupportedLaneCount</a>,\n    T: <a class=\"trait\" href=\"../simd/trait.SimdElement.html\" title=\"trait std::simd::SimdElement\">SimdElement</a>,</div></h3></section><section id=\"impl-AsMut%3C%5BT%5D%3E-for-%5BT;+N%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/array/mod.rs.html#167\">source</a></span><a href=\"#impl-AsMut%3C%5BT%5D%3E-for-%5BT;+N%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a></h3></section><section id=\"impl-AsMut%3C%5BT%5D%3E-for-Simd%3CT,+N%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/vector.rs.html#1007-1010\">source</a><a href=\"#impl-AsMut%3C%5BT%5D%3E-for-Simd%3CT,+N%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.AsMut.html\" title=\"trait std::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"struct\" href=\"../simd/prelude/struct.Simd.html\" title=\"struct std::simd::prelude::Simd\">Simd</a>&lt;T, N&gt;<div class=\"where\">where\n    <a class=\"struct\" href=\"../simd/struct.LaneCount.html\" title=\"struct std::simd::LaneCount\">LaneCount</a>&lt;N&gt;: <a class=\"trait\" href=\"../simd/trait.SupportedLaneCount.html\" title=\"trait std::simd::SupportedLaneCount\">SupportedLaneCount</a>,\n    T: <a class=\"trait\" href=\"../simd/trait.SimdElement.html\" title=\"trait std::simd::SimdElement\">SimdElement</a>,</div></h3></section></div><script src=\"../../trait.impl/core/convert/trait.AsMut.js\" data-ignore-extern-crates=\"alloc,core\" async=\"\"></script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:53.018Z"
}