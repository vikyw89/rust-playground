{
	"title": "LocalKey in std::thread - Rust",
	"url": "https://doc.rust-lang.org/stable/std/thread/struct.LocalKey.html",
	"markdown": "# LocalKey in std::thread - Rust\n\n```\npub struct LocalKey<T: 'static> { /* private fields */ }\n```\n\nExpand description\n\nA thread local storage key which owns its contents.\n\nThis key uses the fastest possible implementation available to it for the target platform. It is instantiated with the [`thread_local!`](../macro.thread_local.html \"macro std::thread_local\") macro and the primary method is the [`with`](about:blank/struct.LocalKey.html#method.with \"method std::thread::LocalKey::with\") method, though there are helpers to make working with [`Cell`](../cell/struct.Cell.html \"struct std::cell::Cell\") types easier.\n\nThe [`with`](about:blank/struct.LocalKey.html#method.with \"method std::thread::LocalKey::with\") method yields a reference to the contained value which cannot outlive the current thread or escape the given closure.\n\n## [§](#initialization-and-destruction)Initialization and Destruction\n\nInitialization is dynamically performed on the first call to a setter (e.g. [`with`](about:blank/struct.LocalKey.html#method.with \"method std::thread::LocalKey::with\")) within a thread, and values that implement [`Drop`](../ops/trait.Drop.html \"trait std::ops::Drop\") get destructed when a thread exits. Some caveats apply, which are explained below.\n\nA `LocalKey`’s initializer cannot recursively depend on itself. Using a `LocalKey` in this way may cause panics, aborts or infinite recursion on the first call to `with`.\n\n## [§](#single-thread-synchronization)Single-thread Synchronization\n\nThough there is no potential race with other threads, it is still possible to obtain multiple references to the thread-local data in different places on the call stack. For this reason, only shared (`&T`) references may be obtained.\n\nTo allow obtaining an exclusive mutable reference (`&mut T`), typically a [`Cell`](../cell/struct.Cell.html \"struct std::cell::Cell\") or [`RefCell`](../cell/struct.RefCell.html \"struct std::cell::RefCell\") is used (see the [`std::cell`](../cell/index.html \"mod std::cell\") for more information on how exactly this works). To make this easier there are specialized implementations for [`LocalKey<Cell<T>>`](about:blank/struct.LocalKey.html#impl-LocalKey%3CCell%3CT%3E%3E) and [`LocalKey<RefCell<T>>`](about:blank/struct.LocalKey.html#impl-LocalKey%3CRefCell%3CT%3E%3E).\n\n## [§](#examples)Examples\n\n```\nuse std::cell::Cell;\nuse std::thread;\n\nthread_local!(static FOO: Cell<u32> = Cell::new(1));\n\nassert_eq!(FOO.get(), 1);\nFOO.set(2);\n\n// each thread starts out with the initial value of 1\nlet t = thread::spawn(move|| {\n    assert_eq!(FOO.get(), 1);\n    FOO.set(3);\n});\n\n// wait for the thread to complete and bail out on panic\nt.join().unwrap();\n\n// we retain our original value of 2 despite the child thread\nassert_eq!(FOO.get(), 2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++use+std::thread;%0A++++%0A++++thread_local!(static+FOO:+Cell%3Cu32%3E+=+Cell::new(1));%0A++++%0A++++assert_eq!(FOO.get(),+1);%0A++++FOO.set(2);%0A++++%0A++++//+each+thread+starts+out+with+the+initial+value+of+1%0A++++let+t+=+thread::spawn(move%7C%7C+%7B%0A++++++++assert_eq!(FOO.get(),+1);%0A++++++++FOO.set(3);%0A++++%7D);%0A++++%0A++++//+wait+for+the+thread+to+complete+and+bail+out+on+panic%0A++++t.join().unwrap();%0A++++%0A++++//+we+retain+our+original+value+of+2+despite+the+child+thread%0A++++assert_eq!(FOO.get(),+2);%0A%7D&edition=2021)\n\n## [§](#platform-specific-behavior)Platform-specific behavior\n\nNote that a “best effort” is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:\n\n1.  On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.\n2.  On all platforms it’s possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.\n3.  When the process exits on Windows systems, TLS destructors may only be run on the thread that causes the process to exit. This is because the other threads may be forcibly terminated.\n\n### [§](#synchronization-in-thread-local-destructors)Synchronization in thread-local destructors\n\nOn Windows, synchronization operations (such as [`JoinHandle::join`](about:blank/struct.JoinHandle.html#method.join \"method std::thread::JoinHandle::join\")) in thread local destructors are prone to deadlocks and so should be avoided. This is because the [loader lock](https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices) is held while a destructor is run. The lock is acquired whenever a thread starts or exits or when a DLL is loaded or unloaded. Therefore these events are blocked for as long as a thread local destructor is running.\n\n[source](about:blank/src/std/thread/local.rs.html#233-313)[§](#impl-LocalKey%3CT%3E)\n\n1.0.0 · [source](about:blank/src/std/thread/local.rs.html#256-264)\n\nAcquires a reference to the value in this TLS key.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics)Panics\n\nThis function will `panic!()` if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n1.26.0 · [source](about:blank/src/std/thread/local.rs.html#278-284)\n\nAcquires a reference to the value in this TLS key.\n\nThis will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an [`AccessError`](struct.AccessError.html \"struct std::thread::AccessError\").\n\n##### [§](#panics-1)Panics\n\nThis function will still `panic!()` if the key is uninitialized and the key’s initializer panics.\n\n[source](about:blank/src/std/thread/local.rs.html#315-440)[§](#impl-LocalKey%3CCell%3CT%3E%3E)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#343-352)\n\nSets or initializes the contained value.\n\nUnlike the other methods, this will _not_ run the lazy initializer of the thread local. Instead, it will be directly initialized with the given value if it wasn’t initialized yet.\n\n##### [§](#panics-2)Panics\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-1)Examples\n\n```\nuse std::cell::Cell;\n\nthread_local! {\n    static X: Cell<i32> = panic!(\"!\");\n}\n\n// Calling X.get() here would result in a panic.\n\nX.set(123); // But X.set() is fine, as it skips the initializer above.\n\nassert_eq!(X.get(), 123);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3Ci32%3E+=+panic!(%22!%22);%0A++++%7D%0A++++%0A++++//+Calling+X.get()+here+would+result+in+a+panic.%0A++++%0A++++X.set(123);+//+But+X.set()+is+fine,+as+it+skips+the+initializer+above.%0A++++%0A++++assert_eq!(X.get(),+123);%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#376-381)\n\nReturns a copy of the contained value.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics-3)Panics\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-2)Examples\n\n```\nuse std::cell::Cell;\n\nthread_local! {\n    static X: Cell<i32> = Cell::new(1);\n}\n\nassert_eq!(X.get(), 1);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3Ci32%3E+=+Cell::new(1);%0A++++%7D%0A++++%0A++++assert_eq!(X.get(),+1);%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#406-411)\n\nTakes the contained value, leaving `Default::default()` in its place.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics-4)Panics\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-3)Examples\n\n```\nuse std::cell::Cell;\n\nthread_local! {\n    static X: Cell<Option<i32>> = Cell::new(Some(1));\n}\n\nassert_eq!(X.take(), Some(1));\nassert_eq!(X.take(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3COption%3Ci32%3E%3E+=+Cell::new(Some(1));%0A++++%7D%0A++++%0A++++assert_eq!(X.take(),+Some(1));%0A++++assert_eq!(X.take(),+None);%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#437-439)\n\nReplaces the contained value, returning the old value.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics-5)Panics\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-4)Examples\n\n```\nuse std::cell::Cell;\n\nthread_local! {\n    static X: Cell<i32> = Cell::new(1);\n}\n\nassert_eq!(X.replace(2), 1);\nassert_eq!(X.replace(3), 2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3Ci32%3E+=+Cell::new(1);%0A++++%7D%0A++++%0A++++assert_eq!(X.replace(2),+1);%0A++++assert_eq!(X.replace(3),+2);%0A%7D&edition=2021)\n\n[source](about:blank/src/std/thread/local.rs.html#442-612)[§](#impl-LocalKey%3CRefCell%3CT%3E%3E)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#467-472)\n\nAcquires a reference to the contained value.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics-6)Panics\n\nPanics if the value is currently mutably borrowed.\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#example)Example\n\n```\nuse std::cell::RefCell;\n\nthread_local! {\n    static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n}\n\nX.with_borrow(|v| assert!(v.is_empty()));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++X.with_borrow(%7Cv%7C+assert!(v.is_empty()));%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#500-505)\n\nAcquires a mutable reference to the contained value.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics-7)Panics\n\nPanics if the value is currently borrowed.\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#example-1)Example\n\n```\nuse std::cell::RefCell;\n\nthread_local! {\n    static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n}\n\nX.with_borrow_mut(|v| v.push(1));\n\nX.with_borrow(|v| assert_eq!(*v, vec![1]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++X.with_borrow_mut(%7Cv%7C+v.push(1));%0A++++%0A++++X.with_borrow(%7Cv%7C+assert_eq!(*v,+vec!%5B1%5D));%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#536-545)\n\nSets or initializes the contained value.\n\nUnlike the other methods, this will _not_ run the lazy initializer of the thread local. Instead, it will be directly initialized with the given value if it wasn’t initialized yet.\n\n##### [§](#panics-8)Panics\n\nPanics if the value is currently borrowed.\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-5)Examples\n\n```\nuse std::cell::RefCell;\n\nthread_local! {\n    static X: RefCell<Vec<i32>> = panic!(\"!\");\n}\n\n// Calling X.with() here would result in a panic.\n\nX.set(vec![1, 2, 3]); // But X.set() is fine, as it skips the initializer above.\n\nX.with_borrow(|v| assert_eq!(*v, vec![1, 2, 3]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+panic!(%22!%22);%0A++++%7D%0A++++%0A++++//+Calling+X.with()+here+would+result+in+a+panic.%0A++++%0A++++X.set(vec!%5B1,+2,+3%5D);+//+But+X.set()+is+fine,+as+it+skips+the+initializer+above.%0A++++%0A++++X.with_borrow(%7Cv%7C+assert_eq!(*v,+vec!%5B1,+2,+3%5D));%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#577-582)\n\nTakes the contained value, leaving `Default::default()` in its place.\n\nThis will lazily initialize the value if this thread has not referenced this key yet.\n\n##### [§](#panics-9)Panics\n\nPanics if the value is currently borrowed.\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-6)Examples\n\n```\nuse std::cell::RefCell;\n\nthread_local! {\n    static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n}\n\nX.with_borrow_mut(|v| v.push(1));\n\nlet a = X.take();\n\nassert_eq!(a, vec![1]);\n\nX.with_borrow(|v| assert!(v.is_empty()));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++X.with_borrow_mut(%7Cv%7C+v.push(1));%0A++++%0A++++let+a+=+X.take();%0A++++%0A++++assert_eq!(a,+vec!%5B1%5D);%0A++++%0A++++X.with_borrow(%7Cv%7C+assert!(v.is_empty()));%0A%7D&edition=2021)\n\n1.73.0 · [source](about:blank/src/std/thread/local.rs.html#609-611)\n\nReplaces the contained value, returning the old value.\n\n##### [§](#panics-10)Panics\n\nPanics if the value is currently borrowed.\n\nPanics if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.\n\n##### [§](#examples-7)Examples\n\n```\nuse std::cell::RefCell;\n\nthread_local! {\n    static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n}\n\nlet prev = X.replace(vec![1, 2, 3]);\nassert!(prev.is_empty());\n\nX.with_borrow(|v| assert_eq!(*v, vec![1, 2, 3]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++let+prev+=+X.replace(vec!%5B1,+2,+3%5D);%0A++++assert!(prev.is_empty());%0A++++%0A++++X.with_borrow(%7Cv%7C+assert_eq!(*v,+vec!%5B1,+2,+3%5D));%0A%7D&edition=2021)\n\n[§](#impl-Freeze-for-LocalKey%3CT%3E)\n\n[§](#impl-RefUnwindSafe-for-LocalKey%3CT%3E)\n\n[§](#impl-Send-for-LocalKey%3CT%3E)\n\n[§](#impl-Sync-for-LocalKey%3CT%3E)\n\n[§](#impl-Unpin-for-LocalKey%3CT%3E)\n\n[§](#impl-UnwindSafe-for-LocalKey%3CT%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140)[§](#impl-Any-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208)[§](#impl-Borrow%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216)[§](#impl-BorrowMut%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765)[§](#impl-From%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768)[§](#method.from)\n\nReturns the argument unchanged.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750)[§](#impl-Into%3CU%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758)[§](#method.into)\n\nCalls `U::from(self)`.\n\nThat is, this conversion is whatever the implementation of `[From](../convert/trait.From.html \"trait std::convert::From\")<T> for U` chooses to do.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807)[§](#impl-TryFrom%3CU%3E-for-T)\n\n[§](#associatedtype.Error-1)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812)[§](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792)[§](#impl-TryInto%3CU%3E-for-T)\n\n[§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797)[§](#method.try_into)\n\nPerforms the conversion.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A thread local storage key which owns its contents.\"><title>LocalKey in std::thread - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">LocalKey</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">LocalKey</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.get\">get</a></li><li><a href=\"#method.replace\">replace</a></li><li><a href=\"#method.replace-1\">replace</a></li><li><a href=\"#method.set\">set</a></li><li><a href=\"#method.set-1\">set</a></li><li><a href=\"#method.take\">take</a></li><li><a href=\"#method.take-1\">take</a></li><li><a href=\"#method.try_with\">try_with</a></li><li><a href=\"#method.with\">with</a></li><li><a href=\"#method.with_borrow\">with_borrow</a></li><li><a href=\"#method.with_borrow_mut\">with_borrow_mut</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Debug-for-LocalKey%3CT%3E\">Debug</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-LocalKey%3CT%3E\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-LocalKey%3CT%3E\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-LocalKey%3CT%3E\">Send</a></li><li><a href=\"#impl-Sync-for-LocalKey%3CT%3E\">Sync</a></li><li><a href=\"#impl-Unpin-for-LocalKey%3CT%3E\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-LocalKey%3CT%3E\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::thread</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AccessError.html\">AccessError</a></li><li><a href=\"struct.Builder.html\">Builder</a></li><li><a href=\"struct.JoinHandle.html\">JoinHandle</a></li><li><a href=\"struct.LocalKey.html\">LocalKey</a></li><li><a href=\"struct.Scope.html\">Scope</a></li><li><a href=\"struct.ScopedJoinHandle.html\">ScopedJoinHandle</a></li><li><a href=\"struct.Thread.html\">Thread</a></li><li><a href=\"struct.ThreadId.html\">ThreadId</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.available_parallelism.html\">available_parallelism</a></li><li><a href=\"fn.current.html\">current</a></li><li><a href=\"fn.panicking.html\">panicking</a></li><li><a href=\"fn.park.html\">park</a></li><li><a href=\"fn.park_timeout.html\">park_timeout</a></li><li><a href=\"fn.park_timeout_ms.html\">park_timeout_ms</a></li><li><a href=\"fn.scope.html\">scope</a></li><li><a href=\"fn.sleep.html\">sleep</a></li><li><a href=\"fn.sleep_ms.html\">sleep_ms</a></li><li><a href=\"fn.sleep_until.html\">sleep_until</a></li><li><a href=\"fn.spawn.html\">spawn</a></li><li><a href=\"fn.yield_now.html\">yield_now</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.Result.html\">Result</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">thread</a>::<wbr><a class=\"struct\" href=\"#\">LocalKey</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#111-127\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct LocalKey&lt;T: 'static&gt; { <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A thread local storage key which owns its contents.</p>\n<p>This key uses the fastest possible implementation available to it for the\ntarget platform. It is instantiated with the <a href=\"../macro.thread_local.html\" title=\"macro std::thread_local\"><code>thread_local!</code></a> macro and the\nprimary method is the <a href=\"struct.LocalKey.html#method.with\" title=\"method std::thread::LocalKey::with\"><code>with</code></a> method, though there are helpers to make\nworking with <a href=\"../cell/struct.Cell.html\" title=\"struct std::cell::Cell\"><code>Cell</code></a> types easier.</p>\n<p>The <a href=\"struct.LocalKey.html#method.with\" title=\"method std::thread::LocalKey::with\"><code>with</code></a> method yields a reference to the contained value which cannot\noutlive the current thread or escape the given closure.</p>\n<h2 id=\"initialization-and-destruction\"><a class=\"doc-anchor\" href=\"#initialization-and-destruction\">§</a>Initialization and Destruction</h2>\n<p>Initialization is dynamically performed on the first call to a setter (e.g.\n<a href=\"struct.LocalKey.html#method.with\" title=\"method std::thread::LocalKey::with\"><code>with</code></a>) within a thread, and values that implement <a href=\"../ops/trait.Drop.html\" title=\"trait std::ops::Drop\"><code>Drop</code></a> get\ndestructed when a thread exits. Some caveats apply, which are explained below.</p>\n<p>A <code>LocalKey</code>’s initializer cannot recursively depend on itself. Using a\n<code>LocalKey</code> in this way may cause panics, aborts or infinite recursion on\nthe first call to <code>with</code>.</p>\n<h2 id=\"single-thread-synchronization\"><a class=\"doc-anchor\" href=\"#single-thread-synchronization\">§</a>Single-thread Synchronization</h2>\n<p>Though there is no potential race with other threads, it is still possible to\nobtain multiple references to the thread-local data in different places on\nthe call stack. For this reason, only shared (<code>&amp;T</code>) references may be obtained.</p>\n<p>To allow obtaining an exclusive mutable reference (<code>&amp;mut T</code>), typically a\n<a href=\"../cell/struct.Cell.html\" title=\"struct std::cell::Cell\"><code>Cell</code></a> or <a href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell</code></a> is used (see the <a href=\"../cell/index.html\" title=\"mod std::cell\"><code>std::cell</code></a> for more information\non how exactly this works). To make this easier there are specialized\nimplementations for <a href=\"struct.LocalKey.html#impl-LocalKey%3CCell%3CT%3E%3E\"><code>LocalKey&lt;Cell&lt;T&gt;&gt;</code></a> and <a href=\"struct.LocalKey.html#impl-LocalKey%3CRefCell%3CT%3E%3E\"><code>LocalKey&lt;RefCell&lt;T&gt;&gt;</code></a>.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"macro\">thread_local!</span>(<span class=\"kw\">static </span>FOO: Cell&lt;u32&gt; = Cell::new(<span class=\"number\">1</span>));\n\n<span class=\"macro\">assert_eq!</span>(FOO.get(), <span class=\"number\">1</span>);\nFOO.set(<span class=\"number\">2</span>);\n\n<span class=\"comment\">// each thread starts out with the initial value of 1\n</span><span class=\"kw\">let </span>t = thread::spawn(<span class=\"kw\">move</span>|| {\n    <span class=\"macro\">assert_eq!</span>(FOO.get(), <span class=\"number\">1</span>);\n    FOO.set(<span class=\"number\">3</span>);\n});\n\n<span class=\"comment\">// wait for the thread to complete and bail out on panic\n</span>t.join().unwrap();\n\n<span class=\"comment\">// we retain our original value of 2 despite the child thread\n</span><span class=\"macro\">assert_eq!</span>(FOO.get(), <span class=\"number\">2</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++use+std::thread;%0A++++%0A++++thread_local!(static+FOO:+Cell%3Cu32%3E+=+Cell::new(1));%0A++++%0A++++assert_eq!(FOO.get(),+1);%0A++++FOO.set(2);%0A++++%0A++++//+each+thread+starts+out+with+the+initial+value+of+1%0A++++let+t+=+thread::spawn(move%7C%7C+%7B%0A++++++++assert_eq!(FOO.get(),+1);%0A++++++++FOO.set(3);%0A++++%7D);%0A++++%0A++++//+wait+for+the+thread+to+complete+and+bail+out+on+panic%0A++++t.join().unwrap();%0A++++%0A++++//+we+retain+our+original+value+of+2+despite+the+child+thread%0A++++assert_eq!(FOO.get(),+2);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"platform-specific-behavior\"><a class=\"doc-anchor\" href=\"#platform-specific-behavior\">§</a>Platform-specific behavior</h2>\n<p>Note that a “best effort” is made to ensure that destructors for types\nstored in thread local storage are run, but not all platforms can guarantee\nthat destructors will be run for all types in thread local storage. For\nexample, there are a number of known caveats where destructors are not run:</p>\n<ol>\n<li>On Unix systems when pthread-based TLS is being used, destructors will\nnot be run for TLS values on the main thread when it exits. Note that the\napplication will exit immediately after the main thread exits as well.</li>\n<li>On all platforms it’s possible for TLS to re-initialize other TLS slots\nduring destruction. Some platforms ensure that this cannot happen\ninfinitely by preventing re-initialization of any slot that has been\ndestroyed, but not all platforms have this guard. Those platforms that do\nnot guard typically have a synthetic limit after which point no more\ndestructors are run.</li>\n<li>When the process exits on Windows systems, TLS destructors may only be\nrun on the thread that causes the process to exit. This is because the\nother threads may be forcibly terminated.</li>\n</ol>\n<h3 id=\"synchronization-in-thread-local-destructors\"><a class=\"doc-anchor\" href=\"#synchronization-in-thread-local-destructors\">§</a>Synchronization in thread-local destructors</h3>\n<p>On Windows, synchronization operations (such as <a href=\"struct.JoinHandle.html#method.join\" title=\"method std::thread::JoinHandle::join\"><code>JoinHandle::join</code></a>) in\nthread local destructors are prone to deadlocks and so should be avoided.\nThis is because the <a href=\"https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\">loader lock</a> is held while a destructor is run. The\nlock is acquired whenever a thread starts or exits or when a DLL is loaded\nor unloaded. Therefore these events are blocked for as long as a thread\nlocal destructor is running.</p>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-LocalKey%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/thread/local.rs.html#233-313\">source</a><a href=\"#impl-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: 'static&gt; <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#256-264\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.with\" class=\"fn\">with</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class=\"docblock\"><p>Acquires a reference to the value in this TLS key.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function will <code>panic!()</code> if the key currently has its\ndestructor running, and it <strong>may</strong> panic if the destructor has\npreviously been run for this thread.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#278-284\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_with\" class=\"fn\">try_with</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;R, <a class=\"struct\" href=\"struct.AccessError.html\" title=\"struct std::thread::AccessError\">AccessError</a>&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class=\"docblock\"><p>Acquires a reference to the value in this TLS key.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet. If the key has been destroyed (which may happen if this is called\nin a destructor), this function will return an <a href=\"struct.AccessError.html\" title=\"struct std::thread::AccessError\"><code>AccessError</code></a>.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>This function will still <code>panic!()</code> if the key is uninitialized and the\nkey’s initializer panics.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-LocalKey%3CCell%3CT%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/thread/local.rs.html#315-440\">source</a><a href=\"#impl-LocalKey%3CCell%3CT%3E%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: 'static&gt; <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;<a class=\"struct\" href=\"../cell/struct.Cell.html\" title=\"struct std::cell::Cell\">Cell</a>&lt;T&gt;&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#343-352\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.set\" class=\"fn\">set</a>(&amp;'static self, value: T)</h4></section></summary><div class=\"docblock\"><p>Sets or initializes the contained value.</p>\n<p>Unlike the other methods, this will <em>not</em> run the lazy initializer of\nthe thread local. Instead, it will be directly initialized with the\ngiven value if it wasn’t initialized yet.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">§</a>Panics</h5>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: Cell&lt;i32&gt; = <span class=\"macro\">panic!</span>(<span class=\"string\">\"!\"</span>);\n}\n\n<span class=\"comment\">// Calling X.get() here would result in a panic.\n\n</span>X.set(<span class=\"number\">123</span>); <span class=\"comment\">// But X.set() is fine, as it skips the initializer above.\n\n</span><span class=\"macro\">assert_eq!</span>(X.get(), <span class=\"number\">123</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3Ci32%3E+=+panic!(%22!%22);%0A++++%7D%0A++++%0A++++//+Calling+X.get()+here+would+result+in+a+panic.%0A++++%0A++++X.set(123);+//+But+X.set()+is+fine,+as+it+skips+the+initializer+above.%0A++++%0A++++assert_eq!(X.get(),+123);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#376-381\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get\" class=\"fn\">get</a>(&amp;'static self) -&gt; T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns a copy of the contained value.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics-3\"><a class=\"doc-anchor\" href=\"#panics-3\">§</a>Panics</h5>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: Cell&lt;i32&gt; = Cell::new(<span class=\"number\">1</span>);\n}\n\n<span class=\"macro\">assert_eq!</span>(X.get(), <span class=\"number\">1</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3Ci32%3E+=+Cell::new(1);%0A++++%7D%0A++++%0A++++assert_eq!(X.get(),+1);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.take\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#406-411\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.take\" class=\"fn\">take</a>(&amp;'static self) -&gt; T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a>,</div></h4></section></summary><div class=\"docblock\"><p>Takes the contained value, leaving <code>Default::default()</code> in its place.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics-4\"><a class=\"doc-anchor\" href=\"#panics-4\">§</a>Panics</h5>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: Cell&lt;<span class=\"prelude-ty\">Option</span>&lt;i32&gt;&gt; = Cell::new(<span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n}\n\n<span class=\"macro\">assert_eq!</span>(X.take(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(X.take(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3COption%3Ci32%3E%3E+=+Cell::new(Some(1));%0A++++%7D%0A++++%0A++++assert_eq!(X.take(),+Some(1));%0A++++assert_eq!(X.take(),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.replace\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#437-439\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.replace\" class=\"fn\">replace</a>(&amp;'static self, value: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Replaces the contained value, returning the old value.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics-5\"><a class=\"doc-anchor\" href=\"#panics-5\">§</a>Panics</h5>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: Cell&lt;i32&gt; = Cell::new(<span class=\"number\">1</span>);\n}\n\n<span class=\"macro\">assert_eq!</span>(X.replace(<span class=\"number\">2</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(X.replace(<span class=\"number\">3</span>), <span class=\"number\">2</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+Cell%3Ci32%3E+=+Cell::new(1);%0A++++%7D%0A++++%0A++++assert_eq!(X.replace(2),+1);%0A++++assert_eq!(X.replace(3),+2);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-LocalKey%3CRefCell%3CT%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/thread/local.rs.html#442-612\">source</a><a href=\"#impl-LocalKey%3CRefCell%3CT%3E%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: 'static&gt; <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;<a class=\"struct\" href=\"../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\">RefCell</a>&lt;T&gt;&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.with_borrow\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#467-472\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.with_borrow\" class=\"fn\">with_borrow</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class=\"docblock\"><p>Acquires a reference to the contained value.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics-6\"><a class=\"doc-anchor\" href=\"#panics-6\">§</a>Panics</h5>\n<p>Panics if the value is currently mutably borrowed.</p>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::RefCell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());\n}\n\nX.with_borrow(|v| <span class=\"macro\">assert!</span>(v.is_empty()));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++X.with_borrow(%7Cv%7C+assert!(v.is_empty()));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.with_borrow_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#500-505\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.with_borrow_mut\" class=\"fn\">with_borrow_mut</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R<div class=\"where\">where\n    F: <a class=\"trait\" href=\"../ops/trait.FnOnce.html\" title=\"trait std::ops::FnOnce\">FnOnce</a>(<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>) -&gt; R,</div></h4></section></summary><div class=\"docblock\"><p>Acquires a mutable reference to the contained value.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics-7\"><a class=\"doc-anchor\" href=\"#panics-7\">§</a>Panics</h5>\n<p>Panics if the value is currently borrowed.</p>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::RefCell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());\n}\n\nX.with_borrow_mut(|v| v.push(<span class=\"number\">1</span>));\n\nX.with_borrow(|v| <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>v, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++X.with_borrow_mut(%7Cv%7C+v.push(1));%0A++++%0A++++X.with_borrow(%7Cv%7C+assert_eq!(*v,+vec!%5B1%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#536-545\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.set-1\" class=\"fn\">set</a>(&amp;'static self, value: T)</h4></section></summary><div class=\"docblock\"><p>Sets or initializes the contained value.</p>\n<p>Unlike the other methods, this will <em>not</em> run the lazy initializer of\nthe thread local. Instead, it will be directly initialized with the\ngiven value if it wasn’t initialized yet.</p>\n<h5 id=\"panics-8\"><a class=\"doc-anchor\" href=\"#panics-8\">§</a>Panics</h5>\n<p>Panics if the value is currently borrowed.</p>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::RefCell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = <span class=\"macro\">panic!</span>(<span class=\"string\">\"!\"</span>);\n}\n\n<span class=\"comment\">// Calling X.with() here would result in a panic.\n\n</span>X.set(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]); <span class=\"comment\">// But X.set() is fine, as it skips the initializer above.\n\n</span>X.with_borrow(|v| <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>v, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+panic!(%22!%22);%0A++++%7D%0A++++%0A++++//+Calling+X.with()+here+would+result+in+a+panic.%0A++++%0A++++X.set(vec!%5B1,+2,+3%5D);+//+But+X.set()+is+fine,+as+it+skips+the+initializer+above.%0A++++%0A++++X.with_borrow(%7Cv%7C+assert_eq!(*v,+vec!%5B1,+2,+3%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.take-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#577-582\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.take-1\" class=\"fn\">take</a>(&amp;'static self) -&gt; T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a>,</div></h4></section></summary><div class=\"docblock\"><p>Takes the contained value, leaving <code>Default::default()</code> in its place.</p>\n<p>This will lazily initialize the value if this thread has not referenced\nthis key yet.</p>\n<h5 id=\"panics-9\"><a class=\"doc-anchor\" href=\"#panics-9\">§</a>Panics</h5>\n<p>Panics if the value is currently borrowed.</p>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::RefCell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());\n}\n\nX.with_borrow_mut(|v| v.push(<span class=\"number\">1</span>));\n\n<span class=\"kw\">let </span>a = X.take();\n\n<span class=\"macro\">assert_eq!</span>(a, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>]);\n\nX.with_borrow(|v| <span class=\"macro\">assert!</span>(v.is_empty()));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++X.with_borrow_mut(%7Cv%7C+v.push(1));%0A++++%0A++++let+a+=+X.take();%0A++++%0A++++assert_eq!(a,+vec!%5B1%5D);%0A++++%0A++++X.with_borrow(%7Cv%7C+assert!(v.is_empty()));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.replace-1\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.73.0\">1.73.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#609-611\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.replace-1\" class=\"fn\">replace</a>(&amp;'static self, value: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Replaces the contained value, returning the old value.</p>\n<h5 id=\"panics-10\"><a class=\"doc-anchor\" href=\"#panics-10\">§</a>Panics</h5>\n<p>Panics if the value is currently borrowed.</p>\n<p>Panics if the key currently has its destructor running,\nand it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::RefCell;\n\n<span class=\"macro\">thread_local!</span> {\n    <span class=\"kw\">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());\n}\n\n<span class=\"kw\">let </span>prev = X.replace(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"macro\">assert!</span>(prev.is_empty());\n\nX.with_borrow(|v| <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>v, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::RefCell;%0A++++%0A++++thread_local!+%7B%0A++++++++static+X:+RefCell%3CVec%3Ci32%3E%3E+=+RefCell::new(Vec::new());%0A++++%7D%0A++++%0A++++let+prev+=+X.replace(vec!%5B1,+2,+3%5D);%0A++++assert!(prev.is_empty());%0A++++%0A++++X.with_borrow(%7Cv%7C+assert_eq!(*v,+vec!%5B1,+2,+3%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-LocalKey%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.16.0\">1.16.0</span> · <a class=\"src\" href=\"../../src/std/thread/local.rs.html#130-134\">source</a></span><a href=\"#impl-Debug-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: 'static&gt; <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/thread/local.rs.html#131-133\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"../fmt/type.Result.html\" title=\"type std::fmt::Result\">Result</a></h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-LocalKey%3CT%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section><section id=\"impl-RefUnwindSafe-for-LocalKey%3CT%3E\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section><section id=\"impl-Send-for-LocalKey%3CT%3E\" class=\"impl\"><a href=\"#impl-Send-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section><section id=\"impl-Sync-for-LocalKey%3CT%3E\" class=\"impl\"><a href=\"#impl-Sync-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section><section id=\"impl-Unpin-for-LocalKey%3CT%3E\" class=\"impl\"><a href=\"#impl-Unpin-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section><section id=\"impl-UnwindSafe-for-LocalKey%3CT%3E\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-LocalKey%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.LocalKey.html\" title=\"struct std::thread::LocalKey\">LocalKey</a>&lt;T&gt;</h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:20:26.559Z"
}