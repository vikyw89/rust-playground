{
	"title": "std::boxed - Rust",
	"url": "https://doc.rust-lang.org/stable/std/boxed/index.html",
	"markdown": "# std::boxed - Rust\n\n## Module [std](../index.html)::[boxed](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/lib.rs.html#236) ·\n\nExpand description\n\nThe `Box<T>` type for heap allocation.\n\n[`Box<T>`](struct.Box.html \"struct std::boxed::Box\"), casually referred to as a ‘box’, provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope. Boxes also ensure that they never allocate more than `isize::MAX` bytes.\n\n## [§](#examples)Examples\n\nMove a value from the stack to the heap by creating a [`Box`](struct.Box.html \"struct std::boxed::Box\"):\n\n```\nlet val: u8 = 5;\nlet boxed: Box<u8> = Box::new(val);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+val:+u8+=+5;%0A++++let+boxed:+Box%3Cu8%3E+=+Box::new(val);%0A%7D&edition=2021)\n\nMove a value from a [`Box`](struct.Box.html \"struct std::boxed::Box\") back to the stack by [dereferencing](../ops/trait.Deref.html \"trait std::ops::Deref\"):\n\n```\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+boxed:+Box%3Cu8%3E+=+Box::new(5);%0A++++let+val:+u8+=+*boxed;%0A%7D&edition=2021)\n\nCreating a recursive data structure:\n\n```\n#[allow(dead_code)]\n#[derive(Debug)]\nenum List<T> {\n    Cons(T, Box<List<T>>),\n    Nil,\n}\n\nlet list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\nprintln!(\"{list:?}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Ballow(dead_code)%5D%0A++++%23%5Bderive(Debug)%5D%0A++++enum+List%3CT%3E+%7B%0A++++++++Cons(T,+Box%3CList%3CT%3E%3E),%0A++++++++Nil,%0A++++%7D%0A++++%0A++++let+list:+List%3Ci32%3E+=+List::Cons(1,+Box::new(List::Cons(2,+Box::new(List::Nil))));%0A++++println!(%22%7Blist:?%7D%22);%0A%7D&edition=2021)\n\nThis will print `Cons(1, Cons(2, Nil))`.\n\nRecursive structures must be boxed, because if the definition of `Cons` looked like this:\n\nIt wouldn’t work. This is because the size of a `List` depends on how many elements are in the list, and so we don’t know how much memory to allocate for a `Cons`. By introducing a [`Box<T>`](struct.Box.html \"struct std::boxed::Box\"), which has a defined size, we know how big `Cons` needs to be.\n\n## [§](#memory-layout)Memory layout\n\nFor non-zero-sized values, a [`Box`](struct.Box.html \"struct std::boxed::Box\") will use the [`Global`](../alloc/struct.Global.html \"struct std::alloc::Global\") allocator for its allocation. It is valid to convert both ways between a [`Box`](struct.Box.html \"struct std::boxed::Box\") and a raw pointer allocated with the [`Global`](../alloc/struct.Global.html \"struct std::alloc::Global\") allocator, given that the [`Layout`](../alloc/struct.Layout.html \"struct std::alloc::Layout\") used with the allocator is correct for the type. More precisely, a `value: *mut T` that has been allocated with the [`Global`](../alloc/struct.Global.html \"struct std::alloc::Global\") allocator with `Layout::for_value(&*value)` may be converted into a box using [`Box::<T>::from_raw(value)`](about:blank/struct.Box.html#method.from_raw \"associated function std::boxed::Box::from_raw\"). Conversely, the memory backing a `value: *mut T` obtained from [`Box::<T>::into_raw`](about:blank/struct.Box.html#method.into_raw \"associated function std::boxed::Box::into_raw\") may be deallocated using the [`Global`](../alloc/struct.Global.html \"struct std::alloc::Global\") allocator with [`Layout::for_value(&*value)`](about:blank/alloc/struct.Layout.html#method.for_value \"associated function std::alloc::Layout::for_value\").\n\nFor zero-sized values, the `Box` pointer still has to be [valid](about:blank/ptr/index.html#safety \"mod std::ptr\") for reads and writes and sufficiently aligned. In particular, casting any aligned non-zero integer literal to a raw pointer produces a valid pointer, but a pointer pointing into previously allocated memory that since got freed is not valid. The recommended way to build a Box to a ZST if `Box::new` cannot be used is to use [`ptr::NonNull::dangling`](about:blank/ptr/struct.NonNull.html#method.dangling \"associated function std::ptr::NonNull::dangling\").\n\nSo long as `T: Sized`, a `Box<T>` is guaranteed to be represented as a single pointer and is also ABI-compatible with C pointers (i.e. the C type `T*`). This means that if you have extern “C” Rust functions that will be called from C, you can define those Rust functions using `Box<T>` types, and use `T*` as corresponding type on the C side. As an example, consider this C header which declares functions that create and destroy some kind of `Foo` value:\n\n```c\n/* C header */\n\n/* Returns ownership to the caller */\nstruct Foo* foo_new(void);\n\n/* Takes ownership from the caller; no-op when invoked with null */\nvoid foo_delete(struct Foo*);\n\n```\n\nThese two functions might be implemented in Rust as follows. Here, the `struct Foo*` type from C is translated to `Box<Foo>`, which captures the ownership constraints. Note also that the nullable argument to `foo_delete` is represented in Rust as `Option<Box<Foo>>`, since `Box<Foo>` cannot be null.\n\n```\n#[repr(C)]\npub struct Foo;\n\n#[no_mangle]\npub extern \"C\" fn foo_new() -> Box<Foo> {\n    Box::new(Foo)\n}\n\n#[no_mangle]\npub extern \"C\" fn foo_delete(_: Option<Box<Foo>>) {}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Brepr(C)%5D%0A++++pub+struct+Foo;%0A++++%0A++++%23%5Bno_mangle%5D%0A++++pub+extern+%22C%22+fn+foo_new()+-%3E+Box%3CFoo%3E+%7B%0A++++++++Box::new(Foo)%0A++++%7D%0A++++%0A++++%23%5Bno_mangle%5D%0A++++pub+extern+%22C%22+fn+foo_delete(_:+Option%3CBox%3CFoo%3E%3E)+%7B%7D%0A%7D&edition=2021)\n\nEven though `Box<T>` has the same representation and C ABI as a C pointer, this does not mean that you can convert an arbitrary `T*` into a `Box<T>` and expect things to work. `Box<T>` values will always be fully aligned, non-null pointers. Moreover, the destructor for `Box<T>` will attempt to free the value with the global allocator. In general, the best practice is to only use `Box<T>` for pointers that originated from the global allocator.\n\n**Important.** At least at present, you should avoid using `Box<T>` types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like `Box<T>` where the C definition is just using `T*` can lead to undefined behavior, as described in [rust-lang/unsafe-code-guidelines#198](https://github.com/rust-lang/unsafe-code-guidelines/issues/198).\n\n## [§](#considerations-for-unsafe-code)Considerations for unsafe code\n\n**Warning: This section is not normative and is subject to change, possibly being relaxed in the future! It is a simplified summary of the rules currently implemented in the compiler.**\n\nThe aliasing rules for `Box<T>` are the same as for `&mut T`. `Box<T>` asserts uniqueness over its content. Using raw pointers derived from a box after that box has been mutated through, moved or borrowed as `&mut T` is not allowed. For more guidance on working with box from unsafe code, see [rust-lang/unsafe-code-guidelines#326](https://github.com/rust-lang/unsafe-code-guidelines/issues/326).\n\n## [§](#editions)Editions\n\nA special case exists for the implementation of `IntoIterator` for arrays on the Rust 2021 edition, as documented [here](../primitive.array.html \"primitive array\"). Unfortunately, it was later found that a similar workaround should be added for boxed slices, and this was applied in the 2024 edition.\n\nSpecifically, `IntoIterator` is implemented for `Box<[T]>` on all editions, but specific calls to `into_iter()` for boxed slices will defer to the slice implementation on editions before 2024:\n\n[ⓘ](# \"This example runs with edition 2021\")\n\n```\n// Rust 2015, 2018, and 2021:\n\nlet boxed_slice: Box<[i32]> = vec![0; 3].into_boxed_slice();\n\n// This creates a slice iterator, producing references to each value.\nfor item in boxed_slice.into_iter().enumerate() {\n    let (i, x): (usize, &i32) = item;\n    println!(\"boxed_slice[{i}] = {x}\");\n}\n\n// The `boxed_slice_into_iter` lint suggests this change for future compatibility:\nfor item in boxed_slice.iter().enumerate() {\n    let (i, x): (usize, &i32) = item;\n    println!(\"boxed_slice[{i}] = {x}\");\n}\n\n// You can explicitly iterate a boxed slice by value using `IntoIterator::into_iter`\nfor item in IntoIterator::into_iter(boxed_slice).enumerate() {\n    let (i, x): (usize, i32) = item;\n    println!(\"boxed_slice[{i}] = {x}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Rust+2015,+2018,+and+2021:%0A%0A%23!%5Ballow(boxed_slice_into_iter)%5D+//+override+our+%60deny(warnings)%60%0Afn+main()+%7B%0A++++let+boxed_slice:+Box%3C%5Bi32%5D%3E+=+vec!%5B0;+3%5D.into_boxed_slice();%0A++++%0A++++//+This+creates+a+slice+iterator,+producing+references+to+each+value.%0A++++for+item+in+boxed_slice.into_iter().enumerate()+%7B%0A++++++++let+(i,+x):+(usize,+%26i32)+=+item;%0A++++++++println!(%22boxed_slice%5B%7Bi%7D%5D+=+%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+The+%60boxed_slice_into_iter%60+lint+suggests+this+change+for+future+compatibility:%0A++++for+item+in+boxed_slice.iter().enumerate()+%7B%0A++++++++let+(i,+x):+(usize,+%26i32)+=+item;%0A++++++++println!(%22boxed_slice%5B%7Bi%7D%5D+=+%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+You+can+explicitly+iterate+a+boxed+slice+by+value+using+%60IntoIterator::into_iter%60%0A++++for+item+in+IntoIterator::into_iter(boxed_slice).enumerate()+%7B%0A++++++++let+(i,+x):+(usize,+i32)+=+item;%0A++++++++println!(%22boxed_slice%5B%7Bi%7D%5D+=+%7Bx%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\nSimilar to the array implementation, this may be modified in the future to remove this override, and it’s best to avoid relying on this edition-dependent behavior if you wish to preserve compatibility with future versions of the compiler.\n\n-   A pointer type that uniquely owns a heap allocation of type `T`.\n    \n-   ThinBox.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"The `Box<T>` type for heap allocation.\"><title>std::boxed - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module boxed</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module boxed</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">boxed</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/lib.rs.html#236\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>The <code>Box&lt;T&gt;</code> type for heap allocation.</p>\n<p><a href=\"struct.Box.html\" title=\"struct std::boxed::Box\"><code>Box&lt;T&gt;</code></a>, casually referred to as a ‘box’, provides the simplest form of\nheap allocation in Rust. Boxes provide ownership for this allocation, and\ndrop their contents when they go out of scope. Boxes also ensure that they\nnever allocate more than <code>isize::MAX</code> bytes.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>Move a value from the stack to the heap by creating a <a href=\"struct.Box.html\" title=\"struct std::boxed::Box\"><code>Box</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>val: u8 = <span class=\"number\">5</span>;\n<span class=\"kw\">let </span>boxed: Box&lt;u8&gt; = Box::new(val);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+val:+u8+=+5;%0A++++let+boxed:+Box%3Cu8%3E+=+Box::new(val);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Move a value from a <a href=\"struct.Box.html\" title=\"struct std::boxed::Box\"><code>Box</code></a> back to the stack by <a href=\"../ops/trait.Deref.html\" title=\"trait std::ops::Deref\">dereferencing</a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>boxed: Box&lt;u8&gt; = Box::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>val: u8 = <span class=\"kw-2\">*</span>boxed;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+boxed:+Box%3Cu8%3E+=+Box::new(5);%0A++++let+val:+u8+=+*boxed;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Creating a recursive data structure:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[allow(dead_code)]\n#[derive(Debug)]\n</span><span class=\"kw\">enum </span>List&lt;T&gt; {\n    Cons(T, Box&lt;List&lt;T&gt;&gt;),\n    Nil,\n}\n\n<span class=\"kw\">let </span>list: List&lt;i32&gt; = List::Cons(<span class=\"number\">1</span>, Box::new(List::Cons(<span class=\"number\">2</span>, Box::new(List::Nil))));\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{list:?}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Ballow(dead_code)%5D%0A++++%23%5Bderive(Debug)%5D%0A++++enum+List%3CT%3E+%7B%0A++++++++Cons(T,+Box%3CList%3CT%3E%3E),%0A++++++++Nil,%0A++++%7D%0A++++%0A++++let+list:+List%3Ci32%3E+=+List::Cons(1,+Box::new(List::Cons(2,+Box::new(List::Nil))));%0A++++println!(%22%7Blist:?%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This will print <code>Cons(1, Cons(2, Nil))</code>.</p>\n<p>Recursive structures must be boxed, because if the definition of <code>Cons</code>\nlooked like this:</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code>Cons(T, List&lt;T&gt;),</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++enum+List%3CT%3E+%7B%0A++++Cons(T,+List%3CT%3E),%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It wouldn’t work. This is because the size of a <code>List</code> depends on how many\nelements are in the list, and so we don’t know how much memory to allocate\nfor a <code>Cons</code>. By introducing a <a href=\"struct.Box.html\" title=\"struct std::boxed::Box\"><code>Box&lt;T&gt;</code></a>, which has a defined size, we know how\nbig <code>Cons</code> needs to be.</p>\n<h2 id=\"memory-layout\"><a class=\"doc-anchor\" href=\"#memory-layout\">§</a>Memory layout</h2>\n<p>For non-zero-sized values, a <a href=\"struct.Box.html\" title=\"struct std::boxed::Box\"><code>Box</code></a> will use the <a href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\"><code>Global</code></a> allocator for\nits allocation. It is valid to convert both ways between a <a href=\"struct.Box.html\" title=\"struct std::boxed::Box\"><code>Box</code></a> and a\nraw pointer allocated with the <a href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\"><code>Global</code></a> allocator, given that the\n<a href=\"../alloc/struct.Layout.html\" title=\"struct std::alloc::Layout\"><code>Layout</code></a> used with the allocator is correct for the type. More precisely,\na <code>value: *mut T</code> that has been allocated with the <a href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\"><code>Global</code></a> allocator\nwith <code>Layout::for_value(&amp;*value)</code> may be converted into a box using\n<a href=\"struct.Box.html#method.from_raw\" title=\"associated function std::boxed::Box::from_raw\"><code>Box::&lt;T&gt;::from_raw(value)</code></a>. Conversely, the memory backing a <code>value: *mut T</code> obtained from <a href=\"struct.Box.html#method.into_raw\" title=\"associated function std::boxed::Box::into_raw\"><code>Box::&lt;T&gt;::into_raw</code></a> may be deallocated using the\n<a href=\"../alloc/struct.Global.html\" title=\"struct std::alloc::Global\"><code>Global</code></a> allocator with <a href=\"../alloc/struct.Layout.html#method.for_value\" title=\"associated function std::alloc::Layout::for_value\"><code>Layout::for_value(&amp;*value)</code></a>.</p>\n<p>For zero-sized values, the <code>Box</code> pointer still has to be <a href=\"../ptr/index.html#safety\" title=\"mod std::ptr\">valid</a> for reads\nand writes and sufficiently aligned. In particular, casting any aligned\nnon-zero integer literal to a raw pointer produces a valid pointer, but a\npointer pointing into previously allocated memory that since got freed is\nnot valid. The recommended way to build a Box to a ZST if <code>Box::new</code> cannot\nbe used is to use <a href=\"../ptr/struct.NonNull.html#method.dangling\" title=\"associated function std::ptr::NonNull::dangling\"><code>ptr::NonNull::dangling</code></a>.</p>\n<p>So long as <code>T: Sized</code>, a <code>Box&lt;T&gt;</code> is guaranteed to be represented\nas a single pointer and is also ABI-compatible with C pointers\n(i.e. the C type <code>T*</code>). This means that if you have extern “C”\nRust functions that will be called from C, you can define those\nRust functions using <code>Box&lt;T&gt;</code> types, and use <code>T*</code> as corresponding\ntype on the C side. As an example, consider this C header which\ndeclares functions that create and destroy some kind of <code>Foo</code>\nvalue:</p>\n<div class=\"example-wrap\"><pre class=\"language-c\"><code>/* C header */\n\n/* Returns ownership to the caller */\nstruct Foo* foo_new(void);\n\n/* Takes ownership from the caller; no-op when invoked with null */\nvoid foo_delete(struct Foo*);\n</code></pre></div>\n<p>These two functions might be implemented in Rust as follows. Here, the\n<code>struct Foo*</code> type from C is translated to <code>Box&lt;Foo&gt;</code>, which captures\nthe ownership constraints. Note also that the nullable argument to\n<code>foo_delete</code> is represented in Rust as <code>Option&lt;Box&lt;Foo&gt;&gt;</code>, since <code>Box&lt;Foo&gt;</code>\ncannot be null.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[repr(C)]\n</span><span class=\"kw\">pub struct </span>Foo;\n\n<span class=\"attr\">#[no_mangle]\n</span><span class=\"kw\">pub extern </span><span class=\"string\">\"C\" </span><span class=\"kw\">fn </span>foo_new() -&gt; Box&lt;Foo&gt; {\n    Box::new(Foo)\n}\n\n<span class=\"attr\">#[no_mangle]\n</span><span class=\"kw\">pub extern </span><span class=\"string\">\"C\" </span><span class=\"kw\">fn </span>foo_delete(<span class=\"kw\">_</span>: <span class=\"prelude-ty\">Option</span>&lt;Box&lt;Foo&gt;&gt;) {}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Brepr(C)%5D%0A++++pub+struct+Foo;%0A++++%0A++++%23%5Bno_mangle%5D%0A++++pub+extern+%22C%22+fn+foo_new()+-%3E+Box%3CFoo%3E+%7B%0A++++++++Box::new(Foo)%0A++++%7D%0A++++%0A++++%23%5Bno_mangle%5D%0A++++pub+extern+%22C%22+fn+foo_delete(_:+Option%3CBox%3CFoo%3E%3E)+%7B%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Even though <code>Box&lt;T&gt;</code> has the same representation and C ABI as a C pointer,\nthis does not mean that you can convert an arbitrary <code>T*</code> into a <code>Box&lt;T&gt;</code>\nand expect things to work. <code>Box&lt;T&gt;</code> values will always be fully aligned,\nnon-null pointers. Moreover, the destructor for <code>Box&lt;T&gt;</code> will attempt to\nfree the value with the global allocator. In general, the best practice\nis to only use <code>Box&lt;T&gt;</code> for pointers that originated from the global\nallocator.</p>\n<p><strong>Important.</strong> At least at present, you should avoid using\n<code>Box&lt;T&gt;</code> types for functions that are defined in C but invoked\nfrom Rust. In those cases, you should directly mirror the C types\nas closely as possible. Using types like <code>Box&lt;T&gt;</code> where the C\ndefinition is just using <code>T*</code> can lead to undefined behavior, as\ndescribed in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/198\">rust-lang/unsafe-code-guidelines#198</a>.</p>\n<h2 id=\"considerations-for-unsafe-code\"><a class=\"doc-anchor\" href=\"#considerations-for-unsafe-code\">§</a>Considerations for unsafe code</h2>\n<p><strong>Warning: This section is not normative and is subject to change, possibly\nbeing relaxed in the future! It is a simplified summary of the rules\ncurrently implemented in the compiler.</strong></p>\n<p>The aliasing rules for <code>Box&lt;T&gt;</code> are the same as for <code>&amp;mut T</code>. <code>Box&lt;T&gt;</code>\nasserts uniqueness over its content. Using raw pointers derived from a box\nafter that box has been mutated through, moved or borrowed as <code>&amp;mut T</code>\nis not allowed. For more guidance on working with box from unsafe code, see\n<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/326\">rust-lang/unsafe-code-guidelines#326</a>.</p>\n<h2 id=\"editions\"><a class=\"doc-anchor\" href=\"#editions\">§</a>Editions</h2>\n<p>A special case exists for the implementation of <code>IntoIterator</code> for arrays on the Rust 2021\nedition, as documented <a href=\"../primitive.array.html\" title=\"primitive array\">here</a>. Unfortunately, it was later found that a similar\nworkaround should be added for boxed slices, and this was applied in the 2024 edition.</p>\n<p>Specifically, <code>IntoIterator</code> is implemented for <code>Box&lt;[T]&gt;</code> on all editions, but specific calls\nto <code>into_iter()</code> for boxed slices will defer to the slice implementation on editions before\n2024:</p>\n\n<div class=\"example-wrap edition\"><a href=\"#\" class=\"tooltip\" title=\"This example runs with edition 2021\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Rust 2015, 2018, and 2021:\n\n</span><span class=\"kw\">let </span>boxed_slice: Box&lt;[i32]&gt; = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">3</span>].into_boxed_slice();\n\n<span class=\"comment\">// This creates a slice iterator, producing references to each value.\n</span><span class=\"kw\">for </span>item <span class=\"kw\">in </span>boxed_slice.into_iter().enumerate() {\n    <span class=\"kw\">let </span>(i, x): (usize, <span class=\"kw-2\">&amp;</span>i32) = item;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"boxed_slice[{i}] = {x}\"</span>);\n}\n\n<span class=\"comment\">// The `boxed_slice_into_iter` lint suggests this change for future compatibility:\n</span><span class=\"kw\">for </span>item <span class=\"kw\">in </span>boxed_slice.iter().enumerate() {\n    <span class=\"kw\">let </span>(i, x): (usize, <span class=\"kw-2\">&amp;</span>i32) = item;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"boxed_slice[{i}] = {x}\"</span>);\n}\n\n<span class=\"comment\">// You can explicitly iterate a boxed slice by value using `IntoIterator::into_iter`\n</span><span class=\"kw\">for </span>item <span class=\"kw\">in </span>IntoIterator::into_iter(boxed_slice).enumerate() {\n    <span class=\"kw\">let </span>(i, x): (usize, i32) = item;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"boxed_slice[{i}] = {x}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Rust+2015,+2018,+and+2021:%0A%0A%23!%5Ballow(boxed_slice_into_iter)%5D+//+override+our+%60deny(warnings)%60%0Afn+main()+%7B%0A++++let+boxed_slice:+Box%3C%5Bi32%5D%3E+=+vec!%5B0;+3%5D.into_boxed_slice();%0A++++%0A++++//+This+creates+a+slice+iterator,+producing+references+to+each+value.%0A++++for+item+in+boxed_slice.into_iter().enumerate()+%7B%0A++++++++let+(i,+x):+(usize,+%26i32)+=+item;%0A++++++++println!(%22boxed_slice%5B%7Bi%7D%5D+=+%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+The+%60boxed_slice_into_iter%60+lint+suggests+this+change+for+future+compatibility:%0A++++for+item+in+boxed_slice.iter().enumerate()+%7B%0A++++++++let+(i,+x):+(usize,+%26i32)+=+item;%0A++++++++println!(%22boxed_slice%5B%7Bi%7D%5D+=+%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+You+can+explicitly+iterate+a+boxed+slice+by+value+using+%60IntoIterator::into_iter%60%0A++++for+item+in+IntoIterator::into_iter(boxed_slice).enumerate()+%7B%0A++++++++let+(i,+x):+(usize,+i32)+=+item;%0A++++++++println!(%22boxed_slice%5B%7Bi%7D%5D+=+%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Similar to the array implementation, this may be modified in the future to remove this override,\nand it’s best to avoid relying on this edition-dependent behavior if you wish to preserve\ncompatibility with future versions of the compiler.</p>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Box.html\" title=\"struct std::boxed::Box\">Box</a></div><div class=\"desc docblock-short\">A pointer type that uniquely owns a heap allocation of type <code>T</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ThinBox.html\" title=\"struct std::boxed::ThinBox\">ThinBox</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">ThinBox.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:10:49.181Z"
}