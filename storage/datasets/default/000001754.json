{
	"title": "available_parallelism in std::thread - Rust",
	"url": "https://doc.rust-lang.org/stable/std/thread/fn.available_parallelism.html",
	"markdown": "# available\\_parallelism in std::thread - Rust\n\n```\npub fn available_parallelism() -> Result<NonZero<usize>>\n```\n\nExpand description\n\nReturns an estimate of the default amount of parallelism a program should use.\n\nParallelism is a resource. A given machine provides a certain capacity for parallelism, i.e., a bound on the number of computations it can perform simultaneously. This number often corresponds to the amount of CPUs a computer has, but it may diverge in various cases.\n\nHost environments such as VMs or container orchestrators may want to restrict the amount of parallelism made available to programs in them. This is often done to limit the potential impact of (unintentionally) resource-intensive programs on other programs running on the same machine.\n\n## [§](#limitations)Limitations\n\nThe purpose of this API is to provide an easy and portable way to query the default amount of parallelism the program should use. Among other things it does not expose information on NUMA regions, does not account for differences in (co)processor capabilities or current system load, and will not modify the program’s global state in order to more accurately query the amount of available parallelism.\n\nWhere both fixed steady-state and burst limits are available the steady-state capacity will be used to ensure more predictable latencies.\n\nResource limits can be changed during the runtime of a program, therefore the value is not cached and instead recomputed every time this function is called. It should not be called from hot code.\n\nThe value returned by this function should be considered a simplified approximation of the actual amount of parallelism available at any given time. To get a more detailed or precise overview of the amount of parallelism available to the program, you may wish to use platform-specific APIs as well. The following platform limitations currently apply to `available_parallelism`:\n\nOn Windows:\n\n-   It may undercount the amount of parallelism available on systems with more than 64 logical CPUs. However, programs typically need specific support to take advantage of more than 64 logical CPUs, and in the absence of such support, the number returned by this function accurately reflects the number of logical CPUs the program can use by default.\n-   It may overcount the amount of parallelism available on systems limited by process-wide affinity masks, or job object limitations.\n\nOn Linux:\n\n-   It may overcount the amount of parallelism available when limited by a process-wide affinity mask or cgroup quotas and `sched_getaffinity()` or cgroup fs can’t be queried, e.g. due to sandboxing.\n-   It may undercount the amount of parallelism if the current thread’s affinity mask does not reflect the process’ cpuset, e.g. due to pinned threads.\n-   If the process is in a cgroup v1 cpu controller, this may need to scan mountpoints to find the corresponding cgroup v1 controller, which may take time on systems with large numbers of mountpoints. (This does not apply to cgroup v2, or to processes not in a cgroup.)\n\nOn all targets:\n\n-   It may overcount the amount of parallelism available when running in a VM with CPU usage limits (e.g. an overcommitted host).\n\n## [§](#errors)Errors\n\nThis function will, but is not limited to, return errors in the following cases:\n\n-   If the amount of parallelism is not known for the target platform.\n-   If the program lacks permission to query the amount of parallelism made available to it.\n\n## [§](#examples)Examples\n\n```\nuse std::{io, thread};\n\nfn main() -> io::Result<()> {\n    let count = thread::available_parallelism()?.get();\n    assert!(count >= 1_usize);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Ause+std::%7Bio,+thread%7D;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+count+=+thread::available_parallelism()?.get();%0A++++assert!(count+%3E=+1_usize);%0A++++Ok(())%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Returns an estimate of the default amount of parallelism a program should use.\"><title>available_parallelism in std::thread - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::thread</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AccessError.html\">AccessError</a></li><li><a href=\"struct.Builder.html\">Builder</a></li><li><a href=\"struct.JoinHandle.html\">JoinHandle</a></li><li><a href=\"struct.LocalKey.html\">LocalKey</a></li><li><a href=\"struct.Scope.html\">Scope</a></li><li><a href=\"struct.ScopedJoinHandle.html\">ScopedJoinHandle</a></li><li><a href=\"struct.Thread.html\">Thread</a></li><li><a href=\"struct.ThreadId.html\">ThreadId</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.available_parallelism.html\">available_parallelism</a></li><li><a href=\"fn.current.html\">current</a></li><li><a href=\"fn.panicking.html\">panicking</a></li><li><a href=\"fn.park.html\">park</a></li><li><a href=\"fn.park_timeout.html\">park_timeout</a></li><li><a href=\"fn.park_timeout_ms.html\">park_timeout_ms</a></li><li><a href=\"fn.scope.html\">scope</a></li><li><a href=\"fn.sleep.html\">sleep</a></li><li><a href=\"fn.sleep_ms.html\">sleep_ms</a></li><li><a href=\"fn.sleep_until.html\">sleep_until</a></li><li><a href=\"fn.spawn.html\">spawn</a></li><li><a href=\"fn.yield_now.html\">yield_now</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.Result.html\">Result</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">thread</a>::<wbr><a class=\"fn\" href=\"#\">available_parallelism</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.59.0\">1.59.0</span> · <a class=\"src\" href=\"../../src/std/thread/mod.rs.html#1854-1856\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub fn available_parallelism() -&gt; <a class=\"type\" href=\"../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"../num/struct.NonZero.html\" title=\"struct std::num::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt;&gt;</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Returns an estimate of the default amount of parallelism a program should use.</p>\n<p>Parallelism is a resource. A given machine provides a certain capacity for\nparallelism, i.e., a bound on the number of computations it can perform\nsimultaneously. This number often corresponds to the amount of CPUs a\ncomputer has, but it may diverge in various cases.</p>\n<p>Host environments such as VMs or container orchestrators may want to\nrestrict the amount of parallelism made available to programs in them. This\nis often done to limit the potential impact of (unintentionally)\nresource-intensive programs on other programs running on the same machine.</p>\n<h2 id=\"limitations\"><a class=\"doc-anchor\" href=\"#limitations\">§</a>Limitations</h2>\n<p>The purpose of this API is to provide an easy and portable way to query\nthe default amount of parallelism the program should use. Among other things it\ndoes not expose information on NUMA regions, does not account for\ndifferences in (co)processor capabilities or current system load,\nand will not modify the program’s global state in order to more accurately\nquery the amount of available parallelism.</p>\n<p>Where both fixed steady-state and burst limits are available the steady-state\ncapacity will be used to ensure more predictable latencies.</p>\n<p>Resource limits can be changed during the runtime of a program, therefore the value is\nnot cached and instead recomputed every time this function is called. It should not be\ncalled from hot code.</p>\n<p>The value returned by this function should be considered a simplified\napproximation of the actual amount of parallelism available at any given\ntime. To get a more detailed or precise overview of the amount of\nparallelism available to the program, you may wish to use\nplatform-specific APIs as well. The following platform limitations currently\napply to <code>available_parallelism</code>:</p>\n<p>On Windows:</p>\n<ul>\n<li>It may undercount the amount of parallelism available on systems with more\nthan 64 logical CPUs. However, programs typically need specific support to\ntake advantage of more than 64 logical CPUs, and in the absence of such\nsupport, the number returned by this function accurately reflects the\nnumber of logical CPUs the program can use by default.</li>\n<li>It may overcount the amount of parallelism available on systems limited by\nprocess-wide affinity masks, or job object limitations.</li>\n</ul>\n<p>On Linux:</p>\n<ul>\n<li>It may overcount the amount of parallelism available when limited by a\nprocess-wide affinity mask or cgroup quotas and <code>sched_getaffinity()</code> or cgroup fs can’t be\nqueried, e.g. due to sandboxing.</li>\n<li>It may undercount the amount of parallelism if the current thread’s affinity mask\ndoes not reflect the process’ cpuset, e.g. due to pinned threads.</li>\n<li>If the process is in a cgroup v1 cpu controller, this may need to\nscan mountpoints to find the corresponding cgroup v1 controller,\nwhich may take time on systems with large numbers of mountpoints.\n(This does not apply to cgroup v2, or to processes not in a\ncgroup.)</li>\n</ul>\n<p>On all targets:</p>\n<ul>\n<li>It may overcount the amount of parallelism available when running in a VM\nwith CPU usage limits (e.g. an overcommitted host).</li>\n</ul>\n<h2 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h2>\n<p>This function will, but is not limited to, return errors in the following\ncases:</p>\n<ul>\n<li>If the amount of parallelism is not known for the target platform.</li>\n<li>If the program lacks permission to query the amount of parallelism made\navailable to it.</li>\n</ul>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{io, thread};\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>count = thread::available_parallelism()<span class=\"question-mark\">?</span>.get();\n    <span class=\"macro\">assert!</span>(count &gt;= <span class=\"number\">1_usize</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Ause+std::%7Bio,+thread%7D;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+count+=+thread::available_parallelism()?.get();%0A++++assert!(count+%3E=+1_usize);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:20:26.833Z"
}