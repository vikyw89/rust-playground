{
	"title": "std::sync - Rust",
	"url": "https://doc.rust-lang.org/stable/std/sync/index.html",
	"markdown": "# std::sync - Rust\n\n## Module [std](../index.html)::[sync](#)\n\n1.0.0 · [source](about:blank/src/std/sync/mod.rs.html#1-204) ·\n\nExpand description\n\nUseful synchronization primitives.\n\n### [§](#the-need-for-synchronization)The need for synchronization\n\nConceptually, a Rust program is a series of operations which will be executed on a computer. The timeline of events happening in the program is consistent with the order of the operations in the code.\n\nConsider the following code, operating on some global static variables:\n\n```\nstatic mut A: u32 = 0;\nstatic mut B: u32 = 0;\nstatic mut C: u32 = 0;\n\nfn main() {\n    unsafe {\n        A = 3;\n        B = 4;\n        A = A + B;\n        C = B;\n        println!(\"{A} {B} {C}\");\n        C = A;\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Astatic+mut+A:+u32+=+0;%0Astatic+mut+B:+u32+=+0;%0Astatic+mut+C:+u32+=+0;%0A%0Afn+main()+%7B%0A++++unsafe+%7B%0A++++++++A+=+3;%0A++++++++B+=+4;%0A++++++++A+=+A+%2B+B;%0A++++++++C+=+B;%0A++++++++println!(%22%7BA%7D+%7BB%7D+%7BC%7D%22);%0A++++++++C+=+A;%0A++++%7D%0A%7D&edition=2021)\n\nIt appears as if some variables stored in memory are changed, an addition is performed, result is stored in `A` and the variable `C` is modified twice.\n\nWhen only a single thread is involved, the results are as expected: the line `7 4 4` gets printed.\n\nAs for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:\n\n-   The first store to `C` might be moved before the store to `A` or `B`, _as if_ we had written `C = 4; A = 3; B = 4`.\n    \n-   Assignment of `A + B` to `A` might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.\n    \n-   The final result could be determined just by looking at the code at compile time, so [constant folding](https://en.wikipedia.org/wiki/Constant_folding) might turn the whole block into a simple `println!(\"7 4 4\")`.\n    \n\nThe compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.\n\nDue to the [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science)) involved in modern computers, assumptions about the program’s execution order are often wrong. Access to global variables can lead to nondeterministic results, **even if** compiler optimizations are disabled, and it is **still possible** to introduce synchronization bugs.\n\nNote that thanks to Rust’s safety guarantees, accessing global (static) variables requires `unsafe` code, assuming we don’t use any of the synchronization primitives in this module.\n\n### [§](#out-of-order-execution)Out-of-order execution\n\nInstructions can execute in a different order from the one we define, due to various reasons:\n\n-   The **compiler** reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start [prefetching](https://en.wikipedia.org/wiki/Cache_prefetching) the values from memory.\n    \n    In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use [compiler fences](atomic/fn.compiler_fence.html \"fn std::sync::atomic::compiler_fence\") to prevent this reordering.\n    \n-   A **single processor** executing instructions [out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution): Modern CPUs are capable of [superscalar](https://en.wikipedia.org/wiki/Superscalar_processor) execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.\n    \n    This kind of reordering is handled transparently by the CPU.\n    \n-   A **multiprocessor** system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:\n    \n    -   [memory fences](atomic/fn.fence.html \"fn std::sync::atomic::fence\") to ensure memory accesses are made visible to other CPUs in the right order.\n    -   [atomic operations](atomic/index.html \"mod std::sync::atomic\") to ensure simultaneous access to the same memory location doesn’t lead to undefined behavior.\n\n### [§](#higher-level-synchronization-objects)Higher-level synchronization objects\n\nMost of the low-level synchronization primitives are quite error-prone and inconvenient to use, which is why the standard library also exposes some higher-level synchronization objects.\n\nThese abstractions can be built out of lower-level primitives. For efficiency, the sync objects in the standard library are usually implemented with help from the operating system’s kernel, which is able to reschedule the threads while they are blocked on acquiring a lock.\n\nThe following is an overview of the available synchronization objects:\n\n-   [`Arc`](struct.Arc.html \"struct std::sync::Arc\"): Atomically Reference-Counted pointer, which can be used in multithreaded environments to prolong the lifetime of some data until all the threads have finished using it.\n    \n-   [`Barrier`](struct.Barrier.html \"struct std::sync::Barrier\"): Ensures multiple threads will wait for each other to reach a point in the program, before continuing execution all together.\n    \n-   [`Condvar`](struct.Condvar.html \"struct std::sync::Condvar\"): Condition Variable, providing the ability to block a thread while waiting for an event to occur.\n    \n-   [`mpsc`](mpsc/index.html \"mod std::sync::mpsc\"): Multi-producer, single-consumer queues, used for message-based communication. Can provide a lightweight inter-thread synchronisation mechanism, at the cost of some extra memory.\n    \n-   [`Mutex`](struct.Mutex.html \"struct std::sync::Mutex\"): Mutual Exclusion mechanism, which ensures that at most one thread at a time is able to access some data.\n    \n-   [`Once`](struct.Once.html \"struct std::sync::Once\"): Used for a thread-safe, one-time global initialization routine\n    \n-   [`OnceLock`](struct.OnceLock.html \"struct std::sync::OnceLock\"): Used for thread-safe, one-time initialization of a variable, with potentially different initializers based on the caller.\n    \n-   [`LazyLock`](struct.LazyLock.html \"struct std::sync::LazyLock\"): Used for thread-safe, one-time initialization of a variable, using one nullary initializer function provided at creation.\n    \n-   [`RwLock`](struct.RwLock.html \"struct std::sync::RwLock\"): Provides a mutual exclusion mechanism which allows multiple readers at the same time, while allowing only one writer at a time. In some cases, this can be more efficient than a mutex.\n    \n\n-   Atomic types\n    \n-   Multi-producer, single-consumer FIFO queue communication primitives.\n    \n\n-   A thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically Reference Counted’.\n    \n-   A barrier enables multiple threads to synchronize the beginning of some computation.\n    \n-   A `BarrierWaitResult` is returned by [`Barrier::wait()`](about:blank/struct.Barrier.html#method.wait \"method std::sync::Barrier::wait\") when all threads in the [`Barrier`](struct.Barrier.html \"struct std::sync::Barrier\") have rendezvoused.\n    \n-   A Condition Variable\n    \n-   A value which is initialized on the first access.\n    \n-   A mutual exclusion primitive useful for protecting shared data\n    \n-   An RAII implementation of a “scoped lock” of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.\n    \n-   A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with [`Once::new()`](about:blank/struct.Once.html#method.new \"associated function std::sync::Once::new\").\n    \n-   A synchronization primitive which can nominally be written to only once.\n    \n-   State yielded to [`Once::call_once_force()`](about:blank/struct.Once.html#method.call_once_force \"method std::sync::Once::call_once_force\")’s closure parameter. The state can be used to query the poison status of the [`Once`](struct.Once.html \"struct std::sync::Once\").\n    \n-   A type of error which can be returned whenever a lock is acquired.\n    \n-   A reader-writer lock\n    \n-   RAII structure used to release the shared read access of a lock when dropped.\n    \n-   RAII structure used to release the exclusive write access of a lock when dropped.\n    \n-   A type indicating whether a timed wait on a condition variable returned due to a time out or not.\n    \n-   `Weak` is a version of [`Arc`](struct.Arc.html \"struct std::sync::Arc\") that holds a non-owning reference to the managed allocation. The allocation is accessed by calling [`upgrade`](about:blank/struct.Weak.html#method.upgrade \"method std::sync::Weak::upgrade\") on the `Weak` pointer, which returns an `[Option](../option/enum.Option.html \"enum std::option::Option\")<[Arc](struct.Arc.html \"struct std::sync::Arc\")<T>>`.\n    \n-   `Exclusive` provides only _mutable_ access, also referred to as _exclusive_ access to the underlying value. It provides no _immutable_, or _shared_ access to the underlying value.\n    \n-   An RAII mutex guard returned by `MutexGuard::map`, which can point to a subfield of the protected data. When this structure is dropped (falls out of scope), the lock will be unlocked.\n    \n-   RAII structure used to release the shared read access of a lock when dropped, which can point to a subfield of the protected data.\n    \n-   RAII structure used to release the exclusive write access of a lock when dropped, which can point to a subfield of the protected data.\n    \n-   A re-entrant mutual exclusion lock\n    \n-   An RAII implementation of a “scoped lock” of a re-entrant lock. When this structure is dropped (falls out of scope), the lock will be unlocked.\n    \n\n-   An enumeration of possible errors associated with a [`TryLockResult`](type.TryLockResult.html \"type std::sync::TryLockResult\") which can occur while trying to acquire a lock, from the [`try_lock`](about:blank/struct.Mutex.html#method.try_lock \"method std::sync::Mutex::try_lock\") method on a [`Mutex`](struct.Mutex.html \"struct std::sync::Mutex\") or the [`try_read`](about:blank/struct.RwLock.html#method.try_read \"method std::sync::RwLock::try_read\") and [`try_write`](about:blank/struct.RwLock.html#method.try_write \"method std::sync::RwLock::try_write\") methods on an [`RwLock`](struct.RwLock.html \"struct std::sync::RwLock\").\n    \n\n-   Initialization value for static [`Once`](struct.Once.html \"struct std::sync::Once\") values.\n    \n\n-   A type alias for the result of a lock method which can be poisoned.\n    \n-   A type alias for the result of a nonblocking locking method.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Useful synchronization primitives.\"><title>std::sync - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module sync</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module sync</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#modules\">Modules</a></li><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li><li><a href=\"#constants\">Constants</a></li><li><a href=\"#types\">Type Aliases</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">sync</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mod.rs.html#1-204\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Useful synchronization primitives.</p>\n<h3 id=\"the-need-for-synchronization\"><a class=\"doc-anchor\" href=\"#the-need-for-synchronization\">§</a>The need for synchronization</h3>\n<p>Conceptually, a Rust program is a series of operations which will\nbe executed on a computer. The timeline of events happening in the\nprogram is consistent with the order of the operations in the code.</p>\n<p>Consider the following code, operating on some global static variables:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">static </span><span class=\"kw-2\">mut </span>A: u32 = <span class=\"number\">0</span>;\n<span class=\"kw\">static </span><span class=\"kw-2\">mut </span>B: u32 = <span class=\"number\">0</span>;\n<span class=\"kw\">static </span><span class=\"kw-2\">mut </span>C: u32 = <span class=\"number\">0</span>;\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">unsafe </span>{\n        A = <span class=\"number\">3</span>;\n        B = <span class=\"number\">4</span>;\n        A = A + B;\n        C = B;\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"{A} {B} {C}\"</span>);\n        C = A;\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Astatic+mut+A:+u32+=+0;%0Astatic+mut+B:+u32+=+0;%0Astatic+mut+C:+u32+=+0;%0A%0Afn+main()+%7B%0A++++unsafe+%7B%0A++++++++A+=+3;%0A++++++++B+=+4;%0A++++++++A+=+A+%2B+B;%0A++++++++C+=+B;%0A++++++++println!(%22%7BA%7D+%7BB%7D+%7BC%7D%22);%0A++++++++C+=+A;%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It appears as if some variables stored in memory are changed, an addition\nis performed, result is stored in <code>A</code> and the variable <code>C</code> is\nmodified twice.</p>\n<p>When only a single thread is involved, the results are as expected:\nthe line <code>7 4 4</code> gets printed.</p>\n<p>As for what happens behind the scenes, when optimizations are enabled the\nfinal generated machine code might look very different from the code:</p>\n<ul>\n<li>\n<p>The first store to <code>C</code> might be moved before the store to <code>A</code> or <code>B</code>,\n<em>as if</em> we had written <code>C = 4; A = 3; B = 4</code>.</p>\n</li>\n<li>\n<p>Assignment of <code>A + B</code> to <code>A</code> might be removed, since the sum can be stored\nin a temporary location until it gets printed, with the global variable\nnever getting updated.</p>\n</li>\n<li>\n<p>The final result could be determined just by looking at the code\nat compile time, so <a href=\"https://en.wikipedia.org/wiki/Constant_folding\">constant folding</a> might turn the whole\nblock into a simple <code>println!(\"7 4 4\")</code>.</p>\n</li>\n</ul>\n<p>The compiler is allowed to perform any combination of these\noptimizations, as long as the final optimized code, when executed,\nproduces the same results as the one without optimizations.</p>\n<p>Due to the <a href=\"https://en.wikipedia.org/wiki/Concurrency_(computer_science)\">concurrency</a> involved in modern computers, assumptions\nabout the program’s execution order are often wrong. Access to\nglobal variables can lead to nondeterministic results, <strong>even if</strong>\ncompiler optimizations are disabled, and it is <strong>still possible</strong>\nto introduce synchronization bugs.</p>\n<p>Note that thanks to Rust’s safety guarantees, accessing global (static)\nvariables requires <code>unsafe</code> code, assuming we don’t use any of the\nsynchronization primitives in this module.</p>\n<h3 id=\"out-of-order-execution\"><a class=\"doc-anchor\" href=\"#out-of-order-execution\">§</a>Out-of-order execution</h3>\n<p>Instructions can execute in a different order from the one we define, due to\nvarious reasons:</p>\n<ul>\n<li>\n<p>The <strong>compiler</strong> reordering instructions: If the compiler can issue an\ninstruction at an earlier point, it will try to do so. For example, it\nmight hoist memory loads at the top of a code block, so that the CPU can\nstart <a href=\"https://en.wikipedia.org/wiki/Cache_prefetching\">prefetching</a> the values from memory.</p>\n<p>In single-threaded scenarios, this can cause issues when writing\nsignal handlers or certain kinds of low-level code.\nUse <a href=\"atomic/fn.compiler_fence.html\" title=\"fn std::sync::atomic::compiler_fence\">compiler fences</a> to prevent this reordering.</p>\n</li>\n<li>\n<p>A <strong>single processor</strong> executing instructions <a href=\"https://en.wikipedia.org/wiki/Out-of-order_execution\">out-of-order</a>:\nModern CPUs are capable of <a href=\"https://en.wikipedia.org/wiki/Superscalar_processor\">superscalar</a> execution,\ni.e., multiple instructions might be executing at the same time,\neven though the machine code describes a sequential process.</p>\n<p>This kind of reordering is handled transparently by the CPU.</p>\n</li>\n<li>\n<p>A <strong>multiprocessor</strong> system executing multiple hardware threads\nat the same time: In multi-threaded scenarios, you can use two\nkinds of primitives to deal with synchronization:</p>\n<ul>\n<li><a href=\"atomic/fn.fence.html\" title=\"fn std::sync::atomic::fence\">memory fences</a> to ensure memory accesses are made visible to\nother CPUs in the right order.</li>\n<li><a href=\"atomic/index.html\" title=\"mod std::sync::atomic\">atomic operations</a> to ensure simultaneous access to the same\nmemory location doesn’t lead to undefined behavior.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"higher-level-synchronization-objects\"><a class=\"doc-anchor\" href=\"#higher-level-synchronization-objects\">§</a>Higher-level synchronization objects</h3>\n<p>Most of the low-level synchronization primitives are quite error-prone and\ninconvenient to use, which is why the standard library also exposes some\nhigher-level synchronization objects.</p>\n<p>These abstractions can be built out of lower-level primitives.\nFor efficiency, the sync objects in the standard library are usually\nimplemented with help from the operating system’s kernel, which is\nable to reschedule the threads while they are blocked on acquiring\na lock.</p>\n<p>The following is an overview of the available synchronization\nobjects:</p>\n<ul>\n<li>\n<p><a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a>: Atomically Reference-Counted pointer, which can be used\nin multithreaded environments to prolong the lifetime of some\ndata until all the threads have finished using it.</p>\n</li>\n<li>\n<p><a href=\"struct.Barrier.html\" title=\"struct std::sync::Barrier\"><code>Barrier</code></a>: Ensures multiple threads will wait for each other\nto reach a point in the program, before continuing execution all\ntogether.</p>\n</li>\n<li>\n<p><a href=\"struct.Condvar.html\" title=\"struct std::sync::Condvar\"><code>Condvar</code></a>: Condition Variable, providing the ability to block\na thread while waiting for an event to occur.</p>\n</li>\n<li>\n<p><a href=\"mpsc/index.html\" title=\"mod std::sync::mpsc\"><code>mpsc</code></a>: Multi-producer, single-consumer queues, used for\nmessage-based communication. Can provide a lightweight\ninter-thread synchronisation mechanism, at the cost of some\nextra memory.</p>\n</li>\n<li>\n<p><a href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\"><code>Mutex</code></a>: Mutual Exclusion mechanism, which ensures that at\nmost one thread at a time is able to access some data.</p>\n</li>\n<li>\n<p><a href=\"struct.Once.html\" title=\"struct std::sync::Once\"><code>Once</code></a>: Used for a thread-safe, one-time global initialization routine</p>\n</li>\n<li>\n<p><a href=\"struct.OnceLock.html\" title=\"struct std::sync::OnceLock\"><code>OnceLock</code></a>: Used for thread-safe, one-time initialization of a\nvariable, with potentially different initializers based on the caller.</p>\n</li>\n<li>\n<p><a href=\"struct.LazyLock.html\" title=\"struct std::sync::LazyLock\"><code>LazyLock</code></a>: Used for thread-safe, one-time initialization of a\nvariable, using one nullary initializer function provided at creation.</p>\n</li>\n<li>\n<p><a href=\"struct.RwLock.html\" title=\"struct std::sync::RwLock\"><code>RwLock</code></a>: Provides a mutual exclusion mechanism which allows\nmultiple readers at the same time, while allowing only one\nwriter at a time. In some cases, this can be more efficient than\na mutex.</p>\n</li>\n</ul>\n</div></details><h2 id=\"modules\" class=\"section-header\">Modules<a href=\"#modules\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"mod\" href=\"atomic/index.html\" title=\"mod std::sync::atomic\">atomic</a></div><div class=\"desc docblock-short\">Atomic types</div></li><li><div class=\"item-name\"><a class=\"mod\" href=\"mpsc/index.html\" title=\"mod std::sync::mpsc\">mpsc</a></div><div class=\"desc docblock-short\">Multi-producer, single-consumer FIFO queue communication primitives.</div></li></ul><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a></div><div class=\"desc docblock-short\">A thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically\nReference Counted’.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Barrier.html\" title=\"struct std::sync::Barrier\">Barrier</a></div><div class=\"desc docblock-short\">A barrier enables multiple threads to synchronize the beginning\nof some computation.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BarrierWaitResult.html\" title=\"struct std::sync::BarrierWaitResult\">BarrierWaitResult</a></div><div class=\"desc docblock-short\">A <code>BarrierWaitResult</code> is returned by <a href=\"struct.Barrier.html#method.wait\" title=\"method std::sync::Barrier::wait\"><code>Barrier::wait()</code></a> when all threads\nin the <a href=\"struct.Barrier.html\" title=\"struct std::sync::Barrier\"><code>Barrier</code></a> have rendezvoused.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Condvar.html\" title=\"struct std::sync::Condvar\">Condvar</a></div><div class=\"desc docblock-short\">A Condition Variable</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.LazyLock.html\" title=\"struct std::sync::LazyLock\">LazyLock</a></div><div class=\"desc docblock-short\">A value which is initialized on the first access.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a></div><div class=\"desc docblock-short\">A mutual exclusion primitive useful for protecting shared data</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.MutexGuard.html\" title=\"struct std::sync::MutexGuard\">MutexGuard</a></div><div class=\"desc docblock-short\">An RAII implementation of a “scoped lock” of a mutex. When this structure is\ndropped (falls out of scope), the lock will be unlocked.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Once.html\" title=\"struct std::sync::Once\">Once</a></div><div class=\"desc docblock-short\">A synchronization primitive which can be used to run a one-time global\ninitialization. Useful for one-time initialization for FFI or related\nfunctionality. This type can only be constructed with <a href=\"struct.Once.html#method.new\" title=\"associated function std::sync::Once::new\"><code>Once::new()</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.OnceLock.html\" title=\"struct std::sync::OnceLock\">OnceLock</a></div><div class=\"desc docblock-short\">A synchronization primitive which can nominally be written to only once.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.OnceState.html\" title=\"struct std::sync::OnceState\">OnceState</a></div><div class=\"desc docblock-short\">State yielded to <a href=\"struct.Once.html#method.call_once_force\" title=\"method std::sync::Once::call_once_force\"><code>Once::call_once_force()</code></a>’s closure parameter. The state\ncan be used to query the poison status of the <a href=\"struct.Once.html\" title=\"struct std::sync::Once\"><code>Once</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.PoisonError.html\" title=\"struct std::sync::PoisonError\">PoisonError</a></div><div class=\"desc docblock-short\">A type of error which can be returned whenever a lock is acquired.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RwLock.html\" title=\"struct std::sync::RwLock\">RwLock</a></div><div class=\"desc docblock-short\">A reader-writer lock</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RwLockReadGuard.html\" title=\"struct std::sync::RwLockReadGuard\">RwLockReadGuard</a></div><div class=\"desc docblock-short\">RAII structure used to release the shared read access of a lock when\ndropped.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RwLockWriteGuard.html\" title=\"struct std::sync::RwLockWriteGuard\">RwLockWriteGuard</a></div><div class=\"desc docblock-short\">RAII structure used to release the exclusive write access of a lock when\ndropped.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.WaitTimeoutResult.html\" title=\"struct std::sync::WaitTimeoutResult\">WaitTimeoutResult</a></div><div class=\"desc docblock-short\">A type indicating whether a timed wait on a condition variable returned\ndue to a time out or not.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Weak.html\" title=\"struct std::sync::Weak\">Weak</a></div><div class=\"desc docblock-short\"><code>Weak</code> is a version of <a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a> that holds a non-owning reference to the\nmanaged allocation. The allocation is accessed by calling <a href=\"struct.Weak.html#method.upgrade\" title=\"method std::sync::Weak::upgrade\"><code>upgrade</code></a> on the <code>Weak</code>\npointer, which returns an <code><a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a href=\"struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T&gt;&gt;</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Exclusive.html\" title=\"struct std::sync::Exclusive\">Exclusive</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\"><code>Exclusive</code> provides only <em>mutable</em> access, also referred to as <em>exclusive</em>\naccess to the underlying value. It provides no <em>immutable</em>, or <em>shared</em>\naccess to the underlying value.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.MappedMutexGuard.html\" title=\"struct std::sync::MappedMutexGuard\">MappedMutexGuard</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An RAII mutex guard returned by <code>MutexGuard::map</code>, which can point to a\nsubfield of the protected data. When this structure is dropped (falls out\nof scope), the lock will be unlocked.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.MappedRwLockReadGuard.html\" title=\"struct std::sync::MappedRwLockReadGuard\">MappedRwLockReadGuard</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">RAII structure used to release the shared read access of a lock when\ndropped, which can point to a subfield of the protected data.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.MappedRwLockWriteGuard.html\" title=\"struct std::sync::MappedRwLockWriteGuard\">MappedRwLockWriteGuard</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">RAII structure used to release the exclusive write access of a lock when\ndropped, which can point to a subfield of the protected data.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ReentrantLock.html\" title=\"struct std::sync::ReentrantLock\">ReentrantLock</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">A re-entrant mutual exclusion lock</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ReentrantLockGuard.html\" title=\"struct std::sync::ReentrantLockGuard\">ReentrantLockGuard</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">An RAII implementation of a “scoped lock” of a re-entrant lock. When this\nstructure is dropped (falls out of scope), the lock will be unlocked.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.TryLockError.html\" title=\"enum std::sync::TryLockError\">TryLockError</a></div><div class=\"desc docblock-short\">An enumeration of possible errors associated with a <a href=\"type.TryLockResult.html\" title=\"type std::sync::TryLockResult\"><code>TryLockResult</code></a> which\ncan occur while trying to acquire a lock, from the <a href=\"struct.Mutex.html#method.try_lock\" title=\"method std::sync::Mutex::try_lock\"><code>try_lock</code></a> method on a\n<a href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\"><code>Mutex</code></a> or the <a href=\"struct.RwLock.html#method.try_read\" title=\"method std::sync::RwLock::try_read\"><code>try_read</code></a> and <a href=\"struct.RwLock.html#method.try_write\" title=\"method std::sync::RwLock::try_write\"><code>try_write</code></a> methods on an <a href=\"struct.RwLock.html\" title=\"struct std::sync::RwLock\"><code>RwLock</code></a>.</div></li></ul><h2 id=\"constants\" class=\"section-header\">Constants<a href=\"#constants\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"constant\" href=\"constant.ONCE_INIT.html\" title=\"constant std::sync::ONCE_INIT\">ONCE_INIT</a><span class=\"stab deprecated\" title=\"\">Deprecated</span></div><div class=\"desc docblock-short\">Initialization value for static <a href=\"struct.Once.html\" title=\"struct std::sync::Once\"><code>Once</code></a> values.</div></li></ul><h2 id=\"types\" class=\"section-header\">Type Aliases<a href=\"#types\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"type\" href=\"type.LockResult.html\" title=\"type std::sync::LockResult\">LockResult</a></div><div class=\"desc docblock-short\">A type alias for the result of a lock method which can be poisoned.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.TryLockResult.html\" title=\"type std::sync::TryLockResult\">TryLockResult</a></div><div class=\"desc docblock-short\">A type alias for the result of a nonblocking locking method.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:08.274Z"
}