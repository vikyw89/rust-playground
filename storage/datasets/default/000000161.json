{
	"title": "Build Script Examples - The Cargo Book",
	"url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
	"markdown": "# Build Script Examples - The Cargo Book\n\nThe following sections illustrate some examples of writing build scripts.\n\nSome common build script functionality can be found via crates on [crates.io](https://crates.io/). Check out the [`build-dependencies` keyword](https://crates.io/keywords/build-dependencies) to see what is available. The following is a sample of some popular crates[1](#†):\n\n-   [`bindgen`](https://crates.io/crates/bindgen) — Automatically generate Rust FFI bindings to C libraries.\n-   [`cc`](https://crates.io/crates/cc) — Compiles C/C++/assembly.\n-   [`pkg-config`](https://crates.io/crates/pkg-config) — Detect system libraries using the `pkg-config` utility.\n-   [`cmake`](https://crates.io/crates/cmake) — Runs the `cmake` build tool to build a native library.\n-   [`autocfg`](https://crates.io/crates/autocfg), [`rustc_version`](https://crates.io/crates/rustc_version), [`version_check`](https://crates.io/crates/version_check) — These crates provide ways to implement conditional compilation based on the current `rustc` such as the version of the compiler.\n\n## [Code generation](#code-generation)\n\nSome Cargo packages need to have code generated just before they are compiled for various reasons. Here we’ll walk through a simple example which generates a library call as part of the build script.\n\nFirst, let’s take a look at the directory structure of this package:\n\n```text\n.\n├── Cargo.toml\n├── build.rs\n└── src\n    └── main.rs\n\n1 directory, 3 files\n\n```\n\nHere we can see that we have a `build.rs` build script and our binary in `main.rs`. This package has a basic manifest:\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"hello-from-generated-code\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n```\n\nLet’s see what’s inside the build script:\n\n```rust\n// build.rs\n\nuse std::env;\nuse std::fs;\nuse std::path::Path;\n\nfn main() {\n    let out_dir = env::var_os(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"hello.rs\");\n    fs::write(\n        &dest_path,\n        \"pub fn message() -> &'static str {\n            \\\"Hello, World!\\\"\n        }\n        \"\n    ).unwrap();\n    println!(\"cargo::rerun-if-changed=build.rs\");\n}\n```\n\nThere’s a couple of points of note here:\n\n-   The script uses the `OUT_DIR` environment variable to discover where the output files should be located. It can use the process’ current working directory to find where the input files should be located, but in this case we don’t have any input files.\n-   In general, build scripts should not modify any files outside of `OUT_DIR`. It may seem fine on the first blush, but it does cause problems when you use such crate as a dependency, because there’s an _implicit_ invariant that sources in `.cargo/registry` should be immutable. `cargo` won’t allow such scripts when packaging.\n-   This script is relatively simple as it just writes out a small generated file. One could imagine that other more complex operations could take place such as generating a Rust module from a C header file or another language definition, for example.\n-   The [`rerun-if-changed` instruction](about:blank/build-scripts.html#rerun-if-changed) tells Cargo that the build script only needs to re-run if the build script itself changes. Without this line, Cargo will automatically run the build script if any file in the package changes. If your code generation uses some input files, this is where you would print a list of each of those files.\n\nNext, let’s peek at the library itself:\n\n```rust\n// src/main.rs\n\ninclude!(concat!(env!(\"OUT_DIR\"), \"/hello.rs\"));\n\nfn main() {\n    println!(\"{}\", message());\n}\n```\n\nThis is where the real magic happens. The library is using the rustc-defined [`include!` macro](../../std/macro.include.html) in combination with the [`concat!`](../../std/macro.concat.html) and [`env!`](../../std/macro.env.html) macros to include the generated file (`hello.rs`) into the crate’s compilation.\n\nUsing the structure shown here, crates can include any number of generated files from the build script itself.\n\n## [Building a native library](#building-a-native-library)\n\nSometimes it’s necessary to build some native C or C++ code as part of a package. This is another excellent use case of leveraging the build script to build a native library before the Rust crate itself. As an example, we’ll create a Rust library which calls into C to print “Hello, World!”.\n\nLike above, let’s first take a look at the package layout:\n\n```text\n.\n├── Cargo.toml\n├── build.rs\n└── src\n    ├── hello.c\n    └── main.rs\n\n1 directory, 4 files\n\n```\n\nPretty similar to before! Next, the manifest:\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"hello-world-from-c\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n```\n\nFor now we’re not going to use any build dependencies, so let’s take a look at the build script now:\n\n```rust\n// build.rs\n\nuse std::process::Command;\nuse std::env;\nuse std::path::Path;\n\nfn main() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n\n    // Note that there are a number of downsides to this approach, the comments\n    // below detail how to improve the portability of these commands.\n    Command::new(\"gcc\").args(&[\"src/hello.c\", \"-c\", \"-fPIC\", \"-o\"])\n                       .arg(&format!(\"{}/hello.o\", out_dir))\n                       .status().unwrap();\n    Command::new(\"ar\").args(&[\"crus\", \"libhello.a\", \"hello.o\"])\n                      .current_dir(&Path::new(&out_dir))\n                      .status().unwrap();\n\n    println!(\"cargo::rustc-link-search=native={}\", out_dir);\n    println!(\"cargo::rustc-link-lib=static=hello\");\n    println!(\"cargo::rerun-if-changed=src/hello.c\");\n}\n```\n\nThis build script starts out by compiling our C file into an object file (by invoking `gcc`) and then converting this object file into a static library (by invoking `ar`). The final step is feedback to Cargo itself to say that our output was in `out_dir` and the compiler should link the crate to `libhello.a` statically via the `-l static=hello` flag.\n\nNote that there are a number of drawbacks to this hard-coded approach:\n\n-   The `gcc` command itself is not portable across platforms. For example it’s unlikely that Windows platforms have `gcc`, and not even all Unix platforms may have `gcc`. The `ar` command is also in a similar situation.\n-   These commands do not take cross-compilation into account. If we’re cross compiling for a platform such as Android it’s unlikely that `gcc` will produce an ARM executable.\n\nNot to fear, though, this is where a `build-dependencies` entry would help! The Cargo ecosystem has a number of packages to make this sort of task much easier, portable, and standardized. Let’s try the [`cc` crate](https://crates.io/crates/cc) from [crates.io](https://crates.io/). First, add it to the `build-dependencies` in `Cargo.toml`:\n\n```toml\n[build-dependencies]\ncc = \"1.0\"\n\n```\n\nAnd rewrite the build script to use this crate:\n\n```rust\n// build.rs\n\nfn main() {\n    cc::Build::new()\n        .file(\"src/hello.c\")\n        .compile(\"hello\");\n    println!(\"cargo::rerun-if-changed=src/hello.c\");\n}\n```\n\nThe [`cc` crate](https://crates.io/crates/cc) abstracts a range of build script requirements for C code:\n\n-   It invokes the appropriate compiler (MSVC for windows, `gcc` for MinGW, `cc` for Unix platforms, etc.).\n-   It takes the `TARGET` variable into account by passing appropriate flags to the compiler being used.\n-   Other environment variables, such as `OPT_LEVEL`, `DEBUG`, etc., are all handled automatically.\n-   The stdout output and `OUT_DIR` locations are also handled by the `cc` library.\n\nHere we can start to see some of the major benefits of farming as much functionality as possible out to common build dependencies rather than duplicating logic across all build scripts!\n\nBack to the case study though, let’s take a quick look at the contents of the `src` directory:\n\n```c\n// src/hello.c\n\n#include <stdio.h>\n\nvoid hello() {\n    printf(\"Hello, World!\\n\");\n}\n\n```\n\n```rust\n// src/main.rs\n\n// Note the lack of the `#[link]` attribute. We’re delegating the responsibility\n// of selecting what to link over to the build script rather than hard-coding\n// it in the source file.\nextern { fn hello(); }\n\nfn main() {\n    unsafe { hello(); }\n}\n```\n\nAnd there we go! This should complete our example of building some C code from a Cargo package using the build script itself. This also shows why using a build dependency can be crucial in many situations and even much more concise!\n\nWe’ve also seen a brief example of how a build script can use a crate as a dependency purely for the build process and not for the crate itself at runtime.\n\n## [Linking to system libraries](#linking-to-system-libraries)\n\nThis example demonstrates how to link a system library and how the build script is used to support this use case.\n\nQuite frequently a Rust crate wants to link to a native library provided on the system to bind its functionality or just use it as part of an implementation detail. This is quite a nuanced problem when it comes to performing this in a platform-agnostic fashion. It is best, if possible, to farm out as much of this as possible to make this as easy as possible for consumers.\n\nFor this example, we will be creating a binding to the system’s zlib library. This is a library that is commonly found on most Unix-like systems that provides data compression. This is already wrapped up in the [`libz-sys` crate](https://crates.io/crates/libz-sys), but for this example, we’ll do an extremely simplified version. Check out [the source code](https://github.com/rust-lang/libz-sys) for the full example.\n\nTo make it easy to find the location of the library, we will use the [`pkg-config` crate](https://crates.io/crates/pkg-config). This crate uses the system’s `pkg-config` utility to discover information about a library. It will automatically tell Cargo what is needed to link the library. This will likely only work on Unix-like systems with `pkg-config` installed. Let’s start by setting up the manifest:\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"libz-sys\"\nversion = \"0.1.0\"\nedition = \"2021\"\nlinks = \"z\"\n\n[build-dependencies]\npkg-config = \"0.3.16\"\n\n```\n\nTake note that we included the `links` key in the `package` table. This tells Cargo that we are linking to the `libz` library. See [“Using another sys crate”](#using-another-sys-crate) for an example that will leverage this.\n\nThe build script is fairly simple:\n\n```rust\n// build.rs\n\nfn main() {\n    pkg_config::Config::new().probe(\"zlib\").unwrap();\n    println!(\"cargo::rerun-if-changed=build.rs\");\n}\n```\n\nLet’s round out the example with a basic FFI binding:\n\n```rust\n// src/lib.rs\n\nuse std::os::raw::{c_uint, c_ulong};\n\nextern \"C\" {\n    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -> c_ulong;\n}\n\n#[test]\nfn test_crc32() {\n    let s = \"hello\";\n    unsafe {\n        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);\n    }\n}\n```\n\nRun `cargo build -vv` to see the output from the build script. On a system with `libz` already installed, it may look something like this:\n\n```text\n[libz-sys 0.1.0] cargo::rustc-link-search=native=/usr/lib\n[libz-sys 0.1.0] cargo::rustc-link-lib=z\n[libz-sys 0.1.0] cargo::rerun-if-changed=build.rs\n\n```\n\nNice! `pkg-config` did all the work of finding the library and telling Cargo where it is.\n\nIt is not unusual for packages to include the source for the library, and build it statically if it is not found on the system, or if a feature or environment variable is set. For example, the real [`libz-sys` crate](https://crates.io/crates/libz-sys) checks the environment variable `LIBZ_SYS_STATIC` or the `static` feature to build it from source instead of using the system library. Check out [the source](https://github.com/rust-lang/libz-sys) for a more complete example.\n\n## [Using another `sys` crate](#using-another-sys-crate)\n\nWhen using the `links` key, crates may set metadata that can be read by other crates that depend on it. This provides a mechanism to communicate information between crates. In this example, we’ll be creating a C library that makes use of zlib from the real [`libz-sys` crate](https://crates.io/crates/libz-sys).\n\nIf you have a C library that depends on zlib, you can leverage the [`libz-sys` crate](https://crates.io/crates/libz-sys) to automatically find it or build it. This is great for cross-platform support, such as Windows where zlib is not usually installed. `libz-sys` [sets the `include` metadata](https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156) to tell other packages where to find the header files for zlib. Our build script can read that metadata with the `DEP_Z_INCLUDE` environment variable. Here’s an example:\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"zuser\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nlibz-sys = \"1.0.25\"\n\n[build-dependencies]\ncc = \"1.0.46\"\n\n```\n\nHere we have included `libz-sys` which will ensure that there is only one `libz` used in the final library, and give us access to it from our build script:\n\n```rust\n// build.rs\n\nfn main() {\n    let mut cfg = cc::Build::new();\n    cfg.file(\"src/zuser.c\");\n    if let Some(include) = std::env::var_os(\"DEP_Z_INCLUDE\") {\n        cfg.include(include);\n    }\n    cfg.compile(\"zuser\");\n    println!(\"cargo::rerun-if-changed=src/zuser.c\");\n}\n```\n\nWith `libz-sys` doing all the heavy lifting, the C source code may now include the zlib header, and it should find the header, even on systems where it isn’t already installed.\n\n```c\n// src/zuser.c\n\n#include \"zlib.h\"\n\n// … rest of code that makes use of zlib.\n\n```\n\n## [Conditional compilation](#conditional-compilation)\n\nA build script may emit [`rustc-cfg` instructions](about:blank/build-scripts.html#rustc-cfg) which can enable conditions that can be checked at compile time. In this example, we’ll take a look at how the [`openssl` crate](https://crates.io/crates/openssl) uses this to support multiple versions of the OpenSSL library.\n\nThe [`openssl-sys` crate](https://crates.io/crates/openssl-sys) implements building and linking the OpenSSL library. It supports multiple different implementations (like LibreSSL) and multiple versions. It makes use of the `links` key so that it may pass information to other build scripts. One of the things it passes is the `version_number` key, which is the version of OpenSSL that was detected. The code in the build script looks something [like this](https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216):\n\n```rust\nprintln!(\"cargo::version_number={:x}\", openssl_version);\n```\n\nThis instruction causes the `DEP_OPENSSL_VERSION_NUMBER` environment variable to be set in any crates that directly depend on `openssl-sys`.\n\nThe `openssl` crate, which provides the higher-level interface, specifies `openssl-sys` as a dependency. The `openssl` build script can read the version information generated by the `openssl-sys` build script with the `DEP_OPENSSL_VERSION_NUMBER` environment variable. It uses this to generate some [`cfg` values](https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36):\n\n```rust\n// (portion of build.rs)\n\nprintln!(\"cargo::rustc-check-cfg=cfg(ossl101,ossl102)\");\nprintln!(\"cargo::rustc-check-cfg=cfg(ossl110,ossl110g,ossl111)\");\n\nif let Ok(version) = env::var(\"DEP_OPENSSL_VERSION_NUMBER\") {\n    let version = u64::from_str_radix(&version, 16).unwrap();\n\n    if version >= 0x1_00_01_00_0 {\n        println!(\"cargo::rustc-cfg=ossl101\");\n    }\n    if version >= 0x1_00_02_00_0 {\n        println!(\"cargo::rustc-cfg=ossl102\");\n    }\n    if version >= 0x1_01_00_00_0 {\n        println!(\"cargo::rustc-cfg=ossl110\");\n    }\n    if version >= 0x1_01_00_07_0 {\n        println!(\"cargo::rustc-cfg=ossl110g\");\n    }\n    if version >= 0x1_01_01_00_0 {\n        println!(\"cargo::rustc-cfg=ossl111\");\n    }\n}\n```\n\nThese `cfg` values can then be used with the [`cfg` attribute](about:blank/reference/conditional-compilation.html#the-cfg-attribute) or the [`cfg` macro](../../std/macro.cfg.html) to conditionally include code. For example, SHA3 support was added in OpenSSL 1.1.1, so it is [conditionally excluded](https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85) for older versions:\n\n```rust\n// (portion of openssl crate)\n\n#[cfg(ossl111)]\npub fn sha3_224() -> MessageDigest {\n    unsafe { MessageDigest(ffi::EVP_sha3_224()) }\n}\n```\n\nOf course, one should be careful when using this, since it makes the resulting binary even more dependent on the build environment. In this example, if the binary is distributed to another system, it may not have the exact same shared libraries, which could cause problems.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Build Script Examples - The Cargo Book</title>\n\n\n        <!-- Custom HTML head -->\n        <style>\n            dd {\n                margin-bottom: 1em;\n            }\n        </style>\n\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../index.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../getting-started/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../getting-started/installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"../getting-started/first-steps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> First Steps with Cargo</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../guide/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Cargo Guide</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../guide/why-cargo-exists.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Why Cargo Exists</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/creating-a-new-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Creating a New Package</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/working-on-an-existing-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Working on an Existing Package</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Dependencies</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/project-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Package Layout</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/cargo-toml-vs-cargo-lock.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.7.</strong> Tests</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/continuous-integration.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.8.</strong> Continuous Integration</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/cargo-home.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.9.</strong> Cargo Home</a></li><li class=\"chapter-item expanded \"><a href=\"../guide/build-cache.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.10.</strong> Build Cache</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Cargo Reference</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/specifying-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Specifying Dependencies</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/overriding-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.1.</strong> Overriding Dependencies</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/manifest.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> The Manifest Format</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/cargo-targets.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.1.</strong> Cargo Targets</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/features-examples.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.1.</strong> Features Examples</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/config.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Configuration</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/build-scripts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Build Scripts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/build-script-examples.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.1.</strong> Build Script Examples</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/publishing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Publishing on crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/pkgid-spec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> Package ID Specifications</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/source-replacement.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Source Replacement</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/external-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.12.</strong> External Tools</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/registries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.</strong> Registries</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/registry-authentication.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.1.</strong> Registry Authentication</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/credential-provider-protocol.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.1.1.</strong> Credential Provider Protocol</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/running-a-registry.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.2.</strong> Running a Registry</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../reference/registry-index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.2.1.</strong> Registry Index</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/registry-web-api.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.13.2.2.</strong> Registry Web API</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../reference/resolver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.14.</strong> Dependency Resolution</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/semver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.15.</strong> SemVer Compatibility</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/future-incompat-report.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.16.</strong> Future incompat report</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/timings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.17.</strong> Reporting build timings</a></li><li class=\"chapter-item expanded \"><a href=\"../reference/unstable.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.18.</strong> Unstable Features</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Cargo Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/general-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> General Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.1.</strong> cargo</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-help.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.2.</strong> cargo help</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-version.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.3.</strong> cargo version</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/build-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Build Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-bench.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.1.</strong> cargo bench</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-build.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.2.</strong> cargo build</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-check.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.3.</strong> cargo check</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-clean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.4.</strong> cargo clean</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-doc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.5.</strong> cargo doc</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-fetch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.6.</strong> cargo fetch</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-fix.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.7.</strong> cargo fix</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-run.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.8.</strong> cargo run</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-rustc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.9.</strong> cargo rustc</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-rustdoc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.10.</strong> cargo rustdoc</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-test.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.11.</strong> cargo test</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-report.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.12.</strong> cargo report</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/manifest-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Manifest Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-add.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.1.</strong> cargo add</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-generate-lockfile.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.2.</strong> cargo generate-lockfile</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-locate-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.3.</strong> cargo locate-project</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-metadata.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.4.</strong> cargo metadata</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-pkgid.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.5.</strong> cargo pkgid</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.6.</strong> cargo remove</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.7.</strong> cargo tree</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-update.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.8.</strong> cargo update</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-vendor.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.9.</strong> cargo vendor</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-verify-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.10.</strong> cargo verify-project</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/package-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Package Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-init.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.1.</strong> cargo init</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-install.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.2.</strong> cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-new.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.3.</strong> cargo new</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-search.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.4.</strong> cargo search</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-uninstall.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../commands/publishing-commands.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Publishing Commands</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-login.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.1.</strong> cargo login</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-logout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.2.</strong> cargo logout</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-owner.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.3.</strong> cargo owner</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-package.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.4.</strong> cargo package</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-publish.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.5.</strong> cargo publish</a></li><li class=\"chapter-item expanded \"><a href=\"../commands/cargo-yank.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.6.</strong> cargo yank</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../faq.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> FAQ</a></li><li class=\"chapter-item expanded \"><a href=\"../appendix/glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Appendix: Glossary</a></li><li class=\"chapter-item expanded \"><a href=\"../appendix/git-authentication.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Appendix: Git Authentication</a></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Cargo Book</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/cargo/tree/master/src/doc/src\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/build-script-examples.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"build-script-examples\"><a class=\"header\" href=\"#build-script-examples\">Build Script Examples</a></h1>\n<p>The following sections illustrate some examples of writing build scripts.</p>\n<p>Some common build script functionality can be found via crates on <a href=\"https://crates.io/\">crates.io</a>.\nCheck out the <a href=\"https://crates.io/keywords/build-dependencies\"><code class=\"hljs\">build-dependencies</code>\nkeyword</a> to see what is\navailable. The following is a sample of some popular crates<sup class=\"footnote-reference\"><a href=\"#†\">1</a></sup>:</p>\n<ul>\n<li><a href=\"https://crates.io/crates/bindgen\"><code class=\"hljs\">bindgen</code></a> — Automatically generate Rust\nFFI bindings to C libraries.</li>\n<li><a href=\"https://crates.io/crates/cc\"><code class=\"hljs\">cc</code></a> — Compiles C/C++/assembly.</li>\n<li><a href=\"https://crates.io/crates/pkg-config\"><code class=\"hljs\">pkg-config</code></a> — Detect system\nlibraries using the <code class=\"hljs\">pkg-config</code> utility.</li>\n<li><a href=\"https://crates.io/crates/cmake\"><code class=\"hljs\">cmake</code></a> — Runs the <code class=\"hljs\">cmake</code> build tool to build a native library.</li>\n<li><a href=\"https://crates.io/crates/autocfg\"><code class=\"hljs\">autocfg</code></a>,\n<a href=\"https://crates.io/crates/rustc_version\"><code class=\"hljs\">rustc_version</code></a>,\n<a href=\"https://crates.io/crates/version_check\"><code class=\"hljs\">version_check</code></a> — These crates\nprovide ways to implement conditional compilation based on the current\n<code class=\"hljs\">rustc</code> such as the version of the compiler.</li>\n</ul>\n<div class=\"footnote-definition\" id=\"†\"><sup class=\"footnote-definition-label\">1</sup>\n<p>This list is not an endorsement. Evaluate your dependencies to see which\nis right for your project.</p>\n</div>\n<h2 id=\"code-generation\"><a class=\"header\" href=\"#code-generation\">Code generation</a></h2>\n<p>Some Cargo packages need to have code generated just before they are compiled\nfor various reasons. Here we’ll walk through a simple example which generates a\nlibrary call as part of the build script.</p>\n<p>First, let’s take a look at the directory structure of this package:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">.\n├── Cargo.toml\n├── build.rs\n└── src\n    └── main.rs\n\n1 directory, 3 files\n</code></pre>\n<p>Here we can see that we have a <code class=\"hljs\">build.rs</code> build script and our binary in\n<code class=\"hljs\">main.rs</code>. This package has a basic manifest:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Cargo.toml</span>\n\n<span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"hello-from-generated-code\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2021\"</span>\n</code></pre>\n<p>Let’s see what’s inside the build script:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-comment\">// build.rs</span>\n\n<span class=\"hljs-keyword\">use</span> std::env;\n<span class=\"hljs-keyword\">use</span> std::fs;\n<span class=\"hljs-keyword\">use</span> std::path::Path;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> out_dir = env::var_os(<span class=\"hljs-string\">\"OUT_DIR\"</span>).unwrap();\n    <span class=\"hljs-keyword\">let</span> dest_path = Path::new(&amp;out_dir).join(<span class=\"hljs-string\">\"hello.rs\"</span>);\n    fs::write(\n        &amp;dest_path,\n        <span class=\"hljs-string\">\"pub fn message() -&gt; &amp;'static str {\n            \\\"Hello, World!\\\"\n        }\n        \"</span>\n    ).unwrap();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rerun-if-changed=build.rs\"</span>);\n}</code></pre></pre>\n<p>There’s a couple of points of note here:</p>\n<ul>\n<li>The script uses the <code class=\"hljs\">OUT_DIR</code> environment variable to discover where the\noutput files should be located. It can use the process’ current working\ndirectory to find where the input files should be located, but in this case we\ndon’t have any input files.</li>\n<li>In general, build scripts should not modify any files outside of <code class=\"hljs\">OUT_DIR</code>.\nIt may seem fine on the first blush, but it does cause problems when you use\nsuch crate as a dependency, because there’s an <em>implicit</em> invariant that\nsources in <code class=\"hljs\">.cargo/registry</code> should be immutable. <code class=\"hljs\">cargo</code> won’t allow such\nscripts when packaging.</li>\n<li>This script is relatively simple as it just writes out a small generated file.\nOne could imagine that other more complex operations could take place such as\ngenerating a Rust module from a C header file or another language definition,\nfor example.</li>\n<li>The <a href=\"build-scripts.html#rerun-if-changed\"><code class=\"hljs\">rerun-if-changed</code> instruction</a>\ntells Cargo that the build script only needs to re-run if the build script\nitself changes. Without this line, Cargo will automatically run the build\nscript if any file in the package changes. If your code generation uses some\ninput files, this is where you would print a list of each of those files.</li>\n</ul>\n<p>Next, let’s peek at the library itself:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// src/main.rs</span>\n\ninclude!(<span class=\"hljs-built_in\">concat!</span>(<span class=\"hljs-built_in\">env!</span>(<span class=\"hljs-string\">\"OUT_DIR\"</span>), <span class=\"hljs-string\">\"/hello.rs\"</span>));\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, message());\n}</code></pre>\n<p>This is where the real magic happens. The library is using the rustc-defined\n<a href=\"../../std/macro.include.html\"><code class=\"hljs\">include!</code> macro</a> in combination with the\n<a href=\"../../std/macro.concat.html\"><code class=\"hljs\">concat!</code></a> and <a href=\"../../std/macro.env.html\"><code class=\"hljs\">env!</code></a> macros to include the\ngenerated file (<code class=\"hljs\">hello.rs</code>) into the crate’s compilation.</p>\n<p>Using the structure shown here, crates can include any number of generated files\nfrom the build script itself.</p>\n<h2 id=\"building-a-native-library\"><a class=\"header\" href=\"#building-a-native-library\">Building a native library</a></h2>\n<p>Sometimes it’s necessary to build some native C or C++ code as part of a\npackage. This is another excellent use case of leveraging the build script to\nbuild a native library before the Rust crate itself. As an example, we’ll create\na Rust library which calls into C to print “Hello, World!”.</p>\n<p>Like above, let’s first take a look at the package layout:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">.\n├── Cargo.toml\n├── build.rs\n└── src\n    ├── hello.c\n    └── main.rs\n\n1 directory, 4 files\n</code></pre>\n<p>Pretty similar to before! Next, the manifest:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Cargo.toml</span>\n\n<span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"hello-world-from-c\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2021\"</span>\n</code></pre>\n<p>For now we’re not going to use any build dependencies, so let’s take a look at\nthe build script now:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust no_run hljs\"><span class=\"hljs-comment\">// build.rs</span>\n\n<span class=\"hljs-keyword\">use</span> std::process::Command;\n<span class=\"hljs-keyword\">use</span> std::env;\n<span class=\"hljs-keyword\">use</span> std::path::Path;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> out_dir = env::var(<span class=\"hljs-string\">\"OUT_DIR\"</span>).unwrap();\n\n    <span class=\"hljs-comment\">// Note that there are a number of downsides to this approach, the comments</span>\n    <span class=\"hljs-comment\">// below detail how to improve the portability of these commands.</span>\n    Command::new(<span class=\"hljs-string\">\"gcc\"</span>).args(&amp;[<span class=\"hljs-string\">\"src/hello.c\"</span>, <span class=\"hljs-string\">\"-c\"</span>, <span class=\"hljs-string\">\"-fPIC\"</span>, <span class=\"hljs-string\">\"-o\"</span>])\n                       .arg(&amp;<span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{}/hello.o\"</span>, out_dir))\n                       .status().unwrap();\n    Command::new(<span class=\"hljs-string\">\"ar\"</span>).args(&amp;[<span class=\"hljs-string\">\"crus\"</span>, <span class=\"hljs-string\">\"libhello.a\"</span>, <span class=\"hljs-string\">\"hello.o\"</span>])\n                      .current_dir(&amp;Path::new(&amp;out_dir))\n                      .status().unwrap();\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-link-search=native={}\"</span>, out_dir);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-link-lib=static=hello\"</span>);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rerun-if-changed=src/hello.c\"</span>);\n}</code></pre></pre>\n<p>This build script starts out by compiling our C file into an object file (by\ninvoking <code class=\"hljs\">gcc</code>) and then converting this object file into a static library (by\ninvoking <code class=\"hljs\">ar</code>). The final step is feedback to Cargo itself to say that our\noutput was in <code class=\"hljs\">out_dir</code> and the compiler should link the crate to <code class=\"hljs\">libhello.a</code>\nstatically via the <code class=\"hljs\">-l static=hello</code> flag.</p>\n<p>Note that there are a number of drawbacks to this hard-coded approach:</p>\n<ul>\n<li>The <code class=\"hljs\">gcc</code> command itself is not portable across platforms. For example it’s\nunlikely that Windows platforms have <code class=\"hljs\">gcc</code>, and not even all Unix platforms\nmay have <code class=\"hljs\">gcc</code>. The <code class=\"hljs\">ar</code> command is also in a similar situation.</li>\n<li>These commands do not take cross-compilation into account. If we’re cross\ncompiling for a platform such as Android it’s unlikely that <code class=\"hljs\">gcc</code> will produce\nan ARM executable.</li>\n</ul>\n<p>Not to fear, though, this is where a <code class=\"hljs\">build-dependencies</code> entry would help!\nThe Cargo ecosystem has a number of packages to make this sort of task much\neasier, portable, and standardized. Let’s try the <a href=\"https://crates.io/crates/cc\"><code class=\"hljs\">cc</code>\ncrate</a> from <a href=\"https://crates.io/\">crates.io</a>. First, add it to the\n<code class=\"hljs\">build-dependencies</code> in <code class=\"hljs\">Cargo.toml</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-section\">[build-dependencies]</span>\n<span class=\"hljs-attr\">cc</span> = <span class=\"hljs-string\">\"1.0\"</span>\n</code></pre>\n<p>And rewrite the build script to use this crate:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// build.rs</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    cc::Build::new()\n        .file(<span class=\"hljs-string\">\"src/hello.c\"</span>)\n        .compile(<span class=\"hljs-string\">\"hello\"</span>);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rerun-if-changed=src/hello.c\"</span>);\n}</code></pre>\n<p>The <a href=\"https://crates.io/crates/cc\"><code class=\"hljs\">cc</code> crate</a> abstracts a range of build script requirements for C code:</p>\n<ul>\n<li>It invokes the appropriate compiler (MSVC for windows, <code class=\"hljs\">gcc</code> for MinGW, <code class=\"hljs\">cc</code>\nfor Unix platforms, etc.).</li>\n<li>It takes the <code class=\"hljs\">TARGET</code> variable into account by passing appropriate flags to\nthe compiler being used.</li>\n<li>Other environment variables, such as <code class=\"hljs\">OPT_LEVEL</code>, <code class=\"hljs\">DEBUG</code>, etc., are all\nhandled automatically.</li>\n<li>The stdout output and <code class=\"hljs\">OUT_DIR</code> locations are also handled by the <code class=\"hljs\">cc</code>\nlibrary.</li>\n</ul>\n<p>Here we can start to see some of the major benefits of farming as much\nfunctionality as possible out to common build dependencies rather than\nduplicating logic across all build scripts!</p>\n<p>Back to the case study though, let’s take a quick look at the contents of the\n<code class=\"hljs\">src</code> directory:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-comment\">// src/hello.c</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Hello, World!\\n\"</span>);\n}\n</code></pre>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// src/main.rs</span>\n\n<span class=\"hljs-comment\">// Note the lack of the `#[link]` attribute. We’re delegating the responsibility</span>\n<span class=\"hljs-comment\">// of selecting what to link over to the build script rather than hard-coding</span>\n<span class=\"hljs-comment\">// it in the source file.</span>\n<span class=\"hljs-keyword\">extern</span> { <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello</span></span>(); }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">unsafe</span> { hello(); }\n}</code></pre>\n<p>And there we go! This should complete our example of building some C code from a\nCargo package using the build script itself. This also shows why using a build\ndependency can be crucial in many situations and even much more concise!</p>\n<p>We’ve also seen a brief example of how a build script can use a crate as a\ndependency purely for the build process and not for the crate itself at runtime.</p>\n<h2 id=\"linking-to-system-libraries\"><a class=\"header\" href=\"#linking-to-system-libraries\">Linking to system libraries</a></h2>\n<p>This example demonstrates how to link a system library and how the build\nscript is used to support this use case.</p>\n<p>Quite frequently a Rust crate wants to link to a native library provided on\nthe system to bind its functionality or just use it as part of an\nimplementation detail. This is quite a nuanced problem when it comes to\nperforming this in a platform-agnostic fashion. It is best, if possible, to\nfarm out as much of this as possible to make this as easy as possible for\nconsumers.</p>\n<p>For this example, we will be creating a binding to the system’s zlib library.\nThis is a library that is commonly found on most Unix-like systems that\nprovides data compression. This is already wrapped up in the <a href=\"https://crates.io/crates/libz-sys\"><code class=\"hljs\">libz-sys</code>\ncrate</a>, but for this example, we’ll do an extremely simplified version. Check\nout <a href=\"https://github.com/rust-lang/libz-sys\">the source code</a> for the full example.</p>\n<p>To make it easy to find the location of the library, we will use the\n<a href=\"https://crates.io/crates/pkg-config\"><code class=\"hljs\">pkg-config</code> crate</a>. This crate uses the system’s <code class=\"hljs\">pkg-config</code> utility to\ndiscover information about a library. It will automatically tell Cargo what is\nneeded to link the library. This will likely only work on Unix-like systems\nwith <code class=\"hljs\">pkg-config</code> installed. Let’s start by setting up the manifest:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Cargo.toml</span>\n\n<span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"libz-sys\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2021\"</span>\n<span class=\"hljs-attr\">links</span> = <span class=\"hljs-string\">\"z\"</span>\n\n<span class=\"hljs-section\">[build-dependencies]</span>\n<span class=\"hljs-attr\">pkg-config</span> = <span class=\"hljs-string\">\"0.3.16\"</span>\n</code></pre>\n<p>Take note that we included the <code class=\"hljs\">links</code> key in the <code class=\"hljs\">package</code> table. This tells\nCargo that we are linking to the <code class=\"hljs\">libz</code> library. See <a href=\"#using-another-sys-crate\">“Using another sys\ncrate”</a> for an example that will leverage this.</p>\n<p>The build script is fairly simple:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// build.rs</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    pkg_config::Config::new().probe(<span class=\"hljs-string\">\"zlib\"</span>).unwrap();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rerun-if-changed=build.rs\"</span>);\n}</code></pre>\n<p>Let’s round out the example with a basic FFI binding:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// src/lib.rs</span>\n\n<span class=\"hljs-keyword\">use</span> std::os::raw::{c_uint, c_ulong};\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">crc32</span></span>(crc: c_ulong, buf: *<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">u8</span>, len: c_uint) -&gt; c_ulong;\n}\n\n<span class=\"hljs-meta\">#[test]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">test_crc32</span></span>() {\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-string\">\"hello\"</span>;\n    <span class=\"hljs-keyword\">unsafe</span> {\n        <span class=\"hljs-built_in\">assert_eq!</span>(crc32(<span class=\"hljs-number\">0</span>, s.as_ptr(), s.len() <span class=\"hljs-keyword\">as</span> c_uint), <span class=\"hljs-number\">0x3610a686</span>);\n    }\n}</code></pre>\n<p>Run <code class=\"hljs\">cargo build -vv</code> to see the output from the build script. On a system\nwith <code class=\"hljs\">libz</code> already installed, it may look something like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">[libz-sys 0.1.0] cargo::rustc-link-search=native=/usr/lib\n[libz-sys 0.1.0] cargo::rustc-link-lib=z\n[libz-sys 0.1.0] cargo::rerun-if-changed=build.rs\n</code></pre>\n<p>Nice! <code class=\"hljs\">pkg-config</code> did all the work of finding the library and telling Cargo\nwhere it is.</p>\n<p>It is not unusual for packages to include the source for the library, and\nbuild it statically if it is not found on the system, or if a feature or\nenvironment variable is set. For example, the real <a href=\"https://crates.io/crates/libz-sys\"><code class=\"hljs\">libz-sys</code> crate</a> checks the\nenvironment variable <code class=\"hljs\">LIBZ_SYS_STATIC</code> or the <code class=\"hljs\">static</code> feature to build it\nfrom source instead of using the system library. Check out <a href=\"https://github.com/rust-lang/libz-sys\">the\nsource</a> for a more complete example.</p>\n<h2 id=\"using-another-sys-crate\"><a class=\"header\" href=\"#using-another-sys-crate\">Using another <code>sys</code> crate</a></h2>\n<p>When using the <code class=\"hljs\">links</code> key, crates may set metadata that can be read by other\ncrates that depend on it. This provides a mechanism to communicate information\nbetween crates. In this example, we’ll be creating a C library that makes use\nof zlib from the real <a href=\"https://crates.io/crates/libz-sys\"><code class=\"hljs\">libz-sys</code> crate</a>.</p>\n<p>If you have a C library that depends on zlib, you can leverage the <a href=\"https://crates.io/crates/libz-sys\"><code class=\"hljs\">libz-sys</code>\ncrate</a> to automatically find it or build it. This is great for cross-platform\nsupport, such as Windows where zlib is not usually installed. <code class=\"hljs\">libz-sys</code> <a href=\"https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156\">sets\nthe <code class=\"hljs\">include</code>\nmetadata</a>\nto tell other packages where to find the header files for zlib. Our build\nscript can read that metadata with the <code class=\"hljs\">DEP_Z_INCLUDE</code> environment variable.\nHere’s an example:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-toml hljs ini\"><span class=\"hljs-comment\"># Cargo.toml</span>\n\n<span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"zuser\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">edition</span> = <span class=\"hljs-string\">\"2021\"</span>\n\n<span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">libz-sys</span> = <span class=\"hljs-string\">\"1.0.25\"</span>\n\n<span class=\"hljs-section\">[build-dependencies]</span>\n<span class=\"hljs-attr\">cc</span> = <span class=\"hljs-string\">\"1.0.46\"</span>\n</code></pre>\n<p>Here we have included <code class=\"hljs\">libz-sys</code> which will ensure that there is only one\n<code class=\"hljs\">libz</code> used in the final library, and give us access to it from our build\nscript:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// build.rs</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> cfg = cc::Build::new();\n    cfg.file(<span class=\"hljs-string\">\"src/zuser.c\"</span>);\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(include) = std::env::var_os(<span class=\"hljs-string\">\"DEP_Z_INCLUDE\"</span>) {\n        cfg.include(include);\n    }\n    cfg.compile(<span class=\"hljs-string\">\"zuser\"</span>);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rerun-if-changed=src/zuser.c\"</span>);\n}</code></pre>\n<p>With <code class=\"hljs\">libz-sys</code> doing all the heavy lifting, the C source code may now include\nthe zlib header, and it should find the header, even on systems where it isn’t\nalready installed.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-c hljs\"><span class=\"hljs-comment\">// src/zuser.c</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">\"zlib.h\"</span></span>\n\n<span class=\"hljs-comment\">// … rest of code that makes use of zlib.</span>\n</code></pre>\n<h2 id=\"conditional-compilation\"><a class=\"header\" href=\"#conditional-compilation\">Conditional compilation</a></h2>\n<p>A build script may emit <a href=\"build-scripts.html#rustc-cfg\"><code class=\"hljs\">rustc-cfg</code> instructions</a> which can enable conditions\nthat can be checked at compile time. In this example, we’ll take a look at how\nthe <a href=\"https://crates.io/crates/openssl\"><code class=\"hljs\">openssl</code> crate</a> uses this to support multiple versions of the OpenSSL\nlibrary.</p>\n<p>The <a href=\"https://crates.io/crates/openssl-sys\"><code class=\"hljs\">openssl-sys</code> crate</a> implements building and linking the OpenSSL library.\nIt supports multiple different implementations (like LibreSSL) and multiple\nversions. It makes use of the <code class=\"hljs\">links</code> key so that it may pass information to\nother build scripts. One of the things it passes is the <code class=\"hljs\">version_number</code> key,\nwhich is the version of OpenSSL that was detected. The code in the build\nscript looks something <a href=\"https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216\">like\nthis</a>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::version_number={:x}\"</span>, openssl_version);</code></pre>\n<p>This instruction causes the <code class=\"hljs\">DEP_OPENSSL_VERSION_NUMBER</code> environment variable\nto be set in any crates that directly depend on <code class=\"hljs\">openssl-sys</code>.</p>\n<p>The <code class=\"hljs\">openssl</code> crate, which provides the higher-level interface, specifies\n<code class=\"hljs\">openssl-sys</code> as a dependency. The <code class=\"hljs\">openssl</code> build script can read the\nversion information generated by the <code class=\"hljs\">openssl-sys</code> build script with the\n<code class=\"hljs\">DEP_OPENSSL_VERSION_NUMBER</code> environment variable. It uses this to generate\nsome <a href=\"https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36\"><code class=\"hljs\">cfg</code>\nvalues</a>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// (portion of build.rs)</span>\n\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-check-cfg=cfg(ossl101,ossl102)\"</span>);\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-check-cfg=cfg(ossl110,ossl110g,ossl111)\"</span>);\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Ok</span>(version) = env::var(<span class=\"hljs-string\">\"DEP_OPENSSL_VERSION_NUMBER\"</span>) {\n    <span class=\"hljs-keyword\">let</span> version = <span class=\"hljs-built_in\">u64</span>::from_str_radix(&amp;version, <span class=\"hljs-number\">16</span>).unwrap();\n\n    <span class=\"hljs-keyword\">if</span> version &gt;= <span class=\"hljs-number\">0x1_00_01_00_0</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-cfg=ossl101\"</span>);\n    }\n    <span class=\"hljs-keyword\">if</span> version &gt;= <span class=\"hljs-number\">0x1_00_02_00_0</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-cfg=ossl102\"</span>);\n    }\n    <span class=\"hljs-keyword\">if</span> version &gt;= <span class=\"hljs-number\">0x1_01_00_00_0</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-cfg=ossl110\"</span>);\n    }\n    <span class=\"hljs-keyword\">if</span> version &gt;= <span class=\"hljs-number\">0x1_01_00_07_0</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-cfg=ossl110g\"</span>);\n    }\n    <span class=\"hljs-keyword\">if</span> version &gt;= <span class=\"hljs-number\">0x1_01_01_00_0</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"cargo::rustc-cfg=ossl111\"</span>);\n    }\n}</code></pre>\n<p>These <code class=\"hljs\">cfg</code> values can then be used with the <a href=\"../../reference/conditional-compilation.html#the-cfg-attribute\"><code class=\"hljs\">cfg</code> attribute</a> or the <a href=\"../../std/macro.cfg.html\"><code class=\"hljs\">cfg</code>\nmacro</a> to conditionally include code. For example, SHA3 support was added in\nOpenSSL 1.1.1, so it is <a href=\"https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85\">conditionally\nexcluded</a>\nfor older versions:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// (portion of openssl crate)</span>\n\n<span class=\"hljs-meta\">#[cfg(ossl111)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">sha3_224</span></span>() -&gt; MessageDigest {\n    <span class=\"hljs-keyword\">unsafe</span> { MessageDigest(ffi::EVP_sha3_224()) }\n}</code></pre>\n<p>Of course, one should be careful when using this, since it makes the resulting\nbinary even more dependent on the build environment. In this example, if the\nbinary is distributed to another system, it may not have the exact same shared\nlibraries, which could cause problems.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../reference/build-scripts.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../reference/publishing.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../reference/build-scripts.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../reference/publishing.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:09:22.537Z"
}