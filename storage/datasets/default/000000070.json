{
	"title": "Treating Smart Pointers Like Regular References with the Deref Trait - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch15-02-deref.html",
	"markdown": "# Treating Smart Pointers Like Regular References with the Deref Trait\n\nImplementing the `Deref` trait allows you to customize the behavior of the _dereference operator_ `*` (not to be confused with the multiplication or glob operator). By implementing `Deref` in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.\n\nLet’s first look at how the dereference operator works with regular references. Then we’ll try to define a custom type that behaves like `Box<T>`, and see why the dereference operator doesn’t work like a reference on our newly defined type. We’ll explore how implementing the `Deref` trait makes it possible for smart pointers to work in ways similar to references. Then we’ll look at Rust’s _deref coercion_ feature and how it lets us work with either references or smart pointers.\n\nNote: There’s one big difference between the `MyBox<T>` type we’re about to build and the real `Box<T>`: our version will not store its data on the heap. We are focusing this example on `Deref`, so where the data is actually stored is less important than the pointer-like behavior.\n\n### [Following the Pointer to the Value](#following-the-pointer-to-the-value)\n\nA regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an `i32` value and then use the dereference operator to follow the reference to the value:\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\nListing 15-6: Using the dereference operator to follow a reference to an `i32` value\n\nThe variable `x` holds an `i32` value `5`. We set `y` equal to a reference to `x`. We can assert that `x` is equal to `5`. However, if we want to make an assertion about the value in `y`, we have to use `*y` to follow the reference to the value it’s pointing to (hence _dereference_) so the compiler can compare the actual value. Once we dereference `y`, we have access to the integer value `y` is pointing to that we can compare with `5`.\n\nIf we tried to write `assert_eq!(5, y);` instead, we would get this compilation error:\n\n```console\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0277]: can't compare `{integer}` with `&{integer}`\n --> src/main.rs:6:5\n  |\n6 |     assert_eq!(5, y);\n  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n  |\n  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `deref-example` (bin \"deref-example\") due to 1 previous error\n\n```\n\nComparing a number and a reference to a number isn’t allowed because they’re different types. We must use the dereference operator to follow the reference to the value it’s pointing to.\n\n### [Using `Box<T>` Like a Reference](#using-boxt-like-a-reference)\n\nWe can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a reference; the dereference operator used on the `Box<T>` in Listing 15-7 functions in the same way as the dereference operator used on the reference in Listing 15-6:\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\nListing 15-7: Using the dereference operator on a `Box<i32>`\n\nThe main difference between Listing 15-7 and Listing 15-6 is that here we set `y` to be an instance of a `Box<T>` pointing to a copied value of `x` rather than a reference pointing to the value of `x`. In the last assertion, we can use the dereference operator to follow the pointer of the `Box<T>` in the same way that we did when `y` was a reference. Next, we’ll explore what is special about `Box<T>` that enables us to use the dereference operator by defining our own type.\n\n### [Defining Our Own Smart Pointer](#defining-our-own-smart-pointer)\n\nLet’s build a smart pointer similar to the `Box<T>` type provided by the standard library to experience how smart pointers behave differently from references by default. Then we’ll look at how to add the ability to use the dereference operator.\n\nThe `Box<T>` type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a `MyBox<T>` type in the same way. We’ll also define a `new` function to match the `new` function defined on `Box<T>`.\n\nFilename: src/main.rs\n\n```rust\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nfn main() {}\n```\n\nListing 15-8: Defining a `MyBox<T>` type\n\nWe define a struct named `MyBox` and declare a generic parameter `T`, because we want our type to hold values of any type. The `MyBox` type is a tuple struct with one element of type `T`. The `MyBox::new` function takes one parameter of type `T` and returns a `MyBox` instance that holds the value passed in.\n\nLet’s try adding the `main` function in Listing 15-7 to Listing 15-8 and changing it to use the `MyBox<T>` type we’ve defined instead of `Box<T>`. The code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference `MyBox`.\n\nFilename: src/main.rs\n\n```rust\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\nListing 15-9: Attempting to use `MyBox<T>` in the same way we used references and `Box<T>`\n\nHere’s the resulting compilation error:\n\n```console\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0614]: type `MyBox<{integer}>` cannot be dereferenced\n  --> src/main.rs:14:19\n   |\n14 |     assert_eq!(5, *y);\n   |                   ^^\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `deref-example` (bin \"deref-example\") due to 1 previous error\n\n```\n\nOur `MyBox<T>` type can’t be dereferenced because we haven’t implemented that ability on our type. To enable dereferencing with the `*` operator, we implement the `Deref` trait.\n\n### [Treating a Type Like a Reference by Implementing the `Deref` Trait](#treating-a-type-like-a-reference-by-implementing-the-deref-trait)\n\nAs discussed in the [“Implementing a Trait on a Type”](about:blank/ch10-02-traits.html#implementing-a-trait-on-a-type) section of Chapter 10, to implement a trait, we need to provide implementations for the trait’s required methods. The `Deref` trait, provided by the standard library, requires us to implement one method named `deref` that borrows `self` and returns a reference to the inner data. Listing 15-10 contains an implementation of `Deref` to add to the definition of `MyBox`:\n\nFilename: src/main.rs\n\n```rust\nuse std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\nListing 15-10: Implementing `Deref` on `MyBox<T>`\n\nThe `type Target = T;` syntax defines an associated type for the `Deref` trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don’t need to worry about them for now; we’ll cover them in more detail in Chapter 19.\n\nWe fill in the body of the `deref` method with `&self.0` so `deref` returns a reference to the value we want to access with the `*` operator; recall from the [“Using Tuple Structs without Named Fields to Create Different Types”](about:blank/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types) section of Chapter 5 that `.0` accesses the first value in a tuple struct. The `main` function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles, and the assertions pass!\n\nWithout the `Deref` trait, the compiler can only dereference `&` references. The `deref` method gives the compiler the ability to take a value of any type that implements `Deref` and call the `deref` method to get a `&` reference that it knows how to dereference.\n\nWhen we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this code:\n\n```rust\n*(y.deref())\n```\n\nRust substitutes the `*` operator with a call to the `deref` method and then a plain dereference so we don’t have to think about whether or not we need to call the `deref` method. This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements `Deref`.\n\nThe reason the `deref` method returns a reference to a value, and that the plain dereference outside the parentheses in `*(y.deref())` is still necessary, is to do with the ownership system. If the `deref` method returned the value directly instead of a reference to the value, the value would be moved out of `self`. We don’t want to take ownership of the inner value inside `MyBox<T>` in this case or in most cases where we use the dereference operator.\n\nNote that the `*` operator is replaced with a call to the `deref` method and then a call to the `*` operator just once, each time we use a `*` in our code. Because the substitution of the `*` operator does not recurse infinitely, we end up with data of type `i32`, which matches the `5` in `assert_eq!` in Listing 15-9.\n\n### [Implicit Deref Coercions with Functions and Methods](#implicit-deref-coercions-with-functions-and-methods)\n\n_Deref coercion_ converts a reference to a type that implements the `Deref` trait into a reference to another type. For example, deref coercion can convert `&String` to `&str` because `String` implements the `Deref` trait such that it returns `&str`. Deref coercion is a convenience Rust performs on arguments to functions and methods, and works only on types that implement the `Deref` trait. It happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the `deref` method converts the type we provided into the type the parameter needs.\n\nDeref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with `&` and `*`. The deref coercion feature also lets us write more code that can work for either references or smart pointers.\n\nTo see deref coercion in action, let’s use the `MyBox<T>` type we defined in Listing 15-8 as well as the implementation of `Deref` that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter:\n\nFilename: src/main.rs\n\n```rust\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {}\n```\n\nListing 15-11: A `hello` function that has the parameter `name` of type `&str`\n\nWe can call the `hello` function with a string slice as an argument, such as `hello(\"Rust\");` for example. Deref coercion makes it possible to call `hello` with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12:\n\nFilename: src/main.rs\n\n```rust\nuse std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&m);\n}\n```\n\nListing 15-12: Calling `hello` with a reference to a `MyBox<String>` value, which works because of deref coercion\n\nHere we’re calling the `hello` function with the argument `&m`, which is a reference to a `MyBox<String>` value. Because we implemented the `Deref` trait on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String` by calling `deref`. The standard library provides an implementation of `Deref` on `String` that returns a string slice, and this is in the API documentation for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which matches the `hello` function’s definition.\n\nIf Rust didn’t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value of type `&MyBox<String>`.\n\nFilename: src/main.rs\n\n```rust\nuse std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}\n```\n\nListing 15-13: The code we would have to write if Rust didn’t have deref coercion\n\nThe `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and `[..]` take a string slice of the `String` that is equal to the whole string to match the signature of `hello`. This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.\n\nWhen the `Deref` trait is defined for the types involved, Rust will analyze the types and use `Deref::deref` as many times as necessary to get a reference to match the parameter’s type. The number of times that `Deref::deref` needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!\n\n### [How Deref Coercion Interacts with Mutability](#how-deref-coercion-interacts-with-mutability)\n\nSimilar to how you use the `Deref` trait to override the `*` operator on immutable references, you can use the `DerefMut` trait to override the `*` operator on mutable references.\n\nRust does deref coercion when it finds types and trait implementations in three cases:\n\n-   From `&T` to `&U` when `T: Deref<Target=U>`\n-   From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`\n-   From `&mut T` to `&U` when `T: Deref<Target=U>`\n\nThe first two cases are the same as each other except that the second implements mutability. The first case states that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can get a `&U` transparently. The second case states that the same deref coercion happens for mutable references.\n\nThe third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is _not_ possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Treating Smart Pointers Like Regular References with the Deref Trait - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"treating-smart-pointers-like-regular-references-with-the-deref-trait\"><a class=\"header\" href=\"#treating-smart-pointers-like-regular-references-with-the-deref-trait\">Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></h2>\n<p>Implementing the <code class=\"hljs\">Deref</code> trait allows you to customize the behavior of the\n<em>dereference operator</em> <code class=\"hljs\">*</code> (not to be confused with the multiplication or glob\noperator). By implementing <code class=\"hljs\">Deref</code> in such a way that a smart pointer can be\ntreated like a regular reference, you can write code that operates on\nreferences and use that code with smart pointers too.</p>\n<p>Let’s first look at how the dereference operator works with regular references.\nThen we’ll try to define a custom type that behaves like <code class=\"hljs\">Box&lt;T&gt;</code>, and see why\nthe dereference operator doesn’t work like a reference on our newly defined\ntype. We’ll explore how implementing the <code class=\"hljs\">Deref</code> trait makes it possible for\nsmart pointers to work in ways similar to references. Then we’ll look at\nRust’s <em>deref coercion</em> feature and how it lets us work with either references\nor smart pointers.</p>\n<section class=\"note\" aria-role=\"note\">\n<p>Note: There’s one big difference between the <code class=\"hljs\">MyBox&lt;T&gt;</code> type we’re about to\nbuild and the real <code class=\"hljs\">Box&lt;T&gt;</code>: our version will not store its data on the heap.\nWe are focusing this example on <code class=\"hljs\">Deref</code>, so where the data is actually stored\nis less important than the pointer-like behavior.</p>\n</section>\n<!-- Old link, do not remove -->\n<p><a id=\"following-the-pointer-to-the-value-with-the-dereference-operator\"></a></p>\n<h3 id=\"following-the-pointer-to-the-value\"><a class=\"header\" href=\"#following-the-pointer-to-the-value\">Following the Pointer to the Value</a></h3>\n<p>A regular reference is a type of pointer, and one way to think of a pointer is\nas an arrow to a value stored somewhere else. In Listing 15-6, we create a\nreference to an <code class=\"hljs\">i32</code> value and then use the dereference operator to follow the\nreference to the value:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y = &amp;x;\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, *y);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-6: Using the dereference operator to follow a\nreference to an <code class=\"hljs\">i32</code> value</span></p>\n<p>The variable <code class=\"hljs\">x</code> holds an <code class=\"hljs\">i32</code> value <code class=\"hljs\">5</code>. We set <code class=\"hljs\">y</code> equal to a reference to\n<code class=\"hljs\">x</code>. We can assert that <code class=\"hljs\">x</code> is equal to <code class=\"hljs\">5</code>. However, if we want to make an\nassertion about the value in <code class=\"hljs\">y</code>, we have to use <code class=\"hljs\">*y</code> to follow the reference\nto the value it’s pointing to (hence <em>dereference</em>) so the compiler can compare\nthe actual value. Once we dereference <code class=\"hljs\">y</code>, we have access to the integer value\n<code class=\"hljs\">y</code> is pointing to that we can compare with <code class=\"hljs\">5</code>.</p>\n<p>If we tried to write <code class=\"hljs\">assert_eq!(5, y);</code> instead, we would get this compilation\nerror:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0277]: can't compare `{integer}` with `&amp;{integer}`\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:6:5</span>\n  |\n6 |     assert_eq!(5, y);\n  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`\n  |\n  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `deref-example` (bin \"deref-example\") due to 1 previous error\n</code></pre>\n<p>Comparing a number and a reference to a number isn’t allowed because they’re\ndifferent types. We must use the dereference operator to follow the reference\nto the value it’s pointing to.</p>\n<h3 id=\"using-boxt-like-a-reference\"><a class=\"header\" href=\"#using-boxt-like-a-reference\">Using <code>Box&lt;T&gt;</code> Like a Reference</a></h3>\n<p>We can rewrite the code in Listing 15-6 to use a <code class=\"hljs\">Box&lt;T&gt;</code> instead of a\nreference; the dereference operator used on the <code class=\"hljs\">Box&lt;T&gt;</code> in Listing 15-7\nfunctions in the same way as the dereference operator used on the reference in\nListing 15-6:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-built_in\">Box</span>::new(x);\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, *y);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-7: Using the dereference operator on a\n<code class=\"hljs\">Box&lt;i32&gt;</code></span></p>\n<p>The main difference between Listing 15-7 and Listing 15-6 is that here we set\n<code class=\"hljs\">y</code> to be an instance of a <code class=\"hljs\">Box&lt;T&gt;</code> pointing to a copied value of <code class=\"hljs\">x</code> rather\nthan a reference pointing to the value of <code class=\"hljs\">x</code>. In the last assertion, we can\nuse the dereference operator to follow the pointer of the <code class=\"hljs\">Box&lt;T&gt;</code> in the same\nway that we did when <code class=\"hljs\">y</code> was a reference. Next, we’ll explore what is special\nabout <code class=\"hljs\">Box&lt;T&gt;</code> that enables us to use the dereference operator by defining our\nown type.</p>\n<h3 id=\"defining-our-own-smart-pointer\"><a class=\"header\" href=\"#defining-our-own-smart-pointer\">Defining Our Own Smart Pointer</a></h3>\n<p>Let’s build a smart pointer similar to the <code class=\"hljs\">Box&lt;T&gt;</code> type provided by the\nstandard library to experience how smart pointers behave differently from\nreferences by default. Then we’ll look at how to add the ability to use the\ndereference operator.</p>\n<p>The <code class=\"hljs\">Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so\nListing 15-8 defines a <code class=\"hljs\">MyBox&lt;T&gt;</code> type in the same way. We’ll also define a\n<code class=\"hljs\">new</code> function to match the <code class=\"hljs\">new</code> function defined on <code class=\"hljs\">Box&lt;T&gt;</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBox</span></span>&lt;T&gt;(T);\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x)\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 15-8: Defining a <code class=\"hljs\">MyBox&lt;T&gt;</code> type</span></p>\n<p>We define a struct named <code class=\"hljs\">MyBox</code> and declare a generic parameter <code class=\"hljs\">T</code>, because\nwe want our type to hold values of any type. The <code class=\"hljs\">MyBox</code> type is a tuple struct\nwith one element of type <code class=\"hljs\">T</code>. The <code class=\"hljs\">MyBox::new</code> function takes one parameter of\ntype <code class=\"hljs\">T</code> and returns a <code class=\"hljs\">MyBox</code> instance that holds the value passed in.</p>\n<p>Let’s try adding the <code class=\"hljs\">main</code> function in Listing 15-7 to Listing 15-8 and\nchanging it to use the <code class=\"hljs\">MyBox&lt;T&gt;</code> type we’ve defined instead of <code class=\"hljs\">Box&lt;T&gt;</code>. The\ncode in Listing 15-9 won’t compile because Rust doesn’t know how to dereference\n<code class=\"hljs\">MyBox</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBox</span></span>&lt;T&gt;(T);\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">        MyBox(x)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y = MyBox::new(x);\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, *y);\n}</code></pre>\n<p><span class=\"caption\">Listing 15-9: Attempting to use <code class=\"hljs\">MyBox&lt;T&gt;</code> in the same\nway we used references and <code class=\"hljs\">Box&lt;T&gt;</code></span></p>\n<p>Here’s the resulting compilation error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/main.rs:14:19</span>\n   |\n14 |     assert_eq!(5, *y);\n   |                   ^^\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `deref-example` (bin \"deref-example\") due to 1 previous error\n</code></pre>\n<p>Our <code class=\"hljs\">MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that\nability on our type. To enable dereferencing with the <code class=\"hljs\">*</code> operator, we\nimplement the <code class=\"hljs\">Deref</code> trait.</p>\n<h3 id=\"treating-a-type-like-a-reference-by-implementing-the-deref-trait\"><a class=\"header\" href=\"#treating-a-type-like-a-reference-by-implementing-the-deref-trait\">Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</a></h3>\n<p>As discussed in the <a href=\"ch10-02-traits.html#implementing-a-trait-on-a-type\">“Implementing a Trait on a Type”</a><!-- ignore\n--> section of Chapter 10, to implement a trait, we need to provide\nimplementations for the trait’s required methods. The <code class=\"hljs\">Deref</code> trait, provided\nby the standard library, requires us to implement one method named <code class=\"hljs\">deref</code> that\nborrows <code class=\"hljs\">self</code> and returns a reference to the inner data. Listing 15-10\ncontains an implementation of <code class=\"hljs\">Deref</code> to add to the definition of <code class=\"hljs\">MyBox</code>:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-keyword\">use</span> std::ops::Deref;\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Deref <span class=\"hljs-keyword\">for</span> MyBox&lt;T&gt; {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = T;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;Self::Target {\n        &amp;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBox</span></span>&lt;T&gt;(T);\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">        MyBox(x)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> y = MyBox::new(x);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, *y);\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 15-10: Implementing <code class=\"hljs\">Deref</code> on <code class=\"hljs\">MyBox&lt;T&gt;</code></span></p>\n<p>The <code class=\"hljs\">type Target = T;</code> syntax defines an associated type for the <code class=\"hljs\">Deref</code>\ntrait to use. Associated types are a slightly different way of declaring a\ngeneric parameter, but you don’t need to worry about them for now; we’ll cover\nthem in more detail in Chapter 19.</p>\n<p>We fill in the body of the <code class=\"hljs\">deref</code> method with <code class=\"hljs\">&amp;self.0</code> so <code class=\"hljs\">deref</code> returns a\nreference to the value we want to access with the <code class=\"hljs\">*</code> operator; recall from the\n<a href=\"ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types\">“Using Tuple Structs without Named Fields to Create Different\nTypes”</a><!-- ignore --> section of Chapter 5 that <code class=\"hljs\">.0</code> accesses\nthe first value in a tuple struct. The <code class=\"hljs\">main</code> function in Listing 15-9 that\ncalls <code class=\"hljs\">*</code> on the <code class=\"hljs\">MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>\n<p>Without the <code class=\"hljs\">Deref</code> trait, the compiler can only dereference <code class=\"hljs\">&amp;</code> references.\nThe <code class=\"hljs\">deref</code> method gives the compiler the ability to take a value of any type\nthat implements <code class=\"hljs\">Deref</code> and call the <code class=\"hljs\">deref</code> method to get a <code class=\"hljs\">&amp;</code> reference that\nit knows how to dereference.</p>\n<p>When we entered <code class=\"hljs\">*y</code> in Listing 15-9, behind the scenes Rust actually ran this\ncode:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\">*(y.deref())</code></pre>\n<p>Rust substitutes the <code class=\"hljs\">*</code> operator with a call to the <code class=\"hljs\">deref</code> method and then a\nplain dereference so we don’t have to think about whether or not we need to\ncall the <code class=\"hljs\">deref</code> method. This Rust feature lets us write code that functions\nidentically whether we have a regular reference or a type that implements\n<code class=\"hljs\">Deref</code>.</p>\n<p>The reason the <code class=\"hljs\">deref</code> method returns a reference to a value, and that the\nplain dereference outside the parentheses in <code class=\"hljs\">*(y.deref())</code> is still necessary,\nis to do with the ownership system. If the <code class=\"hljs\">deref</code> method returned the value\ndirectly instead of a reference to the value, the value would be moved out of\n<code class=\"hljs\">self</code>. We don’t want to take ownership of the inner value inside <code class=\"hljs\">MyBox&lt;T&gt;</code> in\nthis case or in most cases where we use the dereference operator.</p>\n<p>Note that the <code class=\"hljs\">*</code> operator is replaced with a call to the <code class=\"hljs\">deref</code> method and\nthen a call to the <code class=\"hljs\">*</code> operator just once, each time we use a <code class=\"hljs\">*</code> in our code.\nBecause the substitution of the <code class=\"hljs\">*</code> operator does not recurse infinitely, we\nend up with data of type <code class=\"hljs\">i32</code>, which matches the <code class=\"hljs\">5</code> in <code class=\"hljs\">assert_eq!</code> in\nListing 15-9.</p>\n<h3 id=\"implicit-deref-coercions-with-functions-and-methods\"><a class=\"header\" href=\"#implicit-deref-coercions-with-functions-and-methods\">Implicit Deref Coercions with Functions and Methods</a></h3>\n<p><em>Deref coercion</em> converts a reference to a type that implements the <code class=\"hljs\">Deref</code>\ntrait into a reference to another type. For example, deref coercion can convert\n<code class=\"hljs\">&amp;String</code> to <code class=\"hljs\">&amp;str</code> because <code class=\"hljs\">String</code> implements the <code class=\"hljs\">Deref</code> trait such that it\nreturns <code class=\"hljs\">&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to\nfunctions and methods, and works only on types that implement the <code class=\"hljs\">Deref</code>\ntrait. It happens automatically when we pass a reference to a particular type’s\nvalue as an argument to a function or method that doesn’t match the parameter\ntype in the function or method definition. A sequence of calls to the <code class=\"hljs\">deref</code>\nmethod converts the type we provided into the type the parameter needs.</p>\n<p>Deref coercion was added to Rust so that programmers writing function and\nmethod calls don’t need to add as many explicit references and dereferences\nwith <code class=\"hljs\">&amp;</code> and <code class=\"hljs\">*</code>. The deref coercion feature also lets us write more code that\ncan work for either references or smart pointers.</p>\n<p>To see deref coercion in action, let’s use the <code class=\"hljs\">MyBox&lt;T&gt;</code> type we defined in\nListing 15-8 as well as the implementation of <code class=\"hljs\">Deref</code> that we added in Listing\n15-10. Listing 15-11 shows the definition of a function that has a string slice\nparameter:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello</span></span>(name: &amp;<span class=\"hljs-built_in\">str</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello, {name}!\"</span>);\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 15-11: A <code class=\"hljs\">hello</code> function that has the parameter\n<code class=\"hljs\">name</code> of type <code class=\"hljs\">&amp;str</code></span></p>\n<p>We can call the <code class=\"hljs\">hello</code> function with a string slice as an argument, such as\n<code class=\"hljs\">hello(\"Rust\");</code> for example. Deref coercion makes it possible to call <code class=\"hljs\">hello</code>\nwith a reference to a value of type <code class=\"hljs\">MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::ops::Deref;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; Deref <span class=\"hljs-keyword\">for</span> MyBox&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = T;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;T {\n</span><span class=\"boring\">        &amp;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBox</span></span>&lt;T&gt;(T);\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">        MyBox(x)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello</span></span>(name: &amp;<span class=\"hljs-built_in\">str</span>) {\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello, {name}!\"</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> m = MyBox::new(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Rust\"</span>));\n    hello(&amp;m);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-12: Calling <code class=\"hljs\">hello</code> with a reference to a\n<code class=\"hljs\">MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></p>\n<p>Here we’re calling the <code class=\"hljs\">hello</code> function with the argument <code class=\"hljs\">&amp;m</code>, which is a\nreference to a <code class=\"hljs\">MyBox&lt;String&gt;</code> value. Because we implemented the <code class=\"hljs\">Deref</code> trait\non <code class=\"hljs\">MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code class=\"hljs\">&amp;MyBox&lt;String&gt;</code> into <code class=\"hljs\">&amp;String</code>\nby calling <code class=\"hljs\">deref</code>. The standard library provides an implementation of <code class=\"hljs\">Deref</code>\non <code class=\"hljs\">String</code> that returns a string slice, and this is in the API documentation\nfor <code class=\"hljs\">Deref</code>. Rust calls <code class=\"hljs\">deref</code> again to turn the <code class=\"hljs\">&amp;String</code> into <code class=\"hljs\">&amp;str</code>, which\nmatches the <code class=\"hljs\">hello</code> function’s definition.</p>\n<p>If Rust didn’t implement deref coercion, we would have to write the code in\nListing 15-13 instead of the code in Listing 15-12 to call <code class=\"hljs\">hello</code> with a value\nof type <code class=\"hljs\">&amp;MyBox&lt;String&gt;</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::ops::Deref;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; Deref <span class=\"hljs-keyword\">for</span> MyBox&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Target</span></span> = T;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">deref</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; &amp;T {\n</span><span class=\"boring\">        &amp;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyBox</span></span>&lt;T&gt;(T);\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; {\n</span><span class=\"boring\">        MyBox(x)\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello</span></span>(name: &amp;<span class=\"hljs-built_in\">str</span>) {\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello, {name}!\"</span>);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> m = MyBox::new(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Rust\"</span>));\n    hello(&amp;(*m)[..]);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 15-13: The code we would have to write if Rust\ndidn’t have deref coercion</span></p>\n<p>The <code class=\"hljs\">(*m)</code> dereferences the <code class=\"hljs\">MyBox&lt;String&gt;</code> into a <code class=\"hljs\">String</code>. Then the <code class=\"hljs\">&amp;</code> and\n<code class=\"hljs\">[..]</code> take a string slice of the <code class=\"hljs\">String</code> that is equal to the whole string to\nmatch the signature of <code class=\"hljs\">hello</code>. This code without deref coercions is harder to\nread, write, and understand with all of these symbols involved. Deref coercion\nallows Rust to handle these conversions for us automatically.</p>\n<p>When the <code class=\"hljs\">Deref</code> trait is defined for the types involved, Rust will analyze the\ntypes and use <code class=\"hljs\">Deref::deref</code> as many times as necessary to get a reference to\nmatch the parameter’s type. The number of times that <code class=\"hljs\">Deref::deref</code> needs to be\ninserted is resolved at compile time, so there is no runtime penalty for taking\nadvantage of deref coercion!</p>\n<h3 id=\"how-deref-coercion-interacts-with-mutability\"><a class=\"header\" href=\"#how-deref-coercion-interacts-with-mutability\">How Deref Coercion Interacts with Mutability</a></h3>\n<p>Similar to how you use the <code class=\"hljs\">Deref</code> trait to override the <code class=\"hljs\">*</code> operator on\nimmutable references, you can use the <code class=\"hljs\">DerefMut</code> trait to override the <code class=\"hljs\">*</code>\noperator on mutable references.</p>\n<p>Rust does deref coercion when it finds types and trait implementations in three\ncases:</p>\n<ul>\n<li>From <code class=\"hljs\">&amp;T</code> to <code class=\"hljs\">&amp;U</code> when <code class=\"hljs\">T: Deref&lt;Target=U&gt;</code></li>\n<li>From <code class=\"hljs\">&amp;mut T</code> to <code class=\"hljs\">&amp;mut U</code> when <code class=\"hljs\">T: DerefMut&lt;Target=U&gt;</code></li>\n<li>From <code class=\"hljs\">&amp;mut T</code> to <code class=\"hljs\">&amp;U</code> when <code class=\"hljs\">T: Deref&lt;Target=U&gt;</code></li>\n</ul>\n<p>The first two cases are the same as each other except that the second\nimplements mutability. The first case states that if you have a <code class=\"hljs\">&amp;T</code>, and <code class=\"hljs\">T</code>\nimplements <code class=\"hljs\">Deref</code> to some type <code class=\"hljs\">U</code>, you can get a <code class=\"hljs\">&amp;U</code> transparently. The\nsecond case states that the same deref coercion happens for mutable references.</p>\n<p>The third case is trickier: Rust will also coerce a mutable reference to an\nimmutable one. But the reverse is <em>not</em> possible: immutable references will\nnever coerce to mutable references. Because of the borrowing rules, if you have\na mutable reference, that mutable reference must be the only reference to that\ndata (otherwise, the program wouldn’t compile). Converting one mutable\nreference to one immutable reference will never break the borrowing rules.\nConverting an immutable reference to a mutable reference would require that the\ninitial immutable reference is the only immutable reference to that data, but\nthe borrowing rules don’t guarantee that. Therefore, Rust can’t make the\nassumption that converting an immutable reference to a mutable reference is\npossible.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch15-01-box.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch15-03-drop.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch15-01-box.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch15-03-drop.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:29.050Z"
}