{
	"title": "offset_of in std::mem - Rust",
	"url": "https://doc.rust-lang.org/stable/std/mem/macro.offset_of.html",
	"markdown": "# offset\\_of in std::mem - Rust\n\n## Macro [std](../index.html)::[mem](index.html)::[offset\\_of](#)\n\n1.77.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/mem/mod.rs.html#1344) ·\n\n```\npub macro offset_of($Container:ty, $($fields:expr)+ $(,)?) {\n    ...\n}\n```\n\nExpand description\n\nExpands to the offset in bytes of a field from the beginning of the given type.\n\nStructs, enums, unions and tuples are supported.\n\nNested field accesses may be used, but not array indexes.\n\nEnum variants may be traversed as if they were fields. Variants themselves do not have an offset.\n\nHowever, on stable only a single field name is supported, which blocks the use of enum support.\n\nVisibility is respected - all types and fields must be visible to the call site:\n\n```\nmod nested {\n    #[repr(C)]\n    pub struct Struct {\n        private: u8,\n    }\n}\n\n// assert_eq!(mem::offset_of!(nested::Struct, private), 0);\n// ^^^ error[E0616]: field `private` of struct `Struct` is private\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++mod+nested+%7B%0A++++++++%23%5Brepr(C)%5D%0A++++++++pub+struct+Struct+%7B%0A++++++++++++private:+u8,%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+assert_eq!(mem::offset_of!(nested::Struct,+private),+0);%0A++++//+%5E%5E%5E+error%5BE0616%5D:+field+%60private%60+of+struct+%60Struct%60+is+private%0A%7D&edition=2021)\n\nNote that type layout is, in general, [subject to change and platform-specific](https://doc.rust-lang.org/reference/type-layout.html). If layout stability is required, consider using an [explicit `repr` attribute](https://doc.rust-lang.org/reference/type-layout.html#representations).\n\nRust guarantees that the offset of a given field within a given type will not change over the lifetime of the program. However, two different compilations of the same program may result in different layouts. Also, even within a single program execution, no guarantees are made about types which are _similar_ but not _identical_, e.g.:\n\n```\nstruct Wrapper<T, U>(T, U);\n\ntype A = Wrapper<u8, u8>;\ntype B = Wrapper<u8, i8>;\n\n// Not necessarily identical even though `u8` and `i8` have the same layout!\n// assert_eq!(mem::offset_of!(A, 1), mem::offset_of!(B, 1));\n\n#[repr(transparent)]\nstruct U8(u8);\n\ntype C = Wrapper<u8, U8>;\n\n// Not necessarily identical even though `u8` and `U8` have the same layout!\n// assert_eq!(mem::offset_of!(A, 1), mem::offset_of!(C, 1));\n\nstruct Empty<T>(core::marker::PhantomData<T>);\n\n// Not necessarily identical even though `PhantomData` always has the same layout!\n// assert_eq!(mem::offset_of!(Empty<u8>, 0), mem::offset_of!(Empty<i8>, 0));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+Wrapper%3CT,+U%3E(T,+U);%0A++++%0A++++type+A+=+Wrapper%3Cu8,+u8%3E;%0A++++type+B+=+Wrapper%3Cu8,+i8%3E;%0A++++%0A++++//+Not+necessarily+identical+even+though+%60u8%60+and+%60i8%60+have+the+same+layout!%0A++++//+assert_eq!(mem::offset_of!(A,+1),+mem::offset_of!(B,+1));%0A++++%0A++++%23%5Brepr(transparent)%5D%0A++++struct+U8(u8);%0A++++%0A++++type+C+=+Wrapper%3Cu8,+U8%3E;%0A++++%0A++++//+Not+necessarily+identical+even+though+%60u8%60+and+%60U8%60+have+the+same+layout!%0A++++//+assert_eq!(mem::offset_of!(A,+1),+mem::offset_of!(C,+1));%0A++++%0A++++struct+Empty%3CT%3E(core::marker::PhantomData%3CT%3E);%0A++++%0A++++//+Not+necessarily+identical+even+though+%60PhantomData%60+always+has+the+same+layout!%0A++++//+assert_eq!(mem::offset_of!(Empty%3Cu8%3E,+0),+mem::offset_of!(Empty%3Ci8%3E,+0));%0A%7D&edition=2021)\n\n## [§](#examples)Examples\n\n```\n#![feature(offset_of_enum, offset_of_nested)]\n\nuse std::mem;\n#[repr(C)]\nstruct FieldStruct {\n    first: u8,\n    second: u16,\n    third: u8\n}\n\nassert_eq!(mem::offset_of!(FieldStruct, first), 0);\nassert_eq!(mem::offset_of!(FieldStruct, second), 2);\nassert_eq!(mem::offset_of!(FieldStruct, third), 4);\n\n#[repr(C)]\nstruct NestedA {\n    b: NestedB\n}\n\n#[repr(C)]\nstruct NestedB(u8);\n\nassert_eq!(mem::offset_of!(NestedA, b.0), 0);\n\n#[repr(u8)]\nenum Enum {\n    A(u8, u16),\n    B { one: u8, two: u16 },\n}\n\nassert_eq!(mem::offset_of!(Enum, A.0), 1);\nassert_eq!(mem::offset_of!(Enum, B.two), 2);\n\nassert_eq!(mem::offset_of!(Option<&u8>, Some.0), 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(offset_of_enum,+offset_of_nested)%5D%0A%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%23%5Brepr(C)%5D%0A++++struct+FieldStruct+%7B%0A++++++++first:+u8,%0A++++++++second:+u16,%0A++++++++third:+u8%0A++++%7D%0A++++%0A++++assert_eq!(mem::offset_of!(FieldStruct,+first),+0);%0A++++assert_eq!(mem::offset_of!(FieldStruct,+second),+2);%0A++++assert_eq!(mem::offset_of!(FieldStruct,+third),+4);%0A++++%0A++++%23%5Brepr(C)%5D%0A++++struct+NestedA+%7B%0A++++++++b:+NestedB%0A++++%7D%0A++++%0A++++%23%5Brepr(C)%5D%0A++++struct+NestedB(u8);%0A++++%0A++++assert_eq!(mem::offset_of!(NestedA,+b.0),+0);%0A++++%0A++++%23%5Brepr(u8)%5D%0A++++enum+Enum+%7B%0A++++++++A(u8,+u16),%0A++++++++B+%7B+one:+u8,+two:+u16+%7D,%0A++++%7D%0A++++%0A++++assert_eq!(mem::offset_of!(Enum,+A.0),+1);%0A++++assert_eq!(mem::offset_of!(Enum,+B.two),+2);%0A++++%0A++++assert_eq!(mem::offset_of!(Option%3C%26u8%3E,+Some.0),+0);%0A%7D&version=nightly&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Expands to the offset in bytes of a field from the beginning of the given type.\"><title>offset_of in std::mem - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc macro\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::mem</a></h2><h3><a href=\"index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"macro.offset_of.html\">offset_of</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Assume.html\">Assume</a></li><li><a href=\"struct.Discriminant.html\">Discriminant</a></li><li><a href=\"struct.ManuallyDrop.html\">ManuallyDrop</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.BikeshedIntrinsicFrom.html\">BikeshedIntrinsicFrom</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.align_of.html\">align_of</a></li><li><a href=\"fn.align_of_val.html\">align_of_val</a></li><li><a href=\"fn.align_of_val_raw.html\">align_of_val_raw</a></li><li><a href=\"fn.copy.html\">copy</a></li><li><a href=\"fn.discriminant.html\">discriminant</a></li><li><a href=\"fn.drop.html\">drop</a></li><li><a href=\"fn.forget.html\">forget</a></li><li><a href=\"fn.forget_unsized.html\">forget_unsized</a></li><li><a href=\"fn.min_align_of.html\">min_align_of</a></li><li><a href=\"fn.min_align_of_val.html\">min_align_of_val</a></li><li><a href=\"fn.needs_drop.html\">needs_drop</a></li><li><a href=\"fn.replace.html\">replace</a></li><li><a href=\"fn.size_of.html\">size_of</a></li><li><a href=\"fn.size_of_val.html\">size_of_val</a></li><li><a href=\"fn.size_of_val_raw.html\">size_of_val_raw</a></li><li><a href=\"fn.swap.html\">swap</a></li><li><a href=\"fn.take.html\">take</a></li><li><a href=\"fn.transmute.html\">transmute</a></li><li><a href=\"fn.transmute_copy.html\">transmute_copy</a></li><li><a href=\"fn.uninitialized.html\">uninitialized</a></li><li><a href=\"fn.variant_count.html\">variant_count</a></li><li><a href=\"fn.zeroed.html\">zeroed</a></li></ul><h3><a href=\"index.html#unions\">Unions</a></h3><ul class=\"block union\"><li><a href=\"union.MaybeUninit.html\">MaybeUninit</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Macro <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">mem</a>::<wbr><a class=\"macro\" href=\"#\">offset_of</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/mem/mod.rs.html#1344\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><span class=\"kw\">pub macro </span>offset_of(<span class=\"macro-nonterminal\">$Container</span>:ty, $(<span class=\"macro-nonterminal\">$fields</span>:expr)+ $(,)<span class=\"question-mark\">?</span>) {\n    ...\n}</pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Expands to the offset in bytes of a field from the beginning of the given type.</p>\n<p>Structs, enums, unions and tuples are supported.</p>\n<p>Nested field accesses may be used, but not array indexes.</p>\n<p>Enum variants may be traversed as if they were fields. Variants themselves do\nnot have an offset.</p>\n<p>However, on stable only a single field name is supported, which blocks the use of\nenum support.</p>\n<p>Visibility is respected - all types and fields must be visible to the call site:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">mod </span>nested {\n    <span class=\"attr\">#[repr(C)]\n    </span><span class=\"kw\">pub struct </span>Struct {\n        private: u8,\n    }\n}\n\n<span class=\"comment\">// assert_eq!(mem::offset_of!(nested::Struct, private), 0);\n// ^^^ error[E0616]: field `private` of struct `Struct` is private</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++mod+nested+%7B%0A++++++++%23%5Brepr(C)%5D%0A++++++++pub+struct+Struct+%7B%0A++++++++++++private:+u8,%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+assert_eq!(mem::offset_of!(nested::Struct,+private),+0);%0A++++//+%5E%5E%5E+error%5BE0616%5D:+field+%60private%60+of+struct+%60Struct%60+is+private%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that type layout is, in general, <a href=\"https://doc.rust-lang.org/reference/type-layout.html\">subject to change and\nplatform-specific</a>. If\nlayout stability is required, consider using an <a href=\"https://doc.rust-lang.org/reference/type-layout.html#representations\">explicit <code>repr</code> attribute</a>.</p>\n<p>Rust guarantees that the offset of a given field within a given type will not\nchange over the lifetime of the program. However, two different compilations of\nthe same program may result in different layouts. Also, even within a single\nprogram execution, no guarantees are made about types which are <em>similar</em> but\nnot <em>identical</em>, e.g.:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">struct </span>Wrapper&lt;T, U&gt;(T, U);\n\n<span class=\"kw\">type </span>A = Wrapper&lt;u8, u8&gt;;\n<span class=\"kw\">type </span>B = Wrapper&lt;u8, i8&gt;;\n\n<span class=\"comment\">// Not necessarily identical even though `u8` and `i8` have the same layout!\n// assert_eq!(mem::offset_of!(A, 1), mem::offset_of!(B, 1));\n\n</span><span class=\"attr\">#[repr(transparent)]\n</span><span class=\"kw\">struct </span>U8(u8);\n\n<span class=\"kw\">type </span>C = Wrapper&lt;u8, U8&gt;;\n\n<span class=\"comment\">// Not necessarily identical even though `u8` and `U8` have the same layout!\n// assert_eq!(mem::offset_of!(A, 1), mem::offset_of!(C, 1));\n\n</span><span class=\"kw\">struct </span>Empty&lt;T&gt;(core::marker::PhantomData&lt;T&gt;);\n\n<span class=\"comment\">// Not necessarily identical even though `PhantomData` always has the same layout!\n// assert_eq!(mem::offset_of!(Empty&lt;u8&gt;, 0), mem::offset_of!(Empty&lt;i8&gt;, 0));</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+Wrapper%3CT,+U%3E(T,+U);%0A++++%0A++++type+A+=+Wrapper%3Cu8,+u8%3E;%0A++++type+B+=+Wrapper%3Cu8,+i8%3E;%0A++++%0A++++//+Not+necessarily+identical+even+though+%60u8%60+and+%60i8%60+have+the+same+layout!%0A++++//+assert_eq!(mem::offset_of!(A,+1),+mem::offset_of!(B,+1));%0A++++%0A++++%23%5Brepr(transparent)%5D%0A++++struct+U8(u8);%0A++++%0A++++type+C+=+Wrapper%3Cu8,+U8%3E;%0A++++%0A++++//+Not+necessarily+identical+even+though+%60u8%60+and+%60U8%60+have+the+same+layout!%0A++++//+assert_eq!(mem::offset_of!(A,+1),+mem::offset_of!(C,+1));%0A++++%0A++++struct+Empty%3CT%3E(core::marker::PhantomData%3CT%3E);%0A++++%0A++++//+Not+necessarily+identical+even+though+%60PhantomData%60+always+has+the+same+layout!%0A++++//+assert_eq!(mem::offset_of!(Empty%3Cu8%3E,+0),+mem::offset_of!(Empty%3Ci8%3E,+0));%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(offset_of_enum, offset_of_nested)]\n\n</span><span class=\"kw\">use </span>std::mem;\n<span class=\"attr\">#[repr(C)]\n</span><span class=\"kw\">struct </span>FieldStruct {\n    first: u8,\n    second: u16,\n    third: u8\n}\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(FieldStruct, first), <span class=\"number\">0</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(FieldStruct, second), <span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(FieldStruct, third), <span class=\"number\">4</span>);\n\n<span class=\"attr\">#[repr(C)]\n</span><span class=\"kw\">struct </span>NestedA {\n    b: NestedB\n}\n\n<span class=\"attr\">#[repr(C)]\n</span><span class=\"kw\">struct </span>NestedB(u8);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(NestedA, b.<span class=\"number\">0</span>), <span class=\"number\">0</span>);\n\n<span class=\"attr\">#[repr(u8)]\n</span><span class=\"kw\">enum </span>Enum {\n    A(u8, u16),\n    B { one: u8, two: u16 },\n}\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(Enum, A.<span class=\"number\">0</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(Enum, B.two), <span class=\"number\">2</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">mem::offset_of!</span>(<span class=\"prelude-ty\">Option</span>&lt;<span class=\"kw-2\">&amp;</span>u8&gt;, <span class=\"prelude-val\">Some</span>.<span class=\"number\">0</span>), <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(offset_of_enum,+offset_of_nested)%5D%0A%0Afn+main()+%7B%0A++++use+std::mem;%0A++++%23%5Brepr(C)%5D%0A++++struct+FieldStruct+%7B%0A++++++++first:+u8,%0A++++++++second:+u16,%0A++++++++third:+u8%0A++++%7D%0A++++%0A++++assert_eq!(mem::offset_of!(FieldStruct,+first),+0);%0A++++assert_eq!(mem::offset_of!(FieldStruct,+second),+2);%0A++++assert_eq!(mem::offset_of!(FieldStruct,+third),+4);%0A++++%0A++++%23%5Brepr(C)%5D%0A++++struct+NestedA+%7B%0A++++++++b:+NestedB%0A++++%7D%0A++++%0A++++%23%5Brepr(C)%5D%0A++++struct+NestedB(u8);%0A++++%0A++++assert_eq!(mem::offset_of!(NestedA,+b.0),+0);%0A++++%0A++++%23%5Brepr(u8)%5D%0A++++enum+Enum+%7B%0A++++++++A(u8,+u16),%0A++++++++B+%7B+one:+u8,+two:+u16+%7D,%0A++++%7D%0A++++%0A++++assert_eq!(mem::offset_of!(Enum,+A.0),+1);%0A++++assert_eq!(mem::offset_of!(Enum,+B.two),+2);%0A++++%0A++++assert_eq!(mem::offset_of!(Option%3C%26u8%3E,+Some.0),+0);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:23:54.842Z"
}