{
	"title": "Storing UTF-8 Encoded Text with Strings - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch08-02-strings.html",
	"markdown": "# Storing UTF-8 Encoded Text with Strings\n\nWe talked about strings in Chapter 4, but we’ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust’s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you’re coming from other programming languages.\n\nWe discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text. In this section, we’ll talk about the operations on `String` that every collection type has, such as creating, updating, and reading. We’ll also discuss the ways in which `String` is different from the other collections, namely how indexing into a `String` is complicated by the differences between how people and computers interpret `String` data.\n\n### [What Is a String?](#what-is-a-string)\n\nWe’ll first define what we mean by the term _string_. Rust has only one string type in the core language, which is the string slice `str` that is usually seen in its borrowed form `&str`. In Chapter 4, we talked about _string slices_, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program’s binary and are therefore string slices.\n\nThe `String` type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to “strings” in Rust, they might be referring to either the `String` or the string slice `&str` types, not just one of those types. Although this section is largely about `String`, both types are used heavily in Rust’s standard library, and both `String` and string slices are UTF-8 encoded.\n\n### [Creating a New String](#creating-a-new-string)\n\nMany of the same operations available with `Vec<T>` are available with `String` as well because `String` is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities. An example of a function that works the same way with `Vec<T>` and `String` is the `new` function to create an instance, shown in Listing 8-11.\n\n```rust\nfn main() {\n    let mut s = String::new();\n}\n```\n\nListing 8-11: Creating a new, empty `String`\n\nThis line creates a new, empty string called `s`, into which we can then load data. Often, we’ll have some initial data with which we want to start the string. For that, we use the `to_string` method, which is available on any type that implements the `Display` trait, as string literals do. Listing 8-12 shows two examples.\n\n```rust\nfn main() {\n    let data = \"initial contents\";\n\n    let s = data.to_string();\n\n    // the method also works on a literal directly:\n    let s = \"initial contents\".to_string();\n}\n```\n\nListing 8-12: Using the `to_string` method to create a `String` from a string literal\n\nThis code creates a string containing `initial contents`.\n\nWe can also use the function `String::from` to create a `String` from a string literal. The code in Listing 8-13 is equivalent to the code in Listing 8-12 that uses `to_string`.\n\n```rust\nfn main() {\n    let s = String::from(\"initial contents\");\n}\n```\n\nListing 8-13: Using the `String::from` function to create a `String` from a string literal\n\nBecause strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, `String::from` and `to_string` do the same thing, so which one you choose is a matter of style and readability.\n\nRemember that strings are UTF-8 encoded, so we can include any properly encoded data in them, as shown in Listing 8-14.\n\n```rust\nfn main() {\n    let hello = String::from(\"السلام عليكم\");\n    let hello = String::from(\"Dobrý den\");\n    let hello = String::from(\"Hello\");\n    let hello = String::from(\"שלום\");\n    let hello = String::from(\"नमस्ते\");\n    let hello = String::from(\"こんにちは\");\n    let hello = String::from(\"안녕하세요\");\n    let hello = String::from(\"你好\");\n    let hello = String::from(\"Olá\");\n    let hello = String::from(\"Здравствуйте\");\n    let hello = String::from(\"Hola\");\n}\n```\n\nListing 8-14: Storing greetings in different languages in strings\n\nAll of these are valid `String` values.\n\n### [Updating a String](#updating-a-string)\n\nA `String` can grow in size and its contents can change, just like the contents of a `Vec<T>`, if you push more data into it. In addition, you can conveniently use the `+` operator or the `format!` macro to concatenate `String` values.\n\n#### [Appending to a String with `push_str` and `push`](#appending-to-a-string-with-push_str-and-push)\n\nWe can grow a `String` by using the `push_str` method to append a string slice, as shown in Listing 8-15.\n\n```rust\nfn main() {\n    let mut s = String::from(\"foo\");\n    s.push_str(\"bar\");\n}\n```\n\nListing 8-15: Appending a string slice to a `String` using the `push_str` method\n\nAfter these two lines, `s` will contain `foobar`. The `push_str` method takes a string slice because we don’t necessarily want to take ownership of the parameter. For example, in the code in Listing 8-16, we want to be able to use `s2` after appending its contents to `s1`.\n\n```rust\nfn main() {\n    let mut s1 = String::from(\"foo\");\n    let s2 = \"bar\";\n    s1.push_str(s2);\n    println!(\"s2 is {s2}\");\n}\n```\n\nListing 8-16: Using a string slice after appending its contents to a `String`\n\nIf the `push_str` method took ownership of `s2`, we wouldn’t be able to print its value on the last line. However, this code works as we’d expect!\n\nThe `push` method takes a single character as a parameter and adds it to the `String`. Listing 8-17 adds the letter _l_ to a `String` using the `push` method.\n\n```rust\nfn main() {\n    let mut s = String::from(\"lo\");\n    s.push('l');\n}\n```\n\nListing 8-17: Adding one character to a `String` value using `push`\n\nAs a result, `s` will contain `lol`.\n\n#### [Concatenation with the `+` Operator or the `format!` Macro](#concatenation-with-the--operator-or-the-format-macro)\n\nOften, you’ll want to combine two existing strings. One way to do so is to use the `+` operator, as shown in Listing 8-18.\n\n```rust\nfn main() {\n    let s1 = String::from(\"Hello, \");\n    let s2 = String::from(\"world!\");\n    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used\n}\n```\n\nListing 8-18: Using the `+` operator to combine two `String` values into a new `String` value\n\nThe string `s3` will contain `Hello, world!`. The reason `s1` is no longer valid after the addition, and the reason we used a reference to `s2`, has to do with the signature of the method that’s called when we use the `+` operator. The `+` operator uses the `add` method, whose signature looks something like this:\n\n```rust\nfn add(self, s: &str) -> String {\n```\n\nIn the standard library, you’ll see `add` defined using generics and associated types. Here, we’ve substituted in concrete types, which is what happens when we call this method with `String` values. We’ll discuss generics in Chapter 10. This signature gives us the clues we need in order to understand the tricky bits of the `+` operator.\n\nFirst, `s2` has an `&`, meaning that we’re adding a _reference_ of the second string to the first string. This is because of the `s` parameter in the `add` function: we can only add a `&str` to a `String`; we can’t add two `String` values together. But wait—the type of `&s2` is `&String`, not `&str`, as specified in the second parameter to `add`. So why does Listing 8-18 compile?\n\nThe reason we’re able to use `&s2` in the call to `add` is that the compiler can _coerce_ the `&String` argument into a `&str`. When we call the `add` method, Rust uses a _deref coercion_, which here turns `&s2` into `&s2[..]`. We’ll discuss deref coercion in more depth in Chapter 15. Because `add` does not take ownership of the `s` parameter, `s2` will still be a valid `String` after this operation.\n\nSecond, we can see in the signature that `add` takes ownership of `self` because `self` does _not_ have an `&`. This means `s1` in Listing 8-18 will be moved into the `add` call and will no longer be valid after that. So, although `let s3 = s1 + &s2;` looks like it will copy both strings and create a new one, this statement actually takes ownership of `s1`, appends a copy of the contents of `s2`, and then returns ownership of the result. In other words, it looks like it’s making a lot of copies, but it isn’t; the implementation is more efficient than copying.\n\nIf we need to concatenate multiple strings, the behavior of the `+` operator gets unwieldy:\n\n```rust\nfn main() {\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n}\n```\n\nAt this point, `s` will be `tic-tac-toe`. With all of the `+` and `\"` characters, it’s difficult to see what’s going on. For combining strings in more complicated ways, we can instead use the `format!` macro:\n\n```rust\nfn main() {\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = format!(\"{s1}-{s2}-{s3}\");\n}\n```\n\nThis code also sets `s` to `tic-tac-toe`. The `format!` macro works like `println!`, but instead of printing the output to the screen, it returns a `String` with the contents. The version of the code using `format!` is much easier to read, and the code generated by the `format!` macro uses references so that this call doesn’t take ownership of any of its parameters.\n\n### [Indexing into Strings](#indexing-into-strings)\n\nIn many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a `String` using indexing syntax in Rust, you’ll get an error. Consider the invalid code in Listing 8-19.\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let h = s1[0];\n}\n```\n\nListing 8-19: Attempting to use indexing syntax with a String\n\nThis code will result in the following error:\n\n```console\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n --> src/main.rs:3:16\n  |\n3 |     let h = s1[0];\n  |                ^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`, which is required by `String: Index<_>`\n  = note: you can use `.chars().nth()` or `.bytes().nth()`\n          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n  = help: the trait `SliceIndex<[_]>` is implemented for `usize`\n  = help: for that trait implementation, expected `[_]`, found `str`\n  = note: required for `String` to implement `Index<{integer}>`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `collections` (bin \"collections\") due to 1 previous error\n\n```\n\nThe error and the note tell the story: Rust strings don’t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.\n\n#### [Internal Representation](#internal-representation)\n\nA `String` is a wrapper over a `Vec<u8>`. Let’s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:\n\n```rust\nfn main() {\n    let hello = String::from(\"السلام عليكم\");\n    let hello = String::from(\"Dobrý den\");\n    let hello = String::from(\"Hello\");\n    let hello = String::from(\"שלום\");\n    let hello = String::from(\"नमस्ते\");\n    let hello = String::from(\"こんにちは\");\n    let hello = String::from(\"안녕하세요\");\n    let hello = String::from(\"你好\");\n    let hello = String::from(\"Olá\");\n    let hello = String::from(\"Здравствуйте\");\n    let hello = String::from(\"Hola\");\n}\n```\n\nIn this case, `len` will be `4`, which means the vector storing the string `\"Hola\"` is 4 bytes long. Each of these letters takes one byte when encoded in UTF-8. The following line, however, may surprise you (note that this string begins with the capital Cyrillic letter _Ze_, not the number 3):\n\n```rust\nfn main() {\n    let hello = String::from(\"السلام عليكم\");\n    let hello = String::from(\"Dobrý den\");\n    let hello = String::from(\"Hello\");\n    let hello = String::from(\"שלום\");\n    let hello = String::from(\"नमस्ते\");\n    let hello = String::from(\"こんにちは\");\n    let hello = String::from(\"안녕하세요\");\n    let hello = String::from(\"你好\");\n    let hello = String::from(\"Olá\");\n    let hello = String::from(\"Здравствуйте\");\n    let hello = String::from(\"Hola\");\n}\n```\n\nIf you were asked how long the string is, you might say 12. In fact, Rust’s answer is 24: that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string’s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:\n\n```rust\nlet hello = \"Здравствуйте\";\nlet answer = &hello[0];\n```\n\nYou already know that `answer` will not be `З`, the first letter. When encoded in UTF-8, the first byte of `З` is `208` and the second is `151`, so it would seem that `answer` should in fact be `208`, but `208` is not a valid character on its own. Returning `208` is likely not what a user would want if they asked for the first letter of this string; however, that’s the only data that Rust has at byte index 0. Users generally don’t want the byte value returned, even if the string contains only Latin letters: if `&\"hello\"[0]` were valid code that returned the byte value, it would return `104`, not `h`.\n\nThe answer, then, is that to avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn’t compile this code at all and prevents misunderstandings early in the development process.\n\n#### [Bytes and Scalar Values and Grapheme Clusters! Oh My!](#bytes-and-scalar-values-and-grapheme-clusters-oh-my)\n\nAnother point about UTF-8 is that there are actually three relevant ways to look at strings from Rust’s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call _letters_).\n\nIf we look at the Hindi word “नमस्ते” written in the Devanagari script, it is stored as a vector of `u8` values that looks like this:\n\n```text\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n\n```\n\nThat’s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust’s `char` type is, those bytes look like this:\n\n```text\n['न', 'म', 'स', '्', 'त', 'े']\n\n```\n\nThere are six `char` values here, but the fourth and sixth are not letters: they’re diacritics that don’t make sense on their own. Finally, if we look at them as grapheme clusters, we’d get what a person would call the four letters that make up the Hindi word:\n\n```text\n[\"न\", \"म\", \"स्\", \"ते\"]\n\n```\n\nRust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.\n\nA final reason Rust doesn’t allow us to index into a `String` to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a `String`, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.\n\n### [Slicing Strings](#slicing-strings)\n\nIndexing into a string is often a bad idea because it’s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. If you really need to use indices to create string slices, therefore, Rust asks you to be more specific.\n\nRather than indexing using `[]` with a single number, you can use `[]` with a range to create a string slice containing particular bytes:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet hello = \"Здравствуйте\";\n\nlet s = &hello[0..4];\n}\n```\n\nHere, `s` will be a `&str` that contains the first four bytes of the string. Earlier, we mentioned that each of these characters was two bytes, which means `s` will be `Зд`.\n\nIf we were to try to slice only part of a character’s bytes with something like `&hello[0..1]`, Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:\n\n```console\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/collections`\nthread 'main' panicked at src/main.rs:4:19:\nbyte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n```\n\nYou should use caution when creating string slices with ranges, because doing so can crash your program.\n\n### [Methods for Iterating Over Strings](#methods-for-iterating-over-strings)\n\nThe best way to operate on pieces of strings is to be explicit about whether you want characters or bytes. For individual Unicode scalar values, use the `chars` method. Calling `chars` on “Зд” separates out and returns two values of type `char`, and you can iterate over the result to access each element:\n\n```rust\n#![allow(unused)]\nfn main() {\nfor c in \"Зд\".chars() {\n    println!(\"{c}\");\n}\n}\n```\n\nThis code will print the following:\n\n```text\nЗ\nд\n\n```\n\nAlternatively, the `bytes` method returns each raw byte, which might be appropriate for your domain:\n\n```rust\n#![allow(unused)]\nfn main() {\nfor b in \"Зд\".bytes() {\n    println!(\"{b}\");\n}\n}\n```\n\nThis code will print the four bytes that make up this string:\n\n```text\n208\n151\n208\n180\n\n```\n\nBut be sure to remember that valid Unicode scalar values may be made up of more than one byte.\n\nGetting grapheme clusters from strings, as with the Devanagari script, is complex, so this functionality is not provided by the standard library. Crates are available on [crates.io](https://crates.io/) if this is the functionality you need.\n\n### [Strings Are Not So Simple](#strings-are-not-so-simple)\n\nTo summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of `String` data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data up front. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.\n\nThe good news is that the standard library offers a lot of functionality built off the `String` and `&str` types to help handle these complex situations correctly. Be sure to check out the documentation for useful methods like `contains` for searching in a string and `replace` for substituting parts of a string with another string.\n\nLet’s switch to something a bit less complex: hash maps!",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Storing UTF-8 Encoded Text with Strings - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"storing-utf-8-encoded-text-with-strings\"><a class=\"header\" href=\"#storing-utf-8-encoded-text-with-strings\">Storing UTF-8 Encoded Text with Strings</a></h2>\n<p>We talked about strings in Chapter 4, but we’ll look at them in more depth now.\nNew Rustaceans commonly get stuck on strings for a combination of three\nreasons: Rust’s propensity for exposing possible errors, strings being a more\ncomplicated data structure than many programmers give them credit for, and\nUTF-8. These factors combine in a way that can seem difficult when you’re\ncoming from other programming languages.</p>\n<p>We discuss strings in the context of collections because strings are\nimplemented as a collection of bytes, plus some methods to provide useful\nfunctionality when those bytes are interpreted as text. In this section, we’ll\ntalk about the operations on <code class=\"hljs\">String</code> that every collection type has, such as\ncreating, updating, and reading. We’ll also discuss the ways in which <code class=\"hljs\">String</code>\nis different from the other collections, namely how indexing into a <code class=\"hljs\">String</code> is\ncomplicated by the differences between how people and computers interpret\n<code class=\"hljs\">String</code> data.</p>\n<h3 id=\"what-is-a-string\"><a class=\"header\" href=\"#what-is-a-string\">What Is a String?</a></h3>\n<p>We’ll first define what we mean by the term <em>string</em>. Rust has only one string\ntype in the core language, which is the string slice <code class=\"hljs\">str</code> that is usually seen\nin its borrowed form <code class=\"hljs\">&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>,\nwhich are references to some UTF-8 encoded string data stored elsewhere. String\nliterals, for example, are stored in the program’s binary and are therefore\nstring slices.</p>\n<p>The <code class=\"hljs\">String</code> type, which is provided by Rust’s standard library rather than\ncoded into the core language, is a growable, mutable, owned, UTF-8 encoded\nstring type. When Rustaceans refer to “strings” in Rust, they might be\nreferring to either the <code class=\"hljs\">String</code> or the string slice <code class=\"hljs\">&amp;str</code> types, not just one\nof those types. Although this section is largely about <code class=\"hljs\">String</code>, both types are\nused heavily in Rust’s standard library, and both <code class=\"hljs\">String</code> and string slices\nare UTF-8 encoded.</p>\n<h3 id=\"creating-a-new-string\"><a class=\"header\" href=\"#creating-a-new-string\">Creating a New String</a></h3>\n<p>Many of the same operations available with <code class=\"hljs\">Vec&lt;T&gt;</code> are available with <code class=\"hljs\">String</code>\nas well because <code class=\"hljs\">String</code> is actually implemented as a wrapper around a vector\nof bytes with some extra guarantees, restrictions, and capabilities. An example\nof a function that works the same way with <code class=\"hljs\">Vec&lt;T&gt;</code> and <code class=\"hljs\">String</code> is the <code class=\"hljs\">new</code>\nfunction to create an instance, shown in Listing 8-11.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> s = <span class=\"hljs-built_in\">String</span>::new();\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-11: Creating a new, empty <code class=\"hljs\">String</code></span></p>\n<p>This line creates a new, empty string called <code class=\"hljs\">s</code>, into which we can then load\ndata. Often, we’ll have some initial data with which we want to start the\nstring. For that, we use the <code class=\"hljs\">to_string</code> method, which is available on any type\nthat implements the <code class=\"hljs\">Display</code> trait, as string literals do. Listing 8-12 shows\ntwo examples.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> data = <span class=\"hljs-string\">\"initial contents\"</span>;\n\n    <span class=\"hljs-keyword\">let</span> s = data.to_string();\n\n    <span class=\"hljs-comment\">// the method also works on a literal directly:</span>\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-string\">\"initial contents\"</span>.to_string();\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-12: Using the <code class=\"hljs\">to_string</code> method to create a\n<code class=\"hljs\">String</code> from a string literal</span></p>\n<p>This code creates a string containing <code class=\"hljs\">initial contents</code>.</p>\n<p>We can also use the function <code class=\"hljs\">String::from</code> to create a <code class=\"hljs\">String</code> from a string\nliteral. The code in Listing 8-13 is equivalent to the code in Listing 8-12\nthat uses <code class=\"hljs\">to_string</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"initial contents\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-13: Using the <code class=\"hljs\">String::from</code> function to create\na <code class=\"hljs\">String</code> from a string literal</span></p>\n<p>Because strings are used for so many things, we can use many different generic\nAPIs for strings, providing us with a lot of options. Some of them can seem\nredundant, but they all have their place! In this case, <code class=\"hljs\">String::from</code> and\n<code class=\"hljs\">to_string</code> do the same thing, so which one you choose is a matter of style and\nreadability.</p>\n<p>Remember that strings are UTF-8 encoded, so we can include any properly encoded\ndata in them, as shown in Listing 8-14.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"السلام عليكم\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Dobrý den\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"שלום\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"नमस्ते\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"こんにちは\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"안녕하세요\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"你好\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Olá\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Здравствуйте\"</span>);\n    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hola\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-14: Storing greetings in different languages in\nstrings</span></p>\n<p>All of these are valid <code class=\"hljs\">String</code> values.</p>\n<h3 id=\"updating-a-string\"><a class=\"header\" href=\"#updating-a-string\">Updating a String</a></h3>\n<p>A <code class=\"hljs\">String</code> can grow in size and its contents can change, just like the contents\nof a <code class=\"hljs\">Vec&lt;T&gt;</code>, if you push more data into it. In addition, you can conveniently\nuse the <code class=\"hljs\">+</code> operator or the <code class=\"hljs\">format!</code> macro to concatenate <code class=\"hljs\">String</code> values.</p>\n<h4 id=\"appending-to-a-string-with-push_str-and-push\"><a class=\"header\" href=\"#appending-to-a-string-with-push_str-and-push\">Appending to a String with <code>push_str</code> and <code>push</code></a></h4>\n<p>We can grow a <code class=\"hljs\">String</code> by using the <code class=\"hljs\">push_str</code> method to append a string slice,\nas shown in Listing 8-15.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"foo\"</span>);\n    s.push_str(<span class=\"hljs-string\">\"bar\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-15: Appending a string slice to a <code class=\"hljs\">String</code>\nusing the <code class=\"hljs\">push_str</code> method</span></p>\n<p>After these two lines, <code class=\"hljs\">s</code> will contain <code class=\"hljs\">foobar</code>. The <code class=\"hljs\">push_str</code> method takes a\nstring slice because we don’t necessarily want to take ownership of the\nparameter. For example, in the code in Listing 8-16, we want to be able to use\n<code class=\"hljs\">s2</code> after appending its contents to <code class=\"hljs\">s1</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"foo\"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-string\">\"bar\"</span>;\n    s1.push_str(s2);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"s2 is {s2}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-16: Using a string slice after appending its\ncontents to a <code class=\"hljs\">String</code></span></p>\n<p>If the <code class=\"hljs\">push_str</code> method took ownership of <code class=\"hljs\">s2</code>, we wouldn’t be able to print\nits value on the last line. However, this code works as we’d expect!</p>\n<p>The <code class=\"hljs\">push</code> method takes a single character as a parameter and adds it to the\n<code class=\"hljs\">String</code>. Listing 8-17 adds the letter <em>l</em> to a <code class=\"hljs\">String</code> using the <code class=\"hljs\">push</code>\nmethod.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> s = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"lo\"</span>);\n    s.push(<span class=\"hljs-string\">'l'</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-17: Adding one character to a <code class=\"hljs\">String</code> value\nusing <code class=\"hljs\">push</code></span></p>\n<p>As a result, <code class=\"hljs\">s</code> will contain <code class=\"hljs\">lol</code>.</p>\n<h4 id=\"concatenation-with-the--operator-or-the-format-macro\"><a class=\"header\" href=\"#concatenation-with-the--operator-or-the-format-macro\">Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro</a></h4>\n<p>Often, you’ll want to combine two existing strings. One way to do so is to use\nthe <code class=\"hljs\">+</code> operator, as shown in Listing 8-18.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello, \"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"world!\"</span>);\n    <span class=\"hljs-keyword\">let</span> s3 = s1 + &amp;s2; <span class=\"hljs-comment\">// note s1 has been moved here and can no longer be used</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 8-18: Using the <code class=\"hljs\">+</code> operator to combine two\n<code class=\"hljs\">String</code> values into a new <code class=\"hljs\">String</code> value</span></p>\n<p>The string <code class=\"hljs\">s3</code> will contain <code class=\"hljs\">Hello, world!</code>. The reason <code class=\"hljs\">s1</code> is no longer\nvalid after the addition, and the reason we used a reference to <code class=\"hljs\">s2</code>, has to do\nwith the signature of the method that’s called when we use the <code class=\"hljs\">+</code> operator.\nThe <code class=\"hljs\">+</code> operator uses the <code class=\"hljs\">add</code> method, whose signature looks something like\nthis:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(<span class=\"hljs-keyword\">self</span>, s: &amp;<span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">String</span> {</code></pre>\n<p>In the standard library, you’ll see <code class=\"hljs\">add</code> defined using generics and associated\ntypes. Here, we’ve substituted in concrete types, which is what happens when we\ncall this method with <code class=\"hljs\">String</code> values. We’ll discuss generics in Chapter 10.\nThis signature gives us the clues we need in order to understand the tricky\nbits of the <code class=\"hljs\">+</code> operator.</p>\n<p>First, <code class=\"hljs\">s2</code> has an <code class=\"hljs\">&amp;</code>, meaning that we’re adding a <em>reference</em> of the second\nstring to the first string. This is because of the <code class=\"hljs\">s</code> parameter in the <code class=\"hljs\">add</code>\nfunction: we can only add a <code class=\"hljs\">&amp;str</code> to a <code class=\"hljs\">String</code>; we can’t add two <code class=\"hljs\">String</code>\nvalues together. But wait—the type of <code class=\"hljs\">&amp;s2</code> is <code class=\"hljs\">&amp;String</code>, not <code class=\"hljs\">&amp;str</code>, as\nspecified in the second parameter to <code class=\"hljs\">add</code>. So why does Listing 8-18 compile?</p>\n<p>The reason we’re able to use <code class=\"hljs\">&amp;s2</code> in the call to <code class=\"hljs\">add</code> is that the compiler\ncan <em>coerce</em> the <code class=\"hljs\">&amp;String</code> argument into a <code class=\"hljs\">&amp;str</code>. When we call the <code class=\"hljs\">add</code>\nmethod, Rust uses a <em>deref coercion</em>, which here turns <code class=\"hljs\">&amp;s2</code> into <code class=\"hljs\">&amp;s2[..]</code>.\nWe’ll discuss deref coercion in more depth in Chapter 15. Because <code class=\"hljs\">add</code> does\nnot take ownership of the <code class=\"hljs\">s</code> parameter, <code class=\"hljs\">s2</code> will still be a valid <code class=\"hljs\">String</code>\nafter this operation.</p>\n<p>Second, we can see in the signature that <code class=\"hljs\">add</code> takes ownership of <code class=\"hljs\">self</code>\nbecause <code class=\"hljs\">self</code> does <em>not</em> have an <code class=\"hljs\">&amp;</code>. This means <code class=\"hljs\">s1</code> in Listing 8-18 will be\nmoved into the <code class=\"hljs\">add</code> call and will no longer be valid after that. So, although\n<code class=\"hljs\">let s3 = s1 + &amp;s2;</code> looks like it will copy both strings and create a new one,\nthis statement actually takes ownership of <code class=\"hljs\">s1</code>, appends a copy of the contents\nof <code class=\"hljs\">s2</code>, and then returns ownership of the result. In other words, it looks\nlike it’s making a lot of copies, but it isn’t; the implementation is more\nefficient than copying.</p>\n<p>If we need to concatenate multiple strings, the behavior of the <code class=\"hljs\">+</code> operator\ngets unwieldy:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"tic\"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"tac\"</span>);\n    <span class=\"hljs-keyword\">let</span> s3 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"toe\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> s = s1 + <span class=\"hljs-string\">\"-\"</span> + &amp;s2 + <span class=\"hljs-string\">\"-\"</span> + &amp;s3;\n<span class=\"boring\">}</span></code></pre></pre>\n<p>At this point, <code class=\"hljs\">s</code> will be <code class=\"hljs\">tic-tac-toe</code>. With all of the <code class=\"hljs\">+</code> and <code class=\"hljs\">\"</code>\ncharacters, it’s difficult to see what’s going on. For combining strings in\nmore complicated ways, we can instead use the <code class=\"hljs\">format!</code> macro:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"tic\"</span>);\n    <span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"tac\"</span>);\n    <span class=\"hljs-keyword\">let</span> s3 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"toe\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{s1}-{s2}-{s3}\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code also sets <code class=\"hljs\">s</code> to <code class=\"hljs\">tic-tac-toe</code>. The <code class=\"hljs\">format!</code> macro works like\n<code class=\"hljs\">println!</code>, but instead of printing the output to the screen, it returns a\n<code class=\"hljs\">String</code> with the contents. The version of the code using <code class=\"hljs\">format!</code> is much\neasier to read, and the code generated by the <code class=\"hljs\">format!</code> macro uses references\nso that this call doesn’t take ownership of any of its parameters.</p>\n<h3 id=\"indexing-into-strings\"><a class=\"header\" href=\"#indexing-into-strings\">Indexing into Strings</a></h3>\n<p>In many other programming languages, accessing individual characters in a\nstring by referencing them by index is a valid and common operation. However,\nif you try to access parts of a <code class=\"hljs\">String</code> using indexing syntax in Rust, you’ll\nget an error. Consider the invalid code in Listing 8-19.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-small\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>);\n    <span class=\"hljs-keyword\">let</span> h = s1[<span class=\"hljs-number\">0</span>];\n<span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 8-19: Attempting to use indexing syntax with a\nString</span></p>\n<p>This code will result in the following error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:3:16</span>\n  |\n3 |     let h = s1[0];\n  |                ^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`\n  = note: you can use `.chars().nth()` or `.bytes().nth()`\n          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;\n  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`\n  = help: for that trait implementation, expected `[_]`, found `str`\n  = note: required for `String` to implement `Index&lt;{integer}&gt;`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `collections` (bin \"collections\") due to 1 previous error\n</code></pre>\n<p>The error and the note tell the story: Rust strings don’t support indexing. But\nwhy not? To answer that question, we need to discuss how Rust stores strings in\nmemory.</p>\n<h4 id=\"internal-representation\"><a class=\"header\" href=\"#internal-representation\">Internal Representation</a></h4>\n<p>A <code class=\"hljs\">String</code> is a wrapper over a <code class=\"hljs\">Vec&lt;u8&gt;</code>. Let’s look at some of our properly\nencoded UTF-8 example strings from Listing 8-14. First, this one:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"السلام عليكم\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Dobrý den\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"שלום\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"नमस्ते\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"こんにちは\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"안녕하세요\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"你好\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Olá\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Здравствуйте\"</span>);\n</span>    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hola\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In this case, <code class=\"hljs\">len</code> will be <code class=\"hljs\">4</code>, which means the vector storing the string\n<code class=\"hljs\">\"Hola\"</code> is 4 bytes long. Each of these letters takes one byte when encoded in\nUTF-8. The following line, however, may surprise you (note that this string\nbegins with the capital Cyrillic letter <em>Ze</em>, not the number 3):</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"السلام عليكم\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Dobrý den\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"שלום\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"नमस्ते\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"こんにちは\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"안녕하세요\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"你好\"</span>);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Olá\"</span>);\n</span>    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Здравствуйте\"</span>);\n<span class=\"boring\">    <span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hola\"</span>);\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>If you were asked how long the string is, you might say 12. In fact, Rust’s\nanswer is 24: that’s the number of bytes it takes to encode “Здравствуйте” in\nUTF-8, because each Unicode scalar value in that string takes 2 bytes of\nstorage. Therefore, an index into the string’s bytes will not always correlate\nto a valid Unicode scalar value. To demonstrate, consider this invalid Rust\ncode:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-small\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-string\">\"Здравствуйте\"</span>;\n<span class=\"hljs-keyword\">let</span> answer = &amp;hello[<span class=\"hljs-number\">0</span>];</code></pre>\n<p>You already know that <code class=\"hljs\">answer</code> will not be <code class=\"hljs\">З</code>, the first letter. When encoded\nin UTF-8, the first byte of <code class=\"hljs\">З</code> is <code class=\"hljs\">208</code> and the second is <code class=\"hljs\">151</code>, so it would\nseem that <code class=\"hljs\">answer</code> should in fact be <code class=\"hljs\">208</code>, but <code class=\"hljs\">208</code> is not a valid character\non its own. Returning <code class=\"hljs\">208</code> is likely not what a user would want if they asked\nfor the first letter of this string; however, that’s the only data that Rust\nhas at byte index 0. Users generally don’t want the byte value returned, even\nif the string contains only Latin letters: if <code class=\"hljs\">&amp;\"hello\"[0]</code> were valid code\nthat returned the byte value, it would return <code class=\"hljs\">104</code>, not <code class=\"hljs\">h</code>.</p>\n<p>The answer, then, is that to avoid returning an unexpected value and causing\nbugs that might not be discovered immediately, Rust doesn’t compile this code\nat all and prevents misunderstandings early in the development process.</p>\n<h4 id=\"bytes-and-scalar-values-and-grapheme-clusters-oh-my\"><a class=\"header\" href=\"#bytes-and-scalar-values-and-grapheme-clusters-oh-my\">Bytes and Scalar Values and Grapheme Clusters! Oh My!</a></h4>\n<p>Another point about UTF-8 is that there are actually three relevant ways to\nlook at strings from Rust’s perspective: as bytes, scalar values, and grapheme\nclusters (the closest thing to what we would call <em>letters</em>).</p>\n<p>If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is\nstored as a vector of <code class=\"hljs\">u8</code> values that looks like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n</code></pre>\n<p>That’s 18 bytes and is how computers ultimately store this data. If we look at\nthem as Unicode scalar values, which are what Rust’s <code class=\"hljs\">char</code> type is, those\nbytes look like this:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">['न', 'म', 'स', '्', 'त', 'े']\n</code></pre>\n<p>There are six <code class=\"hljs\">char</code> values here, but the fourth and sixth are not letters:\nthey’re diacritics that don’t make sense on their own. Finally, if we look at\nthem as grapheme clusters, we’d get what a person would call the four letters\nthat make up the Hindi word:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">[\"न\", \"म\", \"स्\", \"ते\"]\n</code></pre>\n<p>Rust provides different ways of interpreting the raw string data that computers\nstore so that each program can choose the interpretation it needs, no matter\nwhat human language the data is in.</p>\n<p>A final reason Rust doesn’t allow us to index into a <code class=\"hljs\">String</code> to get a\ncharacter is that indexing operations are expected to always take constant time\n(O(1)). But it isn’t possible to guarantee that performance with a <code class=\"hljs\">String</code>,\nbecause Rust would have to walk through the contents from the beginning to the\nindex to determine how many valid characters there were.</p>\n<h3 id=\"slicing-strings\"><a class=\"header\" href=\"#slicing-strings\">Slicing Strings</a></h3>\n<p>Indexing into a string is often a bad idea because it’s not clear what the\nreturn type of the string-indexing operation should be: a byte value, a\ncharacter, a grapheme cluster, or a string slice. If you really need to use\nindices to create string slices, therefore, Rust asks you to be more specific.</p>\n<p>Rather than indexing using <code class=\"hljs\">[]</code> with a single number, you can use <code class=\"hljs\">[]</code> with a\nrange to create a string slice containing particular bytes:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> hello = <span class=\"hljs-string\">\"Здравствуйте\"</span>;\n\n<span class=\"hljs-keyword\">let</span> s = &amp;hello[<span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">4</span>];\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Here, <code class=\"hljs\">s</code> will be a <code class=\"hljs\">&amp;str</code> that contains the first four bytes of the string.\nEarlier, we mentioned that each of these characters was two bytes, which means\n<code class=\"hljs\">s</code> will be <code class=\"hljs\">Зд</code>.</p>\n<p>If we were to try to slice only part of a character’s bytes with something like\n<code class=\"hljs\">&amp;hello[0..1]</code>, Rust would panic at runtime in the same way as if an invalid\nindex were accessed in a vector:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling collections v0.1.0 (file:///projects/collections)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/collections`\nthread 'main' panicked at src/main.rs:4:19:\nbyte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p>You should use caution when creating string slices with ranges, because doing\nso can crash your program.</p>\n<h3 id=\"methods-for-iterating-over-strings\"><a class=\"header\" href=\"#methods-for-iterating-over-strings\">Methods for Iterating Over Strings</a></h3>\n<p>The best way to operate on pieces of strings is to be explicit about whether\nyou want characters or bytes. For individual Unicode scalar values, use the\n<code class=\"hljs\">chars</code> method. Calling <code class=\"hljs\">chars</code> on “Зд” separates out and returns two values of\ntype <code class=\"hljs\">char</code>, and you can iterate over the result to access each element:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">for</span> c <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">\"Зд\"</span>.chars() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{c}\"</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code will print the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">З\nд\n</code></pre>\n<p>Alternatively, the <code class=\"hljs\">bytes</code> method returns each raw byte, which might be\nappropriate for your domain:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">for</span> b <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">\"Зд\"</span>.bytes() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{b}\"</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code will print the four bytes that make up this string:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">208\n151\n208\n180\n</code></pre>\n<p>But be sure to remember that valid Unicode scalar values may be made up of more\nthan one byte.</p>\n<p>Getting grapheme clusters from strings, as with the Devanagari script, is\ncomplex, so this functionality is not provided by the standard library. Crates\nare available on <a href=\"https://crates.io/\">crates.io</a><!-- ignore --> if this is the\nfunctionality you need.</p>\n<h3 id=\"strings-are-not-so-simple\"><a class=\"header\" href=\"#strings-are-not-so-simple\">Strings Are Not So Simple</a></h3>\n<p>To summarize, strings are complicated. Different programming languages make\ndifferent choices about how to present this complexity to the programmer. Rust\nhas chosen to make the correct handling of <code class=\"hljs\">String</code> data the default behavior\nfor all Rust programs, which means programmers have to put more thought into\nhandling UTF-8 data up front. This trade-off exposes more of the complexity of\nstrings than is apparent in other programming languages, but it prevents you\nfrom having to handle errors involving non-ASCII characters later in your\ndevelopment life cycle.</p>\n<p>The good news is that the standard library offers a lot of functionality built\noff the <code class=\"hljs\">String</code> and <code class=\"hljs\">&amp;str</code> types to help handle these complex situations\ncorrectly. Be sure to check out the documentation for useful methods like\n<code class=\"hljs\">contains</code> for searching in a string and <code class=\"hljs\">replace</code> for substituting parts of a\nstring with another string.</p>\n<p>Let’s switch to something a bit less complex: hash maps!</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch08-01-vectors.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch08-03-hash-maps.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch08-01-vectors.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch08-03-hash-maps.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:20.796Z"
}