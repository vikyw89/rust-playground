{
	"title": "Lifetimes - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/lifetimes.html",
	"markdown": "# Lifetimes - The Rustonomicon\n\nRust enforces these rules through _lifetimes_. Lifetimes are named regions of code that a reference must be valid for. Those regions may be fairly complex, as they correspond to paths of execution in the program. There may even be holes in these paths of execution, as it's possible to invalidate a reference as long as it's reinitialized before it's used again. Types which contain references (or pretend to) may also be tagged with lifetimes so that Rust can prevent them from being invalidated as well.\n\nIn most of our examples, the lifetimes will coincide with scopes. This is because our examples are simple. The more complex cases where they don't coincide are described below.\n\nWithin a function body, Rust generally doesn't let you explicitly name the lifetimes involved. This is because it's generally not really necessary to talk about lifetimes in a local context; Rust has all the information and can work out everything as optimally as possible. Many anonymous scopes and temporaries that you would otherwise have to write are often introduced to make your code Just Work.\n\nHowever once you cross the function boundary, you need to start talking about lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip our toes with lifetimes, we're going to pretend that we're actually allowed to label scopes with lifetimes, and desugar the examples from the start of this chapter.\n\nOriginally, our examples made use of _aggressive_ sugar -- high fructose corn syrup even -- around scopes and lifetimes, because writing everything out explicitly is _extremely noisy_. All Rust code relies on aggressive inference and elision of \"obvious\" things.\n\nOne particularly interesting piece of sugar is that each `let` statement implicitly introduces a scope. For the most part, this doesn't really matter. However it does matter for variables that refer to each other. As a simple example, let's completely desugar this simple piece of Rust code:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 0;\nlet y = &x;\nlet z = &y;\n}\n```\n\nThe borrow checker always tries to minimize the extent of a lifetime, so it will likely desugar to the following:\n\n```rust\n// NOTE: `'a: {` and `&'b x` is not valid syntax!\n'a: {\n    let x: i32 = 0;\n    'b: {\n        // lifetime used is 'b because that's good enough.\n        let y: &'b i32 = &'b x;\n        'c: {\n            // ditto on 'c\n            let z: &'c &'b i32 = &'c y; // \"a reference to a reference to an i32\" (with lifetimes annotated)\n        }\n    }\n}\n```\n\nWow. That's... awful. Let's all take a moment to thank Rust for making this easier.\n\nActually passing references to outer scopes will cause Rust to infer a larger lifetime:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 0;\nlet z;\nlet y = &x;\nz = y;\n}\n```\n\n```rust\n'a: {\n    let x: i32 = 0;\n    'b: {\n        let z: &'b i32;\n        'c: {\n            // Must use 'b here because the reference to x is\n            // being passed to the scope 'b.\n            let y: &'b i32 = &'b x;\n            z = y;\n        }\n    }\n}\n```\n\n## [Example: references that outlive referents](#example-references-that-outlive-referents)\n\nAlright, let's look at some of those examples from before:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn as_str(data: &u32) -> &str {\n    let s = format!(\"{}\", data);\n    &s\n}\n}\n```\n\ndesugars to:\n\n```rust\nfn as_str<'a>(data: &'a u32) -> &'a str {\n    'b: {\n        let s = format!(\"{}\", data);\n        return &'a s;\n    }\n}\n```\n\nThis signature of `as_str` takes a reference to a u32 with _some_ lifetime, and promises that it can produce a reference to a str that can live _just as long_. Already we can see why this signature might be trouble. That basically implies that we're going to find a str somewhere in the scope the reference to the u32 originated in, or somewhere _even earlier_. That's a bit of a tall order.\n\nWe then proceed to compute the string `s`, and return a reference to it. Since the contract of our function says the reference must outlive `'a`, that's the lifetime we infer for the reference. Unfortunately, `s` was defined in the scope `'b`, so the only way this is sound is if `'b` contains `'a` -- which is clearly false since `'a` must contain the function call itself. We have therefore created a reference whose lifetime outlives its referent, which is _literally_ the first thing we said that references can't do. The compiler rightfully blows up in our face.\n\nTo make this more clear, we can expand the example:\n\n```rust\nfn as_str<'a>(data: &'a u32) -> &'a str {\n    'b: {\n        let s = format!(\"{}\", data);\n        return &'a s\n    }\n}\n\nfn main() {\n    'c: {\n        let x: u32 = 0;\n        'd: {\n            // An anonymous scope is introduced because the borrow does not\n            // need to last for the whole scope x is valid for. The return\n            // of as_str must find a str somewhere before this function\n            // call. Obviously not happening.\n            println!(\"{}\", as_str::<'d>(&'d x));\n        }\n    }\n}\n```\n\nShoot!\n\nOf course, the right way to write this function is as follows:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn to_string(data: &u32) -> String {\n    format!(\"{}\", data)\n}\n}\n```\n\nWe must produce an owned value inside the function to return it! The only way we could have returned an `&'a str` would have been if it was in a field of the `&'a u32`, which is obviously not the case.\n\n(Actually we could have also just returned a string literal, which as a global can be considered to reside at the bottom of the stack; though this limits our implementation _just a bit_.)\n\n## [Example: aliasing a mutable reference](#example-aliasing-a-mutable-reference)\n\nHow about the other example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut data = vec![1, 2, 3];\nlet x = &data[0];\ndata.push(4);\nprintln!(\"{}\", x);\n}\n```\n\n```rust\n'a: {\n    let mut data: Vec<i32> = vec![1, 2, 3];\n    'b: {\n        // 'b is as big as we need this borrow to be\n        // (just need to get to `println!`)\n        let x: &'b i32 = Index::index::<'b>(&'b data, 0);\n        'c: {\n            // Temporary scope because we don't need the\n            // &mut to last any longer.\n            Vec::push(&'c mut data, 4);\n        }\n        println!(\"{}\", x);\n    }\n}\n```\n\nThe problem here is a bit more subtle and interesting. We want Rust to reject this program for the following reason: We have a live shared reference `x` to a descendant of `data` when we try to take a mutable reference to `data` to `push`. This would create an aliased mutable reference, which would violate the _second_ rule of references.\n\nHowever this is _not at all_ how Rust reasons that this program is bad. Rust doesn't understand that `x` is a reference to a subpath of `data`. It doesn't understand `Vec` at all. What it _does_ see is that `x` has to live for `'b` in order to be printed. The signature of `Index::index` subsequently demands that the reference we take to `data` has to survive for `'b`. When we try to call `push`, it then sees us try to make an `&'c mut data`. Rust knows that `'c` is contained within `'b`, and rejects our program because the `&'b data` must still be alive!\n\nHere we see that the lifetime system is much more coarse than the reference semantics we're actually interested in preserving. For the most part, _that's totally ok_, because it keeps us from spending all day explaining our program to the compiler. However it does mean that several programs that are totally correct with respect to Rust's _true_ semantics are rejected because lifetimes are too dumb.\n\n## [The area covered by a lifetime](#the-area-covered-by-a-lifetime)\n\nA reference (sometimes called a _borrow_) is _alive_ from the place it is created to its last use. The borrowed value needs to outlive only borrows that are alive. This looks simple, but there are a few subtleties.\n\nThe following snippet compiles, because after printing `x`, it is no longer needed, so it doesn't matter if it is dangling or aliased (even though the variable `x` _technically_ exists to the very end of the scope).\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut data = vec![1, 2, 3];\nlet x = &data[0];\nprintln!(\"{}\", x);\n// This is OK, x is no longer needed\ndata.push(4);\n}\n```\n\nHowever, if the value has a destructor, the destructor is run at the end of the scope. And running the destructor is considered a use â€’ obviously the last one. So, this will _not_ compile.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[derive(Debug)]\nstruct X<'a>(&'a i32);\n\nimpl Drop for X<'_> {\n    fn drop(&mut self) {}\n}\n\nlet mut data = vec![1, 2, 3];\nlet x = X(&data[0]);\nprintln!(\"{:?}\", x);\ndata.push(4);\n// Here, the destructor is run and therefore this'll fail to compile.\n}\n```\n\nOne way to convince the compiler that `x` is no longer valid is by using `drop(x)` before `data.push(4)`.\n\nFurthermore, there might be multiple possible last uses of the borrow, for example in each branch of a condition.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn some_condition() -> bool { true }\nlet mut data = vec![1, 2, 3];\nlet x = &data[0];\n\nif some_condition() {\n    println!(\"{}\", x); // This is the last use of `x` in this branch\n    data.push(4);      // So we can push here\n} else {\n    // There's no use of `x` in here, so effectively the last use is the\n    // creation of x at the top of the example.\n    data.push(5);\n}\n}\n```\n\nAnd a lifetime can have a pause in it. Or you might look at it as two distinct borrows just being tied to the same local variable. This often happens around loops (writing a new value of a variable at the end of the loop and using it for the last time at the top of the next iteration).\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut data = vec![1, 2, 3];\n// This mut allows us to change where the reference points to\nlet mut x = &data[0];\n\nprintln!(\"{}\", x); // Last use of this borrow\ndata.push(4);\nx = &data[3]; // We start a new borrow here\nprintln!(\"{}\", x);\n}\n```\n\nHistorically, Rust kept the borrow alive until the end of scope, so these examples might fail to compile with older compilers. Also, there are still some corner cases where Rust fails to properly shorten the live part of the borrow and fails to compile even when it looks like it should. These'll be solved over time.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Lifetimes - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"lifetimes\"><a class=\"header\" href=\"#lifetimes\">Lifetimes</a></h1>\n<p>Rust enforces these rules through <em>lifetimes</em>. Lifetimes are named\nregions of code that a reference must be valid for. Those regions\nmay be fairly complex, as they correspond to paths of execution\nin the program. There may even be holes in these paths of execution,\nas it's possible to invalidate a reference as long as it's reinitialized\nbefore it's used again. Types which contain references (or pretend to)\nmay also be tagged with lifetimes so that Rust can prevent them from\nbeing invalidated as well.</p>\n<p>In most of our examples, the lifetimes will coincide with scopes. This is\nbecause our examples are simple. The more complex cases where they don't\ncoincide are described below.</p>\n<p>Within a function body, Rust generally doesn't let you explicitly name the\nlifetimes involved. This is because it's generally not really necessary\nto talk about lifetimes in a local context; Rust has all the information and\ncan work out everything as optimally as possible. Many anonymous scopes and\ntemporaries that you would otherwise have to write are often introduced to\nmake your code Just Work.</p>\n<p>However once you cross the function boundary, you need to start talking about\nlifetimes. Lifetimes are denoted with an apostrophe: <code class=\"hljs\">'a</code>, <code class=\"hljs\">'static</code>. To dip\nour toes with lifetimes, we're going to pretend that we're actually allowed\nto label scopes with lifetimes, and desugar the examples from the start of\nthis chapter.</p>\n<p>Originally, our examples made use of <em>aggressive</em> sugar -- high fructose corn\nsyrup even -- around scopes and lifetimes, because writing everything out\nexplicitly is <em>extremely noisy</em>. All Rust code relies on aggressive inference\nand elision of \"obvious\" things.</p>\n<p>One particularly interesting piece of sugar is that each <code class=\"hljs\">let</code> statement\nimplicitly introduces a scope. For the most part, this doesn't really matter.\nHowever it does matter for variables that refer to each other. As a simple\nexample, let's completely desugar this simple piece of Rust code:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">let</span> y = &amp;x;\n<span class=\"hljs-keyword\">let</span> z = &amp;y;\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The borrow checker always tries to minimize the extent of a lifetime, so it will\nlikely desugar to the following:</p>\n<!-- ignore: desugared code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> `'a: {` and `&amp;'b x` is not valid syntax!</span>\n<span class=\"hljs-symbol\">'a</span>: {\n    <span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-symbol\">'b</span>: {\n        <span class=\"hljs-comment\">// lifetime used is 'b because that's good enough.</span>\n        <span class=\"hljs-keyword\">let</span> y: &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">i32</span> = &amp;<span class=\"hljs-symbol\">'b</span> x;\n        <span class=\"hljs-symbol\">'c</span>: {\n            <span class=\"hljs-comment\">// ditto on 'c</span>\n            <span class=\"hljs-keyword\">let</span> z: &amp;<span class=\"hljs-symbol\">'c</span> &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">i32</span> = &amp;<span class=\"hljs-symbol\">'c</span> y; <span class=\"hljs-comment\">// \"a reference to a reference to an i32\" (with lifetimes annotated)</span>\n        }\n    }\n}</code></pre>\n<p>Wow. That's... awful. Let's all take a moment to thank Rust for making this easier.</p>\n<p>Actually passing references to outer scopes will cause Rust to infer\na larger lifetime:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">let</span> z;\n<span class=\"hljs-keyword\">let</span> y = &amp;x;\nz = y;\n<span class=\"boring\">}</span></code></pre></pre>\n<!-- ignore: desugared code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-symbol\">'a</span>: {\n    <span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-symbol\">'b</span>: {\n        <span class=\"hljs-keyword\">let</span> z: &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">i32</span>;\n        <span class=\"hljs-symbol\">'c</span>: {\n            <span class=\"hljs-comment\">// Must use 'b here because the reference to x is</span>\n            <span class=\"hljs-comment\">// being passed to the scope 'b.</span>\n            <span class=\"hljs-keyword\">let</span> y: &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">i32</span> = &amp;<span class=\"hljs-symbol\">'b</span> x;\n            z = y;\n        }\n    }\n}</code></pre>\n<h2 id=\"example-references-that-outlive-referents\"><a class=\"header\" href=\"#example-references-that-outlive-referents\">Example: references that outlive referents</a></h2>\n<p>Alright, let's look at some of those examples from before:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_str</span></span>(data: &amp;<span class=\"hljs-built_in\">u32</span>) -&gt; &amp;<span class=\"hljs-built_in\">str</span> {\n    <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{}\"</span>, data);\n    &amp;s\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>desugars to:</p>\n<!-- ignore: desugared code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_str</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(data: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u32</span>) -&gt; &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span> {\n    <span class=\"hljs-symbol\">'b</span>: {\n        <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{}\"</span>, data);\n        <span class=\"hljs-keyword\">return</span> &amp;<span class=\"hljs-symbol\">'a</span> s;\n    }\n}</code></pre>\n<p>This signature of <code class=\"hljs\">as_str</code> takes a reference to a u32 with <em>some</em> lifetime, and\npromises that it can produce a reference to a str that can live <em>just as long</em>.\nAlready we can see why this signature might be trouble. That basically implies\nthat we're going to find a str somewhere in the scope the reference\nto the u32 originated in, or somewhere <em>even earlier</em>. That's a bit of a tall\norder.</p>\n<p>We then proceed to compute the string <code class=\"hljs\">s</code>, and return a reference to it. Since\nthe contract of our function says the reference must outlive <code class=\"hljs\">'a</code>, that's the\nlifetime we infer for the reference. Unfortunately, <code class=\"hljs\">s</code> was defined in the\nscope <code class=\"hljs\">'b</code>, so the only way this is sound is if <code class=\"hljs\">'b</code> contains <code class=\"hljs\">'a</code> -- which is\nclearly false since <code class=\"hljs\">'a</code> must contain the function call itself. We have therefore\ncreated a reference whose lifetime outlives its referent, which is <em>literally</em>\nthe first thing we said that references can't do. The compiler rightfully blows\nup in our face.</p>\n<p>To make this more clear, we can expand the example:</p>\n<!-- ignore: desugared code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">as_str</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(data: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">u32</span>) -&gt; &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span> {\n    <span class=\"hljs-symbol\">'b</span>: {\n        <span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{}\"</span>, data);\n        <span class=\"hljs-keyword\">return</span> &amp;<span class=\"hljs-symbol\">'a</span> s\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-symbol\">'c</span>: {\n        <span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">u32</span> = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-symbol\">'d</span>: {\n            <span class=\"hljs-comment\">// An anonymous scope is introduced because the borrow does not</span>\n            <span class=\"hljs-comment\">// need to last for the whole scope x is valid for. The return</span>\n            <span class=\"hljs-comment\">// of as_str must find a str somewhere before this function</span>\n            <span class=\"hljs-comment\">// call. Obviously not happening.</span>\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, as_str::&lt;<span class=\"hljs-symbol\">'d</span>&gt;(&amp;<span class=\"hljs-symbol\">'d</span> x));\n        }\n    }\n}</code></pre>\n<p>Shoot!</p>\n<p>Of course, the right way to write this function is as follows:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">to_string</span></span>(data: &amp;<span class=\"hljs-built_in\">u32</span>) -&gt; <span class=\"hljs-built_in\">String</span> {\n    <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{}\"</span>, data)\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>We must produce an owned value inside the function to return it! The only way\nwe could have returned an <code class=\"hljs\">&amp;'a str</code> would have been if it was in a field of the\n<code class=\"hljs\">&amp;'a u32</code>, which is obviously not the case.</p>\n<p>(Actually we could have also just returned a string literal, which as a global\ncan be considered to reside at the bottom of the stack; though this limits\nour implementation <em>just a bit</em>.)</p>\n<h2 id=\"example-aliasing-a-mutable-reference\"><a class=\"header\" href=\"#example-aliasing-a-mutable-reference\">Example: aliasing a mutable reference</a></h2>\n<p>How about the other example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> x = &amp;data[<span class=\"hljs-number\">0</span>];\ndata.push(<span class=\"hljs-number\">4</span>);\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x);\n<span class=\"boring\">}</span></code></pre></pre>\n<!-- ignore: desugared code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-symbol\">'a</span>: {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data: <span class=\"hljs-built_in\">Vec</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n    <span class=\"hljs-symbol\">'b</span>: {\n        <span class=\"hljs-comment\">// 'b is as big as we need this borrow to be</span>\n        <span class=\"hljs-comment\">// (just need to get to `println!`)</span>\n        <span class=\"hljs-keyword\">let</span> x: &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">i32</span> = Index::index::&lt;<span class=\"hljs-symbol\">'b</span>&gt;(&amp;<span class=\"hljs-symbol\">'b</span> data, <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-symbol\">'c</span>: {\n            <span class=\"hljs-comment\">// Temporary scope because we don't need the</span>\n            <span class=\"hljs-comment\">// &amp;mut to last any longer.</span>\n            <span class=\"hljs-built_in\">Vec</span>::push(&amp;<span class=\"hljs-symbol\">'c</span> <span class=\"hljs-keyword\">mut</span> data, <span class=\"hljs-number\">4</span>);\n        }\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x);\n    }\n}</code></pre>\n<p>The problem here is a bit more subtle and interesting. We want Rust to\nreject this program for the following reason: We have a live shared reference <code class=\"hljs\">x</code>\nto a descendant of <code class=\"hljs\">data</code> when we try to take a mutable reference to <code class=\"hljs\">data</code>\nto <code class=\"hljs\">push</code>. This would create an aliased mutable reference, which would\nviolate the <em>second</em> rule of references.</p>\n<p>However this is <em>not at all</em> how Rust reasons that this program is bad. Rust\ndoesn't understand that <code class=\"hljs\">x</code> is a reference to a subpath of <code class=\"hljs\">data</code>. It doesn't\nunderstand <code class=\"hljs\">Vec</code> at all. What it <em>does</em> see is that <code class=\"hljs\">x</code> has to live for <code class=\"hljs\">'b</code> in\norder to be printed. The signature of <code class=\"hljs\">Index::index</code> subsequently demands that\nthe reference we take to <code class=\"hljs\">data</code> has to survive for <code class=\"hljs\">'b</code>. When we try to call\n<code class=\"hljs\">push</code>, it then sees us try to make an <code class=\"hljs\">&amp;'c mut data</code>. Rust knows that <code class=\"hljs\">'c</code> is\ncontained within <code class=\"hljs\">'b</code>, and rejects our program because the <code class=\"hljs\">&amp;'b data</code> must still\nbe alive!</p>\n<p>Here we see that the lifetime system is much more coarse than the reference\nsemantics we're actually interested in preserving. For the most part, <em>that's\ntotally ok</em>, because it keeps us from spending all day explaining our program\nto the compiler. However it does mean that several programs that are totally\ncorrect with respect to Rust's <em>true</em> semantics are rejected because lifetimes\nare too dumb.</p>\n<h2 id=\"the-area-covered-by-a-lifetime\"><a class=\"header\" href=\"#the-area-covered-by-a-lifetime\">The area covered by a lifetime</a></h2>\n<p>A reference (sometimes called a <em>borrow</em>) is <em>alive</em> from the place it is\ncreated to its last use. The borrowed value needs to outlive only borrows that\nare alive. This looks simple, but there are a few subtleties.</p>\n<p>The following snippet compiles, because after printing <code class=\"hljs\">x</code>, it is no longer\nneeded, so it doesn't matter if it is dangling or aliased (even though the\nvariable <code class=\"hljs\">x</code> <em>technically</em> exists to the very end of the scope).</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> x = &amp;data[<span class=\"hljs-number\">0</span>];\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x);\n<span class=\"hljs-comment\">// This is OK, x is no longer needed</span>\ndata.push(<span class=\"hljs-number\">4</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>However, if the value has a destructor, the destructor is run at the end of the\nscope. And running the destructor is considered a use â€’ obviously the last one.\nSo, this will <em>not</em> compile.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">X</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> X&lt;<span class=\"hljs-symbol\">'_</span>&gt; {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> x = X(&amp;data[<span class=\"hljs-number\">0</span>]);\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, x);\ndata.push(<span class=\"hljs-number\">4</span>);\n<span class=\"hljs-comment\">// Here, the destructor is run and therefore this'll fail to compile.</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>One way to convince the compiler that <code class=\"hljs\">x</code> is no longer valid is by using <code class=\"hljs\">drop(x)</code> before <code class=\"hljs\">data.push(4)</code>.</p>\n<p>Furthermore, there might be multiple possible last uses of the borrow, for\nexample in each branch of a condition.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">some_condition</span></span>() -&gt; <span class=\"hljs-built_in\">bool</span> { <span class=\"hljs-literal\">true</span> }\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> x = &amp;data[<span class=\"hljs-number\">0</span>];\n\n<span class=\"hljs-keyword\">if</span> some_condition() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x); <span class=\"hljs-comment\">// This is the last use of `x` in this branch</span>\n    data.push(<span class=\"hljs-number\">4</span>);      <span class=\"hljs-comment\">// So we can push here</span>\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// There's no use of `x` in here, so effectively the last use is the</span>\n    <span class=\"hljs-comment\">// creation of x at the top of the example.</span>\n    data.push(<span class=\"hljs-number\">5</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>And a lifetime can have a pause in it. Or you might look at it as two distinct\nborrows just being tied to the same local variable. This often happens around\nloops (writing a new value of a variable at the end of the loop and using it for\nthe last time at the top of the next iteration).</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> data = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-comment\">// This mut allows us to change where the reference points to</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = &amp;data[<span class=\"hljs-number\">0</span>];\n\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x); <span class=\"hljs-comment\">// Last use of this borrow</span>\ndata.push(<span class=\"hljs-number\">4</span>);\nx = &amp;data[<span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// We start a new borrow here</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Historically, Rust kept the borrow alive until the end of scope, so these\nexamples might fail to compile with older compilers. Also, there are still some\ncorner cases where Rust fails to properly shorten the live part of the borrow\nand fails to compile even when it looks like it should. These'll be solved over\ntime.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"aliasing.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"lifetime-mismatch.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"aliasing.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"lifetime-mismatch.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:06.053Z"
}