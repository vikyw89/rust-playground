{
	"title": "transmute in std::intrinsics - Rust",
	"url": "https://doc.rust-lang.org/stable/std/intrinsics/fn.transmute.html",
	"markdown": "# transmute in std::intrinsics - Rust\n\n## Function [std](../index.html)::[intrinsics](index.html)::[transmute](#)\n\n1.0.0 (const: 1.56.0) · [source](https://doc.rust-lang.org/1.80.0/src/core/intrinsics.rs.html#1441) ·\n\n```\npub const unsafe extern \"rust-intrinsic\" fn transmute<Src, Dst>(\n    src: Src,\n) -> Dst\n```\n\nExpand description\n\nReinterprets the bits of a value of one type as another type.\n\nBoth types must have the same size. Compilation will fail if this is not guaranteed.\n\n`transmute` is semantically equivalent to a bitwise move of one type into another. It copies the bits from the source value into the destination value, then forgets the original. Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is _not_ guaranteed to be preserved by `transmute`.\n\nBoth the argument and the result must be [valid](../../nomicon/what-unsafe-does.html) at their given type. Violating this condition leads to [undefined behavior](../../reference/behavior-considered-undefined.html). The compiler will generate code _assuming that you, the programmer, ensure that there will never be undefined behavior_. It is therefore your responsibility to guarantee that every value passed to `transmute` is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results. This makes `transmute` **incredibly unsafe**. `transmute` should be the absolute last resort.\n\nBecause `transmute` is a by-value operation, alignment of the _transmuted values themselves_ is not a concern. As with any other function, the compiler already ensures both `Src` and `Dst` are properly aligned. However, when transmuting values that _point elsewhere_ (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values.\n\nThe [nomicon](../../nomicon/transmutes.html) has additional documentation.\n\n## [§](#transmutation-between-pointers-and-integers)Transmutation between pointers and integers\n\nSpecial care has to be taken when transmuting between pointers and integers, e.g. transmuting between `*const ()` and `usize`.\n\nTransmuting _pointers to integers_ in a `const` context is [undefined behavior](../../reference/behavior-considered-undefined.html), unless the pointer was originally created _from_ an integer. (That includes this function specifically, integer-to-pointer casts, and helpers like [`dangling`](../ptr/fn.dangling.html \"fn std::ptr::dangling\"), but also semantically-equivalent conversions such as punning through `repr(C)` union fields.) Any attempt to use the resulting value for integer operations will abort const-evaluation. (And even outside `const`, such transmutation is touching on many unspecified aspects of the Rust memory model and should be avoided. See below for alternatives.)\n\nTransmuting _integers to pointers_ is a largely unspecified operation. It is likely _not_ equivalent to an `as` cast. Doing non-zero-sized memory accesses with a pointer constructed this way is currently considered undefined behavior.\n\nAll this also applies when the integer is nested inside an array, tuple, struct, or enum. However, `MaybeUninit<usize>` is not considered an integer type for the purpose of this section. Transmuting `*const ()` to `MaybeUninit<usize>` is fine—but then calling `assume_init()` on that result is considered as completing the pointer-to-integer transmute and thus runs into the issues discussed above.\n\nIn particular, doing a pointer-to-integer-to-pointer roundtrip via `transmute` is _not_ a lossless process. If you want to round-trip a pointer through an integer in a way that you can get back the original pointer, you need to use `as` casts, or replace the integer type by `MaybeUninit<$int>` (and never call `assume_init()`). If you are looking for a way to store data of arbitrary type, also use `MaybeUninit<T>` (that will also handle uninitialized memory due to padding). If you specifically need to store something that is “either an integer or a pointer”, use `*mut ()`: integers can be converted to pointers and back without any loss (via `as` casts or via `transmute`).\n\n## [§](#examples)Examples\n\nThere are a few things that `transmute` is really useful for.\n\nTurning a pointer into a function pointer. This is _not_ portable to machines where function pointers and data pointers have different sizes.\n\n```\nfn foo() -> i32 {\n    0\n}\n// Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer.\n// This avoids an integer-to-pointer `transmute`, which can be problematic.\n// Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.\nlet pointer = foo as *const ();\nlet function = unsafe {\n    std::mem::transmute::<*const (), fn() -> i32>(pointer)\n};\nassert_eq!(function(), 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+foo()+-%3E+i32+%7B%0A++++++++0%0A++++%7D%0A++++//+Crucially,+we+%60as%60-cast+to+a+raw+pointer+before+%60transmute%60ing+to+a+function+pointer.%0A++++//+This+avoids+an+integer-to-pointer+%60transmute%60,+which+can+be+problematic.%0A++++//+Transmuting+between+raw+pointers+and+function+pointers+(i.e.,+two+pointer+types)+is+fine.%0A++++let+pointer+=+foo+as+*const+();%0A++++let+function+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C*const+(),+fn()+-%3E+i32%3E(pointer)%0A++++%7D;%0A++++assert_eq!(function(),+0);%0A%7D&edition=2021)\n\nExtending a lifetime, or shortening an invariant lifetime. This is advanced, very unsafe Rust!\n\n```\nstruct R<'a>(&'a i32);\nunsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n    std::mem::transmute::<R<'b>, R<'static>>(r)\n}\n\nunsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n                                             -> &'b mut R<'c> {\n    std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+R%3C%27a%3E(%26%27a+i32);%0A++++unsafe+fn+extend_lifetime%3C%27b%3E(r:+R%3C%27b%3E)+-%3E+R%3C%27static%3E+%7B%0A++++++++std::mem::transmute::%3CR%3C%27b%3E,+R%3C%27static%3E%3E(r)%0A++++%7D%0A++++%0A++++unsafe+fn+shorten_invariant_lifetime%3C%27b,+%27c%3E(r:+%26%27b+mut+R%3C%27static%3E)%0A+++++++++++++++++++++++++++++++++++++++++++++++++-%3E+%26%27b+mut+R%3C%27c%3E+%7B%0A++++++++std::mem::transmute::%3C%26%27b+mut+R%3C%27static%3E,+%26%27b+mut+R%3C%27c%3E%3E(r)%0A++++%7D%0A%7D&edition=2021)\n\n## [§](#alternatives)Alternatives\n\nDon’t despair: many uses of `transmute` can be achieved through other means. Below are common applications of `transmute` which can be replaced with safer constructs.\n\nTurning raw bytes (`[u8; SZ]`) into `u32`, `f64`, etc.:\n\n```\nlet raw_bytes = [0x78, 0x56, 0x34, 0x12];\n\nlet num = unsafe {\n    std::mem::transmute::<[u8; 4], u32>(raw_bytes)\n};\n\n// use `u32::from_ne_bytes` instead\nlet num = u32::from_ne_bytes(raw_bytes);\n// or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness\nlet num = u32::from_le_bytes(raw_bytes);\nassert_eq!(num, 0x12345678);\nlet num = u32::from_be_bytes(raw_bytes);\nassert_eq!(num, 0x78563412);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+raw_bytes+=+%5B0x78,+0x56,+0x34,+0x12%5D;%0A++++%0A++++let+num+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C%5Bu8;+4%5D,+u32%3E(raw_bytes)%0A++++%7D;%0A++++%0A++++//+use+%60u32::from_ne_bytes%60+instead%0A++++let+num+=+u32::from_ne_bytes(raw_bytes);%0A++++//+or+use+%60u32::from_le_bytes%60+or+%60u32::from_be_bytes%60+to+specify+the+endianness%0A++++let+num+=+u32::from_le_bytes(raw_bytes);%0A++++assert_eq!(num,+0x12345678);%0A++++let+num+=+u32::from_be_bytes(raw_bytes);%0A++++assert_eq!(num,+0x78563412);%0A%7D&edition=2021)\n\nTurning a pointer into a `usize`:\n\n```\nlet ptr = &0;\nlet ptr_num_transmute = unsafe {\n    std::mem::transmute::<&i32, usize>(ptr)\n};\n\n// Use an `as` cast instead\nlet ptr_num_cast = ptr as *const i32 as usize;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr+=+%260;%0A++++let+ptr_num_transmute+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C%26i32,+usize%3E(ptr)%0A++++%7D;%0A++++%0A++++//+Use+an+%60as%60+cast+instead%0A++++let+ptr_num_cast+=+ptr+as+*const+i32+as+usize;%0A%7D&edition=2021)\n\nNote that using `transmute` to turn a pointer to a `usize` is (as noted above) [undefined behavior](../../reference/behavior-considered-undefined.html) in `const` contexts. Also outside of consts, this operation might not behave as expected – this is touching on many unspecified aspects of the Rust memory model. Depending on what the code is doing, the following alternatives are preferable to pointer-to-integer transmutation:\n\n-   If the code just wants to store data of arbitrary type in some buffer and needs to pick a type for that buffer, it can use [`MaybeUninit`](../mem/union.MaybeUninit.html \"union std::mem::MaybeUninit\").\n-   If the code actually wants to work on the address the pointer points to, it can use `as` casts or [`ptr.addr()`](about:blank/primitive.pointer.html#method.addr \"method pointer::addr\").\n\nTurning a `*mut T` into an `&mut T`:\n\n```\nlet ptr: *mut i32 = &mut 0;\nlet ref_transmuted = unsafe {\n    std::mem::transmute::<*mut i32, &mut i32>(ptr)\n};\n\n// Use a reborrow instead\nlet ref_casted = unsafe { &mut *ptr };\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr:+*mut+i32+=+%26mut+0;%0A++++let+ref_transmuted+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C*mut+i32,+%26mut+i32%3E(ptr)%0A++++%7D;%0A++++%0A++++//+Use+a+reborrow+instead%0A++++let+ref_casted+=+unsafe+%7B+%26mut+*ptr+%7D;%0A%7D&edition=2021)\n\nTurning an `&mut T` into an `&mut U`:\n\n```\nlet ptr = &mut 0;\nlet val_transmuted = unsafe {\n    std::mem::transmute::<&mut i32, &mut u32>(ptr)\n};\n\n// Now, put together `as` and reborrowing - note the chaining of `as`\n// `as` is not transitive\nlet val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr+=+%26mut+0;%0A++++let+val_transmuted+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C%26mut+i32,+%26mut+u32%3E(ptr)%0A++++%7D;%0A++++%0A++++//+Now,+put+together+%60as%60+and+reborrowing+-+note+the+chaining+of+%60as%60%0A++++//+%60as%60+is+not+transitive%0A++++let+val_casts+=+unsafe+%7B+%26mut+*(ptr+as+*mut+i32+as+*mut+u32)+%7D;%0A%7D&edition=2021)\n\nTurning an `&str` into a `&[u8]`:\n\n```\n// this is not a good way to do this.\nlet slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\nassert_eq!(slice, &[82, 117, 115, 116]);\n\n// You could use `str::as_bytes`\nlet slice = \"Rust\".as_bytes();\nassert_eq!(slice, &[82, 117, 115, 116]);\n\n// Or, just use a byte string, if you have control over the string\n// literal\nassert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+this+is+not+a+good+way+to+do+this.%0Afn+main()+%7B%0A++++let+slice+=+unsafe+%7B+std::mem::transmute::%3C%26str,+%26%5Bu8%5D%3E(%22Rust%22)+%7D;%0A++++assert_eq!(slice,+%26%5B82,+117,+115,+116%5D);%0A++++%0A++++//+You+could+use+%60str::as_bytes%60%0A++++let+slice+=+%22Rust%22.as_bytes();%0A++++assert_eq!(slice,+%26%5B82,+117,+115,+116%5D);%0A++++%0A++++//+Or,+just+use+a+byte+string,+if+you+have+control+over+the+string%0A++++//+literal%0A++++assert_eq!(b%22Rust%22,+%26%5B82,+117,+115,+116%5D);%0A%7D&edition=2021)\n\nTurning a `Vec<&T>` into a `Vec<Option<&T>>`.\n\nTo transmute the inner type of the contents of a container, you must make sure to not violate any of the container’s invariants. For `Vec`, this means that both the size _and alignment_ of the inner types have to match. Other containers might rely on the size of the type, alignment, or even the `TypeId`, in which case transmuting wouldn’t be possible at all without violating the container invariants.\n\n```\nlet store = [0, 1, 2, 3];\nlet v_orig = store.iter().collect::<Vec<&i32>>();\n\n// clone the vector as we will reuse them later\nlet v_clone = v_orig.clone();\n\n// Using transmute: this relies on the unspecified data layout of `Vec`, which is a\n// bad idea and could cause Undefined Behavior.\n// However, it is no-copy.\nlet v_transmuted = unsafe {\n    std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\n};\n\nlet v_clone = v_orig.clone();\n\n// This is the suggested, safe way.\n// It may copy the entire vector into a new one though, but also may not.\nlet v_collected = v_clone.into_iter()\n                         .map(Some)\n                         .collect::<Vec<Option<&i32>>>();\n\nlet v_clone = v_orig.clone();\n\n// This is the proper no-copy, unsafe way of \"transmuting\" a `Vec`, without relying on the\n// data layout. Instead of literally calling `transmute`, we perform a pointer cast, but\n// in terms of converting the original inner type (`&i32`) to the new one (`Option<&i32>`),\n// this has all the same caveats. Besides the information provided above, also consult the\n// [`from_raw_parts`] documentation.\nlet v_from_raw = unsafe {\n    // Ensure the original vector is not dropped.\n    let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n    Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\n                        v_clone.len(),\n                        v_clone.capacity())\n};\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+store+=+%5B0,+1,+2,+3%5D;%0A++++let+v_orig+=+store.iter().collect::%3CVec%3C%26i32%3E%3E();%0A++++%0A++++//+clone+the+vector+as+we+will+reuse+them+later%0A++++let+v_clone+=+v_orig.clone();%0A++++%0A++++//+Using+transmute:+this+relies+on+the+unspecified+data+layout+of+%60Vec%60,+which+is+a%0A++++//+bad+idea+and+could+cause+Undefined+Behavior.%0A++++//+However,+it+is+no-copy.%0A++++let+v_transmuted+=+unsafe+%7B%0A++++++++std::mem::transmute::%3CVec%3C%26i32%3E,+Vec%3COption%3C%26i32%3E%3E%3E(v_clone)%0A++++%7D;%0A++++%0A++++let+v_clone+=+v_orig.clone();%0A++++%0A++++//+This+is+the+suggested,+safe+way.%0A++++//+It+may+copy+the+entire+vector+into+a+new+one+though,+but+also+may+not.%0A++++let+v_collected+=+v_clone.into_iter()%0A+++++++++++++++++++++++++++++.map(Some)%0A+++++++++++++++++++++++++++++.collect::%3CVec%3COption%3C%26i32%3E%3E%3E();%0A++++%0A++++let+v_clone+=+v_orig.clone();%0A++++%0A++++//+This+is+the+proper+no-copy,+unsafe+way+of+%22transmuting%22+a+%60Vec%60,+without+relying+on+the%0A++++//+data+layout.+Instead+of+literally+calling+%60transmute%60,+we+perform+a+pointer+cast,+but%0A++++//+in+terms+of+converting+the+original+inner+type+(%60%26i32%60)+to+the+new+one+(%60Option%3C%26i32%3E%60),%0A++++//+this+has+all+the+same+caveats.+Besides+the+information+provided+above,+also+consult+the%0A++++//+%5B%60from_raw_parts%60%5D+documentation.%0A++++let+v_from_raw+=+unsafe+%7B%0A++++++++//+Ensure+the+original+vector+is+not+dropped.%0A++++++++let+mut+v_clone+=+std::mem::ManuallyDrop::new(v_clone);%0A++++++++Vec::from_raw_parts(v_clone.as_mut_ptr()+as+*mut+Option%3C%26i32%3E,%0A++++++++++++++++++++++++++++v_clone.len(),%0A++++++++++++++++++++++++++++v_clone.capacity())%0A++++%7D;%0A%7D&edition=2021)\n\nImplementing `split_at_mut`:\n\n```\nuse std::{slice, mem};\n\n// There are multiple ways to do this, and there are multiple problems\n// with the following (transmute) way.\nfn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n                             -> (&mut [T], &mut [T]) {\n    let len = slice.len();\n    assert!(mid <= len);\n    unsafe {\n        let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n        // first: transmute is not type safe; all it checks is that T and\n        // U are of the same size. Second, right here, you have two\n        // mutable references pointing to the same memory.\n        (&mut slice[0..mid], &mut slice2[mid..len])\n    }\n}\n\n// This gets rid of the type safety problems; `&mut *` will *only* give\n// you an `&mut T` from an `&mut T` or `*mut T`.\nfn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n                         -> (&mut [T], &mut [T]) {\n    let len = slice.len();\n    assert!(mid <= len);\n    unsafe {\n        let slice2 = &mut *(slice as *mut [T]);\n        // however, you still have two mutable references pointing to\n        // the same memory.\n        (&mut slice[0..mid], &mut slice2[mid..len])\n    }\n}\n\n// This is how the standard library does it. This is the best method, if\n// you need to do something like this\nfn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n                      -> (&mut [T], &mut [T]) {\n    let len = slice.len();\n    assert!(mid <= len);\n    unsafe {\n        let ptr = slice.as_mut_ptr();\n        // This now has three mutable references pointing at the same\n        // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n        // `slice` is never used after `let ptr = ...`, and so one can\n        // treat it as \"dead\", and therefore, you only have two real\n        // mutable slices.\n        (slice::from_raw_parts_mut(ptr, mid),\n         slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bslice,+mem%7D;%0A++++%0A++++//+There+are+multiple+ways+to+do+this,+and+there+are+multiple+problems%0A++++//+with+the+following+(transmute)+way.%0A++++fn+split_at_mut_transmute%3CT%3E(slice:+%26mut+%5BT%5D,+mid:+usize)%0A+++++++++++++++++++++++++++++++++-%3E+(%26mut+%5BT%5D,+%26mut+%5BT%5D)+%7B%0A++++++++let+len+=+slice.len();%0A++++++++assert!(mid+%3C=+len);%0A++++++++unsafe+%7B%0A++++++++++++let+slice2+=+mem::transmute::%3C%26mut+%5BT%5D,+%26mut+%5BT%5D%3E(slice);%0A++++++++++++//+first:+transmute+is+not+type+safe;+all+it+checks+is+that+T+and%0A++++++++++++//+U+are+of+the+same+size.+Second,+right+here,+you+have+two%0A++++++++++++//+mutable+references+pointing+to+the+same+memory.%0A++++++++++++(%26mut+slice%5B0..mid%5D,+%26mut+slice2%5Bmid..len%5D)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+This+gets+rid+of+the+type+safety+problems;+%60%26mut+*%60+will+*only*+give%0A++++//+you+an+%60%26mut+T%60+from+an+%60%26mut+T%60+or+%60*mut+T%60.%0A++++fn+split_at_mut_casts%3CT%3E(slice:+%26mut+%5BT%5D,+mid:+usize)%0A+++++++++++++++++++++++++++++-%3E+(%26mut+%5BT%5D,+%26mut+%5BT%5D)+%7B%0A++++++++let+len+=+slice.len();%0A++++++++assert!(mid+%3C=+len);%0A++++++++unsafe+%7B%0A++++++++++++let+slice2+=+%26mut+*(slice+as+*mut+%5BT%5D);%0A++++++++++++//+however,+you+still+have+two+mutable+references+pointing+to%0A++++++++++++//+the+same+memory.%0A++++++++++++(%26mut+slice%5B0..mid%5D,+%26mut+slice2%5Bmid..len%5D)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+This+is+how+the+standard+library+does+it.+This+is+the+best+method,+if%0A++++//+you+need+to+do+something+like+this%0A++++fn+split_at_stdlib%3CT%3E(slice:+%26mut+%5BT%5D,+mid:+usize)%0A++++++++++++++++++++++++++-%3E+(%26mut+%5BT%5D,+%26mut+%5BT%5D)+%7B%0A++++++++let+len+=+slice.len();%0A++++++++assert!(mid+%3C=+len);%0A++++++++unsafe+%7B%0A++++++++++++let+ptr+=+slice.as_mut_ptr();%0A++++++++++++//+This+now+has+three+mutable+references+pointing+at+the+same%0A++++++++++++//+memory.+%60slice%60,+the+rvalue+ret.0,+and+the+rvalue+ret.1.%0A++++++++++++//+%60slice%60+is+never+used+after+%60let+ptr+=+...%60,+and+so+one+can%0A++++++++++++//+treat+it+as+%22dead%22,+and+therefore,+you+only+have+two+real%0A++++++++++++//+mutable+slices.%0A++++++++++++(slice::from_raw_parts_mut(ptr,+mid),%0A+++++++++++++slice::from_raw_parts_mut(ptr.add(mid),+len+-+mid))%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Reinterprets the bits of a value of one type as another type.\"><title>transmute in std::intrinsics - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc fn\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><div class=\"sidebar-elems\"><h2><a href=\"index.html\">In std::intrinsics</a></h2><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"mir/index.html\">mir</a></li><li><a href=\"simd/index.html\">simd</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.AggregateRawPtr.html\">AggregateRawPtr</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.abort.html\">abort</a></li><li><a href=\"fn.add_with_overflow.html\">add_with_overflow</a></li><li><a href=\"fn.aggregate_raw_ptr.html\">aggregate_raw_ptr</a></li><li><a href=\"fn.arith_offset.html\">arith_offset</a></li><li><a href=\"fn.assert_inhabited.html\">assert_inhabited</a></li><li><a href=\"fn.assert_mem_uninitialized_valid.html\">assert_mem_uninitialized_valid</a></li><li><a href=\"fn.assert_zero_valid.html\">assert_zero_valid</a></li><li><a href=\"fn.assume.html\">assume</a></li><li><a href=\"fn.atomic_and_acqrel.html\">atomic_and_acqrel</a></li><li><a href=\"fn.atomic_and_acquire.html\">atomic_and_acquire</a></li><li><a href=\"fn.atomic_and_relaxed.html\">atomic_and_relaxed</a></li><li><a href=\"fn.atomic_and_release.html\">atomic_and_release</a></li><li><a href=\"fn.atomic_and_seqcst.html\">atomic_and_seqcst</a></li><li><a href=\"fn.atomic_cxchg_acqrel_acquire.html\">atomic_cxchg_acqrel_acquire</a></li><li><a href=\"fn.atomic_cxchg_acqrel_relaxed.html\">atomic_cxchg_acqrel_relaxed</a></li><li><a href=\"fn.atomic_cxchg_acqrel_seqcst.html\">atomic_cxchg_acqrel_seqcst</a></li><li><a href=\"fn.atomic_cxchg_acquire_acquire.html\">atomic_cxchg_acquire_acquire</a></li><li><a href=\"fn.atomic_cxchg_acquire_relaxed.html\">atomic_cxchg_acquire_relaxed</a></li><li><a href=\"fn.atomic_cxchg_acquire_seqcst.html\">atomic_cxchg_acquire_seqcst</a></li><li><a href=\"fn.atomic_cxchg_relaxed_acquire.html\">atomic_cxchg_relaxed_acquire</a></li><li><a href=\"fn.atomic_cxchg_relaxed_relaxed.html\">atomic_cxchg_relaxed_relaxed</a></li><li><a href=\"fn.atomic_cxchg_relaxed_seqcst.html\">atomic_cxchg_relaxed_seqcst</a></li><li><a href=\"fn.atomic_cxchg_release_acquire.html\">atomic_cxchg_release_acquire</a></li><li><a href=\"fn.atomic_cxchg_release_relaxed.html\">atomic_cxchg_release_relaxed</a></li><li><a href=\"fn.atomic_cxchg_release_seqcst.html\">atomic_cxchg_release_seqcst</a></li><li><a href=\"fn.atomic_cxchg_seqcst_acquire.html\">atomic_cxchg_seqcst_acquire</a></li><li><a href=\"fn.atomic_cxchg_seqcst_relaxed.html\">atomic_cxchg_seqcst_relaxed</a></li><li><a href=\"fn.atomic_cxchg_seqcst_seqcst.html\">atomic_cxchg_seqcst_seqcst</a></li><li><a href=\"fn.atomic_cxchgweak_acqrel_acquire.html\">atomic_cxchgweak_acqrel_acquire</a></li><li><a href=\"fn.atomic_cxchgweak_acqrel_relaxed.html\">atomic_cxchgweak_acqrel_relaxed</a></li><li><a href=\"fn.atomic_cxchgweak_acqrel_seqcst.html\">atomic_cxchgweak_acqrel_seqcst</a></li><li><a href=\"fn.atomic_cxchgweak_acquire_acquire.html\">atomic_cxchgweak_acquire_acquire</a></li><li><a href=\"fn.atomic_cxchgweak_acquire_relaxed.html\">atomic_cxchgweak_acquire_relaxed</a></li><li><a href=\"fn.atomic_cxchgweak_acquire_seqcst.html\">atomic_cxchgweak_acquire_seqcst</a></li><li><a href=\"fn.atomic_cxchgweak_relaxed_acquire.html\">atomic_cxchgweak_relaxed_acquire</a></li><li><a href=\"fn.atomic_cxchgweak_relaxed_relaxed.html\">atomic_cxchgweak_relaxed_relaxed</a></li><li><a href=\"fn.atomic_cxchgweak_relaxed_seqcst.html\">atomic_cxchgweak_relaxed_seqcst</a></li><li><a href=\"fn.atomic_cxchgweak_release_acquire.html\">atomic_cxchgweak_release_acquire</a></li><li><a href=\"fn.atomic_cxchgweak_release_relaxed.html\">atomic_cxchgweak_release_relaxed</a></li><li><a href=\"fn.atomic_cxchgweak_release_seqcst.html\">atomic_cxchgweak_release_seqcst</a></li><li><a href=\"fn.atomic_cxchgweak_seqcst_acquire.html\">atomic_cxchgweak_seqcst_acquire</a></li><li><a href=\"fn.atomic_cxchgweak_seqcst_relaxed.html\">atomic_cxchgweak_seqcst_relaxed</a></li><li><a href=\"fn.atomic_cxchgweak_seqcst_seqcst.html\">atomic_cxchgweak_seqcst_seqcst</a></li><li><a href=\"fn.atomic_fence_acqrel.html\">atomic_fence_acqrel</a></li><li><a href=\"fn.atomic_fence_acquire.html\">atomic_fence_acquire</a></li><li><a href=\"fn.atomic_fence_release.html\">atomic_fence_release</a></li><li><a href=\"fn.atomic_fence_seqcst.html\">atomic_fence_seqcst</a></li><li><a href=\"fn.atomic_load_acquire.html\">atomic_load_acquire</a></li><li><a href=\"fn.atomic_load_relaxed.html\">atomic_load_relaxed</a></li><li><a href=\"fn.atomic_load_seqcst.html\">atomic_load_seqcst</a></li><li><a href=\"fn.atomic_load_unordered.html\">atomic_load_unordered</a></li><li><a href=\"fn.atomic_max_acqrel.html\">atomic_max_acqrel</a></li><li><a href=\"fn.atomic_max_acquire.html\">atomic_max_acquire</a></li><li><a href=\"fn.atomic_max_relaxed.html\">atomic_max_relaxed</a></li><li><a href=\"fn.atomic_max_release.html\">atomic_max_release</a></li><li><a href=\"fn.atomic_max_seqcst.html\">atomic_max_seqcst</a></li><li><a href=\"fn.atomic_min_acqrel.html\">atomic_min_acqrel</a></li><li><a href=\"fn.atomic_min_acquire.html\">atomic_min_acquire</a></li><li><a href=\"fn.atomic_min_relaxed.html\">atomic_min_relaxed</a></li><li><a href=\"fn.atomic_min_release.html\">atomic_min_release</a></li><li><a href=\"fn.atomic_min_seqcst.html\">atomic_min_seqcst</a></li><li><a href=\"fn.atomic_nand_acqrel.html\">atomic_nand_acqrel</a></li><li><a href=\"fn.atomic_nand_acquire.html\">atomic_nand_acquire</a></li><li><a href=\"fn.atomic_nand_relaxed.html\">atomic_nand_relaxed</a></li><li><a href=\"fn.atomic_nand_release.html\">atomic_nand_release</a></li><li><a href=\"fn.atomic_nand_seqcst.html\">atomic_nand_seqcst</a></li><li><a href=\"fn.atomic_or_acqrel.html\">atomic_or_acqrel</a></li><li><a href=\"fn.atomic_or_acquire.html\">atomic_or_acquire</a></li><li><a href=\"fn.atomic_or_relaxed.html\">atomic_or_relaxed</a></li><li><a href=\"fn.atomic_or_release.html\">atomic_or_release</a></li><li><a href=\"fn.atomic_or_seqcst.html\">atomic_or_seqcst</a></li><li><a href=\"fn.atomic_singlethreadfence_acqrel.html\">atomic_singlethreadfence_acqrel</a></li><li><a href=\"fn.atomic_singlethreadfence_acquire.html\">atomic_singlethreadfence_acquire</a></li><li><a href=\"fn.atomic_singlethreadfence_release.html\">atomic_singlethreadfence_release</a></li><li><a href=\"fn.atomic_singlethreadfence_seqcst.html\">atomic_singlethreadfence_seqcst</a></li><li><a href=\"fn.atomic_store_relaxed.html\">atomic_store_relaxed</a></li><li><a href=\"fn.atomic_store_release.html\">atomic_store_release</a></li><li><a href=\"fn.atomic_store_seqcst.html\">atomic_store_seqcst</a></li><li><a href=\"fn.atomic_store_unordered.html\">atomic_store_unordered</a></li><li><a href=\"fn.atomic_umax_acqrel.html\">atomic_umax_acqrel</a></li><li><a href=\"fn.atomic_umax_acquire.html\">atomic_umax_acquire</a></li><li><a href=\"fn.atomic_umax_relaxed.html\">atomic_umax_relaxed</a></li><li><a href=\"fn.atomic_umax_release.html\">atomic_umax_release</a></li><li><a href=\"fn.atomic_umax_seqcst.html\">atomic_umax_seqcst</a></li><li><a href=\"fn.atomic_umin_acqrel.html\">atomic_umin_acqrel</a></li><li><a href=\"fn.atomic_umin_acquire.html\">atomic_umin_acquire</a></li><li><a href=\"fn.atomic_umin_relaxed.html\">atomic_umin_relaxed</a></li><li><a href=\"fn.atomic_umin_release.html\">atomic_umin_release</a></li><li><a href=\"fn.atomic_umin_seqcst.html\">atomic_umin_seqcst</a></li><li><a href=\"fn.atomic_xadd_acqrel.html\">atomic_xadd_acqrel</a></li><li><a href=\"fn.atomic_xadd_acquire.html\">atomic_xadd_acquire</a></li><li><a href=\"fn.atomic_xadd_relaxed.html\">atomic_xadd_relaxed</a></li><li><a href=\"fn.atomic_xadd_release.html\">atomic_xadd_release</a></li><li><a href=\"fn.atomic_xadd_seqcst.html\">atomic_xadd_seqcst</a></li><li><a href=\"fn.atomic_xchg_acqrel.html\">atomic_xchg_acqrel</a></li><li><a href=\"fn.atomic_xchg_acquire.html\">atomic_xchg_acquire</a></li><li><a href=\"fn.atomic_xchg_relaxed.html\">atomic_xchg_relaxed</a></li><li><a href=\"fn.atomic_xchg_release.html\">atomic_xchg_release</a></li><li><a href=\"fn.atomic_xchg_seqcst.html\">atomic_xchg_seqcst</a></li><li><a href=\"fn.atomic_xor_acqrel.html\">atomic_xor_acqrel</a></li><li><a href=\"fn.atomic_xor_acquire.html\">atomic_xor_acquire</a></li><li><a href=\"fn.atomic_xor_relaxed.html\">atomic_xor_relaxed</a></li><li><a href=\"fn.atomic_xor_release.html\">atomic_xor_release</a></li><li><a href=\"fn.atomic_xor_seqcst.html\">atomic_xor_seqcst</a></li><li><a href=\"fn.atomic_xsub_acqrel.html\">atomic_xsub_acqrel</a></li><li><a href=\"fn.atomic_xsub_acquire.html\">atomic_xsub_acquire</a></li><li><a href=\"fn.atomic_xsub_relaxed.html\">atomic_xsub_relaxed</a></li><li><a href=\"fn.atomic_xsub_release.html\">atomic_xsub_release</a></li><li><a href=\"fn.atomic_xsub_seqcst.html\">atomic_xsub_seqcst</a></li><li><a href=\"fn.bitreverse.html\">bitreverse</a></li><li><a href=\"fn.black_box.html\">black_box</a></li><li><a href=\"fn.breakpoint.html\">breakpoint</a></li><li><a href=\"fn.bswap.html\">bswap</a></li><li><a href=\"fn.caller_location.html\">caller_location</a></li><li><a href=\"fn.catch_unwind.html\">catch_unwind</a></li><li><a href=\"fn.ceilf32.html\">ceilf32</a></li><li><a href=\"fn.ceilf64.html\">ceilf64</a></li><li><a href=\"fn.compare_bytes.html\">compare_bytes</a></li><li><a href=\"fn.const_allocate.html\">const_allocate</a></li><li><a href=\"fn.const_deallocate.html\">const_deallocate</a></li><li><a href=\"fn.const_eval_select.html\">const_eval_select</a></li><li><a href=\"fn.copy.html\">copy</a></li><li><a href=\"fn.copy_nonoverlapping.html\">copy_nonoverlapping</a></li><li><a href=\"fn.copysignf32.html\">copysignf32</a></li><li><a href=\"fn.copysignf64.html\">copysignf64</a></li><li><a href=\"fn.cosf32.html\">cosf32</a></li><li><a href=\"fn.cosf64.html\">cosf64</a></li><li><a href=\"fn.ctlz.html\">ctlz</a></li><li><a href=\"fn.ctlz_nonzero.html\">ctlz_nonzero</a></li><li><a href=\"fn.ctpop.html\">ctpop</a></li><li><a href=\"fn.cttz.html\">cttz</a></li><li><a href=\"fn.cttz_nonzero.html\">cttz_nonzero</a></li><li><a href=\"fn.discriminant_value.html\">discriminant_value</a></li><li><a href=\"fn.drop_in_place.html\">drop_in_place</a></li><li><a href=\"fn.exact_div.html\">exact_div</a></li><li><a href=\"fn.exp2f32.html\">exp2f32</a></li><li><a href=\"fn.exp2f64.html\">exp2f64</a></li><li><a href=\"fn.expf32.html\">expf32</a></li><li><a href=\"fn.expf64.html\">expf64</a></li><li><a href=\"fn.fabsf32.html\">fabsf32</a></li><li><a href=\"fn.fabsf64.html\">fabsf64</a></li><li><a href=\"fn.fadd_algebraic.html\">fadd_algebraic</a></li><li><a href=\"fn.fadd_fast.html\">fadd_fast</a></li><li><a href=\"fn.fdiv_algebraic.html\">fdiv_algebraic</a></li><li><a href=\"fn.fdiv_fast.html\">fdiv_fast</a></li><li><a href=\"fn.float_to_int_unchecked.html\">float_to_int_unchecked</a></li><li><a href=\"fn.floorf32.html\">floorf32</a></li><li><a href=\"fn.floorf64.html\">floorf64</a></li><li><a href=\"fn.fmaf32.html\">fmaf32</a></li><li><a href=\"fn.fmaf64.html\">fmaf64</a></li><li><a href=\"fn.fmul_algebraic.html\">fmul_algebraic</a></li><li><a href=\"fn.fmul_fast.html\">fmul_fast</a></li><li><a href=\"fn.forget.html\">forget</a></li><li><a href=\"fn.frem_algebraic.html\">frem_algebraic</a></li><li><a href=\"fn.frem_fast.html\">frem_fast</a></li><li><a href=\"fn.fsub_algebraic.html\">fsub_algebraic</a></li><li><a href=\"fn.fsub_fast.html\">fsub_fast</a></li><li><a href=\"fn.is_val_statically_known.html\">is_val_statically_known</a></li><li><a href=\"fn.likely.html\">likely</a></li><li><a href=\"fn.log10f32.html\">log10f32</a></li><li><a href=\"fn.log10f64.html\">log10f64</a></li><li><a href=\"fn.log2f32.html\">log2f32</a></li><li><a href=\"fn.log2f64.html\">log2f64</a></li><li><a href=\"fn.logf32.html\">logf32</a></li><li><a href=\"fn.logf64.html\">logf64</a></li><li><a href=\"fn.maxnumf32.html\">maxnumf32</a></li><li><a href=\"fn.maxnumf64.html\">maxnumf64</a></li><li><a href=\"fn.min_align_of.html\">min_align_of</a></li><li><a href=\"fn.min_align_of_val.html\">min_align_of_val</a></li><li><a href=\"fn.minnumf32.html\">minnumf32</a></li><li><a href=\"fn.minnumf64.html\">minnumf64</a></li><li><a href=\"fn.mul_with_overflow.html\">mul_with_overflow</a></li><li><a href=\"fn.nearbyintf32.html\">nearbyintf32</a></li><li><a href=\"fn.nearbyintf64.html\">nearbyintf64</a></li><li><a href=\"fn.needs_drop.html\">needs_drop</a></li><li><a href=\"fn.nontemporal_store.html\">nontemporal_store</a></li><li><a href=\"fn.offset.html\">offset</a></li><li><a href=\"fn.powf32.html\">powf32</a></li><li><a href=\"fn.powf64.html\">powf64</a></li><li><a href=\"fn.powif128.html\">powif128</a></li><li><a href=\"fn.powif16.html\">powif16</a></li><li><a href=\"fn.powif32.html\">powif32</a></li><li><a href=\"fn.powif64.html\">powif64</a></li><li><a href=\"fn.pref_align_of.html\">pref_align_of</a></li><li><a href=\"fn.prefetch_read_data.html\">prefetch_read_data</a></li><li><a href=\"fn.prefetch_read_instruction.html\">prefetch_read_instruction</a></li><li><a href=\"fn.prefetch_write_data.html\">prefetch_write_data</a></li><li><a href=\"fn.prefetch_write_instruction.html\">prefetch_write_instruction</a></li><li><a href=\"fn.ptr_guaranteed_cmp.html\">ptr_guaranteed_cmp</a></li><li><a href=\"fn.ptr_mask.html\">ptr_mask</a></li><li><a href=\"fn.ptr_metadata.html\">ptr_metadata</a></li><li><a href=\"fn.ptr_offset_from.html\">ptr_offset_from</a></li><li><a href=\"fn.ptr_offset_from_unsigned.html\">ptr_offset_from_unsigned</a></li><li><a href=\"fn.raw_eq.html\">raw_eq</a></li><li><a href=\"fn.read_via_copy.html\">read_via_copy</a></li><li><a href=\"fn.rintf32.html\">rintf32</a></li><li><a href=\"fn.rintf64.html\">rintf64</a></li><li><a href=\"fn.rotate_left.html\">rotate_left</a></li><li><a href=\"fn.rotate_right.html\">rotate_right</a></li><li><a href=\"fn.roundevenf32.html\">roundevenf32</a></li><li><a href=\"fn.roundevenf64.html\">roundevenf64</a></li><li><a href=\"fn.roundf32.html\">roundf32</a></li><li><a href=\"fn.roundf64.html\">roundf64</a></li><li><a href=\"fn.rustc_peek.html\">rustc_peek</a></li><li><a href=\"fn.saturating_add.html\">saturating_add</a></li><li><a href=\"fn.saturating_sub.html\">saturating_sub</a></li><li><a href=\"fn.sinf32.html\">sinf32</a></li><li><a href=\"fn.sinf64.html\">sinf64</a></li><li><a href=\"fn.size_of.html\">size_of</a></li><li><a href=\"fn.size_of_val.html\">size_of_val</a></li><li><a href=\"fn.sqrtf32.html\">sqrtf32</a></li><li><a href=\"fn.sqrtf64.html\">sqrtf64</a></li><li><a href=\"fn.sub_with_overflow.html\">sub_with_overflow</a></li><li><a href=\"fn.three_way_compare.html\">three_way_compare</a></li><li><a href=\"fn.transmute.html\">transmute</a></li><li><a href=\"fn.transmute_unchecked.html\">transmute_unchecked</a></li><li><a href=\"fn.truncf32.html\">truncf32</a></li><li><a href=\"fn.truncf64.html\">truncf64</a></li><li><a href=\"fn.type_id.html\">type_id</a></li><li><a href=\"fn.type_name.html\">type_name</a></li><li><a href=\"fn.typed_swap.html\">typed_swap</a></li><li><a href=\"fn.ub_checks.html\">ub_checks</a></li><li><a href=\"fn.unaligned_volatile_load.html\">unaligned_volatile_load</a></li><li><a href=\"fn.unaligned_volatile_store.html\">unaligned_volatile_store</a></li><li><a href=\"fn.unchecked_add.html\">unchecked_add</a></li><li><a href=\"fn.unchecked_div.html\">unchecked_div</a></li><li><a href=\"fn.unchecked_mul.html\">unchecked_mul</a></li><li><a href=\"fn.unchecked_rem.html\">unchecked_rem</a></li><li><a href=\"fn.unchecked_shl.html\">unchecked_shl</a></li><li><a href=\"fn.unchecked_shr.html\">unchecked_shr</a></li><li><a href=\"fn.unchecked_sub.html\">unchecked_sub</a></li><li><a href=\"fn.unlikely.html\">unlikely</a></li><li><a href=\"fn.unreachable.html\">unreachable</a></li><li><a href=\"fn.variant_count.html\">variant_count</a></li><li><a href=\"fn.volatile_copy_memory.html\">volatile_copy_memory</a></li><li><a href=\"fn.volatile_copy_nonoverlapping_memory.html\">volatile_copy_nonoverlapping_memory</a></li><li><a href=\"fn.volatile_load.html\">volatile_load</a></li><li><a href=\"fn.volatile_set_memory.html\">volatile_set_memory</a></li><li><a href=\"fn.volatile_store.html\">volatile_store</a></li><li><a href=\"fn.vtable_align.html\">vtable_align</a></li><li><a href=\"fn.vtable_size.html\">vtable_size</a></li><li><a href=\"fn.wrapping_add.html\">wrapping_add</a></li><li><a href=\"fn.wrapping_mul.html\">wrapping_mul</a></li><li><a href=\"fn.wrapping_sub.html\">wrapping_sub</a></li><li><a href=\"fn.write_bytes.html\">write_bytes</a></li><li><a href=\"fn.write_via_move.html\">write_via_move</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Function <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">intrinsics</a>::<wbr><a class=\"fn\" href=\"#\">transmute</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.56.0\">1.0.0 (const: 1.56.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/intrinsics.rs.html#1441\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub const unsafe extern \"rust-intrinsic\" fn transmute&lt;Src, Dst&gt;(\n    src: Src,\n) -&gt; Dst</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Reinterprets the bits of a value of one type as another type.</p>\n<p>Both types must have the same size. Compilation will fail if this is not guaranteed.</p>\n<p><code>transmute</code> is semantically equivalent to a bitwise move of one type\ninto another. It copies the bits from the source value into the\ndestination value, then forgets the original. Note that source and destination\nare passed by-value, which means if <code>Src</code> or <code>Dst</code> contain padding, that padding\nis <em>not</em> guaranteed to be preserved by <code>transmute</code>.</p>\n<p>Both the argument and the result must be <a href=\"../../nomicon/what-unsafe-does.html\">valid</a> at\ntheir given type. Violating this condition leads to <a href=\"../../reference/behavior-considered-undefined.html\">undefined behavior</a>. The compiler\nwill generate code <em>assuming that you, the programmer, ensure that there will never be\nundefined behavior</em>. It is therefore your responsibility to guarantee that every value\npassed to <code>transmute</code> is valid at both types <code>Src</code> and <code>Dst</code>. Failing to uphold this condition\nmay lead to unexpected and unstable compilation results. This makes <code>transmute</code> <strong>incredibly\nunsafe</strong>. <code>transmute</code> should be the absolute last resort.</p>\n<p>Because <code>transmute</code> is a by-value operation, alignment of the <em>transmuted values\nthemselves</em> is not a concern. As with any other function, the compiler already ensures\nboth <code>Src</code> and <code>Dst</code> are properly aligned. However, when transmuting values that <em>point\nelsewhere</em> (such as pointers, references, boxes…), the caller has to ensure proper\nalignment of the pointed-to values.</p>\n<p>The <a href=\"../../nomicon/transmutes.html\">nomicon</a> has additional documentation.</p>\n<h2 id=\"transmutation-between-pointers-and-integers\"><a class=\"doc-anchor\" href=\"#transmutation-between-pointers-and-integers\">§</a>Transmutation between pointers and integers</h2>\n<p>Special care has to be taken when transmuting between pointers and integers, e.g.\ntransmuting between <code>*const ()</code> and <code>usize</code>.</p>\n<p>Transmuting <em>pointers to integers</em> in a <code>const</code> context is <a href=\"../../reference/behavior-considered-undefined.html\">undefined behavior</a>, unless\nthe pointer was originally created <em>from</em> an integer. (That includes this function\nspecifically, integer-to-pointer casts, and helpers like <a href=\"../ptr/fn.dangling.html\" title=\"fn std::ptr::dangling\"><code>dangling</code></a>,\nbut also semantically-equivalent conversions such as punning through <code>repr(C)</code> union\nfields.) Any attempt to use the resulting value for integer operations will abort\nconst-evaluation. (And even outside <code>const</code>, such transmutation is touching on many\nunspecified aspects of the Rust memory model and should be avoided. See below for\nalternatives.)</p>\n<p>Transmuting <em>integers to pointers</em> is a largely unspecified operation. It is likely <em>not</em>\nequivalent to an <code>as</code> cast. Doing non-zero-sized memory accesses with a pointer constructed\nthis way is currently considered undefined behavior.</p>\n<p>All this also applies when the integer is nested inside an array, tuple, struct, or enum.\nHowever, <code>MaybeUninit&lt;usize&gt;</code> is not considered an integer type for the purpose of this\nsection. Transmuting <code>*const ()</code> to <code>MaybeUninit&lt;usize&gt;</code> is fine—but then calling\n<code>assume_init()</code> on that result is considered as completing the pointer-to-integer transmute\nand thus runs into the issues discussed above.</p>\n<p>In particular, doing a pointer-to-integer-to-pointer roundtrip via <code>transmute</code> is <em>not</em> a\nlossless process. If you want to round-trip a pointer through an integer in a way that you\ncan get back the original pointer, you need to use <code>as</code> casts, or replace the integer type\nby <code>MaybeUninit&lt;$int&gt;</code> (and never call <code>assume_init()</code>). If you are looking for a way to\nstore data of arbitrary type, also use <code>MaybeUninit&lt;T&gt;</code> (that will also handle uninitialized\nmemory due to padding). If you specifically need to store something that is “either an\ninteger or a pointer”, use <code>*mut ()</code>: integers can be converted to pointers and back without\nany loss (via <code>as</code> casts or via <code>transmute</code>).</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>There are a few things that <code>transmute</code> is really useful for.</p>\n<p>Turning a pointer into a function pointer. This is <em>not</em> portable to\nmachines where function pointers and data pointers have different sizes.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>foo() -&gt; i32 {\n    <span class=\"number\">0\n</span>}\n<span class=\"comment\">// Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer.\n// This avoids an integer-to-pointer `transmute`, which can be problematic.\n// Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.\n</span><span class=\"kw\">let </span>pointer = foo <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>();\n<span class=\"kw\">let </span>function = <span class=\"kw\">unsafe </span>{\n    std::mem::transmute::&lt;<span class=\"kw-2\">*const </span>(), <span class=\"kw\">fn</span>() -&gt; i32&gt;(pointer)\n};\n<span class=\"macro\">assert_eq!</span>(function(), <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+foo()+-%3E+i32+%7B%0A++++++++0%0A++++%7D%0A++++//+Crucially,+we+%60as%60-cast+to+a+raw+pointer+before+%60transmute%60ing+to+a+function+pointer.%0A++++//+This+avoids+an+integer-to-pointer+%60transmute%60,+which+can+be+problematic.%0A++++//+Transmuting+between+raw+pointers+and+function+pointers+(i.e.,+two+pointer+types)+is+fine.%0A++++let+pointer+=+foo+as+*const+();%0A++++let+function+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C*const+(),+fn()+-%3E+i32%3E(pointer)%0A++++%7D;%0A++++assert_eq!(function(),+0);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Extending a lifetime, or shortening an invariant lifetime. This is\nadvanced, very unsafe Rust!</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">struct </span>R&lt;<span class=\"lifetime\">'a</span>&gt;(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'a </span>i32);\n<span class=\"kw\">unsafe fn </span>extend_lifetime&lt;<span class=\"lifetime\">'b</span>&gt;(r: R&lt;<span class=\"lifetime\">'b</span>&gt;) -&gt; R&lt;<span class=\"lifetime\">'static</span>&gt; {\n    std::mem::transmute::&lt;R&lt;<span class=\"lifetime\">'b</span>&gt;, R&lt;<span class=\"lifetime\">'static</span>&gt;&gt;(r)\n}\n\n<span class=\"kw\">unsafe fn </span>shorten_invariant_lifetime&lt;<span class=\"lifetime\">'b</span>, <span class=\"lifetime\">'c</span>&gt;(r: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'b </span><span class=\"kw-2\">mut </span>R&lt;<span class=\"lifetime\">'static</span>&gt;)\n                                             -&gt; <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'b </span><span class=\"kw-2\">mut </span>R&lt;<span class=\"lifetime\">'c</span>&gt; {\n    std::mem::transmute::&lt;<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'b </span><span class=\"kw-2\">mut </span>R&lt;<span class=\"lifetime\">'static</span>&gt;, <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'b </span><span class=\"kw-2\">mut </span>R&lt;<span class=\"lifetime\">'c</span>&gt;&gt;(r)\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+R%3C'a%3E(%26'a+i32);%0A++++unsafe+fn+extend_lifetime%3C'b%3E(r:+R%3C'b%3E)+-%3E+R%3C'static%3E+%7B%0A++++++++std::mem::transmute::%3CR%3C'b%3E,+R%3C'static%3E%3E(r)%0A++++%7D%0A++++%0A++++unsafe+fn+shorten_invariant_lifetime%3C'b,+'c%3E(r:+%26'b+mut+R%3C'static%3E)%0A+++++++++++++++++++++++++++++++++++++++++++++++++-%3E+%26'b+mut+R%3C'c%3E+%7B%0A++++++++std::mem::transmute::%3C%26'b+mut+R%3C'static%3E,+%26'b+mut+R%3C'c%3E%3E(r)%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"alternatives\"><a class=\"doc-anchor\" href=\"#alternatives\">§</a>Alternatives</h2>\n<p>Don’t despair: many uses of <code>transmute</code> can be achieved through other means.\nBelow are common applications of <code>transmute</code> which can be replaced with safer\nconstructs.</p>\n<p>Turning raw bytes (<code>[u8; SZ]</code>) into <code>u32</code>, <code>f64</code>, etc.:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>raw_bytes = [<span class=\"number\">0x78</span>, <span class=\"number\">0x56</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0x12</span>];\n\n<span class=\"kw\">let </span>num = <span class=\"kw\">unsafe </span>{\n    std::mem::transmute::&lt;[u8; <span class=\"number\">4</span>], u32&gt;(raw_bytes)\n};\n\n<span class=\"comment\">// use `u32::from_ne_bytes` instead\n</span><span class=\"kw\">let </span>num = u32::from_ne_bytes(raw_bytes);\n<span class=\"comment\">// or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness\n</span><span class=\"kw\">let </span>num = u32::from_le_bytes(raw_bytes);\n<span class=\"macro\">assert_eq!</span>(num, <span class=\"number\">0x12345678</span>);\n<span class=\"kw\">let </span>num = u32::from_be_bytes(raw_bytes);\n<span class=\"macro\">assert_eq!</span>(num, <span class=\"number\">0x78563412</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+raw_bytes+=+%5B0x78,+0x56,+0x34,+0x12%5D;%0A++++%0A++++let+num+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C%5Bu8;+4%5D,+u32%3E(raw_bytes)%0A++++%7D;%0A++++%0A++++//+use+%60u32::from_ne_bytes%60+instead%0A++++let+num+=+u32::from_ne_bytes(raw_bytes);%0A++++//+or+use+%60u32::from_le_bytes%60+or+%60u32::from_be_bytes%60+to+specify+the+endianness%0A++++let+num+=+u32::from_le_bytes(raw_bytes);%0A++++assert_eq!(num,+0x12345678);%0A++++let+num+=+u32::from_be_bytes(raw_bytes);%0A++++assert_eq!(num,+0x78563412);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Turning a pointer into a <code>usize</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>ptr = <span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>;\n<span class=\"kw\">let </span>ptr_num_transmute = <span class=\"kw\">unsafe </span>{\n    std::mem::transmute::&lt;<span class=\"kw-2\">&amp;</span>i32, usize&gt;(ptr)\n};\n\n<span class=\"comment\">// Use an `as` cast instead\n</span><span class=\"kw\">let </span>ptr_num_cast = ptr <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>i32 <span class=\"kw\">as </span>usize;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr+=+%260;%0A++++let+ptr_num_transmute+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C%26i32,+usize%3E(ptr)%0A++++%7D;%0A++++%0A++++//+Use+an+%60as%60+cast+instead%0A++++let+ptr_num_cast+=+ptr+as+*const+i32+as+usize;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that using <code>transmute</code> to turn a pointer to a <code>usize</code> is (as noted above) <a href=\"../../reference/behavior-considered-undefined.html\">undefined\nbehavior</a> in <code>const</code> contexts. Also outside of consts, this operation might not behave\nas expected – this is touching on many unspecified aspects of the Rust memory model.\nDepending on what the code is doing, the following alternatives are preferable to\npointer-to-integer transmutation:</p>\n<ul>\n<li>If the code just wants to store data of arbitrary type in some buffer and needs to pick a\ntype for that buffer, it can use <a href=\"../mem/union.MaybeUninit.html\" title=\"union std::mem::MaybeUninit\"><code>MaybeUninit</code></a>.</li>\n<li>If the code actually wants to work on the address the pointer points to, it can use <code>as</code>\ncasts or <a href=\"../primitive.pointer.html#method.addr\" title=\"method pointer::addr\"><code>ptr.addr()</code></a>.</li>\n</ul>\n<p>Turning a <code>*mut T</code> into an <code>&amp;mut T</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>ptr: <span class=\"kw-2\">*mut </span>i32 = <span class=\"kw-2\">&amp;mut </span><span class=\"number\">0</span>;\n<span class=\"kw\">let </span>ref_transmuted = <span class=\"kw\">unsafe </span>{\n    std::mem::transmute::&lt;<span class=\"kw-2\">*mut </span>i32, <span class=\"kw-2\">&amp;mut </span>i32&gt;(ptr)\n};\n\n<span class=\"comment\">// Use a reborrow instead\n</span><span class=\"kw\">let </span>ref_casted = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut *</span>ptr };</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr:+*mut+i32+=+%26mut+0;%0A++++let+ref_transmuted+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C*mut+i32,+%26mut+i32%3E(ptr)%0A++++%7D;%0A++++%0A++++//+Use+a+reborrow+instead%0A++++let+ref_casted+=+unsafe+%7B+%26mut+*ptr+%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Turning an <code>&amp;mut T</code> into an <code>&amp;mut U</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>ptr = <span class=\"kw-2\">&amp;mut </span><span class=\"number\">0</span>;\n<span class=\"kw\">let </span>val_transmuted = <span class=\"kw\">unsafe </span>{\n    std::mem::transmute::&lt;<span class=\"kw-2\">&amp;mut </span>i32, <span class=\"kw-2\">&amp;mut </span>u32&gt;(ptr)\n};\n\n<span class=\"comment\">// Now, put together `as` and reborrowing - note the chaining of `as`\n// `as` is not transitive\n</span><span class=\"kw\">let </span>val_casts = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut *</span>(ptr <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>i32 <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u32) };</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr+=+%26mut+0;%0A++++let+val_transmuted+=+unsafe+%7B%0A++++++++std::mem::transmute::%3C%26mut+i32,+%26mut+u32%3E(ptr)%0A++++%7D;%0A++++%0A++++//+Now,+put+together+%60as%60+and+reborrowing+-+note+the+chaining+of+%60as%60%0A++++//+%60as%60+is+not+transitive%0A++++let+val_casts+=+unsafe+%7B+%26mut+*(ptr+as+*mut+i32+as+*mut+u32)+%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Turning an <code>&amp;str</code> into a <code>&amp;[u8]</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// this is not a good way to do this.\n</span><span class=\"kw\">let </span>slice = <span class=\"kw\">unsafe </span>{ std::mem::transmute::&lt;<span class=\"kw-2\">&amp;</span>str, <span class=\"kw-2\">&amp;</span>[u8]&gt;(<span class=\"string\">\"Rust\"</span>) };\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">82</span>, <span class=\"number\">117</span>, <span class=\"number\">115</span>, <span class=\"number\">116</span>]);\n\n<span class=\"comment\">// You could use `str::as_bytes`\n</span><span class=\"kw\">let </span>slice = <span class=\"string\">\"Rust\"</span>.as_bytes();\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">82</span>, <span class=\"number\">117</span>, <span class=\"number\">115</span>, <span class=\"number\">116</span>]);\n\n<span class=\"comment\">// Or, just use a byte string, if you have control over the string\n// literal\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"Rust\"</span>, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">82</span>, <span class=\"number\">117</span>, <span class=\"number\">115</span>, <span class=\"number\">116</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+this+is+not+a+good+way+to+do+this.%0Afn+main()+%7B%0A++++let+slice+=+unsafe+%7B+std::mem::transmute::%3C%26str,+%26%5Bu8%5D%3E(%22Rust%22)+%7D;%0A++++assert_eq!(slice,+%26%5B82,+117,+115,+116%5D);%0A++++%0A++++//+You+could+use+%60str::as_bytes%60%0A++++let+slice+=+%22Rust%22.as_bytes();%0A++++assert_eq!(slice,+%26%5B82,+117,+115,+116%5D);%0A++++%0A++++//+Or,+just+use+a+byte+string,+if+you+have+control+over+the+string%0A++++//+literal%0A++++assert_eq!(b%22Rust%22,+%26%5B82,+117,+115,+116%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Turning a <code>Vec&lt;&amp;T&gt;</code> into a <code>Vec&lt;Option&lt;&amp;T&gt;&gt;</code>.</p>\n<p>To transmute the inner type of the contents of a container, you must make sure to not\nviolate any of the container’s invariants. For <code>Vec</code>, this means that both the size\n<em>and alignment</em> of the inner types have to match. Other containers might rely on the\nsize of the type, alignment, or even the <code>TypeId</code>, in which case transmuting wouldn’t\nbe possible at all without violating the container invariants.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>store = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>v_orig = store.iter().collect::&lt;Vec&lt;<span class=\"kw-2\">&amp;</span>i32&gt;&gt;();\n\n<span class=\"comment\">// clone the vector as we will reuse them later\n</span><span class=\"kw\">let </span>v_clone = v_orig.clone();\n\n<span class=\"comment\">// Using transmute: this relies on the unspecified data layout of `Vec`, which is a\n// bad idea and could cause Undefined Behavior.\n// However, it is no-copy.\n</span><span class=\"kw\">let </span>v_transmuted = <span class=\"kw\">unsafe </span>{\n    std::mem::transmute::&lt;Vec&lt;<span class=\"kw-2\">&amp;</span>i32&gt;, Vec&lt;<span class=\"prelude-ty\">Option</span>&lt;<span class=\"kw-2\">&amp;</span>i32&gt;&gt;&gt;(v_clone)\n};\n\n<span class=\"kw\">let </span>v_clone = v_orig.clone();\n\n<span class=\"comment\">// This is the suggested, safe way.\n// It may copy the entire vector into a new one though, but also may not.\n</span><span class=\"kw\">let </span>v_collected = v_clone.into_iter()\n                         .map(<span class=\"prelude-val\">Some</span>)\n                         .collect::&lt;Vec&lt;<span class=\"prelude-ty\">Option</span>&lt;<span class=\"kw-2\">&amp;</span>i32&gt;&gt;&gt;();\n\n<span class=\"kw\">let </span>v_clone = v_orig.clone();\n\n<span class=\"comment\">// This is the proper no-copy, unsafe way of \"transmuting\" a `Vec`, without relying on the\n// data layout. Instead of literally calling `transmute`, we perform a pointer cast, but\n// in terms of converting the original inner type (`&amp;i32`) to the new one (`Option&lt;&amp;i32&gt;`),\n// this has all the same caveats. Besides the information provided above, also consult the\n// [`from_raw_parts`] documentation.\n</span><span class=\"kw\">let </span>v_from_raw = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Ensure the original vector is not dropped.\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v_clone = std::mem::ManuallyDrop::new(v_clone);\n    Vec::from_raw_parts(v_clone.as_mut_ptr() <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span><span class=\"prelude-ty\">Option</span>&lt;<span class=\"kw-2\">&amp;</span>i32&gt;,\n                        v_clone.len(),\n                        v_clone.capacity())\n};</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+store+=+%5B0,+1,+2,+3%5D;%0A++++let+v_orig+=+store.iter().collect::%3CVec%3C%26i32%3E%3E();%0A++++%0A++++//+clone+the+vector+as+we+will+reuse+them+later%0A++++let+v_clone+=+v_orig.clone();%0A++++%0A++++//+Using+transmute:+this+relies+on+the+unspecified+data+layout+of+%60Vec%60,+which+is+a%0A++++//+bad+idea+and+could+cause+Undefined+Behavior.%0A++++//+However,+it+is+no-copy.%0A++++let+v_transmuted+=+unsafe+%7B%0A++++++++std::mem::transmute::%3CVec%3C%26i32%3E,+Vec%3COption%3C%26i32%3E%3E%3E(v_clone)%0A++++%7D;%0A++++%0A++++let+v_clone+=+v_orig.clone();%0A++++%0A++++//+This+is+the+suggested,+safe+way.%0A++++//+It+may+copy+the+entire+vector+into+a+new+one+though,+but+also+may+not.%0A++++let+v_collected+=+v_clone.into_iter()%0A+++++++++++++++++++++++++++++.map(Some)%0A+++++++++++++++++++++++++++++.collect::%3CVec%3COption%3C%26i32%3E%3E%3E();%0A++++%0A++++let+v_clone+=+v_orig.clone();%0A++++%0A++++//+This+is+the+proper+no-copy,+unsafe+way+of+%22transmuting%22+a+%60Vec%60,+without+relying+on+the%0A++++//+data+layout.+Instead+of+literally+calling+%60transmute%60,+we+perform+a+pointer+cast,+but%0A++++//+in+terms+of+converting+the+original+inner+type+(%60%26i32%60)+to+the+new+one+(%60Option%3C%26i32%3E%60),%0A++++//+this+has+all+the+same+caveats.+Besides+the+information+provided+above,+also+consult+the%0A++++//+%5B%60from_raw_parts%60%5D+documentation.%0A++++let+v_from_raw+=+unsafe+%7B%0A++++++++//+Ensure+the+original+vector+is+not+dropped.%0A++++++++let+mut+v_clone+=+std::mem::ManuallyDrop::new(v_clone);%0A++++++++Vec::from_raw_parts(v_clone.as_mut_ptr()+as+*mut+Option%3C%26i32%3E,%0A++++++++++++++++++++++++++++v_clone.len(),%0A++++++++++++++++++++++++++++v_clone.capacity())%0A++++%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Implementing <code>split_at_mut</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{slice, mem};\n\n<span class=\"comment\">// There are multiple ways to do this, and there are multiple problems\n// with the following (transmute) way.\n</span><span class=\"kw\">fn </span>split_at_mut_transmute&lt;T&gt;(slice: <span class=\"kw-2\">&amp;mut </span>[T], mid: usize)\n                             -&gt; (<span class=\"kw-2\">&amp;mut </span>[T], <span class=\"kw-2\">&amp;mut </span>[T]) {\n    <span class=\"kw\">let </span>len = slice.len();\n    <span class=\"macro\">assert!</span>(mid &lt;= len);\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"kw\">let </span>slice2 = mem::transmute::&lt;<span class=\"kw-2\">&amp;mut </span>[T], <span class=\"kw-2\">&amp;mut </span>[T]&gt;(slice);\n        <span class=\"comment\">// first: transmute is not type safe; all it checks is that T and\n        // U are of the same size. Second, right here, you have two\n        // mutable references pointing to the same memory.\n        </span>(<span class=\"kw-2\">&amp;mut </span>slice[<span class=\"number\">0</span>..mid], <span class=\"kw-2\">&amp;mut </span>slice2[mid..len])\n    }\n}\n\n<span class=\"comment\">// This gets rid of the type safety problems; `&amp;mut *` will *only* give\n// you an `&amp;mut T` from an `&amp;mut T` or `*mut T`.\n</span><span class=\"kw\">fn </span>split_at_mut_casts&lt;T&gt;(slice: <span class=\"kw-2\">&amp;mut </span>[T], mid: usize)\n                         -&gt; (<span class=\"kw-2\">&amp;mut </span>[T], <span class=\"kw-2\">&amp;mut </span>[T]) {\n    <span class=\"kw\">let </span>len = slice.len();\n    <span class=\"macro\">assert!</span>(mid &lt;= len);\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"kw\">let </span>slice2 = <span class=\"kw-2\">&amp;mut *</span>(slice <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>[T]);\n        <span class=\"comment\">// however, you still have two mutable references pointing to\n        // the same memory.\n        </span>(<span class=\"kw-2\">&amp;mut </span>slice[<span class=\"number\">0</span>..mid], <span class=\"kw-2\">&amp;mut </span>slice2[mid..len])\n    }\n}\n\n<span class=\"comment\">// This is how the standard library does it. This is the best method, if\n// you need to do something like this\n</span><span class=\"kw\">fn </span>split_at_stdlib&lt;T&gt;(slice: <span class=\"kw-2\">&amp;mut </span>[T], mid: usize)\n                      -&gt; (<span class=\"kw-2\">&amp;mut </span>[T], <span class=\"kw-2\">&amp;mut </span>[T]) {\n    <span class=\"kw\">let </span>len = slice.len();\n    <span class=\"macro\">assert!</span>(mid &lt;= len);\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"kw\">let </span>ptr = slice.as_mut_ptr();\n        <span class=\"comment\">// This now has three mutable references pointing at the same\n        // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n        // `slice` is never used after `let ptr = ...`, and so one can\n        // treat it as \"dead\", and therefore, you only have two real\n        // mutable slices.\n        </span>(slice::from_raw_parts_mut(ptr, mid),\n         slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::%7Bslice,+mem%7D;%0A++++%0A++++//+There+are+multiple+ways+to+do+this,+and+there+are+multiple+problems%0A++++//+with+the+following+(transmute)+way.%0A++++fn+split_at_mut_transmute%3CT%3E(slice:+%26mut+%5BT%5D,+mid:+usize)%0A+++++++++++++++++++++++++++++++++-%3E+(%26mut+%5BT%5D,+%26mut+%5BT%5D)+%7B%0A++++++++let+len+=+slice.len();%0A++++++++assert!(mid+%3C=+len);%0A++++++++unsafe+%7B%0A++++++++++++let+slice2+=+mem::transmute::%3C%26mut+%5BT%5D,+%26mut+%5BT%5D%3E(slice);%0A++++++++++++//+first:+transmute+is+not+type+safe;+all+it+checks+is+that+T+and%0A++++++++++++//+U+are+of+the+same+size.+Second,+right+here,+you+have+two%0A++++++++++++//+mutable+references+pointing+to+the+same+memory.%0A++++++++++++(%26mut+slice%5B0..mid%5D,+%26mut+slice2%5Bmid..len%5D)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+This+gets+rid+of+the+type+safety+problems;+%60%26mut+*%60+will+*only*+give%0A++++//+you+an+%60%26mut+T%60+from+an+%60%26mut+T%60+or+%60*mut+T%60.%0A++++fn+split_at_mut_casts%3CT%3E(slice:+%26mut+%5BT%5D,+mid:+usize)%0A+++++++++++++++++++++++++++++-%3E+(%26mut+%5BT%5D,+%26mut+%5BT%5D)+%7B%0A++++++++let+len+=+slice.len();%0A++++++++assert!(mid+%3C=+len);%0A++++++++unsafe+%7B%0A++++++++++++let+slice2+=+%26mut+*(slice+as+*mut+%5BT%5D);%0A++++++++++++//+however,+you+still+have+two+mutable+references+pointing+to%0A++++++++++++//+the+same+memory.%0A++++++++++++(%26mut+slice%5B0..mid%5D,+%26mut+slice2%5Bmid..len%5D)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+This+is+how+the+standard+library+does+it.+This+is+the+best+method,+if%0A++++//+you+need+to+do+something+like+this%0A++++fn+split_at_stdlib%3CT%3E(slice:+%26mut+%5BT%5D,+mid:+usize)%0A++++++++++++++++++++++++++-%3E+(%26mut+%5BT%5D,+%26mut+%5BT%5D)+%7B%0A++++++++let+len+=+slice.len();%0A++++++++assert!(mid+%3C=+len);%0A++++++++unsafe+%7B%0A++++++++++++let+ptr+=+slice.as_mut_ptr();%0A++++++++++++//+This+now+has+three+mutable+references+pointing+at+the+same%0A++++++++++++//+memory.+%60slice%60,+the+rvalue+ret.0,+and+the+rvalue+ret.1.%0A++++++++++++//+%60slice%60+is+never+used+after+%60let+ptr+=+...%60,+and+so+one+can%0A++++++++++++//+treat+it+as+%22dead%22,+and+therefore,+you+only+have+two+real%0A++++++++++++//+mutable+slices.%0A++++++++++++(slice::from_raw_parts_mut(ptr,+mid),%0A+++++++++++++slice::from_raw_parts_mut(ptr.add(mid),+len+-+mid))%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:23:19.826Z"
}