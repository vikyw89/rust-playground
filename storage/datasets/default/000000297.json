{
	"title": "std::process - Rust",
	"url": "https://doc.rust-lang.org/stable/std/process/index.html",
	"markdown": "# std::process - Rust\n\n## Module [std](../index.html)::[process](#)\n\n1.0.0 · [source](about:blank/src/std/process.rs.html#1-2459) ·\n\nExpand description\n\nA module for working with processes.\n\nThis module is mostly concerned with spawning and interacting with child processes, but it also provides [`abort`](fn.abort.html \"fn std::process::abort\") and [`exit`](fn.exit.html \"fn std::process::exit\") for terminating the current process.\n\n## [§](#spawning-a-process)Spawning a process\n\nThe [`Command`](struct.Command.html \"struct std::process::Command\") struct is used to configure and spawn processes:\n\n```\nuse std::process::Command;\n\nlet output = Command::new(\"echo\")\n    .arg(\"Hello world\")\n    .output()\n    .expect(\"Failed to execute command\");\n\nassert_eq!(b\"Hello world\\n\", output.stdout.as_slice());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::Command;%0A++++%0A++++let+output+=+Command::new(%22echo%22)%0A++++++++.arg(%22Hello+world%22)%0A++++++++.output()%0A++++++++.expect(%22Failed+to+execute+command%22);%0A++++%0A++++assert_eq!(b%22Hello+world%5Cn%22,+output.stdout.as_slice());%0A%7D&edition=2021)\n\nSeveral methods on [`Command`](struct.Command.html \"struct std::process::Command\"), such as [`spawn`](about:blank/struct.Command.html#method.spawn \"method std::process::Command::spawn\") or [`output`](about:blank/struct.Command.html#method.output \"method std::process::Command::output\"), can be used to spawn a process. In particular, [`output`](about:blank/struct.Command.html#method.output \"method std::process::Command::output\") spawns the child process and waits until the process terminates, while [`spawn`](about:blank/struct.Command.html#method.spawn \"method std::process::Command::spawn\") will return a [`Child`](struct.Child.html \"struct std::process::Child\") that represents the spawned child process.\n\n## [§](#handling-io)Handling I/O\n\nThe [`stdout`](about:blank/struct.Command.html#method.stdout \"method std::process::Command::stdout\"), [`stdin`](about:blank/struct.Command.html#method.stdin \"method std::process::Command::stdin\"), and [`stderr`](about:blank/struct.Command.html#method.stderr \"method std::process::Command::stderr\") of a child process can be configured by passing an [`Stdio`](struct.Stdio.html \"struct std::process::Stdio\") to the corresponding method on [`Command`](struct.Command.html \"struct std::process::Command\"). Once spawned, they can be accessed from the [`Child`](struct.Child.html \"struct std::process::Child\"). For example, piping output from one command into another command can be done like so:\n\n```\nuse std::process::{Command, Stdio};\n\n// stdout must be configured with `Stdio::piped` in order to use\n// `echo_child.stdout`\nlet echo_child = Command::new(\"echo\")\n    .arg(\"Oh no, a tpyo!\")\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(\"Failed to start echo process\");\n\n// Note that `echo_child` is moved here, but we won't be needing\n// `echo_child` anymore\nlet echo_out = echo_child.stdout.expect(\"Failed to open echo stdout\");\n\nlet mut sed_child = Command::new(\"sed\")\n    .arg(\"s/tpyo/typo/\")\n    .stdin(Stdio::from(echo_out))\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(\"Failed to start sed process\");\n\nlet output = sed_child.wait_with_output().expect(\"Failed to wait on sed\");\nassert_eq!(b\"Oh no, a typo!\\n\", output.stdout.as_slice());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::%7BCommand,+Stdio%7D;%0A++++%0A++++//+stdout+must+be+configured+with+%60Stdio::piped%60+in+order+to+use%0A++++//+%60echo_child.stdout%60%0A++++let+echo_child+=+Command::new(%22echo%22)%0A++++++++.arg(%22Oh+no,+a+tpyo!%22)%0A++++++++.stdout(Stdio::piped())%0A++++++++.spawn()%0A++++++++.expect(%22Failed+to+start+echo+process%22);%0A++++%0A++++//+Note+that+%60echo_child%60+is+moved+here,+but+we+won%27t+be+needing%0A++++//+%60echo_child%60+anymore%0A++++let+echo_out+=+echo_child.stdout.expect(%22Failed+to+open+echo+stdout%22);%0A++++%0A++++let+mut+sed_child+=+Command::new(%22sed%22)%0A++++++++.arg(%22s/tpyo/typo/%22)%0A++++++++.stdin(Stdio::from(echo_out))%0A++++++++.stdout(Stdio::piped())%0A++++++++.spawn()%0A++++++++.expect(%22Failed+to+start+sed+process%22);%0A++++%0A++++let+output+=+sed_child.wait_with_output().expect(%22Failed+to+wait+on+sed%22);%0A++++assert_eq!(b%22Oh+no,+a+typo!%5Cn%22,+output.stdout.as_slice());%0A%7D&edition=2021)\n\nNote that [`ChildStderr`](struct.ChildStderr.html \"struct std::process::ChildStderr\") and [`ChildStdout`](struct.ChildStdout.html \"struct std::process::ChildStdout\") implement [`Read`](../io/trait.Read.html \"trait std::io::Read\") and [`ChildStdin`](struct.ChildStdin.html \"struct std::process::ChildStdin\") implements [`Write`](../io/trait.Write.html \"trait std::io::Write\"):\n\n```\nuse std::process::{Command, Stdio};\nuse std::io::Write;\n\nlet mut child = Command::new(\"/bin/cat\")\n    .stdin(Stdio::piped())\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(\"failed to execute child\");\n\n// If the child process fills its stdout buffer, it may end up\n// waiting until the parent reads the stdout, and not be able to\n// read stdin in the meantime, causing a deadlock.\n// Writing from another thread ensures that stdout is being read\n// at the same time, avoiding the problem.\nlet mut stdin = child.stdin.take().expect(\"failed to get stdin\");\nstd::thread::spawn(move || {\n    stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n});\n\nlet output = child\n    .wait_with_output()\n    .expect(\"failed to wait on child\");\n\nassert_eq!(b\"test\", output.stdout.as_slice());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::%7BCommand,+Stdio%7D;%0A++++use+std::io::Write;%0A++++%0A++++let+mut+child+=+Command::new(%22/bin/cat%22)%0A++++++++.stdin(Stdio::piped())%0A++++++++.stdout(Stdio::piped())%0A++++++++.spawn()%0A++++++++.expect(%22failed+to+execute+child%22);%0A++++%0A++++//+If+the+child+process+fills+its+stdout+buffer,+it+may+end+up%0A++++//+waiting+until+the+parent+reads+the+stdout,+and+not+be+able+to%0A++++//+read+stdin+in+the+meantime,+causing+a+deadlock.%0A++++//+Writing+from+another+thread+ensures+that+stdout+is+being+read%0A++++//+at+the+same+time,+avoiding+the+problem.%0A++++let+mut+stdin+=+child.stdin.take().expect(%22failed+to+get+stdin%22);%0A++++std::thread::spawn(move+%7C%7C+%7B%0A++++++++stdin.write_all(b%22test%22).expect(%22failed+to+write+to+stdin%22);%0A++++%7D);%0A++++%0A++++let+output+=+child%0A++++++++.wait_with_output()%0A++++++++.expect(%22failed+to+wait+on+child%22);%0A++++%0A++++assert_eq!(b%22test%22,+output.stdout.as_slice());%0A%7D&edition=2021)\n\n## [§](#windows-argument-splitting)Windows argument splitting\n\nOn Unix systems arguments are passed to a new process as an array of strings, but on Windows arguments are passed as a single commandline string and it is up to the child process to parse it into an array. Therefore the parent and child processes must agree on how the commandline string is encoded.\n\nMost programs use the standard C run-time `argv`, which in practice results in consistent argument handling. However some programs have their own way of parsing the commandline string. In these cases using [`arg`](about:blank/struct.Command.html#method.arg \"method std::process::Command::arg\") or [`args`](about:blank/struct.Command.html#method.args \"method std::process::Command::args\") may result in the child process seeing a different array of arguments then the parent process intended.\n\nTwo ways of mitigating this are:\n\n-   Validate untrusted input so that only a safe subset is allowed.\n-   Use [`raw_arg`](about:blank/os/windows/process/trait.CommandExt.html#tymethod.raw_arg \"method std::os::windows::process::CommandExt::raw_arg\") to build a custom commandline. This bypasses the escaping rules used by [`arg`](about:blank/struct.Command.html#method.arg \"method std::process::Command::arg\") so should be used with due caution.\n\n`cmd.exe` and `.bat` files use non-standard argument parsing and are especially vulnerable to malicious input as they may be used to run arbitrary shell commands. Untrusted arguments should be restricted as much as possible. For examples on handling this see [`raw_arg`](about:blank/os/windows/process/trait.CommandExt.html#tymethod.raw_arg \"method std::os::windows::process::CommandExt::raw_arg\").\n\n#### [§](#batch-file-special-handling)Batch file special handling\n\nOn Windows, `Command` uses the Windows API function [`CreateProcessW`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) to spawn new processes. An undocumented feature of this function is that when given a `.bat` file as the application to run, it will automatically convert that into running `cmd.exe /c` with the batch file as the next argument.\n\nFor historical reasons Rust currently preserves this behaviour when using [`Command::new`](about:blank/struct.Command.html#method.new \"associated function std::process::Command::new\"), and escapes the arguments according to `cmd.exe` rules. Due to the complexity of `cmd.exe` argument handling, it might not be possible to safely escape some special characters, and using them will result in an error being returned at process spawn. The set of unescapeable special characters might change between releases.\n\nAlso note that running batch scripts in this way may be removed in the future and so should not be relied upon.\n\n-   Representation of a running or exited child process.\n    \n-   A handle to a child process’s stderr.\n    \n-   A handle to a child process’s standard input (stdin).\n    \n-   A handle to a child process’s standard output (stdout).\n    \n-   A process builder, providing fine-grained control over how a new process should be spawned.\n    \n-   An iterator over the command arguments.\n    \n-   An iterator over the command environment variables.\n    \n-   This type represents the status code the current process can return to its parent under normal termination.\n    \n-   Describes the result of a process after it has terminated.\n    \n-   The output of a finished process.\n    \n-   Describes what to do with a standard I/O stream for a child process when passed to the [`stdin`](about:blank/struct.Command.html#method.stdin \"method std::process::Command::stdin\"), [`stdout`](about:blank/struct.Command.html#method.stdout \"method std::process::Command::stdout\"), and [`stderr`](about:blank/struct.Command.html#method.stderr \"method std::process::Command::stderr\") methods of [`Command`](struct.Command.html \"struct std::process::Command\").\n    \n-   Describes the result of a process after it has failed\n    \n\n-   A trait for implementing arbitrary return types in the `main` function.\n    \n\n-   Terminates the process in an abnormal fashion.\n    \n-   Terminates the current process with the specified exit code.\n    \n-   Returns the OS-assigned process identifier associated with this process.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A module for working with processes.\"><title>std::process - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module process</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module process</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#traits\">Traits</a></li><li><a href=\"#functions\">Functions</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">process</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/process.rs.html#1-2459\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A module for working with processes.</p>\n<p>This module is mostly concerned with spawning and interacting with child\nprocesses, but it also provides <a href=\"fn.abort.html\" title=\"fn std::process::abort\"><code>abort</code></a> and <a href=\"fn.exit.html\" title=\"fn std::process::exit\"><code>exit</code></a> for terminating the\ncurrent process.</p>\n<h2 id=\"spawning-a-process\"><a class=\"doc-anchor\" href=\"#spawning-a-process\">§</a>Spawning a process</h2>\n<p>The <a href=\"struct.Command.html\" title=\"struct std::process::Command\"><code>Command</code></a> struct is used to configure and spawn processes:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::process::Command;\n\n<span class=\"kw\">let </span>output = Command::new(<span class=\"string\">\"echo\"</span>)\n    .arg(<span class=\"string\">\"Hello world\"</span>)\n    .output()\n    .expect(<span class=\"string\">\"Failed to execute command\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"Hello world\\n\"</span>, output.stdout.as_slice());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::Command;%0A++++%0A++++let+output+=+Command::new(%22echo%22)%0A++++++++.arg(%22Hello+world%22)%0A++++++++.output()%0A++++++++.expect(%22Failed+to+execute+command%22);%0A++++%0A++++assert_eq!(b%22Hello+world%5Cn%22,+output.stdout.as_slice());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Several methods on <a href=\"struct.Command.html\" title=\"struct std::process::Command\"><code>Command</code></a>, such as <a href=\"struct.Command.html#method.spawn\" title=\"method std::process::Command::spawn\"><code>spawn</code></a> or <a href=\"struct.Command.html#method.output\" title=\"method std::process::Command::output\"><code>output</code></a>, can be used\nto spawn a process. In particular, <a href=\"struct.Command.html#method.output\" title=\"method std::process::Command::output\"><code>output</code></a> spawns the child process and\nwaits until the process terminates, while <a href=\"struct.Command.html#method.spawn\" title=\"method std::process::Command::spawn\"><code>spawn</code></a> will return a <a href=\"struct.Child.html\" title=\"struct std::process::Child\"><code>Child</code></a>\nthat represents the spawned child process.</p>\n<h2 id=\"handling-io\"><a class=\"doc-anchor\" href=\"#handling-io\">§</a>Handling I/O</h2>\n<p>The <a href=\"struct.Command.html#method.stdout\" title=\"method std::process::Command::stdout\"><code>stdout</code></a>, <a href=\"struct.Command.html#method.stdin\" title=\"method std::process::Command::stdin\"><code>stdin</code></a>, and <a href=\"struct.Command.html#method.stderr\" title=\"method std::process::Command::stderr\"><code>stderr</code></a> of a child process can be\nconfigured by passing an <a href=\"struct.Stdio.html\" title=\"struct std::process::Stdio\"><code>Stdio</code></a> to the corresponding method on\n<a href=\"struct.Command.html\" title=\"struct std::process::Command\"><code>Command</code></a>. Once spawned, they can be accessed from the <a href=\"struct.Child.html\" title=\"struct std::process::Child\"><code>Child</code></a>. For\nexample, piping output from one command into another command can be done\nlike so:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::process::{Command, Stdio};\n\n<span class=\"comment\">// stdout must be configured with `Stdio::piped` in order to use\n// `echo_child.stdout`\n</span><span class=\"kw\">let </span>echo_child = Command::new(<span class=\"string\">\"echo\"</span>)\n    .arg(<span class=\"string\">\"Oh no, a tpyo!\"</span>)\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(<span class=\"string\">\"Failed to start echo process\"</span>);\n\n<span class=\"comment\">// Note that `echo_child` is moved here, but we won't be needing\n// `echo_child` anymore\n</span><span class=\"kw\">let </span>echo_out = echo_child.stdout.expect(<span class=\"string\">\"Failed to open echo stdout\"</span>);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>sed_child = Command::new(<span class=\"string\">\"sed\"</span>)\n    .arg(<span class=\"string\">\"s/tpyo/typo/\"</span>)\n    .stdin(Stdio::from(echo_out))\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(<span class=\"string\">\"Failed to start sed process\"</span>);\n\n<span class=\"kw\">let </span>output = sed_child.wait_with_output().expect(<span class=\"string\">\"Failed to wait on sed\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"Oh no, a typo!\\n\"</span>, output.stdout.as_slice());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::%7BCommand,+Stdio%7D;%0A++++%0A++++//+stdout+must+be+configured+with+%60Stdio::piped%60+in+order+to+use%0A++++//+%60echo_child.stdout%60%0A++++let+echo_child+=+Command::new(%22echo%22)%0A++++++++.arg(%22Oh+no,+a+tpyo!%22)%0A++++++++.stdout(Stdio::piped())%0A++++++++.spawn()%0A++++++++.expect(%22Failed+to+start+echo+process%22);%0A++++%0A++++//+Note+that+%60echo_child%60+is+moved+here,+but+we+won't+be+needing%0A++++//+%60echo_child%60+anymore%0A++++let+echo_out+=+echo_child.stdout.expect(%22Failed+to+open+echo+stdout%22);%0A++++%0A++++let+mut+sed_child+=+Command::new(%22sed%22)%0A++++++++.arg(%22s/tpyo/typo/%22)%0A++++++++.stdin(Stdio::from(echo_out))%0A++++++++.stdout(Stdio::piped())%0A++++++++.spawn()%0A++++++++.expect(%22Failed+to+start+sed+process%22);%0A++++%0A++++let+output+=+sed_child.wait_with_output().expect(%22Failed+to+wait+on+sed%22);%0A++++assert_eq!(b%22Oh+no,+a+typo!%5Cn%22,+output.stdout.as_slice());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that <a href=\"struct.ChildStderr.html\" title=\"struct std::process::ChildStderr\"><code>ChildStderr</code></a> and <a href=\"struct.ChildStdout.html\" title=\"struct std::process::ChildStdout\"><code>ChildStdout</code></a> implement <a href=\"../io/trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a> and\n<a href=\"struct.ChildStdin.html\" title=\"struct std::process::ChildStdin\"><code>ChildStdin</code></a> implements <a href=\"../io/trait.Write.html\" title=\"trait std::io::Write\"><code>Write</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::process::{Command, Stdio};\n<span class=\"kw\">use </span>std::io::Write;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>child = Command::new(<span class=\"string\">\"/bin/cat\"</span>)\n    .stdin(Stdio::piped())\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(<span class=\"string\">\"failed to execute child\"</span>);\n\n<span class=\"comment\">// If the child process fills its stdout buffer, it may end up\n// waiting until the parent reads the stdout, and not be able to\n// read stdin in the meantime, causing a deadlock.\n// Writing from another thread ensures that stdout is being read\n// at the same time, avoiding the problem.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>stdin = child.stdin.take().expect(<span class=\"string\">\"failed to get stdin\"</span>);\nstd::thread::spawn(<span class=\"kw\">move </span>|| {\n    stdin.write_all(<span class=\"string\">b\"test\"</span>).expect(<span class=\"string\">\"failed to write to stdin\"</span>);\n});\n\n<span class=\"kw\">let </span>output = child\n    .wait_with_output()\n    .expect(<span class=\"string\">\"failed to wait on child\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"test\"</span>, output.stdout.as_slice());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::%7BCommand,+Stdio%7D;%0A++++use+std::io::Write;%0A++++%0A++++let+mut+child+=+Command::new(%22/bin/cat%22)%0A++++++++.stdin(Stdio::piped())%0A++++++++.stdout(Stdio::piped())%0A++++++++.spawn()%0A++++++++.expect(%22failed+to+execute+child%22);%0A++++%0A++++//+If+the+child+process+fills+its+stdout+buffer,+it+may+end+up%0A++++//+waiting+until+the+parent+reads+the+stdout,+and+not+be+able+to%0A++++//+read+stdin+in+the+meantime,+causing+a+deadlock.%0A++++//+Writing+from+another+thread+ensures+that+stdout+is+being+read%0A++++//+at+the+same+time,+avoiding+the+problem.%0A++++let+mut+stdin+=+child.stdin.take().expect(%22failed+to+get+stdin%22);%0A++++std::thread::spawn(move+%7C%7C+%7B%0A++++++++stdin.write_all(b%22test%22).expect(%22failed+to+write+to+stdin%22);%0A++++%7D);%0A++++%0A++++let+output+=+child%0A++++++++.wait_with_output()%0A++++++++.expect(%22failed+to+wait+on+child%22);%0A++++%0A++++assert_eq!(b%22test%22,+output.stdout.as_slice());%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"windows-argument-splitting\"><a class=\"doc-anchor\" href=\"#windows-argument-splitting\">§</a>Windows argument splitting</h2>\n<p>On Unix systems arguments are passed to a new process as an array of strings,\nbut on Windows arguments are passed as a single commandline string and it is\nup to the child process to parse it into an array. Therefore the parent and\nchild processes must agree on how the commandline string is encoded.</p>\n<p>Most programs use the standard C run-time <code>argv</code>, which in practice results\nin consistent argument handling. However some programs have their own way of\nparsing the commandline string. In these cases using <a href=\"struct.Command.html#method.arg\" title=\"method std::process::Command::arg\"><code>arg</code></a> or <a href=\"struct.Command.html#method.args\" title=\"method std::process::Command::args\"><code>args</code></a> may\nresult in the child process seeing a different array of arguments then the\nparent process intended.</p>\n<p>Two ways of mitigating this are:</p>\n<ul>\n<li>Validate untrusted input so that only a safe subset is allowed.</li>\n<li>Use <a href=\"../os/windows/process/trait.CommandExt.html#tymethod.raw_arg\" title=\"method std::os::windows::process::CommandExt::raw_arg\"><code>raw_arg</code></a> to build a custom commandline. This bypasses the escaping\nrules used by <a href=\"struct.Command.html#method.arg\" title=\"method std::process::Command::arg\"><code>arg</code></a> so should be used with due caution.</li>\n</ul>\n<p><code>cmd.exe</code> and <code>.bat</code> files use non-standard argument parsing and are especially\nvulnerable to malicious input as they may be used to run arbitrary shell\ncommands. Untrusted arguments should be restricted as much as possible.\nFor examples on handling this see <a href=\"../os/windows/process/trait.CommandExt.html#tymethod.raw_arg\" title=\"method std::os::windows::process::CommandExt::raw_arg\"><code>raw_arg</code></a>.</p>\n<h4 id=\"batch-file-special-handling\"><a class=\"doc-anchor\" href=\"#batch-file-special-handling\">§</a>Batch file special handling</h4>\n<p>On Windows, <code>Command</code> uses the Windows API function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw\"><code>CreateProcessW</code></a> to\nspawn new processes. An undocumented feature of this function is that\nwhen given a <code>.bat</code> file as the application to run, it will automatically\nconvert that into running <code>cmd.exe /c</code> with the batch file as the next argument.</p>\n<p>For historical reasons Rust currently preserves this behaviour when using\n<a href=\"struct.Command.html#method.new\" title=\"associated function std::process::Command::new\"><code>Command::new</code></a>, and escapes the arguments according to <code>cmd.exe</code> rules.\nDue to the complexity of <code>cmd.exe</code> argument handling, it might not be\npossible to safely escape some special characters, and using them will result\nin an error being returned at process spawn. The set of unescapeable\nspecial characters might change between releases.</p>\n<p>Also note that running batch scripts in this way may be removed in the\nfuture and so should not be relied upon.</p>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Child.html\" title=\"struct std::process::Child\">Child</a></div><div class=\"desc docblock-short\">Representation of a running or exited child process.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ChildStderr.html\" title=\"struct std::process::ChildStderr\">ChildStderr</a></div><div class=\"desc docblock-short\">A handle to a child process’s stderr.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ChildStdin.html\" title=\"struct std::process::ChildStdin\">ChildStdin</a></div><div class=\"desc docblock-short\">A handle to a child process’s standard input (stdin).</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ChildStdout.html\" title=\"struct std::process::ChildStdout\">ChildStdout</a></div><div class=\"desc docblock-short\">A handle to a child process’s standard output (stdout).</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Command.html\" title=\"struct std::process::Command\">Command</a></div><div class=\"desc docblock-short\">A process builder, providing fine-grained control\nover how a new process should be spawned.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.CommandArgs.html\" title=\"struct std::process::CommandArgs\">CommandArgs</a></div><div class=\"desc docblock-short\">An iterator over the command arguments.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.CommandEnvs.html\" title=\"struct std::process::CommandEnvs\">CommandEnvs</a></div><div class=\"desc docblock-short\">An iterator over the command environment variables.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ExitCode.html\" title=\"struct std::process::ExitCode\">ExitCode</a></div><div class=\"desc docblock-short\">This type represents the status code the current process can return\nto its parent under normal termination.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ExitStatus.html\" title=\"struct std::process::ExitStatus\">ExitStatus</a></div><div class=\"desc docblock-short\">Describes the result of a process after it has terminated.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Output.html\" title=\"struct std::process::Output\">Output</a></div><div class=\"desc docblock-short\">The output of a finished process.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Stdio.html\" title=\"struct std::process::Stdio\">Stdio</a></div><div class=\"desc docblock-short\">Describes what to do with a standard I/O stream for a child process when\npassed to the <a href=\"struct.Command.html#method.stdin\" title=\"method std::process::Command::stdin\"><code>stdin</code></a>, <a href=\"struct.Command.html#method.stdout\" title=\"method std::process::Command::stdout\"><code>stdout</code></a>, and <a href=\"struct.Command.html#method.stderr\" title=\"method std::process::Command::stderr\"><code>stderr</code></a> methods of <a href=\"struct.Command.html\" title=\"struct std::process::Command\"><code>Command</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.ExitStatusError.html\" title=\"struct std::process::ExitStatusError\">ExitStatusError</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Describes the result of a process after it has failed</div></li></ul><h2 id=\"traits\" class=\"section-header\">Traits<a href=\"#traits\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Termination.html\" title=\"trait std::process::Termination\">Termination</a></div><div class=\"desc docblock-short\">A trait for implementing arbitrary return types in the <code>main</code> function.</div></li></ul><h2 id=\"functions\" class=\"section-header\">Functions<a href=\"#functions\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.abort.html\" title=\"fn std::process::abort\">abort</a></div><div class=\"desc docblock-short\">Terminates the process in an abnormal fashion.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.exit.html\" title=\"fn std::process::exit\">exit</a></div><div class=\"desc docblock-short\">Terminates the current process with the specified exit code.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.id.html\" title=\"fn std::process::id\">id</a></div><div class=\"desc docblock-short\">Returns the OS-assigned process identifier associated with this process.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:05.757Z"
}