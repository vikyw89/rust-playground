{
	"title": "GlobalAlloc in std::alloc - Rust",
	"url": "https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html#tymethod.dealloc",
	"markdown": "# GlobalAlloc in std::alloc - Rust\n\n```\npub unsafe trait GlobalAlloc {\n    // Required methods\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n\n    // Provided methods\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 { ... }\n    unsafe fn realloc(\n        &self,\n        ptr: *mut u8,\n        layout: Layout,\n        new_size: usize,\n    ) -> *mut u8 { ... }\n}\n```\n\nExpand description\n\nA memory allocator that can be registered as the standard library’s default through the `#[global_allocator]` attribute.\n\nSome of the methods require that a memory block be _currently allocated_ via an allocator. This means that:\n\n-   the starting address for that memory block was previously returned by a previous call to an allocation method such as `alloc`, and\n    \n-   the memory block has not been subsequently deallocated, where blocks are deallocated either by being passed to a deallocation method such as `dealloc` or by being passed to a reallocation method that returns a non-null pointer.\n    \n\n## [§](#example)Example\n\n```\nuse std::alloc::{GlobalAlloc, Layout};\nuse std::cell::UnsafeCell;\nuse std::ptr::null_mut;\nuse std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n\nconst ARENA_SIZE: usize = 128 * 1024;\nconst MAX_SUPPORTED_ALIGN: usize = 4096;\n#[repr(C, align(4096))] // 4096 == MAX_SUPPORTED_ALIGN\nstruct SimpleAllocator {\n    arena: UnsafeCell<[u8; ARENA_SIZE]>,\n    remaining: AtomicUsize, // we allocate from the top, counting down\n}\n\n#[global_allocator]\nstatic ALLOCATOR: SimpleAllocator = SimpleAllocator {\n    arena: UnsafeCell::new([0x55; ARENA_SIZE]),\n    remaining: AtomicUsize::new(ARENA_SIZE),\n};\n\nunsafe impl Sync for SimpleAllocator {}\n\nunsafe impl GlobalAlloc for SimpleAllocator {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        let size = layout.size();\n        let align = layout.align();\n\n        // `Layout` contract forbids making a `Layout` with align=0, or align not power of 2.\n        // So we can safely use a mask to ensure alignment without worrying about UB.\n        let align_mask_to_round_down = !(align - 1);\n\n        if align > MAX_SUPPORTED_ALIGN {\n            return null_mut();\n        }\n\n        let mut allocated = 0;\n        if self\n            .remaining\n            .fetch_update(Relaxed, Relaxed, |mut remaining| {\n                if size > remaining {\n                    return None;\n                }\n                remaining -= size;\n                remaining &= align_mask_to_round_down;\n                allocated = remaining;\n                Some(remaining)\n            })\n            .is_err()\n        {\n            return null_mut();\n        };\n        self.arena.get().cast::<u8>().add(allocated)\n    }\n    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n}\n\nfn main() {\n    let _s = format!(\"allocating a string!\");\n    let currently = ALLOCATOR.remaining.load(Relaxed);\n    println!(\"allocated so far: {}\", ARENA_SIZE - currently);\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::alloc::%7BGlobalAlloc,+Layout%7D;%0Ause+std::cell::UnsafeCell;%0Ause+std::ptr::null_mut;%0Ause+std::sync::atomic::%7BAtomicUsize,+Ordering::Relaxed%7D;%0A%0Aconst+ARENA_SIZE:+usize+=+128+*+1024;%0Aconst+MAX_SUPPORTED_ALIGN:+usize+=+4096;%0A%23%5Brepr(C,+align(4096))%5D+//+4096+==+MAX_SUPPORTED_ALIGN%0Astruct+SimpleAllocator+%7B%0A++++arena:+UnsafeCell%3C%5Bu8;+ARENA_SIZE%5D%3E,%0A++++remaining:+AtomicUsize,+//+we+allocate+from+the+top,+counting+down%0A%7D%0A%0A%23%5Bglobal_allocator%5D%0Astatic+ALLOCATOR:+SimpleAllocator+=+SimpleAllocator+%7B%0A++++arena:+UnsafeCell::new(%5B0x55;+ARENA_SIZE%5D),%0A++++remaining:+AtomicUsize::new(ARENA_SIZE),%0A%7D;%0A%0Aunsafe+impl+Sync+for+SimpleAllocator+%7B%7D%0A%0Aunsafe+impl+GlobalAlloc+for+SimpleAllocator+%7B%0A++++unsafe+fn+alloc(%26self,+layout:+Layout)+-%3E+*mut+u8+%7B%0A++++++++let+size+=+layout.size();%0A++++++++let+align+=+layout.align();%0A%0A++++++++//+%60Layout%60+contract+forbids+making+a+%60Layout%60+with+align=0,+or+align+not+power+of+2.%0A++++++++//+So+we+can+safely+use+a+mask+to+ensure+alignment+without+worrying+about+UB.%0A++++++++let+align_mask_to_round_down+=+!(align+-+1);%0A%0A++++++++if+align+%3E+MAX_SUPPORTED_ALIGN+%7B%0A++++++++++++return+null_mut();%0A++++++++%7D%0A%0A++++++++let+mut+allocated+=+0;%0A++++++++if+self%0A++++++++++++.remaining%0A++++++++++++.fetch_update(Relaxed,+Relaxed,+%7Cmut+remaining%7C+%7B%0A++++++++++++++++if+size+%3E+remaining+%7B%0A++++++++++++++++++++return+None;%0A++++++++++++++++%7D%0A++++++++++++++++remaining+-=+size;%0A++++++++++++++++remaining+%26=+align_mask_to_round_down;%0A++++++++++++++++allocated+=+remaining;%0A++++++++++++++++Some(remaining)%0A++++++++++++%7D)%0A++++++++++++.is_err()%0A++++++++%7B%0A++++++++++++return+null_mut();%0A++++++++%7D;%0A++++++++self.arena.get().cast::%3Cu8%3E().add(allocated)%0A++++%7D%0A++++unsafe+fn+dealloc(%26self,+_ptr:+*mut+u8,+_layout:+Layout)+%7B%7D%0A%7D%0A%0Afn+main()+%7B%0A++++let+_s+=+format!(%22allocating+a+string!%22);%0A++++let+currently+=+ALLOCATOR.remaining.load(Relaxed);%0A++++println!(%22allocated+so+far:+%7B%7D%22,+ARENA_SIZE+-+currently);%0A%7D&edition=2021)\n\n## [§](#safety)Safety\n\nThe `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and implementors must ensure that they adhere to these contracts:\n\n-   It’s undefined behavior if global allocators unwind. This restriction may be lifted in the future, but currently a panic from any of these functions may lead to memory unsafety.\n    \n-   `Layout` queries and calculations in general must be correct. Callers of this trait are allowed to rely on the contracts defined on each method, and implementors must ensure such contracts remain true.\n    \n-   You must not rely on allocations actually happening, even if there are explicit heap allocations in the source. The optimizer may detect unused allocations that it can either eliminate entirely or move to the stack and thus never invoke the allocator. The optimizer may further assume that allocation is infallible, so code that used to fail due to allocator failures may now suddenly work because the optimizer worked around the need for an allocation. More concretely, the following code example is unsound, irrespective of whether your custom allocator allows counting how many allocations have happened.\n    \n    [ⓘ](# \"This example is not tested\")\n    \n    ```\n    drop(Box::new(42));\n    let number_of_heap_allocs = /* call private allocator API */;\n    unsafe { std::hint::assert_unchecked(number_of_heap_allocs > 0); }\n    ```\n    \n    [Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++drop(Box::new(42));%0A++++let+number_of_heap_allocs+=+/*+call+private+allocator+API+*/;%0A++++unsafe+%7B+std::hint::assert_unchecked(number_of_heap_allocs+%3E+0);+%7D%0A%7D&edition=2021)\n    \n    Note that the optimizations mentioned above are not the only optimization that can be applied. You may generally not rely on heap allocations happening if they can be removed without changing program behavior. Whether allocations happen or not is not part of the program behavior, even if it could be detected via an allocator that tracks allocations by printing or otherwise having side effects.\n    \n\n1.28.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#154)\n\nAllocate memory as described by the given `layout`.\n\nReturns a pointer to newly-allocated memory, or null to indicate allocation failure.\n\n##### [§](#safety-1)Safety\n\nThis function is unsafe because undefined behavior can result if the caller does not ensure that `layout` has non-zero size.\n\n(Extension subtraits might provide more specific bounds on behavior, e.g., guarantee a sentinel address or a null pointer in response to a zero-size allocation request.)\n\nThe allocated block of memory may or may not be initialized.\n\n##### [§](#errors)Errors\n\nReturning a null pointer indicates that either memory is exhausted or `layout` does not meet this allocator’s size or alignment constraints.\n\nImplementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n1.28.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#169)\n\nDeallocate the block of memory at the given `ptr` pointer with the given `layout`.\n\n##### [§](#safety-2)Safety\n\nThis function is unsafe because undefined behavior can result if the caller does not ensure all of the following:\n\n-   `ptr` must denote a block of memory currently allocated via this allocator,\n    \n-   `layout` must be the same layout that was used to allocate that block of memory.\n    \n\n1.28.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#191)\n\nBehaves like `alloc`, but also ensures that the contents are set to zero before being returned.\n\n##### [§](#safety-3)Safety\n\nThis function is unsafe for the same reasons that `alloc` is. However the allocated block of memory is guaranteed to be initialized.\n\n##### [§](#errors-1)Errors\n\nReturning a null pointer indicates that either memory is exhausted or `layout` does not meet allocator’s size or alignment constraints, just as in `alloc`.\n\nClients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n1.28.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#260)\n\nShrink or grow a block of memory to the given `new_size` in bytes. The block is described by the given `ptr` pointer and `layout`.\n\nIf this returns a non-null pointer, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. Any access to the old `ptr` is Undefined Behavior, even if the allocation remained in-place. The newly returned pointer is the only valid pointer for accessing this memory now.\n\nThe new memory block is allocated with `layout`, but with the `size` updated to `new_size` in bytes. This new layout must be used when deallocating the new memory block with `dealloc`. The range `0..min(layout.size(), new_size)` of the new memory block is guaranteed to have the same values as the original block.\n\nIf this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.\n\n##### [§](#safety-4)Safety\n\nThis function is unsafe because undefined behavior can result if the caller does not ensure all of the following:\n\n-   `ptr` must be currently allocated via this allocator,\n    \n-   `layout` must be the same layout that was used to allocate that block of memory,\n    \n-   `new_size` must be greater than zero.\n    \n-   `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow isize (i.e., the rounded value must be less than or equal to `isize::MAX`).\n    \n\n(Extension subtraits might provide more specific bounds on behavior, e.g., guarantee a sentinel address or a null pointer in response to a zero-size allocation request.)\n\n##### [§](#errors-2)Errors\n\nReturns null if the new layout does not meet the size and alignment constraints of the allocator, or if reallocation otherwise fails.\n\nImplementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is _legal_ to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\nClients wishing to abort computation in response to a reallocation error are encouraged to call the [`handle_alloc_error`](../../alloc/alloc/fn.handle_alloc_error.html) function, rather than directly invoking `panic!` or similar.\n\n1.28.0 · [source](about:blank/src/std/sys/pal/unix/alloc.rs.html#6-59)[§](#impl-GlobalAlloc-for-System)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A memory allocator that can be registered as the standard library’s default through the `#[global_allocator]` attribute.\"><title>GlobalAlloc in std::alloc - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc trait\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">GlobalAlloc</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">GlobalAlloc</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#required-methods\">Required Methods</a></h3><ul class=\"block\"><li><a href=\"#tymethod.alloc\">alloc</a></li><li><a href=\"#tymethod.dealloc\">dealloc</a></li></ul><h3><a href=\"#provided-methods\">Provided Methods</a></h3><ul class=\"block\"><li><a href=\"#method.alloc_zeroed\">alloc_zeroed</a></li><li><a href=\"#method.realloc\">realloc</a></li></ul><h3><a href=\"#implementors\">Implementors</a></h3></section><h2><a href=\"index.html\">In std::alloc</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.AllocError.html\">AllocError</a></li><li><a href=\"struct.Global.html\">Global</a></li><li><a href=\"struct.Layout.html\">Layout</a></li><li><a href=\"struct.LayoutError.html\">LayoutError</a></li><li><a href=\"struct.System.html\">System</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.Allocator.html\">Allocator</a></li><li><a href=\"trait.GlobalAlloc.html\">GlobalAlloc</a></li></ul><h3><a href=\"index.html#functions\">Functions</a></h3><ul class=\"block fn\"><li><a href=\"fn.alloc.html\">alloc</a></li><li><a href=\"fn.alloc_zeroed.html\">alloc_zeroed</a></li><li><a href=\"fn.dealloc.html\">dealloc</a></li><li><a href=\"fn.handle_alloc_error.html\">handle_alloc_error</a></li><li><a href=\"fn.realloc.html\">realloc</a></li><li><a href=\"fn.set_alloc_error_hook.html\">set_alloc_error_hook</a></li><li><a href=\"fn.take_alloc_error_hook.html\">take_alloc_error_hook</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.LayoutErr.html\">LayoutErr</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Trait <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">alloc</a>::<wbr><a class=\"trait\" href=\"#\">GlobalAlloc</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#120\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub unsafe trait GlobalAlloc {\n    // Required methods\n    unsafe fn <a href=\"#tymethod.alloc\" class=\"fn\">alloc</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>;\n<span class=\"item-spacer\"></span>    unsafe fn <a href=\"#tymethod.dealloc\" class=\"fn\">dealloc</a>(&amp;self, ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>);\n\n    // Provided methods\n    unsafe fn <a href=\"#method.alloc_zeroed\" class=\"fn\">alloc_zeroed</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a> { ... }\n<span class=\"item-spacer\"></span>    unsafe fn <a href=\"#method.realloc\" class=\"fn\">realloc</a>(\n        &amp;self,\n        ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>,\n        layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n        new_size: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n    ) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a> { ... }\n}</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A memory allocator that can be registered as the standard library’s default\nthrough the <code>#[global_allocator]</code> attribute.</p>\n<p>Some of the methods require that a memory block be <em>currently\nallocated</em> via an allocator. This means that:</p>\n<ul>\n<li>\n<p>the starting address for that memory block was previously\nreturned by a previous call to an allocation method\nsuch as <code>alloc</code>, and</p>\n</li>\n<li>\n<p>the memory block has not been subsequently deallocated, where\nblocks are deallocated either by being passed to a deallocation\nmethod such as <code>dealloc</code> or by being\npassed to a reallocation method that returns a non-null pointer.</p>\n</li>\n</ul>\n<h2 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::alloc::{GlobalAlloc, Layout};\n<span class=\"kw\">use </span>std::cell::UnsafeCell;\n<span class=\"kw\">use </span>std::ptr::null_mut;\n<span class=\"kw\">use </span>std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n\n<span class=\"kw\">const </span>ARENA_SIZE: usize = <span class=\"number\">128 </span>* <span class=\"number\">1024</span>;\n<span class=\"kw\">const </span>MAX_SUPPORTED_ALIGN: usize = <span class=\"number\">4096</span>;\n<span class=\"attr\">#[repr(C, align(<span class=\"number\">4096</span>))] </span><span class=\"comment\">// 4096 == MAX_SUPPORTED_ALIGN\n</span><span class=\"kw\">struct </span>SimpleAllocator {\n    arena: UnsafeCell&lt;[u8; ARENA_SIZE]&gt;,\n    remaining: AtomicUsize, <span class=\"comment\">// we allocate from the top, counting down\n</span>}\n\n<span class=\"attr\">#[global_allocator]\n</span><span class=\"kw\">static </span>ALLOCATOR: SimpleAllocator = SimpleAllocator {\n    arena: UnsafeCell::new([<span class=\"number\">0x55</span>; ARENA_SIZE]),\n    remaining: AtomicUsize::new(ARENA_SIZE),\n};\n\n<span class=\"kw\">unsafe impl </span>Sync <span class=\"kw\">for </span>SimpleAllocator {}\n\n<span class=\"kw\">unsafe impl </span>GlobalAlloc <span class=\"kw\">for </span>SimpleAllocator {\n    <span class=\"kw\">unsafe fn </span>alloc(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, layout: Layout) -&gt; <span class=\"kw-2\">*mut </span>u8 {\n        <span class=\"kw\">let </span>size = layout.size();\n        <span class=\"kw\">let </span>align = layout.align();\n\n        <span class=\"comment\">// `Layout` contract forbids making a `Layout` with align=0, or align not power of 2.\n        // So we can safely use a mask to ensure alignment without worrying about UB.\n        </span><span class=\"kw\">let </span>align_mask_to_round_down = !(align - <span class=\"number\">1</span>);\n\n        <span class=\"kw\">if </span>align &gt; MAX_SUPPORTED_ALIGN {\n            <span class=\"kw\">return </span>null_mut();\n        }\n\n        <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>allocated = <span class=\"number\">0</span>;\n        <span class=\"kw\">if </span><span class=\"self\">self\n            </span>.remaining\n            .fetch_update(Relaxed, Relaxed, |<span class=\"kw-2\">mut </span>remaining| {\n                <span class=\"kw\">if </span>size &gt; remaining {\n                    <span class=\"kw\">return </span><span class=\"prelude-val\">None</span>;\n                }\n                remaining -= size;\n                remaining &amp;= align_mask_to_round_down;\n                allocated = remaining;\n                <span class=\"prelude-val\">Some</span>(remaining)\n            })\n            .is_err()\n        {\n            <span class=\"kw\">return </span>null_mut();\n        };\n        <span class=\"self\">self</span>.arena.get().cast::&lt;u8&gt;().add(allocated)\n    }\n    <span class=\"kw\">unsafe fn </span>dealloc(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, _ptr: <span class=\"kw-2\">*mut </span>u8, _layout: Layout) {}\n}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>_s = <span class=\"macro\">format!</span>(<span class=\"string\">\"allocating a string!\"</span>);\n    <span class=\"kw\">let </span>currently = ALLOCATOR.remaining.load(Relaxed);\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"allocated so far: {}\"</span>, ARENA_SIZE - currently);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::alloc::%7BGlobalAlloc,+Layout%7D;%0Ause+std::cell::UnsafeCell;%0Ause+std::ptr::null_mut;%0Ause+std::sync::atomic::%7BAtomicUsize,+Ordering::Relaxed%7D;%0A%0Aconst+ARENA_SIZE:+usize+=+128+*+1024;%0Aconst+MAX_SUPPORTED_ALIGN:+usize+=+4096;%0A%23%5Brepr(C,+align(4096))%5D+//+4096+==+MAX_SUPPORTED_ALIGN%0Astruct+SimpleAllocator+%7B%0A++++arena:+UnsafeCell%3C%5Bu8;+ARENA_SIZE%5D%3E,%0A++++remaining:+AtomicUsize,+//+we+allocate+from+the+top,+counting+down%0A%7D%0A%0A%23%5Bglobal_allocator%5D%0Astatic+ALLOCATOR:+SimpleAllocator+=+SimpleAllocator+%7B%0A++++arena:+UnsafeCell::new(%5B0x55;+ARENA_SIZE%5D),%0A++++remaining:+AtomicUsize::new(ARENA_SIZE),%0A%7D;%0A%0Aunsafe+impl+Sync+for+SimpleAllocator+%7B%7D%0A%0Aunsafe+impl+GlobalAlloc+for+SimpleAllocator+%7B%0A++++unsafe+fn+alloc(%26self,+layout:+Layout)+-%3E+*mut+u8+%7B%0A++++++++let+size+=+layout.size();%0A++++++++let+align+=+layout.align();%0A%0A++++++++//+%60Layout%60+contract+forbids+making+a+%60Layout%60+with+align=0,+or+align+not+power+of+2.%0A++++++++//+So+we+can+safely+use+a+mask+to+ensure+alignment+without+worrying+about+UB.%0A++++++++let+align_mask_to_round_down+=+!(align+-+1);%0A%0A++++++++if+align+%3E+MAX_SUPPORTED_ALIGN+%7B%0A++++++++++++return+null_mut();%0A++++++++%7D%0A%0A++++++++let+mut+allocated+=+0;%0A++++++++if+self%0A++++++++++++.remaining%0A++++++++++++.fetch_update(Relaxed,+Relaxed,+%7Cmut+remaining%7C+%7B%0A++++++++++++++++if+size+%3E+remaining+%7B%0A++++++++++++++++++++return+None;%0A++++++++++++++++%7D%0A++++++++++++++++remaining+-=+size;%0A++++++++++++++++remaining+%26=+align_mask_to_round_down;%0A++++++++++++++++allocated+=+remaining;%0A++++++++++++++++Some(remaining)%0A++++++++++++%7D)%0A++++++++++++.is_err()%0A++++++++%7B%0A++++++++++++return+null_mut();%0A++++++++%7D;%0A++++++++self.arena.get().cast::%3Cu8%3E().add(allocated)%0A++++%7D%0A++++unsafe+fn+dealloc(%26self,+_ptr:+*mut+u8,+_layout:+Layout)+%7B%7D%0A%7D%0A%0Afn+main()+%7B%0A++++let+_s+=+format!(%22allocating+a+string!%22);%0A++++let+currently+=+ALLOCATOR.remaining.load(Relaxed);%0A++++println!(%22allocated+so+far:+%7B%7D%22,+ARENA_SIZE+-+currently);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h2>\n<p>The <code>GlobalAlloc</code> trait is an <code>unsafe</code> trait for a number of reasons, and\nimplementors must ensure that they adhere to these contracts:</p>\n<ul>\n<li>\n<p>It’s undefined behavior if global allocators unwind. This restriction may\nbe lifted in the future, but currently a panic from any of these\nfunctions may lead to memory unsafety.</p>\n</li>\n<li>\n<p><code>Layout</code> queries and calculations in general must be correct. Callers of\nthis trait are allowed to rely on the contracts defined on each method,\nand implementors must ensure such contracts remain true.</p>\n</li>\n<li>\n<p>You must not rely on allocations actually happening, even if there are explicit\nheap allocations in the source. The optimizer may detect unused allocations that it can either\neliminate entirely or move to the stack and thus never invoke the allocator. The\noptimizer may further assume that allocation is infallible, so code that used to fail due\nto allocator failures may now suddenly work because the optimizer worked around the\nneed for an allocation. More concretely, the following code example is unsound, irrespective\nof whether your custom allocator allows counting how many allocations have happened.</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code>drop(Box::new(<span class=\"number\">42</span>));\n<span class=\"kw\">let </span>number_of_heap_allocs = <span class=\"comment\">/* call private allocator API */</span>;\n<span class=\"kw\">unsafe </span>{ std::hint::assert_unchecked(number_of_heap_allocs &gt; <span class=\"number\">0</span>); }</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++drop(Box::new(42));%0A++++let+number_of_heap_allocs+=+/*+call+private+allocator+API+*/;%0A++++unsafe+%7B+std::hint::assert_unchecked(number_of_heap_allocs+%3E+0);+%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that the optimizations mentioned above are not the only\noptimization that can be applied. You may generally not rely on heap allocations\nhappening if they can be removed without changing program behavior.\nWhether allocations happen or not is not part of the program behavior, even if it\ncould be detected via an allocator that tracks allocations by printing or otherwise\nhaving side effects.</p>\n</li>\n</ul>\n</div></details><h2 id=\"required-methods\" class=\"section-header\">Required Methods<a href=\"#required-methods\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.alloc\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#154\">source</a></span><h4 class=\"code-header\">unsafe fn <a href=\"#tymethod.alloc\" class=\"fn\">alloc</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></summary><div class=\"docblock\"><p>Allocate memory as described by the given <code>layout</code>.</p>\n<p>Returns a pointer to newly-allocated memory,\nor null to indicate allocation failure.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>This function is unsafe because undefined behavior can result\nif the caller does not ensure that <code>layout</code> has non-zero size.</p>\n<p>(Extension subtraits might provide more specific bounds on\nbehavior, e.g., guarantee a sentinel address or a null pointer\nin response to a zero-size allocation request.)</p>\n<p>The allocated block of memory may or may not be initialized.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>Returning a null pointer indicates that either memory is exhausted\nor <code>layout</code> does not meet this allocator’s size or alignment constraints.</p>\n<p>Implementations are encouraged to return null on memory\nexhaustion rather than aborting, but this is not\na strict requirement. (Specifically: it is <em>legal</em> to\nimplement this trait atop an underlying native allocation\nlibrary that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to an\nallocation error are encouraged to call the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function,\nrather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.dealloc\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#169\">source</a></span><h4 class=\"code-header\">unsafe fn <a href=\"#tymethod.dealloc\" class=\"fn\">dealloc</a>(&amp;self, ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>)</h4></section></summary><div class=\"docblock\"><p>Deallocate the block of memory at the given <code>ptr</code> pointer with the given <code>layout</code>.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">§</a>Safety</h5>\n<p>This function is unsafe because undefined behavior can result\nif the caller does not ensure all of the following:</p>\n<ul>\n<li>\n<p><code>ptr</code> must denote a block of memory currently allocated via\nthis allocator,</p>\n</li>\n<li>\n<p><code>layout</code> must be the same layout that was used\nto allocate that block of memory.</p>\n</li>\n</ul>\n</div></details></div><h2 id=\"provided-methods\" class=\"section-header\">Provided Methods<a href=\"#provided-methods\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.alloc_zeroed\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#191\">source</a></span><h4 class=\"code-header\">unsafe fn <a href=\"#method.alloc_zeroed\" class=\"fn\">alloc_zeroed</a>(&amp;self, layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></summary><div class=\"docblock\"><p>Behaves like <code>alloc</code>, but also ensures that the contents\nare set to zero before being returned.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">§</a>Safety</h5>\n<p>This function is unsafe for the same reasons that <code>alloc</code> is.\nHowever the allocated block of memory is guaranteed to be initialized.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">§</a>Errors</h5>\n<p>Returning a null pointer indicates that either memory is exhausted\nor <code>layout</code> does not meet allocator’s size or alignment constraints,\njust as in <code>alloc</code>.</p>\n<p>Clients wishing to abort computation in response to an\nallocation error are encouraged to call the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function,\nrather than directly invoking <code>panic!</code> or similar.</p>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.realloc\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/alloc/global.rs.html#260\">source</a></span><h4 class=\"code-header\">unsafe fn <a href=\"#method.realloc\" class=\"fn\">realloc</a>(\n    &amp;self,\n    ptr: <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a>,\n    layout: <a class=\"struct\" href=\"struct.Layout.html\" title=\"struct std::alloc::Layout\">Layout</a>,\n    new_size: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"primitive\" href=\"../primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"../primitive.u8.html\">u8</a></h4></section></summary><div class=\"docblock\"><p>Shrink or grow a block of memory to the given <code>new_size</code> in bytes.\nThe block is described by the given <code>ptr</code> pointer and <code>layout</code>.</p>\n<p>If this returns a non-null pointer, then ownership of the memory block\nreferenced by <code>ptr</code> has been transferred to this allocator.\nAny access to the old <code>ptr</code> is Undefined Behavior, even if the\nallocation remained in-place. The newly returned pointer is the only valid pointer\nfor accessing this memory now.</p>\n<p>The new memory block is allocated with <code>layout</code>,\nbut with the <code>size</code> updated to <code>new_size</code> in bytes.\nThis new layout must be used when deallocating the new memory block with <code>dealloc</code>.\nThe range <code>0..min(layout.size(), new_size)</code> of the new memory block is\nguaranteed to have the same values as the original block.</p>\n<p>If this method returns null, then ownership of the memory\nblock has not been transferred to this allocator, and the\ncontents of the memory block are unaltered.</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">§</a>Safety</h5>\n<p>This function is unsafe because undefined behavior can result\nif the caller does not ensure all of the following:</p>\n<ul>\n<li>\n<p><code>ptr</code> must be currently allocated via this allocator,</p>\n</li>\n<li>\n<p><code>layout</code> must be the same layout that was used\nto allocate that block of memory,</p>\n</li>\n<li>\n<p><code>new_size</code> must be greater than zero.</p>\n</li>\n<li>\n<p><code>new_size</code>, when rounded up to the nearest multiple of <code>layout.align()</code>,\nmust not overflow isize (i.e., the rounded value must be less than or\nequal to <code>isize::MAX</code>).</p>\n</li>\n</ul>\n<p>(Extension subtraits might provide more specific bounds on\nbehavior, e.g., guarantee a sentinel address or a null pointer\nin response to a zero-size allocation request.)</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">§</a>Errors</h5>\n<p>Returns null if the new layout does not meet the size\nand alignment constraints of the allocator, or if reallocation\notherwise fails.</p>\n<p>Implementations are encouraged to return null on memory\nexhaustion rather than panicking or aborting, but this is not\na strict requirement. (Specifically: it is <em>legal</em> to\nimplement this trait atop an underlying native allocation\nlibrary that aborts on memory exhaustion.)</p>\n<p>Clients wishing to abort computation in response to a\nreallocation error are encouraged to call the <a href=\"../../alloc/alloc/fn.handle_alloc_error.html\"><code>handle_alloc_error</code></a> function,\nrather than directly invoking <code>panic!</code> or similar.</p>\n</div></details></div><h2 id=\"implementors\" class=\"section-header\">Implementors<a href=\"#implementors\" class=\"anchor\">§</a></h2><div id=\"implementors-list\"><section id=\"impl-GlobalAlloc-for-System\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.28.0\">1.28.0</span> · <a class=\"src\" href=\"../../src/std/sys/pal/unix/alloc.rs.html#6-59\">source</a></span><a href=\"#impl-GlobalAlloc-for-System\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.GlobalAlloc.html\" title=\"trait std::alloc::GlobalAlloc\">GlobalAlloc</a> for <a class=\"struct\" href=\"struct.System.html\" title=\"struct std::alloc::System\">System</a></h3></section></div><script src=\"../../trait.impl/core/alloc/global/trait.GlobalAlloc.js\" async=\"\"></script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:14:19.641Z"
}