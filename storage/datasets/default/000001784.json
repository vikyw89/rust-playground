{
	"title": "Disjoint capture in closures - The Rust Edition Guide",
	"url": "https://doc.rust-lang.org/stable/edition-guide/rust-2021/disjoint-capture-in-closures.html",
	"markdown": "# Disjoint capture in closures - The Rust Edition Guide\n\n## [Summary](#summary)\n\n-   `|| a.x + 1` now captures only `a.x` instead of `a`.\n-   This can cause things to be dropped at different times or affect whether closures implement traits like `Send` or `Clone`.\n    -   If possible changes are detected, `cargo fix` will insert statements like `let _ = &a` to force a closure to capture the entire variable.\n\n## [Details](#details)\n\n[Closures](https://doc.rust-lang.org/book/ch13-01-closures.html) automatically capture anything that you refer to from within their body. For example, `|| a + 1` automatically captures a reference to `a` from the surrounding context.\n\nIn Rust 2018 and before, closures capture entire variables, even if the closure only uses one field. For example, `|| a.x + 1` captures a reference to `a` and not just `a.x`. Capturing `a` in its entirety prevents mutation or moves from other fields of `a`, so that code like this does not compile:\n\n```rust\nlet a = SomeStruct::new();\ndrop(a.x); // Move out of one field of the struct\nprintln!(\"{}\", a.y); // Ok: Still use another field of the struct\nlet c = || println!(\"{}\", a.y); // Error: Tries to capture all of `a`\nc();\n```\n\nStarting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.\n\nDisjoint capture was proposed as part of [RFC 2229](https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md) and the RFC contains details about the motivation.\n\n## [Migration](#migration)\n\nAs a part of the 2021 edition a migration lint, `rust_2021_incompatible_closure_captures`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.\n\nIn order to migrate your code to be Rust 2021 Edition compatible, run:\n\n```sh\ncargo fix --edition\n\n```\n\nBelow is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail or you would like to better understand how the migration works.\n\nChanging the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:\n\n-   changes to drop order, or when destructors run ([details](#drop-order));\n-   changes to which traits a closure implements ([details](#trait-implementations)).\n\nWhenever any of the scenarios below are detected, `cargo fix` will insert a \"dummy let\" into your closure to force it to capture the entire variable:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = (vec![22], vec![23]);\nlet c = move || {\n    // \"Dummy let\" that forces `x` to be captured in its entirety\n    let _ = &x;\n\n    // Otherwise, only `x.0` would be captured here\n    println!(\"{:?}\", x.0);\n};\n}\n```\n\nThis is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.\n\n### [Wild Card Patterns](#wild-card-patterns)\n\nClosures now only capture data that needs to be read, which means the following closures will not capture `x`:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 10;\nlet c = || {\n    let _ = x; // no-op\n};\n\nlet c = || match x {\n    _ => println!(\"Hello World!\")\n};\n}\n```\n\nThe `let _ = x` statement here is a no-op, since the `_` pattern completely ignores the right-hand side, and `x` is a reference to a place in memory (in this case, a variable).\n\nThis change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the \"drop order\" change below.\n\n**Subtle:** There are other similar expressions, such as the \"dummy lets\" `let _ = &x` that we insert, which are not no-ops. This is because the right-hand side (`&x`) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).\n\n### [Drop Order](#drop-order)\n\nWhen a closure takes ownership of a value from a variable `t`, that value is then dropped when the closure is dropped, and not when the variable `t` goes out of scope:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn move_value<T>(_: T){}\n{\n    let t = (vec![0], vec![0]);\n\n    {\n        let c = || move_value(t); // t is moved here\n    } // c is dropped, which drops the tuple `t` as well\n} // t goes out of scope here\n}\n```\n\nThe above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of _part_ of a variable, there can be differences:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn move_value<T>(_: T){}\n{\n    let t = (vec![0], vec![0]);\n\n    {\n        let c = || {\n            // In Rust 2018, captures all of `t`.\n            // In Rust 2021, captures only `t.0`\n            move_value(t.0);\n        };\n\n        // In Rust 2018, `c` (and `t`) are both dropped when we\n        // exit this block.\n        //\n        // In Rust 2021, `c` and `t.0` are both dropped when we\n        // exit this block.\n    }\n\n// In Rust 2018, the value from `t` has been moved and is\n// not dropped.\n//\n// In Rust 2021, the value from `t.0` has been moved, but `t.1`\n// remains, so it will be dropped here.\n}\n}\n```\n\nIn most cases, dropping values at different times just affects when memory is freed and is not important. However, some `Drop` impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy `let` to force the entire variable to be captured.\n\n### [Trait implementations](#trait-implementations)\n\nClosures automatically implement the following traits based on what values they capture:\n\n-   [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html): if all captured values are `Clone`.\n-   [Auto traits](https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits) like [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html), and [`UnwindSafe`](https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html): if all captured values implement the given trait.\n\nIn Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then \"dummy lets\" are inserted.\n\nFor instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement `Send`/`Sync` auto trait for the wrapper. The closure that is passed to `thread::spawn` uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is `Send`/`Sync`, the code is considered safe and therefore compiles successfully.\n\nWith disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally `Send`/`Sync` defeating the purpose of the wrapper.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::thread;\n\nstruct Ptr(*mut i32);\nunsafe impl Send for Ptr {}\n\n\nlet mut x = 5;\nlet px = Ptr(&mut x as *mut i32);\n\nlet c = thread::spawn(move || {\n    unsafe {\n        *(px.0) += 10;\n    }\n}); // Closure captured px.0 which is not Send\n}\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Disjoint capture in closures - The Rust Edition Guide</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> What are editions?</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../editions/creating-a-new-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Creating a new project</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/transitioning-an-existing-project-to-a-new-edition.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Transitioning an existing project to a new edition</a></li><li class=\"chapter-item expanded \"><a href=\"../editions/advanced-migrations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Advanced migrations</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2015/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Rust 2015</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Rust 2018</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2018/path-changes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Path and module system changes</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/trait-fn-parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Anonymous trait function parameters deprecated</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/new-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> New keywords</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/tyvar-behind-raw-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2018/cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Cargo changes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Rust 2021</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2021/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/default-cargo-resolver.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> Default Cargo feature resolver</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/IntoIterator-for-arrays.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> IntoIterator for arrays</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/disjoint-capture-in-closures.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Disjoint capture in closures</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/panic-macro-consistency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.5.</strong> Panic macro consistency</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/reserving-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.6.</strong> Reserving syntax</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/warnings-promoted-to-error.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.7.</strong> Warnings promoted to errors</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/or-patterns-macro-rules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.8.</strong> Or patterns in macro-rules</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2021/c-string-literals.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.9.</strong> C-string literals</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/index.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Rust 2024 🚧</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../rust-2024/prelude.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Additions to the prelude</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/unsafe-op-in-unsafe-fn.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> unsafe_op_in_unsafe_fn warning</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/rpit-lifetime-capture.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> RPIT lifetime capture</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/static-mut-reference.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.4.</strong> Disallow references to static mut</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/public-private-dependencies.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.5.</strong> Public/private dependencies</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-remove-implicit-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.6.</strong> Cargo: Remove implicit features</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-table-key-names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.7.</strong> Cargo: Table and key name consistency</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/cargo-inherited-default-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.8.</strong> Cargo: Reject unused inherited default-features</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/rustfmt-overflow-delimited-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.9.</strong> Rustfmt: Combine all delimited exprs as last argument</a></li><li class=\"chapter-item expanded \"><a href=\"../rust-2024/gen-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.10.</strong> gen keyword</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Edition Guide</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/edition-guide/edit/master/src/rust-2021/disjoint-capture-in-closures.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"disjoint-capture-in-closures\"><a class=\"header\" href=\"#disjoint-capture-in-closures\">Disjoint capture in closures</a></h1>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<ul>\n<li><code class=\"hljs\">|| a.x + 1</code> now captures only <code class=\"hljs\">a.x</code> instead of <code class=\"hljs\">a</code>.</li>\n<li>This can cause things to be dropped at different times or affect whether closures implement traits like <code class=\"hljs\">Send</code> or <code class=\"hljs\">Clone</code>.\n<ul>\n<li>If possible changes are detected, <code class=\"hljs\">cargo fix</code> will insert statements like <code class=\"hljs\">let _ = &amp;a</code> to force a closure to capture the entire variable.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"details\"><a class=\"header\" href=\"#details\">Details</a></h2>\n<p><a href=\"https://doc.rust-lang.org/book/ch13-01-closures.html\">Closures</a>\nautomatically capture anything that you refer to from within their body.\nFor example, <code class=\"hljs\">|| a + 1</code> automatically captures a reference to <code class=\"hljs\">a</code> from the surrounding context.</p>\n<p>In Rust 2018 and before, closures capture entire variables, even if the closure only uses one field.\nFor example, <code class=\"hljs\">|| a.x + 1</code> captures a reference to <code class=\"hljs\">a</code> and not just <code class=\"hljs\">a.x</code>.\nCapturing <code class=\"hljs\">a</code> in its entirety prevents mutation or moves from other fields of <code class=\"hljs\">a</code>, so that code like this does not compile:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> a = SomeStruct::new();\n<span class=\"hljs-built_in\">drop</span>(a.x); <span class=\"hljs-comment\">// Move out of one field of the struct</span>\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, a.y); <span class=\"hljs-comment\">// Ok: Still use another field of the struct</span>\n<span class=\"hljs-keyword\">let</span> c = || <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, a.y); <span class=\"hljs-comment\">// Error: Tries to capture all of `a`</span>\nc();</code></pre>\n<p>Starting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.</p>\n<p>Disjoint capture was proposed as part of <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md\">RFC 2229</a> and the RFC contains details about the motivation.</p>\n<h2 id=\"migration\"><a class=\"header\" href=\"#migration\">Migration</a></h2>\n<p>As a part of the 2021 edition a migration lint, <code class=\"hljs\">rust_2021_incompatible_closure_captures</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>\n<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-sh hljs bash\">cargo fix --edition\n</code></pre>\n<p>Below is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail\nor you would like to better understand how the migration works.</p>\n<p>Changing the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:</p>\n<ul>\n<li>changes to drop order, or when destructors run (<a href=\"#drop-order\">details</a>);</li>\n<li>changes to which traits a closure implements (<a href=\"#trait-implementations\">details</a>).</li>\n</ul>\n<p>Whenever any of the scenarios below are detected, <code class=\"hljs\">cargo fix</code> will insert a \"dummy let\" into your closure to force it to capture the entire variable:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = (<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">22</span>], <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">23</span>]);\n<span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">move</span> || {\n    <span class=\"hljs-comment\">// \"Dummy let\" that forces `x` to be captured in its entirety</span>\n    <span class=\"hljs-keyword\">let</span> _ = &amp;x;\n\n    <span class=\"hljs-comment\">// Otherwise, only `x.0` would be captured here</span>\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, x.<span class=\"hljs-number\">0</span>);\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.</p>\n<h3 id=\"wild-card-patterns\"><a class=\"header\" href=\"#wild-card-patterns\">Wild Card Patterns</a></h3>\n<p>Closures now only capture data that needs to be read, which means the following closures will not capture <code class=\"hljs\">x</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">let</span> c = || {\n    <span class=\"hljs-keyword\">let</span> _ = x; <span class=\"hljs-comment\">// no-op</span>\n};\n\n<span class=\"hljs-keyword\">let</span> c = || <span class=\"hljs-keyword\">match</span> x {\n    _ =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello World!\"</span>)\n};\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The <code class=\"hljs\">let _ = x</code> statement here is a no-op, since the <code class=\"hljs\">_</code> pattern completely ignores the right-hand side, and <code class=\"hljs\">x</code> is a reference to a place in memory (in this case, a variable).</p>\n<p>This change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the \"drop order\" change below.</p>\n<p><strong>Subtle:</strong> There are other similar expressions, such as the \"dummy lets\" <code class=\"hljs\">let _ = &amp;x</code> that we insert, which are not no-ops. This is because the right-hand side (<code class=\"hljs\">&amp;x</code>) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).</p>\n<h3 id=\"drop-order\"><a class=\"header\" href=\"#drop-order\">Drop Order</a></h3>\n<p>When a closure takes ownership of a value from a variable <code class=\"hljs\">t</code>, that value is then dropped when the closure is dropped, and not when the variable <code class=\"hljs\">t</code> goes out of scope:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">move_value</span></span>&lt;T&gt;(_: T){}\n</span>{\n    <span class=\"hljs-keyword\">let</span> t = (<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>]);\n\n    {\n        <span class=\"hljs-keyword\">let</span> c = || move_value(t); <span class=\"hljs-comment\">// t is moved here</span>\n    } <span class=\"hljs-comment\">// c is dropped, which drops the tuple `t` as well</span>\n} <span class=\"hljs-comment\">// t goes out of scope here</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of <em>part</em> of a variable, there can be differences:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">move_value</span></span>&lt;T&gt;(_: T){}\n</span>{\n    <span class=\"hljs-keyword\">let</span> t = (<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>]);\n\n    {\n        <span class=\"hljs-keyword\">let</span> c = || {\n            <span class=\"hljs-comment\">// In Rust 2018, captures all of `t`.</span>\n            <span class=\"hljs-comment\">// In Rust 2021, captures only `t.0`</span>\n            move_value(t.<span class=\"hljs-number\">0</span>);\n        };\n\n        <span class=\"hljs-comment\">// In Rust 2018, `c` (and `t`) are both dropped when we</span>\n        <span class=\"hljs-comment\">// exit this block.</span>\n        <span class=\"hljs-comment\">//</span>\n        <span class=\"hljs-comment\">// In Rust 2021, `c` and `t.0` are both dropped when we</span>\n        <span class=\"hljs-comment\">// exit this block.</span>\n    }\n\n<span class=\"hljs-comment\">// In Rust 2018, the value from `t` has been moved and is</span>\n<span class=\"hljs-comment\">// not dropped.</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// In Rust 2021, the value from `t.0` has been moved, but `t.1`</span>\n<span class=\"hljs-comment\">// remains, so it will be dropped here.</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In most cases, dropping values at different times just affects when memory is freed and is not important. However, some <code class=\"hljs\">Drop</code> impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy <code class=\"hljs\">let</code> to force the entire variable to be captured.</p>\n<h3 id=\"trait-implementations\"><a class=\"header\" href=\"#trait-implementations\">Trait implementations</a></h3>\n<p>Closures automatically implement the following traits based on what values they capture:</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/std/clone/trait.Clone.html\"><code class=\"hljs\">Clone</code></a>: if all captured values are <code class=\"hljs\">Clone</code>.</li>\n<li><a href=\"https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits\">Auto traits</a> like <a href=\"https://doc.rust-lang.org/std/marker/trait.Send.html\"><code class=\"hljs\">Send</code></a>, <a href=\"https://doc.rust-lang.org/std/marker/trait.Sync.html\"><code class=\"hljs\">Sync</code></a>, and <a href=\"https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html\"><code class=\"hljs\">UnwindSafe</code></a>: if all captured values implement the given trait.</li>\n</ul>\n<p>In Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then \"dummy lets\" are inserted.</p>\n<p>For instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement <code class=\"hljs\">Send</code>/<code class=\"hljs\">Sync</code> auto trait for the wrapper. The closure that is passed to <code class=\"hljs\">thread::spawn</code> uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is <code class=\"hljs\">Send</code>/<code class=\"hljs\">Sync</code>, the code is considered safe and therefore compiles successfully.</p>\n<p>With disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally <code class=\"hljs\">Send</code>/<code class=\"hljs\">Sync</code> defeating the purpose of the wrapper.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Ptr</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>);\n<span class=\"hljs-keyword\">unsafe</span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Send</span> <span class=\"hljs-keyword\">for</span> Ptr {}\n\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">let</span> px = Ptr(&amp;<span class=\"hljs-keyword\">mut</span> x <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-keyword\">let</span> c = thread::spawn(<span class=\"hljs-keyword\">move</span> || {\n    <span class=\"hljs-keyword\">unsafe</span> {\n        *(px.<span class=\"hljs-number\">0</span>) += <span class=\"hljs-number\">10</span>;\n    }\n}); <span class=\"hljs-comment\">// Closure captured px.0 which is not Send</span>\n<span class=\"boring\">}</span></code></pre></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../rust-2021/IntoIterator-for-arrays.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../rust-2021/panic-macro-consistency.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../rust-2021/IntoIterator-for-arrays.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../rust-2021/panic-macro-consistency.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:20:31.743Z"
}