{
	"title": "How to Write Tests - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch11-01-writing-tests.html",
	"markdown": "# How to Write Tests - The Rust Programming Language\n\nTests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:\n\n1.  Set up any needed data or state.\n2.  Run the code you want to test.\n3.  Assert the results are what you expect.\n\nLet’s look at the features Rust provides specifically for writing tests that take these actions, which include the `test` attribute, a few macros, and the `should_panic` attribute.\n\n### [The Anatomy of a Test Function](#the-anatomy-of-a-test-function)\n\nAt its simplest, a test in Rust is a function that’s annotated with the `test` attribute. Attributes are metadata about pieces of Rust code; one example is the `derive` attribute we used with structs in Chapter 5. To change a function into a test function, add `#[test]` on the line before `fn`. When you run your tests with the `cargo test` command, Rust builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails.\n\nWhenever we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module gives you a template for writing your tests so you don’t have to look up the exact structure and syntax every time you start a new project. You can add as many additional test functions and as many test modules as you want!\n\nWe’ll explore some aspects of how tests work by experimenting with the template test before we actually test any code. Then we’ll write some real-world tests that call some code that we’ve written and assert that its behavior is correct.\n\nLet’s create a new library project called `adder` that will add two numbers:\n\n```console\n$ cargo new adder --lib\n     Created library `adder` project\n$ cd adder\n\n```\n\nThe contents of the _src/lib.rs_ file in your `adder` library should look like Listing 11-1.\n\nFilename: src/lib.rs\n\n```rust\npub fn add(left: usize, right: usize) -> usize {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\nListing 11-1: The test module and function generated automatically by `cargo new`\n\nFor now, let’s focus solely on the `it_works()` function. Note the `#[test]` annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the `tests` module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.\n\nThe example function body uses the `assert_eq!` macro to assert that `result`, which contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. Let’s run it to see that this test passes.\n\nThe `cargo test` command runs all tests in our project, as shown in Listing 11-2.\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nListing 11-2: The output from running the automatically generated test\n\nCargo compiled and ran the test. We see the line `running 1 test`. The next line shows the name of the generated test function, called `it_works`, and that the result of running that test is `ok`. The overall summary `test result: ok.` means that all the tests passed, and the portion that reads `1 passed; 0 failed` totals the number of tests that passed or failed.\n\nIt’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the [“Ignoring Some Tests Unless Specifically Requested”](about:blank/ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested) section later in this chapter. Because we haven’t done that here, the summary shows `0 ignored`. We can also pass an argument to the `cargo test` command to run only tests whose name matches a string; this is called _filtering_ and we’ll cover that in the [“Running a Subset of Tests by Name”](about:blank/ch11-02-running-tests.html#running-a-subset-of-tests-by-name) section. We also haven’t filtered the tests being run, so the end of the summary shows `0 filtered out`.\n\nThe `0 measured` statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See [the documentation about benchmark tests](../unstable-book/library-features/test.html) to learn more.\n\nThe next part of the test output starting at `Doc-tests adder` is for the results of any documentation tests. We don’t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps keep your docs and your code in sync! We’ll discuss how to write documentation tests in the [“Documentation Comments as Tests”](about:blank/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests) section of Chapter 14. For now, we’ll ignore the `Doc-tests` output.\n\nLet’s start to customize the test to our own needs. First change the name of the `it_works` function to a different name, such as `exploration`, like so:\n\nFilename: src/lib.rs\n\n```rust\npub fn add(left: usize, right: usize) -> usize {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exploration() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\nThen run `cargo test` again. The output now shows `exploration` instead of `it_works`:\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nNow we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. In Chapter 9, we talked about how the simplest way to panic is to call the `panic!` macro. Enter the new test as a function named `another`, so your _src/lib.rs_ file looks like Listing 11-3.\n\nFilename: src/lib.rs\n\n```rust\npub fn add(left: usize, right: usize) -> usize {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exploration() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n    \n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n```\n\nListing 11-3: Adding a second test that will fail because we call the `panic!` macro\n\nRun the tests again using `cargo test`. The output should look like Listing 11-4, which shows that our `exploration` test passed and `another` failed.\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\nthread 'tests::another' panicked at src/lib.rs:17:9:\nMake this test fail\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nListing 11-4: Test results when one test passes and one test fails\n\nInstead of `ok`, the line `test tests::another` shows `FAILED`. Two new sections appear between the individual results and the summary: the first displays the detailed reason for each test failure. In this case, we get the details that `another` failed because it `panicked at 'Make this test fail'` on line 10 in the _src/lib.rs_ file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we’ll talk more about ways to run tests in the [“Controlling How Tests Are Run”](about:blank/ch11-02-running-tests.html#controlling-how-tests-are-run) section.\n\nThe summary line displays at the end: overall, our test result is `FAILED`. We had one test pass and one test fail.\n\nNow that you’ve seen what the test results look like in different scenarios, let’s look at some macros other than `panic!` that are useful in tests.\n\n### [Checking Results with the `assert!` Macro](#checking-results-with-the-assert-macro)\n\nThe `assert!` macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to `true`. We give the `assert!` macro an argument that evaluates to a Boolean. If the value is `true`, nothing happens and the test passes. If the value is `false`, the `assert!` macro calls `panic!` to cause the test to fail. Using the `assert!` macro helps us check that our code is functioning in the way we intend.\n\nIn Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold` method, which are repeated here in Listing 11-5. Let’s put this code in the _src/lib.rs_ file, then write some tests for it using the `assert!` macro.\n\nFilename: src/lib.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n```\n\nListing 11-5: Using the `Rectangle` struct and its `can_hold` method from Chapter 5\n\nThe `can_hold` method returns a Boolean, which means it’s a perfect use case for the `assert!` macro. In Listing 11-6, we write a test that exercises the `can_hold` method by creating a `Rectangle` instance that has a width of 8 and a height of 7 and asserting that it can hold another `Rectangle` instance that has a width of 5 and a height of 1.\n\nFilename: src/lib.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&smaller));\n    }\n}\n```\n\nListing 11-6: A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle\n\nNote that we’ve added a new line inside the `tests` module: `use super::*;`. The `tests` module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the [“Paths for Referring to an Item in the Module Tree”](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html) section. Because the `tests` module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this `tests` module.\n\nWe’ve named our test `larger_can_hold_smaller`, and we’ve created the two `Rectangle` instances that we need. Then we called the `assert!` macro and passed it the result of calling `larger.can_hold(&smaller)`. This expression is supposed to return `true`, so our test should pass. Let’s find out!\n\n```console\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nIt does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:\n\nFilename: src/lib.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        // --snip--\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&smaller));\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(!smaller.can_hold(&larger));\n    }\n}\n```\n\nBecause the correct result of the `can_hold` function in this case is `false`, we need to negate that result before we pass it to the `assert!` macro. As a result, our test will pass if `can_hold` returns `false`:\n\n```console\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... ok\ntest tests::smaller_cannot_hold_larger ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nTwo tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the `can_hold` method by replacing the greater-than sign with a less-than sign when it compares the widths:\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\n// --snip--\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width < other.width && self.height > other.height\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&smaller));\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(!smaller.can_hold(&larger));\n    }\n}\n```\n\nRunning the tests now produces the following:\n\n```console\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... FAILED\ntest tests::smaller_cannot_hold_larger ... ok\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\nthread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:\nassertion failed: larger.can_hold(&smaller)\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nOur tests caught the bug! Because `larger.width` is 8 and `smaller.width` is 5, the comparison of the widths in `can_hold` now returns `false`: 8 is not less than 5.\n\n### [Testing Equality with the `assert_eq!` and `assert_ne!` Macros](#testing-equality-with-the-assert_eq-and-assert_ne-macros)\n\nA common way to verify functionality is to test for equality between the result of the code under test and the value you expect the code to return. You could do this using the `assert!` macro and passing it an expression using the `==` operator. However, this is such a common test that the standard library provides a pair of macros—`assert_eq!` and `assert_ne!`—to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They’ll also print the two values if the assertion fails, which makes it easier to see _why_ the test failed; conversely, the `assert!` macro only indicates that it got a `false` value for the `==` expression, without printing the values that led to the `false` value.\n\nIn Listing 11-7, we write a function named `add_two` that adds `2` to its parameter, then we test this function using the `assert_eq!` macro.\n\nFilename: src/lib.rs\n\n```rust\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        assert_eq!(4, add_two(2));\n    }\n}\n```\n\nListing 11-7: Testing the function `add_two` using the `assert_eq!` macro\n\nLet’s check that it passes!\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nWe pass `4` as the argument to `assert_eq!`, which is equal to the result of calling `add_two(2)`. The line for this test is `test tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed!\n\nLet’s introduce a bug into our code to see what `assert_eq!` looks like when it fails. Change the implementation of the `add_two` function to instead add `3`:\n\n```rust\npub fn add_two(a: i32) -> i32 {\n    a + 3\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        assert_eq!(4, add_two(2));\n    }\n}\n```\n\nRun the tests again:\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... FAILED\n\nfailures:\n\n---- tests::it_adds_two stdout ----\nthread 'tests::it_adds_two' panicked at src/lib.rs:11:9:\nassertion `left == right` failed\n  left: 4\n right: 5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_adds_two\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nOur test caught the bug! The `it_adds_two` test failed, and the message tells us that the assertion that fails was ``assertion `left == right` failed`` and what the `left` and `right` values are. This message helps us start debugging: the `left` argument was `4` but the `right` argument, where we had `add_two(2)`, was `5`. You can imagine that this would be especially helpful when we have a lot of tests going on.\n\nNote that in some languages and test frameworks, the parameters to equality assertion functions are called `expected` and `actual`, and the order in which we specify the arguments matters. However, in Rust, they’re called `left` and `right`, and the order in which we specify the value we expect and the value the code produces doesn’t matter. We could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which would result in the same failure message that displays ``assertion failed: `(left == right)` ``.\n\nThe `assert_ne!` macro will pass if the two values we give it are not equal and fail if they’re equal. This macro is most useful for cases when we’re not sure what a value _will_ be, but we know what the value definitely _shouldn’t_ be. For example, if we’re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.\n\nUnder the surface, the `assert_eq!` and `assert_ne!` macros use the operators `==` and `!=`, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the `PartialEq` and `Debug` traits. All primitive types and most of the standard library types implement these traits. For structs and enums that you define yourself, you’ll need to implement `PartialEq` to assert equality of those types. You’ll also need to implement `Debug` to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum definition. See Appendix C, [“Derivable Traits,”](appendix-03-derivable-traits.html) for more details about these and other derivable traits.\n\n### [Adding Custom Failure Messages](#adding-custom-failure-messages)\n\nYou can also add a custom message to be printed with the failure message as optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any arguments specified after the required arguments are passed along to the `format!` macro (discussed in Chapter 8 in the [“Concatenation with the `+` Operator or the `format!` Macro”](about:blank/ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro) section), so you can pass a format string that contains `{}` placeholders and values to go in those placeholders. Custom messages are useful for documenting what an assertion means; when a test fails, you’ll have a better idea of what the problem is with the code.\n\nFor example, let’s say we have a function that greets people by name and we want to test that the name we pass into the function appears in the output:\n\nFilename: src/lib.rs\n\n```rust\npub fn greeting(name: &str) -> String {\n    format!(\"Hello {name}!\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(result.contains(\"Carol\"));\n    }\n}\n```\n\nThe requirements for this program haven’t been agreed upon yet, and we’re pretty sure the `Hello` text at the beginning of the greeting will change. We decided we don’t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the `greeting` function, we’ll just assert that the output contains the text of the input parameter.\n\nNow let’s introduce a bug into this code by changing `greeting` to exclude `name` to see what the default test failure looks like:\n\n```rust\npub fn greeting(name: &str) -> String {\n    String::from(\"Hello!\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(result.contains(\"Carol\"));\n    }\n}\n```\n\nRunning this test produces the following:\n\n```console\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nassertion failed: result.contains(\"Carol\")\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nThis result just indicates that the assertion failed and which line the assertion is on. A more useful failure message would print the value from the `greeting` function. Let’s add a custom failure message composed of a format string with a placeholder filled in with the actual value we got from the `greeting` function:\n\n```rust\npub fn greeting(name: &str) -> String {\n    String::from(\"Hello!\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(\n            result.contains(\"Carol\"),\n            \"Greeting did not contain name, value was `{}`\",\n            result\n        );\n    }\n}\n```\n\nNow when we run the test, we’ll get a more informative error message:\n\n```console\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nGreeting did not contain name, value was `Hello!`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nWe can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.\n\n### [Checking for Panics with `should_panic`](#checking-for-panics-with-should_panic)\n\nIn addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the `Guess` type that we created in Chapter 9, Listing 9-13. Other code that uses `Guess` depends on the guarantee that `Guess` instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a `Guess` instance with a value outside that range panics.\n\nWe do this by adding the attribute `should_panic` to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.\n\nListing 11-8 shows a test that checks that the error conditions of `Guess::new` happen when we expect them to.\n\nFilename: src/lib.rs\n\n```rust\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\nListing 11-8: Testing that a condition will cause a `panic!`\n\nWe place the `#[should_panic]` attribute after the `#[test]` attribute and before the test function it applies to. Let’s look at the result when this test passes:\n\n```console\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests guessing_game\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\n```\n\nLooks good! Now let’s introduce a bug in our code by removing the condition that the `new` function will panic if the value is greater than 100:\n\n```rust\npub struct Guess {\n    value: i32,\n}\n\n// --snip--\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\nWhen we run the test in Listing 11-8, it will fail:\n\n```console\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nnote: test did not panic as expected\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nWe don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with `#[should_panic]`. The failure we got means that the code in the test function did not cause a panic.\n\nTests that use `should_panic` can be imprecise. A `should_panic` test would pass even if the test panics for a different reason from the one we were expecting. To make `should_panic` tests more precise, we can add an optional `expected` parameter to the `should_panic` attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for `Guess` in Listing 11-9 where the `new` function panics with different messages depending on whether the value is too small or too large.\n\nFilename: src/lib.rs\n\n```rust\npub struct Guess {\n    value: i32,\n}\n\n// --snip--\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {value}.\"\n            );\n        } else if value > 100 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {value}.\"\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = \"less than or equal to 100\")]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\nListing 11-9: Testing for a `panic!` with a panic message containing a specified substring\n\nThis test will pass because the value we put in the `should_panic` attribute’s `expected` parameter is a substring of the message that the `Guess::new` function panics with. We could have specified the entire panic message that we expect, which in this case would be `Guess value must be less than or equal to 100, got 200.` What you choose to specify depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the `else if value > 100` case.\n\nTo see what happens when a `should_panic` test with an `expected` message fails, let’s again introduce a bug into our code by swapping the bodies of the `if value < 1` and the `else if value > 100` blocks:\n\n```rust\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {value}.\"\n            );\n        } else if value > 100 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {value}.\"\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = \"less than or equal to 100\")]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\nThis time when we run the `should_panic` test, it will fail:\n\n```console\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nthread 'tests::greater_than_100' panicked at src/lib.rs:12:13:\nGuess value must be greater than or equal to 1, got 200.\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nnote: panic did not contain expected string\n      panic message: `\"Guess value must be greater than or equal to 1, got 200.\"`,\n expected substring: `\"less than or equal to 100\"`\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n```\n\nThe failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string `less than or equal to 100`. The panic message that we did get in this case was `Guess value must be greater than or equal to 1, got 200.` Now we can start figuring out where our bug is!\n\n### [Using `Result<T, E>` in Tests](#using-resultt-e-in-tests)\n\nOur tests so far all panic when they fail. We can also write tests that use `Result<T, E>`! Here’s the test from Listing 11-1, rewritten to use `Result<T, E>` and return an `Err` instead of panicking:\n\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() -> Result<(), String> {\n        if 2 + 2 == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n}\n```\n\nThe `it_works` function now has the `Result<(), String>` return type. In the body of the function, rather than calling the `assert_eq!` macro, we return `Ok(())` when the test passes and an `Err` with a `String` inside when the test fails.\n\nWriting tests so they return a `Result<T, E>` enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an `Err` variant.\n\nYou can’t use the `#[should_panic]` annotation on tests that use `Result<T, E>`. To assert that an operation returns an `Err` variant, _don’t_ use the question mark operator on the `Result<T, E>` value. Instead, use `assert!(value.is_err())`.\n\nNow that you know several ways to write tests, let’s look at what is happening when we run our tests and explore the different options we can use with `cargo test`.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>How to Write Tests - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"how-to-write-tests\"><a class=\"header\" href=\"#how-to-write-tests\">How to Write Tests</a></h2>\n<p>Tests are Rust functions that verify that the non-test code is functioning in\nthe expected manner. The bodies of test functions typically perform these three\nactions:</p>\n<ol>\n<li>Set up any needed data or state.</li>\n<li>Run the code you want to test.</li>\n<li>Assert the results are what you expect.</li>\n</ol>\n<p>Let’s look at the features Rust provides specifically for writing tests that\ntake these actions, which include the <code class=\"hljs\">test</code> attribute, a few macros, and the\n<code class=\"hljs\">should_panic</code> attribute.</p>\n<h3 id=\"the-anatomy-of-a-test-function\"><a class=\"header\" href=\"#the-anatomy-of-a-test-function\">The Anatomy of a Test Function</a></h3>\n<p>At its simplest, a test in Rust is a function that’s annotated with the <code class=\"hljs\">test</code>\nattribute. Attributes are metadata about pieces of Rust code; one example is\nthe <code class=\"hljs\">derive</code> attribute we used with structs in Chapter 5. To change a function\ninto a test function, add <code class=\"hljs\">#[test]</code> on the line before <code class=\"hljs\">fn</code>. When you run your\ntests with the <code class=\"hljs\">cargo test</code> command, Rust builds a test runner binary that runs\nthe annotated functions and reports on whether each\ntest function passes or fails.</p>\n<p>Whenever we make a new library project with Cargo, a test module with a test\nfunction in it is automatically generated for us. This module gives you a\ntemplate for writing your tests so you don’t have to look up the exact\nstructure and syntax every time you start a new project. You can add as many\nadditional test functions and as many test modules as you want!</p>\n<p>We’ll explore some aspects of how tests work by experimenting with the template\ntest before we actually test any code. Then we’ll write some real-world tests\nthat call some code that we’ve written and assert that its behavior is correct.</p>\n<p>Let’s create a new library project called <code class=\"hljs\">adder</code> that will add two numbers:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo new adder --lib</span>\n     Created library `adder` project\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> <span class=\"hljs-built_in\">cd</span> adder</span>\n</code></pre>\n<p>The contents of the <em>src/lib.rs</em> file in your <code class=\"hljs\">adder</code> library should look like\nListing 11-1.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<!-- manual-regeneration\ncd listings/ch11-writing-automated-tests\nrm -rf listing-11-01\ncargo new listing-11-01 --lib --name adder\ncd listing-11-01\ncargo test\ngit co output.txt\ncd ../../..\n-->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(left: <span class=\"hljs-built_in\">usize</span>, right: <span class=\"hljs-built_in\">usize</span>) -&gt; <span class=\"hljs-built_in\">usize</span> {\n    left + right\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">it_works</span></span>() {\n        <span class=\"hljs-keyword\">let</span> result = add(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(result, <span class=\"hljs-number\">4</span>);\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-1: The test module and function generated\nautomatically by <code class=\"hljs\">cargo new</code></span></p>\n<p>For now, let’s focus solely on the <code class=\"hljs\">it_works()</code> function. Note the\n<code class=\"hljs\">#[test]</code> annotation: this attribute indicates this is a test function, so the\ntest runner knows to treat this function as a test. We might also have non-test\nfunctions in the <code class=\"hljs\">tests</code> module to help set up common scenarios or perform\ncommon operations, so we always need to indicate which functions are tests.</p>\n<p>The example function body uses the <code class=\"hljs\">assert_eq!</code> macro to assert that <code class=\"hljs\">result</code>,\nwhich contains the result of adding 2 and 2, equals 4. This assertion serves as\nan example of the format for a typical test. Let’s run it to see that this test\npasses.</p>\n<p>The <code class=\"hljs\">cargo test</code> command runs all tests in our project, as shown in Listing\n11-2.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p><span class=\"caption\">Listing 11-2: The output from running the automatically\ngenerated test</span></p>\n<p>Cargo compiled and ran the test. We see the line <code class=\"hljs\">running 1 test</code>. The next\nline shows the name of the generated test function, called <code class=\"hljs\">it_works</code>, and that\nthe result of running that test is <code class=\"hljs\">ok</code>. The overall summary <code class=\"hljs\">test result: ok.</code>\nmeans that all the tests passed, and the portion that reads <code class=\"hljs\">1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>\n<p>It’s possible to mark a test as ignored so it doesn’t run in a particular\ninstance; we’ll cover that in the <a href=\"ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested\">“Ignoring Some Tests Unless Specifically\nRequested”</a><!-- ignore --> section later in this chapter. Because we\nhaven’t done that here, the summary shows <code class=\"hljs\">0 ignored</code>. We can also pass an\nargument to the <code class=\"hljs\">cargo test</code> command to run only tests whose name matches a\nstring; this is called <em>filtering</em> and we’ll cover that in the <a href=\"ch11-02-running-tests.html#running-a-subset-of-tests-by-name\">“Running a\nSubset of Tests by Name”</a><!-- ignore --> section. We also haven’t\nfiltered the tests being run, so the end of the summary shows <code class=\"hljs\">0 filtered out</code>.</p>\n<p>The <code class=\"hljs\">0 measured</code> statistic is for benchmark tests that measure performance.\nBenchmark tests are, as of this writing, only available in nightly Rust. See\n<a href=\"../unstable-book/library-features/test.html\">the documentation about benchmark tests</a> to learn more.</p>\n<p>The next part of the test output starting at <code class=\"hljs\">Doc-tests adder</code> is for the\nresults of any documentation tests. We don’t have any documentation tests yet,\nbut Rust can compile any code examples that appear in our API documentation.\nThis feature helps keep your docs and your code in sync! We’ll discuss how to\nwrite documentation tests in the <a href=\"ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests\">“Documentation Comments as\nTests”</a><!-- ignore --> section of Chapter 14. For now, we’ll\nignore the <code class=\"hljs\">Doc-tests</code> output.</p>\n<p>Let’s start to customize the test to our own needs. First change the name of\nthe <code class=\"hljs\">it_works</code> function to a different name, such as <code class=\"hljs\">exploration</code>, like so:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(left: <span class=\"hljs-built_in\">usize</span>, right: <span class=\"hljs-built_in\">usize</span>) -&gt; <span class=\"hljs-built_in\">usize</span> {\n    left + right\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">exploration</span></span>() {\n        <span class=\"hljs-keyword\">let</span> result = add(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(result, <span class=\"hljs-number\">4</span>);\n    }\n}</code></pre>\n<p>Then run <code class=\"hljs\">cargo test</code> again. The output now shows <code class=\"hljs\">exploration</code> instead of\n<code class=\"hljs\">it_works</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests\nfail when something in the test function panics. Each test is run in a new\nthread, and when the main thread sees that a test thread has died, the test is\nmarked as failed. In Chapter 9, we talked about how the simplest way to panic\nis to call the <code class=\"hljs\">panic!</code> macro. Enter the new test as a function named\n<code class=\"hljs\">another</code>, so your <em>src/lib.rs</em> file looks like Listing 11-3.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/panics.svg\" title=\"This code panics!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust panics noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add</span></span>(left: <span class=\"hljs-built_in\">usize</span>, right: <span class=\"hljs-built_in\">usize</span>) -&gt; <span class=\"hljs-built_in\">usize</span> {\n    left + right\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">exploration</span></span>() {\n        <span class=\"hljs-keyword\">let</span> result = add(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(result, <span class=\"hljs-number\">4</span>);\n    }\n    \n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">another</span></span>() {\n        <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Make this test fail\"</span>);\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-3: Adding a second test that will fail because\nwe call the <code class=\"hljs\">panic!</code> macro</span></p>\n<p>Run the tests again using <code class=\"hljs\">cargo test</code>. The output should look like Listing\n11-4, which shows that our <code class=\"hljs\">exploration</code> test passed and <code class=\"hljs\">another</code> failed.</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\nthread 'tests::another' panicked at src/lib.rs:17:9:\nMake this test fail\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p><span class=\"caption\">Listing 11-4: Test results when one test passes and one\ntest fails</span></p>\n<p>Instead of <code class=\"hljs\">ok</code>, the line <code class=\"hljs\">test tests::another</code> shows <code class=\"hljs\">FAILED</code>. Two new\nsections appear between the individual results and the summary: the first\ndisplays the detailed reason for each test failure. In this case, we get the\ndetails that <code class=\"hljs\">another</code> failed because it <code class=\"hljs\">panicked at 'Make this test fail'</code> on\nline 10 in the <em>src/lib.rs</em> file. The next section lists just the names of all\nthe failing tests, which is useful when there are lots of tests and lots of\ndetailed failing test output. We can use the name of a failing test to run just\nthat test to more easily debug it; we’ll talk more about ways to run tests in\nthe <a href=\"ch11-02-running-tests.html#controlling-how-tests-are-run\">“Controlling How Tests Are Run”</a><!-- ignore\n--> section.</p>\n<p>The summary line displays at the end: overall, our test result is <code class=\"hljs\">FAILED</code>. We\nhad one test pass and one test fail.</p>\n<p>Now that you’ve seen what the test results look like in different scenarios,\nlet’s look at some macros other than <code class=\"hljs\">panic!</code> that are useful in tests.</p>\n<h3 id=\"checking-results-with-the-assert-macro\"><a class=\"header\" href=\"#checking-results-with-the-assert-macro\">Checking Results with the <code>assert!</code> Macro</a></h3>\n<p>The <code class=\"hljs\">assert!</code> macro, provided by the standard library, is useful when you want\nto ensure that some condition in a test evaluates to <code class=\"hljs\">true</code>. We give the\n<code class=\"hljs\">assert!</code> macro an argument that evaluates to a Boolean. If the value is\n<code class=\"hljs\">true</code>, nothing happens and the test passes. If the value is <code class=\"hljs\">false</code>, the\n<code class=\"hljs\">assert!</code> macro calls <code class=\"hljs\">panic!</code> to cause the test to fail. Using the <code class=\"hljs\">assert!</code>\nmacro helps us check that our code is functioning in the way we intend.</p>\n<p>In Chapter 5, Listing 5-15, we used a <code class=\"hljs\">Rectangle</code> struct and a <code class=\"hljs\">can_hold</code>\nmethod, which are repeated here in Listing 11-5. Let’s put this code in the\n<em>src/lib.rs</em> file, then write some tests for it using the <code class=\"hljs\">assert!</code> macro.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n    width: <span class=\"hljs-built_in\">u32</span>,\n    height: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">can_hold</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rectangle) -&gt; <span class=\"hljs-built_in\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.width &gt; other.width &amp;&amp; <span class=\"hljs-keyword\">self</span>.height &gt; other.height\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-5: Using the <code class=\"hljs\">Rectangle</code> struct and its\n<code class=\"hljs\">can_hold</code> method from Chapter 5</span></p>\n<p>The <code class=\"hljs\">can_hold</code> method returns a Boolean, which means it’s a perfect use case\nfor the <code class=\"hljs\">assert!</code> macro. In Listing 11-6, we write a test that exercises the\n<code class=\"hljs\">can_hold</code> method by creating a <code class=\"hljs\">Rectangle</code> instance that has a width of 8 and\na height of 7 and asserting that it can hold another <code class=\"hljs\">Rectangle</code> instance that\nhas a width of 5 and a height of 1.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Rectangle {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">can_hold</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rectangle) -&gt; <span class=\"hljs-built_in\">bool</span> {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.width &gt; other.width &amp;&amp; <span class=\"hljs-keyword\">self</span>.height &gt; other.height\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">larger_can_hold_smaller</span></span>() {\n        <span class=\"hljs-keyword\">let</span> larger = Rectangle {\n            width: <span class=\"hljs-number\">8</span>,\n            height: <span class=\"hljs-number\">7</span>,\n        };\n        <span class=\"hljs-keyword\">let</span> smaller = Rectangle {\n            width: <span class=\"hljs-number\">5</span>,\n            height: <span class=\"hljs-number\">1</span>,\n        };\n\n        <span class=\"hljs-built_in\">assert!</span>(larger.can_hold(&amp;smaller));\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-6: A test for <code class=\"hljs\">can_hold</code> that checks whether a\nlarger rectangle can indeed hold a smaller rectangle</span></p>\n<p>Note that we’ve added a new line inside the <code class=\"hljs\">tests</code> module: <code class=\"hljs\">use super::*;</code>.\nThe <code class=\"hljs\">tests</code> module is a regular module that follows the usual visibility rules\nwe covered in Chapter 7 in the <a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\">“Paths for Referring to an Item in the Module\nTree”</a><!-- ignore -->\nsection. Because the <code class=\"hljs\">tests</code> module is an inner module, we need to bring the\ncode under test in the outer module into the scope of the inner module. We use\na glob here so anything we define in the outer module is available to this\n<code class=\"hljs\">tests</code> module.</p>\n<p>We’ve named our test <code class=\"hljs\">larger_can_hold_smaller</code>, and we’ve created the two\n<code class=\"hljs\">Rectangle</code> instances that we need. Then we called the <code class=\"hljs\">assert!</code> macro and\npassed it the result of calling <code class=\"hljs\">larger.can_hold(&amp;smaller)</code>. This expression is\nsupposed to return <code class=\"hljs\">true</code>, so our test should pass. Let’s find out!</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p>It does pass! Let’s add another test, this time asserting that a smaller\nrectangle cannot hold a larger rectangle:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Rectangle {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">can_hold</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rectangle) -&gt; <span class=\"hljs-built_in\">bool</span> {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.width &gt; other.width &amp;&amp; <span class=\"hljs-keyword\">self</span>.height &gt; other.height\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">larger_can_hold_smaller</span></span>() {\n        <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">        <span class=\"hljs-keyword\">let</span> larger = Rectangle {\n</span><span class=\"boring\">            width: <span class=\"hljs-number\">8</span>,\n</span><span class=\"boring\">            height: <span class=\"hljs-number\">7</span>,\n</span><span class=\"boring\">        };\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> smaller = Rectangle {\n</span><span class=\"boring\">            width: <span class=\"hljs-number\">5</span>,\n</span><span class=\"boring\">            height: <span class=\"hljs-number\">1</span>,\n</span><span class=\"boring\">        };\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(larger.can_hold(&amp;smaller));\n</span>    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">smaller_cannot_hold_larger</span></span>() {\n        <span class=\"hljs-keyword\">let</span> larger = Rectangle {\n            width: <span class=\"hljs-number\">8</span>,\n            height: <span class=\"hljs-number\">7</span>,\n        };\n        <span class=\"hljs-keyword\">let</span> smaller = Rectangle {\n            width: <span class=\"hljs-number\">5</span>,\n            height: <span class=\"hljs-number\">1</span>,\n        };\n\n        <span class=\"hljs-built_in\">assert!</span>(!smaller.can_hold(&amp;larger));\n    }\n}</code></pre>\n<p>Because the correct result of the <code class=\"hljs\">can_hold</code> function in this case is <code class=\"hljs\">false</code>,\nwe need to negate that result before we pass it to the <code class=\"hljs\">assert!</code> macro. As a\nresult, our test will pass if <code class=\"hljs\">can_hold</code> returns <code class=\"hljs\">false</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... ok\ntest tests::smaller_cannot_hold_larger ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p>Two tests that pass! Now let’s see what happens to our test results when we\nintroduce a bug in our code. We’ll change the implementation of the <code class=\"hljs\">can_hold</code>\nmethod by replacing the greater-than sign with a less-than sign when it\ncompares the widths:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust not_desired_behavior noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-comment\">// --snip--</span>\n<span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">can_hold</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rectangle) -&gt; <span class=\"hljs-built_in\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.width &lt; other.width &amp;&amp; <span class=\"hljs-keyword\">self</span>.height &gt; other.height\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">larger_can_hold_smaller</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> larger = Rectangle {\n</span><span class=\"boring\">            width: <span class=\"hljs-number\">8</span>,\n</span><span class=\"boring\">            height: <span class=\"hljs-number\">7</span>,\n</span><span class=\"boring\">        };\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> smaller = Rectangle {\n</span><span class=\"boring\">            width: <span class=\"hljs-number\">5</span>,\n</span><span class=\"boring\">            height: <span class=\"hljs-number\">1</span>,\n</span><span class=\"boring\">        };\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(larger.can_hold(&amp;smaller));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">smaller_cannot_hold_larger</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> larger = Rectangle {\n</span><span class=\"boring\">            width: <span class=\"hljs-number\">8</span>,\n</span><span class=\"boring\">            height: <span class=\"hljs-number\">7</span>,\n</span><span class=\"boring\">        };\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> smaller = Rectangle {\n</span><span class=\"boring\">            width: <span class=\"hljs-number\">5</span>,\n</span><span class=\"boring\">            height: <span class=\"hljs-number\">1</span>,\n</span><span class=\"boring\">        };\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(!smaller.can_hold(&amp;larger));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>Running the tests now produces the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... FAILED\ntest tests::smaller_cannot_hold_larger ... ok\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\nthread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:\nassertion failed: larger.can_hold(&amp;smaller)\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>Our tests caught the bug! Because <code class=\"hljs\">larger.width</code> is 8 and <code class=\"hljs\">smaller.width</code> is\n5, the comparison of the widths in <code class=\"hljs\">can_hold</code> now returns <code class=\"hljs\">false</code>: 8 is not\nless than 5.</p>\n<h3 id=\"testing-equality-with-the-assert_eq-and-assert_ne-macros\"><a class=\"header\" href=\"#testing-equality-with-the-assert_eq-and-assert_ne-macros\">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>\n<p>A common way to verify functionality is to test for equality between the result\nof the code under test and the value you expect the code to return. You could\ndo this using the <code class=\"hljs\">assert!</code> macro and passing it an expression using the <code class=\"hljs\">==</code>\noperator. However, this is such a common test that the standard library\nprovides a pair of macros—<code class=\"hljs\">assert_eq!</code> and <code class=\"hljs\">assert_ne!</code>—to perform this test\nmore conveniently. These macros compare two arguments for equality or\ninequality, respectively. They’ll also print the two values if the assertion\nfails, which makes it easier to see <em>why</em> the test failed; conversely, the\n<code class=\"hljs\">assert!</code> macro only indicates that it got a <code class=\"hljs\">false</code> value for the <code class=\"hljs\">==</code>\nexpression, without printing the values that led to the <code class=\"hljs\">false</code> value.</p>\n<p>In Listing 11-7, we write a function named <code class=\"hljs\">add_two</code> that adds <code class=\"hljs\">2</code> to its\nparameter, then we test this function using the <code class=\"hljs\">assert_eq!</code> macro.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_two</span></span>(a: <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-built_in\">i32</span> {\n    a + <span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">it_adds_two</span></span>() {\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">4</span>, add_two(<span class=\"hljs-number\">2</span>));\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-7: Testing the function <code class=\"hljs\">add_two</code> using the\n<code class=\"hljs\">assert_eq!</code> macro</span></p>\n<p>Let’s check that it passes!</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p>We pass <code class=\"hljs\">4</code> as the argument to <code class=\"hljs\">assert_eq!</code>, which is equal to the result of\ncalling <code class=\"hljs\">add_two(2)</code>. The line for this test is <code class=\"hljs\">test tests::it_adds_two ... ok</code>, and the <code class=\"hljs\">ok</code> text indicates that our test passed!</p>\n<p>Let’s introduce a bug into our code to see what <code class=\"hljs\">assert_eq!</code> looks like when it\nfails. Change the implementation of the <code class=\"hljs\">add_two</code> function to instead add <code class=\"hljs\">3</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-small\"></a></div><code class=\"language-rust not_desired_behavior noplayground hljs hide-boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_two</span></span>(a: <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-built_in\">i32</span> {\n    a + <span class=\"hljs-number\">3</span>\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">it_adds_two</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">4</span>, add_two(<span class=\"hljs-number\">2</span>));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>Run the tests again:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... FAILED\n\nfailures:\n\n---- tests::it_adds_two stdout ----\nthread 'tests::it_adds_two' panicked at src/lib.rs:11:9:\nassertion `left == right` failed\n  left: 4\n right: 5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_adds_two\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>Our test caught the bug! The <code class=\"hljs\">it_adds_two</code> test failed, and the message tells\nus that the assertion that fails was <code class=\"hljs\">assertion `left == right` failed</code>\nand what the <code class=\"hljs\">left</code> and <code class=\"hljs\">right</code> values are. This message helps us start\ndebugging: the <code class=\"hljs\">left</code> argument was <code class=\"hljs\">4</code> but the <code class=\"hljs\">right</code> argument, where we had\n<code class=\"hljs\">add_two(2)</code>, was <code class=\"hljs\">5</code>. You can imagine that this would be especially helpful\nwhen we have a lot of tests going on.</p>\n<p>Note that in some languages and test frameworks, the parameters to equality\nassertion functions are called <code class=\"hljs\">expected</code> and <code class=\"hljs\">actual</code>, and the order in which\nwe specify the arguments matters. However, in Rust, they’re called <code class=\"hljs\">left</code> and\n<code class=\"hljs\">right</code>, and the order in which we specify the value we expect and the value\nthe code produces doesn’t matter. We could write the assertion in this test as\n<code class=\"hljs\">assert_eq!(add_two(2), 4)</code>, which would result in the same failure message\nthat displays <code class=\"hljs\">assertion failed: `(left == right)`</code>.</p>\n<p>The <code class=\"hljs\">assert_ne!</code> macro will pass if the two values we give it are not equal and\nfail if they’re equal. This macro is most useful for cases when we’re not sure\nwhat a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.\nFor example, if we’re testing a function that is guaranteed to change its input\nin some way, but the way in which the input is changed depends on the day of\nthe week that we run our tests, the best thing to assert might be that the\noutput of the function is not equal to the input.</p>\n<p>Under the surface, the <code class=\"hljs\">assert_eq!</code> and <code class=\"hljs\">assert_ne!</code> macros use the operators\n<code class=\"hljs\">==</code> and <code class=\"hljs\">!=</code>, respectively. When the assertions fail, these macros print their\narguments using debug formatting, which means the values being compared must\nimplement the <code class=\"hljs\">PartialEq</code> and <code class=\"hljs\">Debug</code> traits. All primitive types and most of\nthe standard library types implement these traits. For structs and enums that\nyou define yourself, you’ll need to implement <code class=\"hljs\">PartialEq</code> to assert equality of\nthose types. You’ll also need to implement <code class=\"hljs\">Debug</code> to print the values when the\nassertion fails. Because both traits are derivable traits, as mentioned in\nListing 5-12 in Chapter 5, this is usually as straightforward as adding the\n<code class=\"hljs\">#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See\nAppendix C, <a href=\"appendix-03-derivable-traits.html\">“Derivable Traits,”</a><!-- ignore --> for more\ndetails about these and other derivable traits.</p>\n<h3 id=\"adding-custom-failure-messages\"><a class=\"header\" href=\"#adding-custom-failure-messages\">Adding Custom Failure Messages</a></h3>\n<p>You can also add a custom message to be printed with the failure message as\noptional arguments to the <code class=\"hljs\">assert!</code>, <code class=\"hljs\">assert_eq!</code>, and <code class=\"hljs\">assert_ne!</code> macros. Any\narguments specified after the required arguments are passed along to the\n<code class=\"hljs\">format!</code> macro (discussed in Chapter 8 in the <a href=\"ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro\">“Concatenation with the <code class=\"hljs\">+</code>\nOperator or the <code class=\"hljs\">format!</code>\nMacro”</a><!-- ignore -->\nsection), so you can pass a format string that contains <code class=\"hljs\">{}</code> placeholders and\nvalues to go in those placeholders. Custom messages are useful for documenting\nwhat an assertion means; when a test fails, you’ll have a better idea of what\nthe problem is with the code.</p>\n<p>For example, let’s say we have a function that greets people by name and we\nwant to test that the name we pass into the function appears in the output:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greeting</span></span>(name: &amp;<span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">String</span> {\n    <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"Hello {name}!\"</span>)\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greeting_contains_name</span></span>() {\n        <span class=\"hljs-keyword\">let</span> result = greeting(<span class=\"hljs-string\">\"Carol\"</span>);\n        <span class=\"hljs-built_in\">assert!</span>(result.contains(<span class=\"hljs-string\">\"Carol\"</span>));\n    }\n}</code></pre>\n<p>The requirements for this program haven’t been agreed upon yet, and we’re\npretty sure the <code class=\"hljs\">Hello</code> text at the beginning of the greeting will change. We\ndecided we don’t want to have to update the test when the requirements change,\nso instead of checking for exact equality to the value returned from the\n<code class=\"hljs\">greeting</code> function, we’ll just assert that the output contains the text of the\ninput parameter.</p>\n<p>Now let’s introduce a bug into this code by changing <code class=\"hljs\">greeting</code> to exclude\n<code class=\"hljs\">name</code> to see what the default test failure looks like:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-small\"></a></div><code class=\"language-rust not_desired_behavior noplayground hljs hide-boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greeting</span></span>(name: &amp;<span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">String</span> {\n    <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello!\"</span>)\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greeting_contains_name</span></span>() {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> result = greeting(<span class=\"hljs-string\">\"Carol\"</span>);\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(result.contains(<span class=\"hljs-string\">\"Carol\"</span>));\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>Running this test produces the following:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nassertion failed: result.contains(\"Carol\")\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>This result just indicates that the assertion failed and which line the\nassertion is on. A more useful failure message would print the value from the\n<code class=\"hljs\">greeting</code> function. Let’s add a custom failure message composed of a format\nstring with a placeholder filled in with the actual value we got from the\n<code class=\"hljs\">greeting</code> function:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greeting</span></span>(name: &amp;<span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">String</span> {\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"Hello!\"</span>)\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greeting_contains_name</span></span>() {\n        <span class=\"hljs-keyword\">let</span> result = greeting(<span class=\"hljs-string\">\"Carol\"</span>);\n        <span class=\"hljs-built_in\">assert!</span>(\n            result.contains(<span class=\"hljs-string\">\"Carol\"</span>),\n            <span class=\"hljs-string\">\"Greeting did not contain name, value was `{}`\"</span>,\n            result\n        );\n    }\n<span class=\"boring\">}</span></code></pre>\n<p>Now when we run the test, we’ll get a more informative error message:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nGreeting did not contain name, value was `Hello!`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>We can see the value we actually got in the test output, which would help us\ndebug what happened instead of what we were expecting to happen.</p>\n<h3 id=\"checking-for-panics-with-should_panic\"><a class=\"header\" href=\"#checking-for-panics-with-should_panic\">Checking for Panics with <code>should_panic</code></a></h3>\n<p>In addition to checking return values, it’s important to check that our code\nhandles error conditions as we expect. For example, consider the <code class=\"hljs\">Guess</code> type\nthat we created in Chapter 9, Listing 9-13. Other code that uses <code class=\"hljs\">Guess</code>\ndepends on the guarantee that <code class=\"hljs\">Guess</code> instances will contain only values\nbetween 1 and 100. We can write a test that ensures that attempting to create a\n<code class=\"hljs\">Guess</code> instance with a value outside that range panics.</p>\n<p>We do this by adding the attribute <code class=\"hljs\">should_panic</code> to our test function. The\ntest passes if the code inside the function panics; the test fails if the code\ninside the function doesn’t panic.</p>\n<p>Listing 11-8 shows a test that checks that the error conditions of <code class=\"hljs\">Guess::new</code>\nhappen when we expect them to.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Guess</span></span> {\n    value: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Guess {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: <span class=\"hljs-built_in\">i32</span>) -&gt; Guess {\n        <span class=\"hljs-keyword\">if</span> value &lt; <span class=\"hljs-number\">1</span> || value &gt; <span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Guess value must be between 1 and 100, got {value}.\"</span>);\n        }\n\n        Guess { value }\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-meta\">#[should_panic]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greater_than_100</span></span>() {\n        Guess::new(<span class=\"hljs-number\">200</span>);\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-8: Testing that a condition will cause a\n<code class=\"hljs\">panic!</code></span></p>\n<p>We place the <code class=\"hljs\">#[should_panic]</code> attribute after the <code class=\"hljs\">#[test]</code> attribute and\nbefore the test function it applies to. Let’s look at the result when this test\npasses:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests guessing_game\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>\n<p>Looks good! Now let’s introduce a bug in our code by removing the condition\nthat the <code class=\"hljs\">new</code> function will panic if the value is greater than 100:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust not_desired_behavior noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Guess</span></span> {\n</span><span class=\"boring\">    value: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-comment\">// --snip--</span>\n<span class=\"hljs-keyword\">impl</span> Guess {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: <span class=\"hljs-built_in\">i32</span>) -&gt; Guess {\n        <span class=\"hljs-keyword\">if</span> value &lt; <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"Guess value must be between 1 and 100, got {value}.\"</span>);\n        }\n\n        Guess { value }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[should_panic]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greater_than_100</span></span>() {\n</span><span class=\"boring\">        Guess::new(<span class=\"hljs-number\">200</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>When we run the test in Listing 11-8, it will fail:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nnote: test did not panic as expected\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>We don’t get a very helpful message in this case, but when we look at the test\nfunction, we see that it’s annotated with <code class=\"hljs\">#[should_panic]</code>. The failure we got\nmeans that the code in the test function did not cause a panic.</p>\n<p>Tests that use <code class=\"hljs\">should_panic</code> can be imprecise. A <code class=\"hljs\">should_panic</code> test would\npass even if the test panics for a different reason from the one we were\nexpecting. To make <code class=\"hljs\">should_panic</code> tests more precise, we can add an optional\n<code class=\"hljs\">expected</code> parameter to the <code class=\"hljs\">should_panic</code> attribute. The test harness will\nmake sure that the failure message contains the provided text. For example,\nconsider the modified code for <code class=\"hljs\">Guess</code> in Listing 11-9 where the <code class=\"hljs\">new</code> function\npanics with different messages depending on whether the value is too small or\ntoo large.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Guess</span></span> {\n</span><span class=\"boring\">    value: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"hljs-keyword\">impl</span> Guess {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: <span class=\"hljs-built_in\">i32</span>) -&gt; Guess {\n        <span class=\"hljs-keyword\">if</span> value &lt; <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-built_in\">panic!</span>(\n                <span class=\"hljs-string\">\"Guess value must be greater than or equal to 1, got {value}.\"</span>\n            );\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> value &gt; <span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-built_in\">panic!</span>(\n                <span class=\"hljs-string\">\"Guess value must be less than or equal to 100, got {value}.\"</span>\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-meta\">#[should_panic(expected = <span class=\"hljs-meta-string\">\"less than or equal to 100\"</span>)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greater_than_100</span></span>() {\n        Guess::new(<span class=\"hljs-number\">200</span>);\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 11-9: Testing for a <code class=\"hljs\">panic!</code> with a panic message\ncontaining a specified substring</span></p>\n<p>This test will pass because the value we put in the <code class=\"hljs\">should_panic</code> attribute’s\n<code class=\"hljs\">expected</code> parameter is a substring of the message that the <code class=\"hljs\">Guess::new</code>\nfunction panics with. We could have specified the entire panic message that we\nexpect, which in this case would be <code class=\"hljs\">Guess value must be less than or equal to 100, got 200.</code> What you choose to specify depends on how much of the panic\nmessage is unique or dynamic and how precise you want your test to be. In this\ncase, a substring of the panic message is enough to ensure that the code in the\ntest function executes the <code class=\"hljs\">else if value &gt; 100</code> case.</p>\n<p>To see what happens when a <code class=\"hljs\">should_panic</code> test with an <code class=\"hljs\">expected</code> message\nfails, let’s again introduce a bug into our code by swapping the bodies of the\n<code class=\"hljs\">if value &lt; 1</code> and the <code class=\"hljs\">else if value &gt; 100</code> blocks:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore not_desired_behavior hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Guess</span></span> {\n</span><span class=\"boring\">    value: <span class=\"hljs-built_in\">i32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Guess {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: <span class=\"hljs-built_in\">i32</span>) -&gt; Guess {\n</span>        <span class=\"hljs-keyword\">if</span> value &lt; <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-built_in\">panic!</span>(\n                <span class=\"hljs-string\">\"Guess value must be less than or equal to 100, got {value}.\"</span>\n            );\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> value &gt; <span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-built_in\">panic!</span>(\n                <span class=\"hljs-string\">\"Guess value must be greater than or equal to 1, got {value}.\"</span>\n            );\n        }\n<span class=\"boring\">\n</span><span class=\"boring\">        Guess { value }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n</span><span class=\"boring\"><span class=\"hljs-keyword\">mod</span> tests {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">use</span> super::*;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[test]</span>\n</span><span class=\"boring\">    <span class=\"hljs-meta\">#[should_panic(expected = <span class=\"hljs-meta-string\">\"less than or equal to 100\"</span>)]</span>\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">greater_than_100</span></span>() {\n</span><span class=\"boring\">        Guess::new(<span class=\"hljs-number\">200</span>);\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>This time when we run the <code class=\"hljs\">should_panic</code> test, it will fail:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo <span class=\"hljs-built_in\">test</span></span>\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nthread 'tests::greater_than_100' panicked at src/lib.rs:12:13:\nGuess value must be greater than or equal to 1, got 200.\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nnote: panic did not contain expected string\n      panic message: `\"Guess value must be greater than or equal to 1, got 200.\"`,\n expected substring: `\"less than or equal to 100\"`\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n</code></pre>\n<p>The failure message indicates that this test did indeed panic as we expected,\nbut the panic message did not include the expected string <code class=\"hljs\">less than or equal to 100</code>. The panic message that we did get in this case was <code class=\"hljs\">Guess value must be greater than or equal to 1, got 200.</code> Now we can start figuring out where\nour bug is!</p>\n<h3 id=\"using-resultt-e-in-tests\"><a class=\"header\" href=\"#using-resultt-e-in-tests\">Using <code>Result&lt;T, E&gt;</code> in Tests</a></h3>\n<p>Our tests so far all panic when they fail. We can also write tests that use\n<code class=\"hljs\">Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use <code class=\"hljs\">Result&lt;T, E&gt;</code> and return an <code class=\"hljs\">Err</code> instead of panicking:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">it_works</span></span>() -&gt; <span class=\"hljs-built_in\">Result</span>&lt;(), <span class=\"hljs-built_in\">String</span>&gt; {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">4</span> {\n            <span class=\"hljs-literal\">Ok</span>(())\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"two plus two does not equal four\"</span>))\n        }\n    }\n}</code></pre>\n<p>The <code class=\"hljs\">it_works</code> function now has the <code class=\"hljs\">Result&lt;(), String&gt;</code> return type. In the\nbody of the function, rather than calling the <code class=\"hljs\">assert_eq!</code> macro, we return\n<code class=\"hljs\">Ok(())</code> when the test passes and an <code class=\"hljs\">Err</code> with a <code class=\"hljs\">String</code> inside when the test\nfails.</p>\n<p>Writing tests so they return a <code class=\"hljs\">Result&lt;T, E&gt;</code> enables you to use the question\nmark operator in the body of tests, which can be a convenient way to write\ntests that should fail if any operation within them returns an <code class=\"hljs\">Err</code> variant.</p>\n<p>You can’t use the <code class=\"hljs\">#[should_panic]</code> annotation on tests that use <code class=\"hljs\">Result&lt;T, E&gt;</code>. To assert that an operation returns an <code class=\"hljs\">Err</code> variant, <em>don’t</em> use the\nquestion mark operator on the <code class=\"hljs\">Result&lt;T, E&gt;</code> value. Instead, use\n<code class=\"hljs\">assert!(value.is_err())</code>.</p>\n<p>Now that you know several ways to write tests, let’s look at what is happening\nwhen we run our tests and explore the different options we can use with <code class=\"hljs\">cargo test</code>.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch11-00-testing.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch11-02-running-tests.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch11-00-testing.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch11-02-running-tests.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:23.988Z"
}