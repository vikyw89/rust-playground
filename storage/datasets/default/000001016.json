{
	"title": "Mutex in std::sync - Rust",
	"url": "https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html",
	"markdown": "# Mutex in std::sync - Rust\n\n## Struct [std](../index.html)::[sync](index.html)::[Mutex](#)\n\n1.0.0 · [source](about:blank/src/std/sync/mutex.rs.html#178-182) ·\n\n```\npub struct Mutex<T: ?Sized> { /* private fields */ }\n```\n\nExpand description\n\nA mutual exclusion primitive useful for protecting shared data\n\nThis mutex will block threads waiting for the lock to become available. The mutex can be created via a [`new`](about:blank/struct.Mutex.html#method.new \"associated function std::sync::Mutex::new\") constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from [`lock`](about:blank/struct.Mutex.html#method.lock \"method std::sync::Mutex::lock\") and [`try_lock`](about:blank/struct.Mutex.html#method.try_lock \"method std::sync::Mutex::try_lock\"), which guarantees that the data is only ever accessed when the mutex is locked.\n\n## [§](#poisoning)Poisoning\n\nThe mutexes in this module implement a strategy called “poisoning” where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).\n\nFor a mutex, this means that the [`lock`](about:blank/struct.Mutex.html#method.lock \"method std::sync::Mutex::lock\") and [`try_lock`](about:blank/struct.Mutex.html#method.try_lock \"method std::sync::Mutex::try_lock\") methods return a [`Result`](../result/enum.Result.html \"enum std::result::Result\") which indicates whether a mutex has been poisoned or not. Most usage of a mutex will simply [`unwrap()`](about:blank/result/enum.Result.html#method.unwrap \"method std::result::Result::unwrap\") these results, propagating panics among threads to ensure that a possibly invalid invariant is not witnessed.\n\nA poisoned mutex, however, does not prevent all access to the underlying data. The [`PoisonError`](struct.PoisonError.html \"struct std::sync::PoisonError\") type has an [`into_inner`](about:blank/struct.PoisonError.html#method.into_inner \"method std::sync::PoisonError::into_inner\") method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.\n\n## [§](#examples)Examples\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nconst N: usize = 10;\n\n// Spawn a few threads to increment a shared variable (non-atomically), and\n// let the main thread know once all increments are done.\n//\n// Here we're using an Arc to share memory among threads, and the data inside\n// the Arc is protected with a mutex.\nlet data = Arc::new(Mutex::new(0));\n\nlet (tx, rx) = channel();\nfor _ in 0..N {\n    let (data, tx) = (Arc::clone(&data), tx.clone());\n    thread::spawn(move || {\n        // The shared state can only be accessed once the lock is held.\n        // Our non-atomic increment is safe because we're the only thread\n        // which can access the shared state when the lock is held.\n        //\n        // We unwrap() the return value to assert that we are not expecting\n        // threads to ever fail while holding the lock.\n        let mut data = data.lock().unwrap();\n        *data += 1;\n        if *data == N {\n            tx.send(()).unwrap();\n        }\n        // the lock is unlocked here when `data` goes out of scope.\n    });\n}\n\nrx.recv().unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++const+N:+usize+=+10;%0A++++%0A++++//+Spawn+a+few+threads+to+increment+a+shared+variable+(non-atomically),+and%0A++++//+let+the+main+thread+know+once+all+increments+are+done.%0A++++//%0A++++//+Here+we%27re+using+an+Arc+to+share+memory+among+threads,+and+the+data+inside%0A++++//+the+Arc+is+protected+with+a+mutex.%0A++++let+data+=+Arc::new(Mutex::new(0));%0A++++%0A++++let+(tx,+rx)+=+channel();%0A++++for+_+in+0..N+%7B%0A++++++++let+(data,+tx)+=+(Arc::clone(%26data),+tx.clone());%0A++++++++thread::spawn(move+%7C%7C+%7B%0A++++++++++++//+The+shared+state+can+only+be+accessed+once+the+lock+is+held.%0A++++++++++++//+Our+non-atomic+increment+is+safe+because+we%27re+the+only+thread%0A++++++++++++//+which+can+access+the+shared+state+when+the+lock+is+held.%0A++++++++++++//%0A++++++++++++//+We+unwrap()+the+return+value+to+assert+that+we+are+not+expecting%0A++++++++++++//+threads+to+ever+fail+while+holding+the+lock.%0A++++++++++++let+mut+data+=+data.lock().unwrap();%0A++++++++++++*data+%2B=+1;%0A++++++++++++if+*data+==+N+%7B%0A++++++++++++++++tx.send(()).unwrap();%0A++++++++++++%7D%0A++++++++++++//+the+lock+is+unlocked+here+when+%60data%60+goes+out+of+scope.%0A++++++++%7D);%0A++++%7D%0A++++%0A++++rx.recv().unwrap();%0A%7D&edition=2021)\n\nTo recover from a poisoned mutex:\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet lock = Arc::new(Mutex::new(0_u32));\nlet lock2 = Arc::clone(&lock);\n\nlet _ = thread::spawn(move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // `lock` because the lock has not been poisoned.\n    let _guard = lock2.lock().unwrap();\n\n    // This panic while holding the lock (`_guard` is in scope) will poison\n    // the mutex.\n    panic!();\n}).join();\n\n// The lock is poisoned by this point, but the returned result can be\n// pattern matched on to return the underlying guard on both branches.\nlet mut guard = match lock.lock() {\n    Ok(guard) => guard,\n    Err(poisoned) => poisoned.into_inner(),\n};\n\n*guard += 1;\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+lock+=+Arc::new(Mutex::new(0_u32));%0A++++let+lock2+=+Arc::clone(%26lock);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+-%3E+()+%7B%0A++++++++//+This+thread+will+acquire+the+mutex+first,+unwrapping+the+result+of%0A++++++++//+%60lock%60+because+the+lock+has+not+been+poisoned.%0A++++++++let+_guard+=+lock2.lock().unwrap();%0A++++%0A++++++++//+This+panic+while+holding+the+lock+(%60_guard%60+is+in+scope)+will+poison%0A++++++++//+the+mutex.%0A++++++++panic!();%0A++++%7D).join();%0A++++%0A++++//+The+lock+is+poisoned+by+this+point,+but+the+returned+result+can+be%0A++++//+pattern+matched+on+to+return+the+underlying+guard+on+both+branches.%0A++++let+mut+guard+=+match+lock.lock()+%7B%0A++++++++Ok(guard)+=%3E+guard,%0A++++++++Err(poisoned)+=%3E+poisoned.into_inner(),%0A++++%7D;%0A++++%0A++++*guard+%2B=+1;%0A%7D&edition=2021)\n\nTo unlock a mutex guard sooner than the end of the enclosing scope, either create an inner scope or drop the guard manually.\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nconst N: usize = 3;\n\nlet data_mutex = Arc::new(Mutex::new(vec![1, 2, 3, 4]));\nlet res_mutex = Arc::new(Mutex::new(0));\n\nlet mut threads = Vec::with_capacity(N);\n(0..N).for_each(|_| {\n    let data_mutex_clone = Arc::clone(&data_mutex);\n    let res_mutex_clone = Arc::clone(&res_mutex);\n\n    threads.push(thread::spawn(move || {\n        // Here we use a block to limit the lifetime of the lock guard.\n        let result = {\n            let mut data = data_mutex_clone.lock().unwrap();\n            // This is the result of some important and long-ish work.\n            let result = data.iter().fold(0, |acc, x| acc + x * 2);\n            data.push(result);\n            result\n            // The mutex guard gets dropped here, together with any other values\n            // created in the critical section.\n        };\n        // The guard created here is a temporary dropped at the end of the statement, i.e.\n        // the lock would not remain being held even if the thread did some additional work.\n        *res_mutex_clone.lock().unwrap() += result;\n    }));\n});\n\nlet mut data = data_mutex.lock().unwrap();\n// This is the result of some important and long-ish work.\nlet result = data.iter().fold(0, |acc, x| acc + x * 2);\ndata.push(result);\n// We drop the `data` explicitly because it's not necessary anymore and the\n// thread still has work to do. This allows other threads to start working on\n// the data immediately, without waiting for the rest of the unrelated work\n// to be done here.\n//\n// It's even more important here than in the threads because we `.join` the\n// threads after that. If we had not dropped the mutex guard, a thread could\n// be waiting forever for it, causing a deadlock.\n// As in the threads, a block could have been used instead of calling the\n// `drop` function.\ndrop(data);\n// Here the mutex guard is not assigned to a variable and so, even if the\n// scope does not end after this line, the mutex is still released: there is\n// no deadlock.\n*res_mutex.lock().unwrap() += result;\n\nthreads.into_iter().for_each(|thread| {\n    thread\n        .join()\n        .expect(\"The thread creating or execution failed !\")\n});\n\nassert_eq!(*res_mutex.lock().unwrap(), 800);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++const+N:+usize+=+3;%0A++++%0A++++let+data_mutex+=+Arc::new(Mutex::new(vec!%5B1,+2,+3,+4%5D));%0A++++let+res_mutex+=+Arc::new(Mutex::new(0));%0A++++%0A++++let+mut+threads+=+Vec::with_capacity(N);%0A++++(0..N).for_each(%7C_%7C+%7B%0A++++++++let+data_mutex_clone+=+Arc::clone(%26data_mutex);%0A++++++++let+res_mutex_clone+=+Arc::clone(%26res_mutex);%0A++++%0A++++++++threads.push(thread::spawn(move+%7C%7C+%7B%0A++++++++++++//+Here+we+use+a+block+to+limit+the+lifetime+of+the+lock+guard.%0A++++++++++++let+result+=+%7B%0A++++++++++++++++let+mut+data+=+data_mutex_clone.lock().unwrap();%0A++++++++++++++++//+This+is+the+result+of+some+important+and+long-ish+work.%0A++++++++++++++++let+result+=+data.iter().fold(0,+%7Cacc,+x%7C+acc+%2B+x+*+2);%0A++++++++++++++++data.push(result);%0A++++++++++++++++result%0A++++++++++++++++//+The+mutex+guard+gets+dropped+here,+together+with+any+other+values%0A++++++++++++++++//+created+in+the+critical+section.%0A++++++++++++%7D;%0A++++++++++++//+The+guard+created+here+is+a+temporary+dropped+at+the+end+of+the+statement,+i.e.%0A++++++++++++//+the+lock+would+not+remain+being+held+even+if+the+thread+did+some+additional+work.%0A++++++++++++*res_mutex_clone.lock().unwrap()+%2B=+result;%0A++++++++%7D));%0A++++%7D);%0A++++%0A++++let+mut+data+=+data_mutex.lock().unwrap();%0A++++//+This+is+the+result+of+some+important+and+long-ish+work.%0A++++let+result+=+data.iter().fold(0,+%7Cacc,+x%7C+acc+%2B+x+*+2);%0A++++data.push(result);%0A++++//+We+drop+the+%60data%60+explicitly+because+it%27s+not+necessary+anymore+and+the%0A++++//+thread+still+has+work+to+do.+This+allows+other+threads+to+start+working+on%0A++++//+the+data+immediately,+without+waiting+for+the+rest+of+the+unrelated+work%0A++++//+to+be+done+here.%0A++++//%0A++++//+It%27s+even+more+important+here+than+in+the+threads+because+we+%60.join%60+the%0A++++//+threads+after+that.+If+we+had+not+dropped+the+mutex+guard,+a+thread+could%0A++++//+be+waiting+forever+for+it,+causing+a+deadlock.%0A++++//+As+in+the+threads,+a+block+could+have+been+used+instead+of+calling+the%0A++++//+%60drop%60+function.%0A++++drop(data);%0A++++//+Here+the+mutex+guard+is+not+assigned+to+a+variable+and+so,+even+if+the%0A++++//+scope+does+not+end+after+this+line,+the+mutex+is+still+released:+there+is%0A++++//+no+deadlock.%0A++++*res_mutex.lock().unwrap()+%2B=+result;%0A++++%0A++++threads.into_iter().for_each(%7Cthread%7C+%7B%0A++++++++thread%0A++++++++++++.join()%0A++++++++++++.expect(%22The+thread+creating+or+execution+failed+!%22)%0A++++%7D);%0A++++%0A++++assert_eq!(*res_mutex.lock().unwrap(),+800);%0A%7D&edition=2021)\n\n[source](about:blank/src/std/sync/mutex.rs.html#260-276)[§](#impl-Mutex%3CT%3E)\n\n1.0.0 (const: 1.63.0) · [source](about:blank/src/std/sync/mutex.rs.html#273-275)\n\nCreates a new mutex in an unlocked state ready for use.\n\n##### [§](#examples-1)Examples\n\n```\nuse std::sync::Mutex;\n\nlet mutex = Mutex::new(0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Mutex;%0A++++%0A++++let+mutex+=+Mutex::new(0);%0A%7D&edition=2021)\n\n[source](about:blank/src/std/sync/mutex.rs.html#278-484)[§](#impl-Mutex%3CT%3E-1)\n\n1.0.0 · [source](about:blank/src/std/sync/mutex.rs.html#315-320)\n\nAcquires a mutex, blocking the current thread until it is able to do so.\n\nThis function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.\n\nThe exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).\n\n##### [§](#errors)Errors\n\nIf another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.\n\n##### [§](#panics)Panics\n\nThis function might panic when called if the lock is already held by the current thread.\n\n##### [§](#examples-2)Examples\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = Arc::clone(&mutex);\n\nthread::spawn(move || {\n    *c_mutex.lock().unwrap() = 10;\n}).join().expect(\"thread::spawn failed\");\nassert_eq!(*mutex.lock().unwrap(), 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++thread::spawn(move+%7C%7C+%7B%0A++++++++*c_mutex.lock().unwrap()+=+10;%0A++++%7D).join().expect(%22thread::spawn+failed%22);%0A++++assert_eq!(*mutex.lock().unwrap(),+10);%0A%7D&edition=2021)\n\n1.0.0 · [source](about:blank/src/std/sync/mutex.rs.html#362-370)\n\nAttempts to acquire this lock.\n\nIf the lock could not be acquired at this time, then [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.\n\nThis function does not block.\n\n##### [§](#errors-1)Errors\n\nIf another user of this mutex panicked while holding the mutex, then this call will return the [`Poisoned`](about:blank/enum.TryLockError.html#variant.Poisoned \"variant std::sync::TryLockError::Poisoned\") error if the mutex would otherwise be acquired.\n\nIf the mutex could not be acquired because it is already locked, then this call will return the [`WouldBlock`](about:blank/enum.TryLockError.html#variant.WouldBlock \"variant std::sync::TryLockError::WouldBlock\") error.\n\n##### [§](#examples-3)Examples\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = Arc::clone(&mutex);\n\nthread::spawn(move || {\n    let mut lock = c_mutex.try_lock();\n    if let Ok(ref mut mutex) = lock {\n        **mutex = 10;\n    } else {\n        println!(\"try_lock failed\");\n    }\n}).join().expect(\"thread::spawn failed\");\nassert_eq!(*mutex.lock().unwrap(), 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++thread::spawn(move+%7C%7C+%7B%0A++++++++let+mut+lock+=+c_mutex.try_lock();%0A++++++++if+let+Ok(ref+mut+mutex)+=+lock+%7B%0A++++++++++++**mutex+=+10;%0A++++++++%7D+else+%7B%0A++++++++++++println!(%22try_lock+failed%22);%0A++++++++%7D%0A++++%7D).join().expect(%22thread::spawn+failed%22);%0A++++assert_eq!(*mutex.lock().unwrap(),+10);%0A%7D&edition=2021)\n\n1.2.0 · [source](about:blank/src/std/sync/mutex.rs.html#395-397)\n\nDetermines whether the mutex is poisoned.\n\nIf another thread is active, the mutex can still become poisoned at any time. You should not trust a `false` value for program correctness without additional synchronization.\n\n##### [§](#examples-4)Examples\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = Arc::clone(&mutex);\n\nlet _ = thread::spawn(move || {\n    let _lock = c_mutex.lock().unwrap();\n    panic!(); // the mutex gets poisoned\n}).join();\nassert_eq!(mutex.is_poisoned(), true);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+_lock+=+c_mutex.lock().unwrap();%0A++++++++panic!();+//+the+mutex+gets+poisoned%0A++++%7D).join();%0A++++assert_eq!(mutex.is_poisoned(),+true);%0A%7D&edition=2021)\n\n1.77.0 · [source](about:blank/src/std/sync/mutex.rs.html#432-434)\n\nClear the poisoned state from a mutex.\n\nIf the mutex is poisoned, it will remain poisoned until this function is called. This allows recovering from a poisoned state and marking that it has recovered. For example, if the value is overwritten by a known-good value, then the mutex can be marked as un-poisoned. Or possibly, the value could be inspected to determine if it is in a consistent state, and if so the poison is removed.\n\n##### [§](#examples-5)Examples\n\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = Arc::clone(&mutex);\n\nlet _ = thread::spawn(move || {\n    let _lock = c_mutex.lock().unwrap();\n    panic!(); // the mutex gets poisoned\n}).join();\n\nassert_eq!(mutex.is_poisoned(), true);\nlet x = mutex.lock().unwrap_or_else(|mut e| {\n    **e.get_mut() = 1;\n    mutex.clear_poison();\n    e.into_inner()\n});\nassert_eq!(mutex.is_poisoned(), false);\nassert_eq!(*x, 1);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+_lock+=+c_mutex.lock().unwrap();%0A++++++++panic!();+//+the+mutex+gets+poisoned%0A++++%7D).join();%0A++++%0A++++assert_eq!(mutex.is_poisoned(),+true);%0A++++let+x+=+mutex.lock().unwrap_or_else(%7Cmut+e%7C+%7B%0A++++++++**e.get_mut()+=+1;%0A++++++++mutex.clear_poison();%0A++++++++e.into_inner()%0A++++%7D);%0A++++assert_eq!(mutex.is_poisoned(),+false);%0A++++assert_eq!(*x,+1);%0A%7D&edition=2021)\n\n1.6.0 · [source](about:blank/src/std/sync/mutex.rs.html#452-458)\n\nConsumes this mutex, returning the underlying data.\n\n##### [§](#errors-2)Errors\n\nIf another user of this mutex panicked while holding the mutex, then this call will return an error instead.\n\n##### [§](#examples-6)Examples\n\n```\nuse std::sync::Mutex;\n\nlet mutex = Mutex::new(0);\nassert_eq!(mutex.into_inner().unwrap(), 0);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Mutex;%0A++++%0A++++let+mutex+=+Mutex::new(0);%0A++++assert_eq!(mutex.into_inner().unwrap(),+0);%0A%7D&edition=2021)\n\n1.6.0 · [source](about:blank/src/std/sync/mutex.rs.html#480-483)\n\nReturns a mutable reference to the underlying data.\n\nSince this call borrows the `Mutex` mutably, no actual locking needs to take place – the mutable borrow statically guarantees no locks exist.\n\n##### [§](#errors-3)Errors\n\nIf another user of this mutex panicked while holding the mutex, then this call will return an error instead.\n\n##### [§](#examples-7)Examples\n\n```\nuse std::sync::Mutex;\n\nlet mut mutex = Mutex::new(0);\n*mutex.get_mut().unwrap() = 10;\nassert_eq!(*mutex.lock().unwrap(), 10);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Mutex;%0A++++%0A++++let+mut+mutex+=+Mutex::new(0);%0A++++*mutex.get_mut().unwrap()+=+10;%0A++++assert_eq!(*mutex.lock().unwrap(),+10);%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A mutual exclusion primitive useful for protecting shared data\"><title>Mutex in std::sync - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Mutex</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Mutex</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.clear_poison\">clear_poison</a></li><li><a href=\"#method.get_mut\">get_mut</a></li><li><a href=\"#method.into_inner\">into_inner</a></li><li><a href=\"#method.is_poisoned\">is_poisoned</a></li><li><a href=\"#method.lock\">lock</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.try_lock\">try_lock</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Debug-for-Mutex%3CT%3E\">Debug</a></li><li><a href=\"#impl-Default-for-Mutex%3CT%3E\">Default</a></li><li><a href=\"#impl-From%3CT%3E-for-Mutex%3CT%3E\">From&lt;T&gt;</a></li><li><a href=\"#impl-RefUnwindSafe-for-Mutex%3CT%3E\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-Mutex%3CT%3E\">Send</a></li><li><a href=\"#impl-Sync-for-Mutex%3CT%3E\">Sync</a></li><li><a href=\"#impl-UnwindSafe-for-Mutex%3CT%3E\">UnwindSafe</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-Mutex%3CT%3E\">!Freeze</a></li><li><a href=\"#impl-Unpin-for-Mutex%3CT%3E\">Unpin</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3C!%3E-for-T\">From&lt;!&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::sync</a></h2><h3><a href=\"index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"atomic/index.html\">atomic</a></li><li><a href=\"mpsc/index.html\">mpsc</a></li></ul><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Arc.html\">Arc</a></li><li><a href=\"struct.Barrier.html\">Barrier</a></li><li><a href=\"struct.BarrierWaitResult.html\">BarrierWaitResult</a></li><li><a href=\"struct.Condvar.html\">Condvar</a></li><li><a href=\"struct.Exclusive.html\">Exclusive</a></li><li><a href=\"struct.LazyLock.html\">LazyLock</a></li><li><a href=\"struct.MappedMutexGuard.html\">MappedMutexGuard</a></li><li><a href=\"struct.MappedRwLockReadGuard.html\">MappedRwLockReadGuard</a></li><li><a href=\"struct.MappedRwLockWriteGuard.html\">MappedRwLockWriteGuard</a></li><li><a href=\"struct.Mutex.html\">Mutex</a></li><li><a href=\"struct.MutexGuard.html\">MutexGuard</a></li><li><a href=\"struct.Once.html\">Once</a></li><li><a href=\"struct.OnceLock.html\">OnceLock</a></li><li><a href=\"struct.OnceState.html\">OnceState</a></li><li><a href=\"struct.PoisonError.html\">PoisonError</a></li><li><a href=\"struct.ReentrantLock.html\">ReentrantLock</a></li><li><a href=\"struct.ReentrantLockGuard.html\">ReentrantLockGuard</a></li><li><a href=\"struct.RwLock.html\">RwLock</a></li><li><a href=\"struct.RwLockReadGuard.html\">RwLockReadGuard</a></li><li><a href=\"struct.RwLockWriteGuard.html\">RwLockWriteGuard</a></li><li><a href=\"struct.WaitTimeoutResult.html\">WaitTimeoutResult</a></li><li><a href=\"struct.Weak.html\">Weak</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.TryLockError.html\">TryLockError</a></li></ul><h3><a href=\"index.html#constants\">Constants</a></h3><ul class=\"block constant\"><li><a href=\"constant.ONCE_INIT.html\">ONCE_INIT</a></li></ul><h3><a href=\"index.html#types\">Type Aliases</a></h3><ul class=\"block type\"><li><a href=\"type.LockResult.html\">LockResult</a></li><li><a href=\"type.TryLockResult.html\">TryLockResult</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">sync</a>::<wbr><a class=\"struct\" href=\"#\">Mutex</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#178-182\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct Mutex&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; { <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A mutual exclusion primitive useful for protecting shared data</p>\n<p>This mutex will block threads waiting for the lock to become available. The\nmutex can be created via a <a href=\"struct.Mutex.html#method.new\" title=\"associated function std::sync::Mutex::new\"><code>new</code></a> constructor. Each mutex has a type parameter\nwhich represents the data that it is protecting. The data can only be accessed\nthrough the RAII guards returned from <a href=\"struct.Mutex.html#method.lock\" title=\"method std::sync::Mutex::lock\"><code>lock</code></a> and <a href=\"struct.Mutex.html#method.try_lock\" title=\"method std::sync::Mutex::try_lock\"><code>try_lock</code></a>, which\nguarantees that the data is only ever accessed when the mutex is locked.</p>\n<h2 id=\"poisoning\"><a class=\"doc-anchor\" href=\"#poisoning\">§</a>Poisoning</h2>\n<p>The mutexes in this module implement a strategy called “poisoning” where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex. Once a mutex is poisoned, all other threads are unable to access the\ndata by default as it is likely tainted (some invariant is not being\nupheld).</p>\n<p>For a mutex, this means that the <a href=\"struct.Mutex.html#method.lock\" title=\"method std::sync::Mutex::lock\"><code>lock</code></a> and <a href=\"struct.Mutex.html#method.try_lock\" title=\"method std::sync::Mutex::try_lock\"><code>try_lock</code></a> methods return a\n<a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> which indicates whether a mutex has been poisoned or not. Most\nusage of a mutex will simply <a href=\"../result/enum.Result.html#method.unwrap\" title=\"method std::result::Result::unwrap\"><code>unwrap()</code></a> these results, propagating panics\namong threads to ensure that a possibly invalid invariant is not witnessed.</p>\n<p>A poisoned mutex, however, does not prevent all access to the underlying\ndata. The <a href=\"struct.PoisonError.html\" title=\"struct std::sync::PoisonError\"><code>PoisonError</code></a> type has an <a href=\"struct.PoisonError.html#method.into_inner\" title=\"method std::sync::PoisonError::into_inner\"><code>into_inner</code></a> method which will return\nthe guard that would have otherwise been returned on a successful lock. This\nallows access to the data, despite the lock being poisoned.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>std::sync::mpsc::channel;\n\n<span class=\"kw\">const </span>N: usize = <span class=\"number\">10</span>;\n\n<span class=\"comment\">// Spawn a few threads to increment a shared variable (non-atomically), and\n// let the main thread know once all increments are done.\n//\n// Here we're using an Arc to share memory among threads, and the data inside\n// the Arc is protected with a mutex.\n</span><span class=\"kw\">let </span>data = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n\n<span class=\"kw\">let </span>(tx, rx) = channel();\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..N {\n    <span class=\"kw\">let </span>(data, tx) = (Arc::clone(<span class=\"kw-2\">&amp;</span>data), tx.clone());\n    thread::spawn(<span class=\"kw\">move </span>|| {\n        <span class=\"comment\">// The shared state can only be accessed once the lock is held.\n        // Our non-atomic increment is safe because we're the only thread\n        // which can access the shared state when the lock is held.\n        //\n        // We unwrap() the return value to assert that we are not expecting\n        // threads to ever fail while holding the lock.\n        </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = data.lock().unwrap();\n        <span class=\"kw-2\">*</span>data += <span class=\"number\">1</span>;\n        <span class=\"kw\">if </span><span class=\"kw-2\">*</span>data == N {\n            tx.send(()).unwrap();\n        }\n        <span class=\"comment\">// the lock is unlocked here when `data` goes out of scope.\n    </span>});\n}\n\nrx.recv().unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++use+std::sync::mpsc::channel;%0A++++%0A++++const+N:+usize+=+10;%0A++++%0A++++//+Spawn+a+few+threads+to+increment+a+shared+variable+(non-atomically),+and%0A++++//+let+the+main+thread+know+once+all+increments+are+done.%0A++++//%0A++++//+Here+we're+using+an+Arc+to+share+memory+among+threads,+and+the+data+inside%0A++++//+the+Arc+is+protected+with+a+mutex.%0A++++let+data+=+Arc::new(Mutex::new(0));%0A++++%0A++++let+(tx,+rx)+=+channel();%0A++++for+_+in+0..N+%7B%0A++++++++let+(data,+tx)+=+(Arc::clone(%26data),+tx.clone());%0A++++++++thread::spawn(move+%7C%7C+%7B%0A++++++++++++//+The+shared+state+can+only+be+accessed+once+the+lock+is+held.%0A++++++++++++//+Our+non-atomic+increment+is+safe+because+we're+the+only+thread%0A++++++++++++//+which+can+access+the+shared+state+when+the+lock+is+held.%0A++++++++++++//%0A++++++++++++//+We+unwrap()+the+return+value+to+assert+that+we+are+not+expecting%0A++++++++++++//+threads+to+ever+fail+while+holding+the+lock.%0A++++++++++++let+mut+data+=+data.lock().unwrap();%0A++++++++++++*data+%2B=+1;%0A++++++++++++if+*data+==+N+%7B%0A++++++++++++++++tx.send(()).unwrap();%0A++++++++++++%7D%0A++++++++++++//+the+lock+is+unlocked+here+when+%60data%60+goes+out+of+scope.%0A++++++++%7D);%0A++++%7D%0A++++%0A++++rx.recv().unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>To recover from a poisoned mutex:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>lock = Arc::new(Mutex::new(<span class=\"number\">0_u32</span>));\n<span class=\"kw\">let </span>lock2 = Arc::clone(<span class=\"kw-2\">&amp;</span>lock);\n\n<span class=\"kw\">let _ </span>= thread::spawn(<span class=\"kw\">move </span>|| -&gt; () {\n    <span class=\"comment\">// This thread will acquire the mutex first, unwrapping the result of\n    // `lock` because the lock has not been poisoned.\n    </span><span class=\"kw\">let </span>_guard = lock2.lock().unwrap();\n\n    <span class=\"comment\">// This panic while holding the lock (`_guard` is in scope) will poison\n    // the mutex.\n    </span><span class=\"macro\">panic!</span>();\n}).join();\n\n<span class=\"comment\">// The lock is poisoned by this point, but the returned result can be\n// pattern matched on to return the underlying guard on both branches.\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>guard = <span class=\"kw\">match </span>lock.lock() {\n    <span class=\"prelude-val\">Ok</span>(guard) =&gt; guard,\n    <span class=\"prelude-val\">Err</span>(poisoned) =&gt; poisoned.into_inner(),\n};\n\n<span class=\"kw-2\">*</span>guard += <span class=\"number\">1</span>;</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+lock+=+Arc::new(Mutex::new(0_u32));%0A++++let+lock2+=+Arc::clone(%26lock);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+-%3E+()+%7B%0A++++++++//+This+thread+will+acquire+the+mutex+first,+unwrapping+the+result+of%0A++++++++//+%60lock%60+because+the+lock+has+not+been+poisoned.%0A++++++++let+_guard+=+lock2.lock().unwrap();%0A++++%0A++++++++//+This+panic+while+holding+the+lock+(%60_guard%60+is+in+scope)+will+poison%0A++++++++//+the+mutex.%0A++++++++panic!();%0A++++%7D).join();%0A++++%0A++++//+The+lock+is+poisoned+by+this+point,+but+the+returned+result+can+be%0A++++//+pattern+matched+on+to+return+the+underlying+guard+on+both+branches.%0A++++let+mut+guard+=+match+lock.lock()+%7B%0A++++++++Ok(guard)+=%3E+guard,%0A++++++++Err(poisoned)+=%3E+poisoned.into_inner(),%0A++++%7D;%0A++++%0A++++*guard+%2B=+1;%0A%7D&amp;edition=2021\">Run</a></div>\n<p>To unlock a mutex guard sooner than the end of the enclosing scope,\neither create an inner scope or drop the guard manually.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">const </span>N: usize = <span class=\"number\">3</span>;\n\n<span class=\"kw\">let </span>data_mutex = Arc::new(Mutex::new(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]));\n<span class=\"kw\">let </span>res_mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>threads = Vec::with_capacity(N);\n(<span class=\"number\">0</span>..N).for_each(|<span class=\"kw\">_</span>| {\n    <span class=\"kw\">let </span>data_mutex_clone = Arc::clone(<span class=\"kw-2\">&amp;</span>data_mutex);\n    <span class=\"kw\">let </span>res_mutex_clone = Arc::clone(<span class=\"kw-2\">&amp;</span>res_mutex);\n\n    threads.push(thread::spawn(<span class=\"kw\">move </span>|| {\n        <span class=\"comment\">// Here we use a block to limit the lifetime of the lock guard.\n        </span><span class=\"kw\">let </span>result = {\n            <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = data_mutex_clone.lock().unwrap();\n            <span class=\"comment\">// This is the result of some important and long-ish work.\n            </span><span class=\"kw\">let </span>result = data.iter().fold(<span class=\"number\">0</span>, |acc, x| acc + x * <span class=\"number\">2</span>);\n            data.push(result);\n            result\n            <span class=\"comment\">// The mutex guard gets dropped here, together with any other values\n            // created in the critical section.\n        </span>};\n        <span class=\"comment\">// The guard created here is a temporary dropped at the end of the statement, i.e.\n        // the lock would not remain being held even if the thread did some additional work.\n        </span><span class=\"kw-2\">*</span>res_mutex_clone.lock().unwrap() += result;\n    }));\n});\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = data_mutex.lock().unwrap();\n<span class=\"comment\">// This is the result of some important and long-ish work.\n</span><span class=\"kw\">let </span>result = data.iter().fold(<span class=\"number\">0</span>, |acc, x| acc + x * <span class=\"number\">2</span>);\ndata.push(result);\n<span class=\"comment\">// We drop the `data` explicitly because it's not necessary anymore and the\n// thread still has work to do. This allows other threads to start working on\n// the data immediately, without waiting for the rest of the unrelated work\n// to be done here.\n//\n// It's even more important here than in the threads because we `.join` the\n// threads after that. If we had not dropped the mutex guard, a thread could\n// be waiting forever for it, causing a deadlock.\n// As in the threads, a block could have been used instead of calling the\n// `drop` function.\n</span>drop(data);\n<span class=\"comment\">// Here the mutex guard is not assigned to a variable and so, even if the\n// scope does not end after this line, the mutex is still released: there is\n// no deadlock.\n</span><span class=\"kw-2\">*</span>res_mutex.lock().unwrap() += result;\n\nthreads.into_iter().for_each(|thread| {\n    thread\n        .join()\n        .expect(<span class=\"string\">\"The thread creating or execution failed !\"</span>)\n});\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>res_mutex.lock().unwrap(), <span class=\"number\">800</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++const+N:+usize+=+3;%0A++++%0A++++let+data_mutex+=+Arc::new(Mutex::new(vec!%5B1,+2,+3,+4%5D));%0A++++let+res_mutex+=+Arc::new(Mutex::new(0));%0A++++%0A++++let+mut+threads+=+Vec::with_capacity(N);%0A++++(0..N).for_each(%7C_%7C+%7B%0A++++++++let+data_mutex_clone+=+Arc::clone(%26data_mutex);%0A++++++++let+res_mutex_clone+=+Arc::clone(%26res_mutex);%0A++++%0A++++++++threads.push(thread::spawn(move+%7C%7C+%7B%0A++++++++++++//+Here+we+use+a+block+to+limit+the+lifetime+of+the+lock+guard.%0A++++++++++++let+result+=+%7B%0A++++++++++++++++let+mut+data+=+data_mutex_clone.lock().unwrap();%0A++++++++++++++++//+This+is+the+result+of+some+important+and+long-ish+work.%0A++++++++++++++++let+result+=+data.iter().fold(0,+%7Cacc,+x%7C+acc+%2B+x+*+2);%0A++++++++++++++++data.push(result);%0A++++++++++++++++result%0A++++++++++++++++//+The+mutex+guard+gets+dropped+here,+together+with+any+other+values%0A++++++++++++++++//+created+in+the+critical+section.%0A++++++++++++%7D;%0A++++++++++++//+The+guard+created+here+is+a+temporary+dropped+at+the+end+of+the+statement,+i.e.%0A++++++++++++//+the+lock+would+not+remain+being+held+even+if+the+thread+did+some+additional+work.%0A++++++++++++*res_mutex_clone.lock().unwrap()+%2B=+result;%0A++++++++%7D));%0A++++%7D);%0A++++%0A++++let+mut+data+=+data_mutex.lock().unwrap();%0A++++//+This+is+the+result+of+some+important+and+long-ish+work.%0A++++let+result+=+data.iter().fold(0,+%7Cacc,+x%7C+acc+%2B+x+*+2);%0A++++data.push(result);%0A++++//+We+drop+the+%60data%60+explicitly+because+it's+not+necessary+anymore+and+the%0A++++//+thread+still+has+work+to+do.+This+allows+other+threads+to+start+working+on%0A++++//+the+data+immediately,+without+waiting+for+the+rest+of+the+unrelated+work%0A++++//+to+be+done+here.%0A++++//%0A++++//+It's+even+more+important+here+than+in+the+threads+because+we+%60.join%60+the%0A++++//+threads+after+that.+If+we+had+not+dropped+the+mutex+guard,+a+thread+could%0A++++//+be+waiting+forever+for+it,+causing+a+deadlock.%0A++++//+As+in+the+threads,+a+block+could+have+been+used+instead+of+calling+the%0A++++//+%60drop%60+function.%0A++++drop(data);%0A++++//+Here+the+mutex+guard+is+not+assigned+to+a+variable+and+so,+even+if+the%0A++++//+scope+does+not+end+after+this+line,+the+mutex+is+still+released:+there+is%0A++++//+no+deadlock.%0A++++*res_mutex.lock().unwrap()+%2B=+result;%0A++++%0A++++threads.into_iter().for_each(%7Cthread%7C+%7B%0A++++++++thread%0A++++++++++++.join()%0A++++++++++++.expect(%22The+thread+creating+or+execution+failed+!%22)%0A++++%7D);%0A++++%0A++++assert_eq!(*res_mutex.lock().unwrap(),+800);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Mutex%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/sync/mutex.rs.html#260-276\">source</a><a href=\"#impl-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.63.0\">1.0.0 (const: 1.63.0)</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#273-275\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.new\" class=\"fn\">new</a>(t: T) -&gt; <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new mutex in an unlocked state ready for use.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span>mutex = Mutex::new(<span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Mutex;%0A++++%0A++++let+mutex+=+Mutex::new(0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Mutex%3CT%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"../../src/std/sync/mutex.rs.html#278-484\">source</a><a href=\"#impl-Mutex%3CT%3E-1\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lock\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#315-320\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.lock\" class=\"fn\">lock</a>(&amp;self) -&gt; <a class=\"type\" href=\"type.LockResult.html\" title=\"type std::sync::LockResult\">LockResult</a>&lt;<a class=\"struct\" href=\"struct.MutexGuard.html\" title=\"struct std::sync::MutexGuard\">MutexGuard</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Acquires a mutex, blocking the current thread until it is able to do so.</p>\n<p>This function will block the local thread until it is available to acquire\nthe mutex. Upon returning, the thread is the only thread with the lock\nheld. An RAII guard is returned to allow scoped unlock of the lock. When\nthe guard goes out of scope, the mutex will be unlocked.</p>\n<p>The exact behavior on locking a mutex in the thread which already holds\nthe lock is left unspecified. However, this function will not return on\nthe second call (it might panic or deadlock, for example).</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error once the mutex is acquired.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function might panic when called if the lock is already held by\nthe current thread.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\nthread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw-2\">*</span>c_mutex.lock().unwrap() = <span class=\"number\">10</span>;\n}).join().expect(<span class=\"string\">\"thread::spawn failed\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>mutex.lock().unwrap(), <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++thread::spawn(move+%7C%7C+%7B%0A++++++++*c_mutex.lock().unwrap()+=+10;%0A++++%7D).join().expect(%22thread::spawn+failed%22);%0A++++assert_eq!(*mutex.lock().unwrap(),+10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_lock\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#362-370\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_lock\" class=\"fn\">try_lock</a>(&amp;self) -&gt; <a class=\"type\" href=\"type.TryLockResult.html\" title=\"type std::sync::TryLockResult\">TryLockResult</a>&lt;<a class=\"struct\" href=\"struct.MutexGuard.html\" title=\"struct std::sync::MutexGuard\">MutexGuard</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to acquire this lock.</p>\n<p>If the lock could not be acquired at this time, then <a href=\"../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned.\nOtherwise, an RAII guard is returned. The lock will be unlocked when the\nguard is dropped.</p>\n<p>This function does not block.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return the <a href=\"enum.TryLockError.html#variant.Poisoned\" title=\"variant std::sync::TryLockError::Poisoned\"><code>Poisoned</code></a> error if the mutex would\notherwise be acquired.</p>\n<p>If the mutex could not be acquired because it is already locked, then\nthis call will return the <a href=\"enum.TryLockError.html#variant.WouldBlock\" title=\"variant std::sync::TryLockError::WouldBlock\"><code>WouldBlock</code></a> error.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\nthread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>lock = c_mutex.try_lock();\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>(<span class=\"kw-2\">ref mut </span>mutex) = lock {\n        <span class=\"kw-2\">**</span>mutex = <span class=\"number\">10</span>;\n    } <span class=\"kw\">else </span>{\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"try_lock failed\"</span>);\n    }\n}).join().expect(<span class=\"string\">\"thread::spawn failed\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>mutex.lock().unwrap(), <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++thread::spawn(move+%7C%7C+%7B%0A++++++++let+mut+lock+=+c_mutex.try_lock();%0A++++++++if+let+Ok(ref+mut+mutex)+=+lock+%7B%0A++++++++++++**mutex+=+10;%0A++++++++%7D+else+%7B%0A++++++++++++println!(%22try_lock+failed%22);%0A++++++++%7D%0A++++%7D).join().expect(%22thread::spawn+failed%22);%0A++++assert_eq!(*mutex.lock().unwrap(),+10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_poisoned\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#395-397\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_poisoned\" class=\"fn\">is_poisoned</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Determines whether the mutex is poisoned.</p>\n<p>If another thread is active, the mutex can still become poisoned at any\ntime. You should not trust a <code>false</code> value for program correctness\nwithout additional synchronization.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\n<span class=\"kw\">let _ </span>= thread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span>_lock = c_mutex.lock().unwrap();\n    <span class=\"macro\">panic!</span>(); <span class=\"comment\">// the mutex gets poisoned\n</span>}).join();\n<span class=\"macro\">assert_eq!</span>(mutex.is_poisoned(), <span class=\"bool-val\">true</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+_lock+=+c_mutex.lock().unwrap();%0A++++++++panic!();+//+the+mutex+gets+poisoned%0A++++%7D).join();%0A++++assert_eq!(mutex.is_poisoned(),+true);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clear_poison\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#432-434\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.clear_poison\" class=\"fn\">clear_poison</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Clear the poisoned state from a mutex.</p>\n<p>If the mutex is poisoned, it will remain poisoned until this function is called. This\nallows recovering from a poisoned state and marking that it has recovered. For example, if\nthe value is overwritten by a known-good value, then the mutex can be marked as\nun-poisoned. Or possibly, the value could be inspected to determine if it is in a\nconsistent state, and if so the poison is removed.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\n<span class=\"kw\">let _ </span>= thread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span>_lock = c_mutex.lock().unwrap();\n    <span class=\"macro\">panic!</span>(); <span class=\"comment\">// the mutex gets poisoned\n</span>}).join();\n\n<span class=\"macro\">assert_eq!</span>(mutex.is_poisoned(), <span class=\"bool-val\">true</span>);\n<span class=\"kw\">let </span>x = mutex.lock().unwrap_or_else(|<span class=\"kw-2\">mut </span>e| {\n    <span class=\"kw-2\">**</span>e.get_mut() = <span class=\"number\">1</span>;\n    mutex.clear_poison();\n    e.into_inner()\n});\n<span class=\"macro\">assert_eq!</span>(mutex.is_poisoned(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">1</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+Mutex%7D;%0A++++use+std::thread;%0A++++%0A++++let+mutex+=+Arc::new(Mutex::new(0));%0A++++let+c_mutex+=+Arc::clone(%26mutex);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+_lock+=+c_mutex.lock().unwrap();%0A++++++++panic!();+//+the+mutex+gets+poisoned%0A++++%7D).join();%0A++++%0A++++assert_eq!(mutex.is_poisoned(),+true);%0A++++let+x+=+mutex.lock().unwrap_or_else(%7Cmut+e%7C+%7B%0A++++++++**e.get_mut()+=+1;%0A++++++++mutex.clear_poison();%0A++++++++e.into_inner()%0A++++%7D);%0A++++assert_eq!(mutex.is_poisoned(),+false);%0A++++assert_eq!(*x,+1);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_inner\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#452-458\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_inner\" class=\"fn\">into_inner</a>(self) -&gt; <a class=\"type\" href=\"type.LockResult.html\" title=\"type std::sync::LockResult\">LockResult</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Consumes this mutex, returning the underlying data.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error instead.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span>mutex = Mutex::new(<span class=\"number\">0</span>);\n<span class=\"macro\">assert_eq!</span>(mutex.into_inner().unwrap(), <span class=\"number\">0</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Mutex;%0A++++%0A++++let+mutex+=+Mutex::new(0);%0A++++assert_eq!(mutex.into_inner().unwrap(),+0);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#480-483\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get_mut\" class=\"fn\">get_mut</a>(&amp;mut self) -&gt; <a class=\"type\" href=\"type.LockResult.html\" title=\"type std::sync::LockResult\">LockResult</a>&lt;<a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the underlying data.</p>\n<p>Since this call borrows the <code>Mutex</code> mutably, no actual locking needs to\ntake place – the mutable borrow statically guarantees no locks exist.</p>\n<h5 id=\"errors-3\"><a class=\"doc-anchor\" href=\"#errors-3\">§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error instead.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>mutex = Mutex::new(<span class=\"number\">0</span>);\n<span class=\"kw-2\">*</span>mutex.get_mut().unwrap() = <span class=\"number\">10</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>mutex.lock().unwrap(), <span class=\"number\">10</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Mutex;%0A++++%0A++++let+mut+mutex+=+Mutex::new(0);%0A++++*mutex.get_mut().unwrap()+=+10;%0A++++assert_eq!(*mutex.lock().unwrap(),+10);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#504-521\">source</a></span><a href=\"#impl-Debug-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a>&gt; <a class=\"trait\" href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/sync/mutex.rs.html#505-520\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"../fmt/type.Result.html\" title=\"type std::fmt::Result\">Result</a></h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#496-501\">source</a></span><a href=\"#impl-Default-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a>&gt; <a class=\"trait\" href=\"../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/sync/mutex.rs.html#498-500\">source</a><a href=\"#method.default\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a <code>Mutex&lt;T&gt;</code>, with the <code>Default</code> value for T.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CT%3E-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#487-493\">source</a></span><a href=\"#impl-From%3CT%3E-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../src/std/sync/mutex.rs.html#490-492\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; Self</h4></section></summary><div class=\"docblock\"><p>Creates a new mutex in an unlocked state ready for use.\nThis is equivalent to <a href=\"struct.Mutex.html#method.new\" title=\"associated function std::sync::Mutex::new\"><code>Mutex::new</code></a>.</p>\n</div></details></div></details><section id=\"impl-RefUnwindSafe-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> · <a class=\"src\" href=\"../../src/std/panic.rs.html#74\">source</a></span><a href=\"#impl-RefUnwindSafe-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"trait\" href=\"../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section><section id=\"impl-Send-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#187\">source</a></span><a href=\"#impl-Send-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>&gt; <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section><section id=\"impl-Sync-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/sync/mutex.rs.html#189\">source</a></span><a href=\"#impl-Sync-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>&gt; <a class=\"trait\" href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section><section id=\"impl-UnwindSafe-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> · <a class=\"src\" href=\"../../src/std/panic.rs.html#67\">source</a></span><a href=\"#impl-UnwindSafe-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>&gt; <a class=\"trait\" href=\"../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-Mutex%3CT%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; !<a class=\"trait\" href=\"../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;</h3></section><section id=\"impl-Unpin-for-Mutex%3CT%3E\" class=\"impl\"><a href=\"#impl-Unpin-for-Mutex%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.Mutex.html\" title=\"struct std::sync::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3C!%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#782\">source</a><a href=\"#impl-From%3C!%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"primitive\" href=\"../primitive.never.html\">!</a>&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#783\">source</a><a href=\"#method.from-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: <a class=\"primitive\" href=\"../primitive.never.html\">!</a>) -&gt; T</h4></section></summary><div class=\"docblock\">Converts to this type from the input type.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:14:47.837Z"
}