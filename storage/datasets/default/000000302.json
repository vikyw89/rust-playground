{
	"title": "std::result - Rust",
	"url": "https://doc.rust-lang.org/stable/std/result/index.html",
	"markdown": "# std::result - Rust\n\n## Module [std](../index.html)::[result](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#406) ·\n\nExpand description\n\nError handling with the `Result` type.\n\n[`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating errors. It is an enum with the variants, [`Ok(T)`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"), representing success and containing a value, and [`Err(E)`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\"), representing error and containing an error value.\n\n```\nenum Result<T, E> {\n   Ok(T),\n   Err(E),\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Ballow(dead_code)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok(T),%0A+++++++Err(E),%0A++++%7D%0A%7D&edition=2021)\n\nFunctions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and recoverable. In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used for [I/O](../../std/io/index.html).\n\nA simple function returning [`Result`](enum.Result.html \"enum std::result::Result\") might be defined and used like so:\n\n```\n#[derive(Debug)]\nenum Version { Version1, Version2 }\n\nfn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n    match header.get(0) {\n        None => Err(\"invalid header length\"),\n        Some(&1) => Ok(Version::Version1),\n        Some(&2) => Ok(Version::Version2),\n        Some(_) => Err(\"invalid version\"),\n    }\n}\n\nlet version = parse_version(&[1, 2, 3, 4]);\nmatch version {\n    Ok(v) => println!(\"working with version: {v:?}\"),\n    Err(e) => println!(\"error parsing header: {e:?}\"),\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bderive(Debug)%5D%0A++++enum+Version+%7B+Version1,+Version2+%7D%0A++++%0A++++fn+parse_version(header:+%26%5Bu8%5D)+-%3E+Result%3CVersion,+%26%27static+str%3E+%7B%0A++++++++match+header.get(0)+%7B%0A++++++++++++None+=%3E+Err(%22invalid+header+length%22),%0A++++++++++++Some(%261)+=%3E+Ok(Version::Version1),%0A++++++++++++Some(%262)+=%3E+Ok(Version::Version2),%0A++++++++++++Some(_)+=%3E+Err(%22invalid+version%22),%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+version+=+parse_version(%26%5B1,+2,+3,+4%5D);%0A++++match+version+%7B%0A++++++++Ok(v)+=%3E+println!(%22working+with+version:+%7Bv:?%7D%22),%0A++++++++Err(e)+=%3E+println!(%22error+parsing+header:+%7Be:?%7D%22),%0A++++%7D%0A%7D&edition=2021)\n\nPattern matching on [`Result`](enum.Result.html \"enum std::result::Result\")s is clear and straightforward for simple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods that make working with it more succinct.\n\n```\n// The `is_ok` and `is_err` methods do what they say.\nlet good_result: Result<i32, i32> = Ok(10);\nlet bad_result: Result<i32, i32> = Err(10);\nassert!(good_result.is_ok() && !good_result.is_err());\nassert!(bad_result.is_err() && !bad_result.is_ok());\n\n// `map` and `map_err` consume the `Result` and produce another.\nlet good_result: Result<i32, i32> = good_result.map(|i| i + 1);\nlet bad_result: Result<i32, i32> = bad_result.map_err(|i| i - 1);\nassert_eq!(good_result, Ok(11));\nassert_eq!(bad_result, Err(9));\n\n// Use `and_then` to continue the computation.\nlet good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\nassert_eq!(good_result, Ok(true));\n\n// Use `or_else` to handle the error.\nlet bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(i + 20));\nassert_eq!(bad_result, Ok(29));\n\n// Consume the result and return the contents with `unwrap`.\nlet final_awesome_result = good_result.unwrap();\nassert!(final_awesome_result)\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+The+%60is_ok%60+and+%60is_err%60+methods+do+what+they+say.%0Afn+main()+%7B%0A++++let+good_result:+Result%3Ci32,+i32%3E+=+Ok(10);%0A++++let+bad_result:+Result%3Ci32,+i32%3E+=+Err(10);%0A++++assert!(good_result.is_ok()+%26%26+!good_result.is_err());%0A++++assert!(bad_result.is_err()+%26%26+!bad_result.is_ok());%0A++++%0A++++//+%60map%60+and+%60map_err%60+consume+the+%60Result%60+and+produce+another.%0A++++let+good_result:+Result%3Ci32,+i32%3E+=+good_result.map(%7Ci%7C+i+%2B+1);%0A++++let+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.map_err(%7Ci%7C+i+-+1);%0A++++assert_eq!(good_result,+Ok(11));%0A++++assert_eq!(bad_result,+Err(9));%0A++++%0A++++//+Use+%60and_then%60+to+continue+the+computation.%0A++++let+good_result:+Result%3Cbool,+i32%3E+=+good_result.and_then(%7Ci%7C+Ok(i+==+11));%0A++++assert_eq!(good_result,+Ok(true));%0A++++%0A++++//+Use+%60or_else%60+to+handle+the+error.%0A++++let+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.or_else(%7Ci%7C+Ok(i+%2B+20));%0A++++assert_eq!(bad_result,+Ok(29));%0A++++%0A++++//+Consume+the+result+and+return+the+contents+with+%60unwrap%60.%0A++++let+final_awesome_result+=+good_result.unwrap();%0A++++assert!(final_awesome_result)%0A%7D&edition=2021)\n\n## [§](#results-must-be-used)Results must be used\n\nA common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. [`Result`](enum.Result.html \"enum std::result::Result\") is annotated with the `#[must_use]` attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes [`Result`](enum.Result.html \"enum std::result::Result\") especially useful with functions that may encounter errors but don’t otherwise return a useful value.\n\nConsider the [`write_all`](about:blank/std/io/trait.Write.html#method.write_all \"io::Write::write_all\") method defined for I/O types by the [`Write`](../../std/io/trait.Write.html \"io::Write\") trait:\n\n```\nuse std::io;\n\ntrait Write {\n    fn write_all(&mut self, bytes: &[u8]) -> Result<(), io::Error>;\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::io;%0A++++%0A++++trait+Write+%7B%0A++++++++fn+write_all(%26mut+self,+bytes:+%26%5Bu8%5D)+-%3E+Result%3C(),+io::Error%3E;%0A++++%7D%0A%7D&edition=2021)\n\n_Note: The actual definition of [`Write`](../../std/io/trait.Write.html \"io::Write\") uses [`io::Result`](../../std/io/type.Result.html \"io::Result\"), which is just a synonym for `[Result](enum.Result.html \"enum std::result::Result\")<T, [io::Error](../../std/io/struct.Error.html \"io::Error\")>`._\n\nThis method doesn’t produce a value, but the write may fail. It’s crucial to handle the error case, and _not_ write something like this:\n\n```\nuse std::fs::File;\nuse std::io::prelude::*;\n\nlet mut file = File::create(\"valuable_data.txt\").unwrap();\n// If `write_all` errors, then we'll never know, because the return\n// value is ignored.\nfile.write_all(b\"important message\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D+//+%5Co/%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A++++//+If+%60write_all%60+errors,+then+we%27ll+never+know,+because+the+return%0A++++//+value+is+ignored.%0A++++file.write_all(b%22important+message%22);%0A%7D&edition=2021)\n\nIf you _do_ write that in Rust, the compiler will give you a warning (by default, controlled by the `unused_must_use` lint).\n\nYou might instead, if you don’t want to handle the error, simply assert success with [`expect`](about:blank/enum.Result.html#method.expect \"method std::result::Result::expect\"). This will panic if the write fails, providing a marginally useful message indicating why:\n\n```\nuse std::fs::File;\nuse std::io::prelude::*;\n\nlet mut file = File::create(\"valuable_data.txt\").unwrap();\nfile.write_all(b\"important message\").expect(\"failed to write message\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A++++file.write_all(b%22important+message%22).expect(%22failed+to+write+message%22);%0A%7D&edition=2021)\n\nYou might also simply assert success:\n\n```\nassert!(file.write_all(b\"important message\").is_ok());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A++++assert!(file.write_all(b%22important+message%22).is_ok());%0A%7D&edition=2021)\n\nOr propagate the error up the call stack with [`?`](../ops/trait.Try.html \"trait std::ops::Try\"):\n\n```\nfn write_message() -> io::Result<()> {\n    let mut file = File::create(\"valuable_data.txt\")?;\n    file.write_all(b\"important message\")?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow(dead_code)%5D%0A++++fn+write_message()+-%3E+io::Result%3C()%3E+%7B%0A++++++++let+mut+file+=+File::create(%22valuable_data.txt%22)?;%0A++++++++file.write_all(b%22important+message%22)?;%0A++++++++Ok(())%0A++++%7D%0A%7D&edition=2021)\n\n## [§](#the-question-mark-operator-)The question mark operator, `?`\n\nWhen writing code that calls many functions that return the [`Result`](enum.Result.html \"enum std::result::Result\") type, the error handling can be tedious. The question mark operator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\"), hides some of the boilerplate of propagating errors up the call stack.\n\nIt replaces this:\n\n```\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: &Info) -> io::Result<()> {\n    // Early return on error\n    let mut file = match File::create(\"my_best_friends.txt\") {\n           Err(e) => return Err(e),\n           Ok(f) => f,\n    };\n    if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n        return Err(e)\n    }\n    if let Err(e) = file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()) {\n        return Err(e)\n    }\n    if let Err(e) = file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()) {\n        return Err(e)\n    }\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%0A++++struct+Info+%7B%0A++++++++name:+String,%0A++++++++age:+i32,%0A++++++++rating:+i32,%0A++++%7D%0A++++%0A++++fn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++++++//+Early+return+on+error%0A++++++++let+mut+file+=+match+File::create(%22my_best_friends.txt%22)+%7B%0A+++++++++++++++Err(e)+=%3E+return+Err(e),%0A+++++++++++++++Ok(f)+=%3E+f,%0A++++++++%7D;%0A++++++++if+let+Err(e)+=+file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())+%7B%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++++++if+let+Err(e)+=+file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())+%7B%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++++++if+let+Err(e)+=+file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())+%7B%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++++++Ok(())%0A++++%7D%0A%7D&edition=2021)\n\nWith this:\n\n```\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: &Info) -> io::Result<()> {\n    let mut file = File::create(\"my_best_friends.txt\")?;\n    // Early return on error\n    file.write_all(format!(\"name: {}\\n\", info.name).as_bytes())?;\n    file.write_all(format!(\"age: {}\\n\", info.age).as_bytes())?;\n    file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes())?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%0A++++struct+Info+%7B%0A++++++++name:+String,%0A++++++++age:+i32,%0A++++++++rating:+i32,%0A++++%7D%0A++++%0A++++fn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++++++let+mut+file+=+File::create(%22my_best_friends.txt%22)?;%0A++++++++//+Early+return+on+error%0A++++++++file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())?;%0A++++++++file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())?;%0A++++++++file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())?;%0A++++++++Ok(())%0A++++%7D%0A%7D&edition=2021)\n\n_It’s much nicer!_\n\nEnding the expression with [`?`](../ops/trait.Try.html \"trait std::ops::Try\") will result in the [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\")’s unwrapped value, unless the result is [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\"), in which case [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned early from the enclosing function.\n\n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the early return of [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") that it provides.\n\n## [§](#representation)Representation\n\nIn some cases, [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will gain the same size, alignment, and ABI guarantees as [`Option<U>`](../option/enum.Option.html \"enum std::option::Option\") has. One of either the `T` or `E` type must be a type that qualifies for the `Option` [representation guarantees](about:blank/option/index.html#representation \"Option Representation\"), and the _other_ type must meet all of the following conditions:\n\n-   Is a zero-sized type with alignment 1 (a “1-ZST”).\n-   Has no fields.\n-   Does not have the `#[non_exhaustive]` attribute.\n\nFor example, `NonZeroI32` qualifies for the `Option` representation guarantees, and `()` is a zero-sized type with alignment 1, no fields, and it isn’t `non_exhaustive`. This means that both `Result<NonZeroI32, ()>` and `Result<(), NonZeroI32>` have the same size, alignment, and ABI guarantees as `Option<NonZeroI32>`. The only difference is the implied semantics:\n\n-   `Option<NonZeroI32>` is “a non-zero i32 might be present”\n-   `Result<NonZeroI32, ()>` is “a non-zero i32 success result, if any”\n-   `Result<(), NonZeroI32>` is “a non-zero i32 error result, if any”\n\n## [§](#method-overview)Method overview\n\nIn addition to working with pattern matching, [`Result`](enum.Result.html \"enum std::result::Result\") provides a wide variety of different methods.\n\n### [§](#querying-the-variant)Querying the variant\n\nThe [`is_ok`](about:blank/enum.Result.html#method.is_ok \"method std::result::Result::is_ok\") and [`is_err`](about:blank/enum.Result.html#method.is_err \"method std::result::Result::is_err\") methods return [`true`](../primitive.bool.html \"primitive bool\") if the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") or [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\"), respectively.\n\n### [§](#adapters-for-working-with-references)Adapters for working with references\n\n-   [`as_ref`](about:blank/enum.Result.html#method.as_ref \"method std::result::Result::as_ref\") converts from `&Result<T, E>` to `Result<&T, &E>`\n-   [`as_mut`](about:blank/enum.Result.html#method.as_mut \"method std::result::Result::as_mut\") converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`\n-   [`as_deref`](about:blank/enum.Result.html#method.as_deref \"method std::result::Result::as_deref\") converts from `&Result<T, E>` to `Result<&T::Target, &E>`\n-   [`as_deref_mut`](about:blank/enum.Result.html#method.as_deref_mut \"method std::result::Result::as_deref_mut\") converts from `&mut Result<T, E>` to `Result<&mut T::Target, &mut E>`\n\nThese methods extract the contained value in a [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") when it is the [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") variant. If the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\"):\n\n-   [`expect`](about:blank/enum.Result.html#method.expect \"method std::result::Result::expect\") panics with a provided custom message\n-   [`unwrap`](about:blank/enum.Result.html#method.unwrap \"method std::result::Result::unwrap\") panics with a generic message\n-   [`unwrap_or`](about:blank/enum.Result.html#method.unwrap_or \"method std::result::Result::unwrap_or\") returns the provided default value\n-   [`unwrap_or_default`](about:blank/enum.Result.html#method.unwrap_or_default \"method std::result::Result::unwrap_or_default\") returns the default value of the type `T` (which must implement the [`Default`](../default/trait.Default.html \"trait std::default::Default\") trait)\n-   [`unwrap_or_else`](about:blank/enum.Result.html#method.unwrap_or_else \"method std::result::Result::unwrap_or_else\") returns the result of evaluating the provided function\n\nThe panicking methods [`expect`](about:blank/enum.Result.html#method.expect \"method std::result::Result::expect\") and [`unwrap`](about:blank/enum.Result.html#method.unwrap \"method std::result::Result::unwrap\") require `E` to implement the [`Debug`](../fmt/trait.Debug.html \"trait std::fmt::Debug\") trait.\n\nThese methods extract the contained value in a [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") when it is the [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") variant. They require `T` to implement the [`Debug`](../fmt/trait.Debug.html \"trait std::fmt::Debug\") trait. If the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"):\n\n-   [`expect_err`](about:blank/enum.Result.html#method.expect_err \"method std::result::Result::expect_err\") panics with a provided custom message\n-   [`unwrap_err`](about:blank/enum.Result.html#method.unwrap_err \"method std::result::Result::unwrap_err\") panics with a generic message\n\n### [§](#transforming-contained-values)Transforming contained values\n\nThese methods transform [`Result`](enum.Result.html \"enum std::result::Result\") to [`Option`](../option/enum.Option.html \"enum std::option::Option\"):\n\n-   [`err`](about:blank/enum.Result.html#method.err \"method std::result::Result::err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<E>`](../option/enum.Option.html \"enum std::option::Option\"), mapping [`Err(e)`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") to [`Some(e)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") and [`Ok(v)`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") to [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`ok`](about:blank/enum.Result.html#method.ok \"method std::result::Result::ok\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<T>`](../option/enum.Option.html \"enum std::option::Option\"), mapping [`Ok(v)`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") to [`Some(v)`](about:blank/option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") and [`Err(e)`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") to [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\")\n-   [`transpose`](about:blank/enum.Result.html#method.transpose \"method std::result::Result::transpose\") transposes a [`Result`](enum.Result.html \"enum std::result::Result\") of an [`Option`](../option/enum.Option.html \"enum std::option::Option\") into an [`Option`](../option/enum.Option.html \"enum std::option::Option\") of a [`Result`](enum.Result.html \"enum std::result::Result\")\n\nThis method transforms the contained value of the [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") variant:\n\n-   [`map`](about:blank/enum.Result.html#method.map \"method std::result::Result::map\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Result<U, E>`](enum.Result.html \"enum std::result::Result\") by applying the provided function to the contained value of [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") and leaving [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") values unchanged\n\nThis method transforms the contained value of the [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") variant:\n\n-   [`map_err`](about:blank/enum.Result.html#method.map_err \"method std::result::Result::map_err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Result<T, F>`](enum.Result.html \"enum std::result::Result\") by applying the provided function to the contained value of [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") and leaving [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") values unchanged\n\nThese methods transform a [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into a value of a possibly different type `U`:\n\n-   [`map_or`](about:blank/enum.Result.html#method.map_or \"method std::result::Result::map_or\") applies the provided function to the contained value of [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"), or returns the provided default value if the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\")\n-   [`map_or_else`](about:blank/enum.Result.html#method.map_or_else \"method std::result::Result::map_or_else\") applies the provided function to the contained value of [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"), or applies the provided default fallback function to the contained value of [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\")\n\n### [§](#boolean-operators)Boolean operators\n\nThese methods treat the [`Result`](enum.Result.html \"enum std::result::Result\") as a boolean value, where [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") acts like [`true`](../primitive.bool.html \"primitive bool\") and [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") acts like [`false`](../primitive.bool.html \"primitive bool\"). There are two categories of these methods: ones that take a [`Result`](enum.Result.html \"enum std::result::Result\") as input, and ones that take a function as input (to be lazily evaluated).\n\nThe [`and`](about:blank/enum.Result.html#method.and \"method std::result::Result::and\") and [`or`](about:blank/enum.Result.html#method.or \"method std::result::Result::or\") methods take another [`Result`](enum.Result.html \"enum std::result::Result\") as input, and produce a [`Result`](enum.Result.html \"enum std::result::Result\") as output. The [`and`](about:blank/enum.Result.html#method.and \"method std::result::Result::and\") method can produce a [`Result<U, E>`](enum.Result.html \"enum std::result::Result\") value having a different inner type `U` than [`Result<T, E>`](enum.Result.html \"enum std::result::Result\"). The [`or`](about:blank/enum.Result.html#method.or \"method std::result::Result::or\") method can produce a [`Result<T, F>`](enum.Result.html \"enum std::result::Result\") value having a different error type `F` than [`Result<T, E>`](enum.Result.html \"enum std::result::Result\").\n\n| method | self | input | output |\n| --- | --- | --- | --- |\n| [`and`](about:blank/enum.Result.html#method.and \"method std::result::Result::and\") | `Err(e)` | (ignored) | `Err(e)` |\n| [`and`](about:blank/enum.Result.html#method.and \"method std::result::Result::and\") | `Ok(x)` | `Err(d)` | `Err(d)` |\n| [`and`](about:blank/enum.Result.html#method.and \"method std::result::Result::and\") | `Ok(x)` | `Ok(y)` | `Ok(y)` |\n| [`or`](about:blank/enum.Result.html#method.or \"method std::result::Result::or\") | `Err(e)` | `Err(d)` | `Err(d)` |\n| [`or`](about:blank/enum.Result.html#method.or \"method std::result::Result::or\") | `Err(e)` | `Ok(y)` | `Ok(y)` |\n| [`or`](about:blank/enum.Result.html#method.or \"method std::result::Result::or\") | `Ok(x)` | (ignored) | `Ok(x)` |\n\nThe [`and_then`](about:blank/enum.Result.html#method.and_then \"method std::result::Result::and_then\") and [`or_else`](about:blank/enum.Result.html#method.or_else \"method std::result::Result::or_else\") methods take a function as input, and only evaluate the function when they need to produce a new value. The [`and_then`](about:blank/enum.Result.html#method.and_then \"method std::result::Result::and_then\") method can produce a [`Result<U, E>`](enum.Result.html \"enum std::result::Result\") value having a different inner type `U` than [`Result<T, E>`](enum.Result.html \"enum std::result::Result\"). The [`or_else`](about:blank/enum.Result.html#method.or_else \"method std::result::Result::or_else\") method can produce a [`Result<T, F>`](enum.Result.html \"enum std::result::Result\") value having a different error type `F` than [`Result<T, E>`](enum.Result.html \"enum std::result::Result\").\n\n| method | self | function input | function result | output |\n| --- | --- | --- | --- | --- |\n| [`and_then`](about:blank/enum.Result.html#method.and_then \"method std::result::Result::and_then\") | `Err(e)` | (not provided) | (not evaluated) | `Err(e)` |\n| [`and_then`](about:blank/enum.Result.html#method.and_then \"method std::result::Result::and_then\") | `Ok(x)` | `x` | `Err(d)` | `Err(d)` |\n| [`and_then`](about:blank/enum.Result.html#method.and_then \"method std::result::Result::and_then\") | `Ok(x)` | `x` | `Ok(y)` | `Ok(y)` |\n| [`or_else`](about:blank/enum.Result.html#method.or_else \"method std::result::Result::or_else\") | `Err(e)` | `e` | `Err(d)` | `Err(d)` |\n| [`or_else`](about:blank/enum.Result.html#method.or_else \"method std::result::Result::or_else\") | `Err(e)` | `e` | `Ok(y)` | `Ok(y)` |\n| [`or_else`](about:blank/enum.Result.html#method.or_else \"method std::result::Result::or_else\") | `Ok(x)` | (not provided) | (not evaluated) | `Ok(x)` |\n\n### [§](#comparison-operators)Comparison operators\n\nIf `T` and `E` both implement [`PartialOrd`](../cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\") then [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will derive its [`PartialOrd`](../cmp/trait.PartialOrd.html \"trait std::cmp::PartialOrd\") implementation. With this order, an [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") compares as less than any [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\"), while two [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") or two [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") compare as their contained values would in `T` or `E` respectively. If `T` and `E` both also implement [`Ord`](../cmp/trait.Ord.html \"trait std::cmp::Ord\"), then so does [`Result<T, E>`](enum.Result.html \"enum std::result::Result\").\n\n```\nassert!(Ok(1) < Err(0));\nlet x: Result<i32, ()> = Ok(0);\nlet y = Ok(1);\nassert!(x < y);\nlet x: Result<(), i32> = Err(0);\nlet y = Err(1);\nassert!(x < y);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(Ok(1)+%3C+Err(0));%0A++++let+x:+Result%3Ci32,+()%3E+=+Ok(0);%0A++++let+y+=+Ok(1);%0A++++assert!(x+%3C+y);%0A++++let+x:+Result%3C(),+i32%3E+=+Err(0);%0A++++let+y+=+Err(1);%0A++++assert!(x+%3C+y);%0A%7D&edition=2021)\n\n### [§](#iterating-over-result)Iterating over `Result`\n\nA [`Result`](enum.Result.html \"enum std::result::Result\") can be iterated over. This can be helpful if you need an iterator that is conditionally empty. The iterator will either produce a single value (when the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\")), or produce no values (when the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\")). For example, [`into_iter`](about:blank/enum.Result.html#method.into_iter \"method std::result::Result::into_iter\") acts like [`once(v)`](../iter/fn.once.html \"fn std::iter::once\") if the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok(v)`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\"), and like [`empty()`](../iter/fn.empty.html \"fn std::iter::empty\") if the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\").\n\nIterators over [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") come in three types:\n\n-   [`into_iter`](about:blank/enum.Result.html#method.into_iter \"method std::result::Result::into_iter\") consumes the [`Result`](enum.Result.html \"enum std::result::Result\") and produces the contained value\n-   [`iter`](about:blank/enum.Result.html#method.iter \"method std::result::Result::iter\") produces an immutable reference of type `&T` to the contained value\n-   [`iter_mut`](about:blank/enum.Result.html#method.iter_mut \"method std::result::Result::iter_mut\") produces a mutable reference of type `&mut T` to the contained value\n\nSee [Iterating over `Option`](about:blank/option/index.html#iterating-over-option \"mod std::option\") for examples of how this can be useful.\n\nYou might want to use an iterator chain to do multiple instances of an operation that can fail, but would like to ignore failures while continuing to process the successful results. In this example, we take advantage of the iterable nature of [`Result`](enum.Result.html \"enum std::result::Result\") to select only the [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") values using [`flatten`](about:blank/iter/trait.Iterator.html#method.flatten \"method std::iter::Iterator::flatten\").\n\n```\nlet mut results = vec![];\nlet mut errs = vec![];\nlet nums: Vec<_> = [\"17\", \"not a number\", \"99\", \"-27\", \"768\"]\n   .into_iter()\n   .map(u8::from_str)\n   // Save clones of the raw `Result` values to inspect\n   .inspect(|x| results.push(x.clone()))\n   // Challenge: explain how this captures only the `Err` values\n   .inspect(|x| errs.extend(x.clone().err()))\n   .flatten()\n   .collect();\nassert_eq!(errs.len(), 3);\nassert_eq!(nums, [17, 99]);\nprintln!(\"results {results:?}\");\nprintln!(\"errs {errs:?}\");\nprintln!(\"nums {nums:?}\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::str::FromStr;%0A++++let+mut+results+=+vec!%5B%5D;%0A++++let+mut+errs+=+vec!%5B%5D;%0A++++let+nums:+Vec%3C_%3E+=+%5B%2217%22,+%22not+a+number%22,+%2299%22,+%22-27%22,+%22768%22%5D%0A+++++++.into_iter()%0A+++++++.map(u8::from_str)%0A+++++++//+Save+clones+of+the+raw+%60Result%60+values+to+inspect%0A+++++++.inspect(%7Cx%7C+results.push(x.clone()))%0A+++++++//+Challenge:+explain+how+this+captures+only+the+%60Err%60+values%0A+++++++.inspect(%7Cx%7C+errs.extend(x.clone().err()))%0A+++++++.flatten()%0A+++++++.collect();%0A++++assert_eq!(errs.len(),+3);%0A++++assert_eq!(nums,+%5B17,+99%5D);%0A++++println!(%22results+%7Bresults:?%7D%22);%0A++++println!(%22errs+%7Berrs:?%7D%22);%0A++++println!(%22nums+%7Bnums:?%7D%22);%0A%7D&edition=2021)\n\n### [§](#collecting-into-result)Collecting into `Result`\n\n[`Result`](enum.Result.html \"enum std::result::Result\") implements the [`FromIterator`](about:blank/enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E \"enum std::result::Result\") trait, which allows an iterator over [`Result`](enum.Result.html \"enum std::result::Result\") values to be collected into a [`Result`](enum.Result.html \"enum std::result::Result\") of a collection of each contained value of the original [`Result`](enum.Result.html \"enum std::result::Result\") values, or [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\") if any of the elements was [`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\").\n\n```\nlet v = [Ok(2), Ok(4), Err(\"err!\"), Ok(8)];\nlet res: Result<Vec<_>, &str> = v.into_iter().collect();\nassert_eq!(res, Err(\"err!\"));\nlet v = [Ok(2), Ok(4), Ok(8)];\nlet res: Result<Vec<_>, &str> = v.into_iter().collect();\nassert_eq!(res, Ok(vec![2, 4, 8]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BOk(2),+Ok(4),+Err(%22err!%22),+Ok(8)%5D;%0A++++let+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+Err(%22err!%22));%0A++++let+v+=+%5BOk(2),+Ok(4),+Ok(8)%5D;%0A++++let+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+Ok(vec!%5B2,+4,+8%5D));%0A%7D&edition=2021)\n\n[`Result`](enum.Result.html \"enum std::result::Result\") also implements the [`Product`](about:blank/enum.Result.html#impl-Product%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E \"enum std::result::Result\") and [`Sum`](about:blank/enum.Result.html#impl-Sum%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E \"enum std::result::Result\") traits, allowing an iterator over [`Result`](enum.Result.html \"enum std::result::Result\") values to provide the [`product`](about:blank/iter/trait.Iterator.html#method.product \"method std::iter::Iterator::product\") and [`sum`](about:blank/iter/trait.Iterator.html#method.sum \"method std::iter::Iterator::sum\") methods.\n\n```\nlet v = [Err(\"error!\"), Ok(1), Ok(2), Ok(3), Err(\"foo\")];\nlet res: Result<i32, &str> = v.into_iter().sum();\nassert_eq!(res, Err(\"error!\"));\nlet v = [Ok(1), Ok(2), Ok(21)];\nlet res: Result<i32, &str> = v.into_iter().product();\nassert_eq!(res, Ok(42));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BErr(%22error!%22),+Ok(1),+Ok(2),+Ok(3),+Err(%22foo%22)%5D;%0A++++let+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().sum();%0A++++assert_eq!(res,+Err(%22error!%22));%0A++++let+v+=+%5BOk(1),+Ok(2),+Ok(21)%5D;%0A++++let+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().product();%0A++++assert_eq!(res,+Ok(42));%0A%7D&edition=2021)\n\n-   An iterator over the value in a [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") variant of a [`Result`](enum.Result.html \"enum std::result::Result\").\n    \n-   An iterator over a reference to the [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") variant of a [`Result`](enum.Result.html \"enum std::result::Result\").\n    \n-   An iterator over a mutable reference to the [`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\") variant of a [`Result`](enum.Result.html \"enum std::result::Result\").\n    \n\n-   `Result` is a type that represents either success ([`Ok`](about:blank/enum.Result.html#variant.Ok \"variant std::result::Result::Ok\")) or failure ([`Err`](about:blank/enum.Result.html#variant.Err \"variant std::result::Result::Err\")).",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Error handling with the `Result` type.\"><title>std::result - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module result</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module result</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">result</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#406\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Error handling with the <code>Result</code> type.</p>\n<p><a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> is the type used for returning and propagating\nerrors. It is an enum with the variants, <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok(T)</code></a>, representing\nsuccess and containing a value, and <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err(E)</code></a>, representing error\nand containing an error value.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">enum </span><span class=\"prelude-ty\">Result</span>&lt;T, E&gt; {\n   <span class=\"prelude-val\">Ok</span>(T),\n   <span class=\"prelude-val\">Err</span>(E),\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Ballow(dead_code)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok(T),%0A+++++++Err(E),%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Functions return <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> whenever errors are expected and\nrecoverable. In the <code>std</code> crate, <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is most prominently used\nfor <a href=\"../../std/io/index.html\">I/O</a>.</p>\n<p>A simple function returning <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> might be\ndefined and used like so:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[derive(Debug)]\n</span><span class=\"kw\">enum </span>Version { Version1, Version2 }\n\n<span class=\"kw\">fn </span>parse_version(header: <span class=\"kw-2\">&amp;</span>[u8]) -&gt; <span class=\"prelude-ty\">Result</span>&lt;Version, <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span>str&gt; {\n    <span class=\"kw\">match </span>header.get(<span class=\"number\">0</span>) {\n        <span class=\"prelude-val\">None </span>=&gt; <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"invalid header length\"</span>),\n        <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>) =&gt; <span class=\"prelude-val\">Ok</span>(Version::Version1),\n        <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>) =&gt; <span class=\"prelude-val\">Ok</span>(Version::Version2),\n        <span class=\"prelude-val\">Some</span>(<span class=\"kw\">_</span>) =&gt; <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"invalid version\"</span>),\n    }\n}\n\n<span class=\"kw\">let </span>version = parse_version(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n<span class=\"kw\">match </span>version {\n    <span class=\"prelude-val\">Ok</span>(v) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"working with version: {v:?}\"</span>),\n    <span class=\"prelude-val\">Err</span>(e) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"error parsing header: {e:?}\"</span>),\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bderive(Debug)%5D%0A++++enum+Version+%7B+Version1,+Version2+%7D%0A++++%0A++++fn+parse_version(header:+%26%5Bu8%5D)+-%3E+Result%3CVersion,+%26'static+str%3E+%7B%0A++++++++match+header.get(0)+%7B%0A++++++++++++None+=%3E+Err(%22invalid+header+length%22),%0A++++++++++++Some(%261)+=%3E+Ok(Version::Version1),%0A++++++++++++Some(%262)+=%3E+Ok(Version::Version2),%0A++++++++++++Some(_)+=%3E+Err(%22invalid+version%22),%0A++++++++%7D%0A++++%7D%0A++++%0A++++let+version+=+parse_version(%26%5B1,+2,+3,+4%5D);%0A++++match+version+%7B%0A++++++++Ok(v)+=%3E+println!(%22working+with+version:+%7Bv:?%7D%22),%0A++++++++Err(e)+=%3E+println!(%22error+parsing+header:+%7Be:?%7D%22),%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Pattern matching on <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>s is clear and straightforward for\nsimple cases, but <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> comes with some convenience methods\nthat make working with it more succinct.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// The `is_ok` and `is_err` methods do what they say.\n</span><span class=\"kw\">let </span>good_result: <span class=\"prelude-ty\">Result</span>&lt;i32, i32&gt; = <span class=\"prelude-val\">Ok</span>(<span class=\"number\">10</span>);\n<span class=\"kw\">let </span>bad_result: <span class=\"prelude-ty\">Result</span>&lt;i32, i32&gt; = <span class=\"prelude-val\">Err</span>(<span class=\"number\">10</span>);\n<span class=\"macro\">assert!</span>(good_result.is_ok() &amp;&amp; !good_result.is_err());\n<span class=\"macro\">assert!</span>(bad_result.is_err() &amp;&amp; !bad_result.is_ok());\n\n<span class=\"comment\">// `map` and `map_err` consume the `Result` and produce another.\n</span><span class=\"kw\">let </span>good_result: <span class=\"prelude-ty\">Result</span>&lt;i32, i32&gt; = good_result.map(|i| i + <span class=\"number\">1</span>);\n<span class=\"kw\">let </span>bad_result: <span class=\"prelude-ty\">Result</span>&lt;i32, i32&gt; = bad_result.map_err(|i| i - <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(good_result, <span class=\"prelude-val\">Ok</span>(<span class=\"number\">11</span>));\n<span class=\"macro\">assert_eq!</span>(bad_result, <span class=\"prelude-val\">Err</span>(<span class=\"number\">9</span>));\n\n<span class=\"comment\">// Use `and_then` to continue the computation.\n</span><span class=\"kw\">let </span>good_result: <span class=\"prelude-ty\">Result</span>&lt;bool, i32&gt; = good_result.and_then(|i| <span class=\"prelude-val\">Ok</span>(i == <span class=\"number\">11</span>));\n<span class=\"macro\">assert_eq!</span>(good_result, <span class=\"prelude-val\">Ok</span>(<span class=\"bool-val\">true</span>));\n\n<span class=\"comment\">// Use `or_else` to handle the error.\n</span><span class=\"kw\">let </span>bad_result: <span class=\"prelude-ty\">Result</span>&lt;i32, i32&gt; = bad_result.or_else(|i| <span class=\"prelude-val\">Ok</span>(i + <span class=\"number\">20</span>));\n<span class=\"macro\">assert_eq!</span>(bad_result, <span class=\"prelude-val\">Ok</span>(<span class=\"number\">29</span>));\n\n<span class=\"comment\">// Consume the result and return the contents with `unwrap`.\n</span><span class=\"kw\">let </span>final_awesome_result = good_result.unwrap();\n<span class=\"macro\">assert!</span>(final_awesome_result)</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+The+%60is_ok%60+and+%60is_err%60+methods+do+what+they+say.%0Afn+main()+%7B%0A++++let+good_result:+Result%3Ci32,+i32%3E+=+Ok(10);%0A++++let+bad_result:+Result%3Ci32,+i32%3E+=+Err(10);%0A++++assert!(good_result.is_ok()+%26%26+!good_result.is_err());%0A++++assert!(bad_result.is_err()+%26%26+!bad_result.is_ok());%0A++++%0A++++//+%60map%60+and+%60map_err%60+consume+the+%60Result%60+and+produce+another.%0A++++let+good_result:+Result%3Ci32,+i32%3E+=+good_result.map(%7Ci%7C+i+%2B+1);%0A++++let+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.map_err(%7Ci%7C+i+-+1);%0A++++assert_eq!(good_result,+Ok(11));%0A++++assert_eq!(bad_result,+Err(9));%0A++++%0A++++//+Use+%60and_then%60+to+continue+the+computation.%0A++++let+good_result:+Result%3Cbool,+i32%3E+=+good_result.and_then(%7Ci%7C+Ok(i+==+11));%0A++++assert_eq!(good_result,+Ok(true));%0A++++%0A++++//+Use+%60or_else%60+to+handle+the+error.%0A++++let+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.or_else(%7Ci%7C+Ok(i+%2B+20));%0A++++assert_eq!(bad_result,+Ok(29));%0A++++%0A++++//+Consume+the+result+and+return+the+contents+with+%60unwrap%60.%0A++++let+final_awesome_result+=+good_result.unwrap();%0A++++assert!(final_awesome_result)%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"results-must-be-used\"><a class=\"doc-anchor\" href=\"#results-must-be-used\">§</a>Results must be used</h2>\n<p>A common problem with using return values to indicate errors is\nthat it is easy to ignore the return value, thus failing to handle\nthe error. <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is annotated with the <code>#[must_use]</code> attribute,\nwhich will cause the compiler to issue a warning when a Result\nvalue is ignored. This makes <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> especially useful with\nfunctions that may encounter errors but don’t otherwise return a\nuseful value.</p>\n<p>Consider the <a href=\"../../std/io/trait.Write.html#method.write_all\" title=\"io::Write::write_all\"><code>write_all</code></a> method defined for I/O types\nby the <a href=\"../../std/io/trait.Write.html\" title=\"io::Write\"><code>Write</code></a> trait:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">trait </span>Write {\n    <span class=\"kw\">fn </span>write_all(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>, bytes: <span class=\"kw-2\">&amp;</span>[u8]) -&gt; <span class=\"prelude-ty\">Result</span>&lt;(), io::Error&gt;;\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::io;%0A++++%0A++++trait+Write+%7B%0A++++++++fn+write_all(%26mut+self,+bytes:+%26%5Bu8%5D)+-%3E+Result%3C(),+io::Error%3E;%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>Note: The actual definition of <a href=\"../../std/io/trait.Write.html\" title=\"io::Write\"><code>Write</code></a> uses <a href=\"../../std/io/type.Result.html\" title=\"io::Result\"><code>io::Result</code></a>, which\nis just a synonym for <code><a href=\"enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, <a href=\"../../std/io/struct.Error.html\" title=\"io::Error\">io::Error</a>&gt;</code>.</em></p>\n<p>This method doesn’t produce a value, but the write may\nfail. It’s crucial to handle the error case, and <em>not</em> write\nsomething like this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>file = File::create(<span class=\"string\">\"valuable_data.txt\"</span>).unwrap();\n<span class=\"comment\">// If `write_all` errors, then we'll never know, because the return\n// value is ignored.\n</span>file.write_all(<span class=\"string\">b\"important message\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D+//+%5Co/%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A++++//+If+%60write_all%60+errors,+then+we'll+never+know,+because+the+return%0A++++//+value+is+ignored.%0A++++file.write_all(b%22important+message%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If you <em>do</em> write that in Rust, the compiler will give you a\nwarning (by default, controlled by the <code>unused_must_use</code> lint).</p>\n<p>You might instead, if you don’t want to handle the error, simply\nassert success with <a href=\"enum.Result.html#method.expect\" title=\"method std::result::Result::expect\"><code>expect</code></a>. This will panic if the\nwrite fails, providing a marginally useful message indicating why:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>file = File::create(<span class=\"string\">\"valuable_data.txt\"</span>).unwrap();\nfile.write_all(<span class=\"string\">b\"important message\"</span>).expect(<span class=\"string\">\"failed to write message\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A++++file.write_all(b%22important+message%22).expect(%22failed+to+write+message%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>You might also simply assert success:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>(file.write_all(<span class=\"string\">b\"important message\"</span>).is_ok());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A++++assert!(file.write_all(b%22important+message%22).is_ok());%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Or propagate the error up the call stack with <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>write_message() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>file = File::create(<span class=\"string\">\"valuable_data.txt\"</span>)<span class=\"question-mark\">?</span>;\n    file.write_all(<span class=\"string\">b\"important message\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow(dead_code)%5D%0A++++fn+write_message()+-%3E+io::Result%3C()%3E+%7B%0A++++++++let+mut+file+=+File::create(%22valuable_data.txt%22)?;%0A++++++++file.write_all(b%22important+message%22)?;%0A++++++++Ok(())%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"the-question-mark-operator-\"><a class=\"doc-anchor\" href=\"#the-question-mark-operator-\">§</a>The question mark operator, <code>?</code></h2>\n<p>When writing code that calls many functions that return the\n<a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> type, the error handling can be tedious. The question mark\noperator, <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a>, hides some of the boilerplate of propagating errors\nup the call stack.</p>\n<p>It replaces this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">struct </span>Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\n<span class=\"kw\">fn </span>write_info(info: <span class=\"kw-2\">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {\n    <span class=\"comment\">// Early return on error\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>file = <span class=\"kw\">match </span>File::create(<span class=\"string\">\"my_best_friends.txt\"</span>) {\n           <span class=\"prelude-val\">Err</span>(e) =&gt; <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(e),\n           <span class=\"prelude-val\">Ok</span>(f) =&gt; f,\n    };\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(e) = file.write_all(<span class=\"macro\">format!</span>(<span class=\"string\">\"name: {}\\n\"</span>, info.name).as_bytes()) {\n        <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(e)\n    }\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(e) = file.write_all(<span class=\"macro\">format!</span>(<span class=\"string\">\"age: {}\\n\"</span>, info.age).as_bytes()) {\n        <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(e)\n    }\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(e) = file.write_all(<span class=\"macro\">format!</span>(<span class=\"string\">\"rating: {}\\n\"</span>, info.rating).as_bytes()) {\n        <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(e)\n    }\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%0A++++struct+Info+%7B%0A++++++++name:+String,%0A++++++++age:+i32,%0A++++++++rating:+i32,%0A++++%7D%0A++++%0A++++fn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++++++//+Early+return+on+error%0A++++++++let+mut+file+=+match+File::create(%22my_best_friends.txt%22)+%7B%0A+++++++++++++++Err(e)+=%3E+return+Err(e),%0A+++++++++++++++Ok(f)+=%3E+f,%0A++++++++%7D;%0A++++++++if+let+Err(e)+=+file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())+%7B%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++++++if+let+Err(e)+=+file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())+%7B%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++++++if+let+Err(e)+=+file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())+%7B%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++++++Ok(())%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>With this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fs::File;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">struct </span>Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\n<span class=\"kw\">fn </span>write_info(info: <span class=\"kw-2\">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>file = File::create(<span class=\"string\">\"my_best_friends.txt\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"comment\">// Early return on error\n    </span>file.write_all(<span class=\"macro\">format!</span>(<span class=\"string\">\"name: {}\\n\"</span>, info.name).as_bytes())<span class=\"question-mark\">?</span>;\n    file.write_all(<span class=\"macro\">format!</span>(<span class=\"string\">\"age: {}\\n\"</span>, info.age).as_bytes())<span class=\"question-mark\">?</span>;\n    file.write_all(<span class=\"macro\">format!</span>(<span class=\"string\">\"rating: {}\\n\"</span>, info.rating).as_bytes())<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%0A++++struct+Info+%7B%0A++++++++name:+String,%0A++++++++age:+i32,%0A++++++++rating:+i32,%0A++++%7D%0A++++%0A++++fn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++++++let+mut+file+=+File::create(%22my_best_friends.txt%22)?;%0A++++++++//+Early+return+on+error%0A++++++++file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())?;%0A++++++++file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())?;%0A++++++++file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())?;%0A++++++++Ok(())%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p><em>It’s much nicer!</em></p>\n<p>Ending the expression with <a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a> will result in the <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>’s unwrapped value, unless the result\nis <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>, in which case <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned early from the enclosing function.</p>\n<p><a href=\"../ops/trait.Try.html\" title=\"trait std::ops::Try\"><code>?</code></a> can be used in functions that return <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> because of the\nearly return of <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> that it provides.</p>\n<h2 id=\"representation\"><a class=\"doc-anchor\" href=\"#representation\">§</a>Representation</h2>\n<p>In some cases, <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> will gain the same size, alignment, and ABI\nguarantees as <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;U&gt;</code></a> has. One of either the <code>T</code> or <code>E</code> type must be a\ntype that qualifies for the <code>Option</code> <a href=\"../option/index.html#representation\" title=\"Option Representation\">representation guarantees</a>,\nand the <em>other</em> type must meet all of the following conditions:</p>\n<ul>\n<li>Is a zero-sized type with alignment 1 (a “1-ZST”).</li>\n<li>Has no fields.</li>\n<li>Does not have the <code>#[non_exhaustive]</code> attribute.</li>\n</ul>\n<p>For example, <code>NonZeroI32</code> qualifies for the <code>Option</code> representation\nguarantees, and <code>()</code> is a zero-sized type with alignment 1, no fields, and\nit isn’t <code>non_exhaustive</code>. This means that both <code>Result&lt;NonZeroI32, ()&gt;</code> and\n<code>Result&lt;(), NonZeroI32&gt;</code> have the same size, alignment, and ABI guarantees\nas <code>Option&lt;NonZeroI32&gt;</code>. The only difference is the implied semantics:</p>\n<ul>\n<li><code>Option&lt;NonZeroI32&gt;</code> is “a non-zero i32 might be present”</li>\n<li><code>Result&lt;NonZeroI32, ()&gt;</code> is “a non-zero i32 success result, if any”</li>\n<li><code>Result&lt;(), NonZeroI32&gt;</code> is “a non-zero i32 error result, if any”</li>\n</ul>\n<h2 id=\"method-overview\"><a class=\"doc-anchor\" href=\"#method-overview\">§</a>Method overview</h2>\n<p>In addition to working with pattern matching, <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> provides a\nwide variety of different methods.</p>\n<h3 id=\"querying-the-variant\"><a class=\"doc-anchor\" href=\"#querying-the-variant\">§</a>Querying the variant</h3>\n<p>The <a href=\"enum.Result.html#method.is_ok\" title=\"method std::result::Result::is_ok\"><code>is_ok</code></a> and <a href=\"enum.Result.html#method.is_err\" title=\"method std::result::Result::is_err\"><code>is_err</code></a> methods return <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> if the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>\nis <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> or <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>, respectively.</p>\n<h3 id=\"adapters-for-working-with-references\"><a class=\"doc-anchor\" href=\"#adapters-for-working-with-references\">§</a>Adapters for working with references</h3>\n<ul>\n<li><a href=\"enum.Result.html#method.as_ref\" title=\"method std::result::Result::as_ref\"><code>as_ref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code></li>\n<li><a href=\"enum.Result.html#method.as_mut\" title=\"method std::result::Result::as_mut\"><code>as_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>\n<li><a href=\"enum.Result.html#method.as_deref\" title=\"method std::result::Result::as_deref\"><code>as_deref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T::Target, &amp;E&gt;</code></li>\n<li><a href=\"enum.Result.html#method.as_deref_mut\" title=\"method std::result::Result::as_deref_mut\"><code>as_deref_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to\n<code>Result&lt;&amp;mut T::Target, &amp;mut E&gt;</code></li>\n</ul>\n<h3 id=\"extracting-contained-values\"><a class=\"doc-anchor\" href=\"#extracting-contained-values\">§</a>Extracting contained values</h3>\n<p>These methods extract the contained value in a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> when it\nis the <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> variant. If the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.expect\" title=\"method std::result::Result::expect\"><code>expect</code></a> panics with a provided custom message</li>\n<li><a href=\"enum.Result.html#method.unwrap\" title=\"method std::result::Result::unwrap\"><code>unwrap</code></a> panics with a generic message</li>\n<li><a href=\"enum.Result.html#method.unwrap_or\" title=\"method std::result::Result::unwrap_or\"><code>unwrap_or</code></a> returns the provided default value</li>\n<li><a href=\"enum.Result.html#method.unwrap_or_default\" title=\"method std::result::Result::unwrap_or_default\"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code>\n(which must implement the <a href=\"../default/trait.Default.html\" title=\"trait std::default::Default\"><code>Default</code></a> trait)</li>\n<li><a href=\"enum.Result.html#method.unwrap_or_else\" title=\"method std::result::Result::unwrap_or_else\"><code>unwrap_or_else</code></a> returns the result of evaluating the provided\nfunction</li>\n</ul>\n<p>The panicking methods <a href=\"enum.Result.html#method.expect\" title=\"method std::result::Result::expect\"><code>expect</code></a> and <a href=\"enum.Result.html#method.unwrap\" title=\"method std::result::Result::unwrap\"><code>unwrap</code></a> require <code>E</code> to\nimplement the <a href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a> trait.</p>\n<p>These methods extract the contained value in a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> when it\nis the <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> variant. They require <code>T</code> to implement the <a href=\"../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a>\ntrait. If the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.expect_err\" title=\"method std::result::Result::expect_err\"><code>expect_err</code></a> panics with a provided custom message</li>\n<li><a href=\"enum.Result.html#method.unwrap_err\" title=\"method std::result::Result::unwrap_err\"><code>unwrap_err</code></a> panics with a generic message</li>\n</ul>\n<h3 id=\"transforming-contained-values\"><a class=\"doc-anchor\" href=\"#transforming-contained-values\">§</a>Transforming contained values</h3>\n<p>These methods transform <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> to <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a>:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.err\" title=\"method std::result::Result::err\"><code>err</code></a> transforms <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> into <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;E&gt;</code></a>,\nmapping <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err(e)</code></a> to <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(e)</code></a> and <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok(v)</code></a> to <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Result.html#method.ok\" title=\"method std::result::Result::ok\"><code>ok</code></a> transforms <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> into <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option&lt;T&gt;</code></a>,\nmapping <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok(v)</code></a> to <a href=\"../option/enum.Option.html#variant.Some\" title=\"variant std::option::Option::Some\"><code>Some(v)</code></a> and <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err(e)</code></a> to <a href=\"../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a></li>\n<li><a href=\"enum.Result.html#method.transpose\" title=\"method std::result::Result::transpose\"><code>transpose</code></a> transposes a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> of an <a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> into an\n<a href=\"../option/enum.Option.html\" title=\"enum std::option::Option\"><code>Option</code></a> of a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a></li>\n</ul>\n<p>This method transforms the contained value of the <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> variant:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.map\" title=\"method std::result::Result::map\"><code>map</code></a> transforms <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> into <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;U, E&gt;</code></a> by applying\nthe provided function to the contained value of <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> and leaving\n<a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> values unchanged</li>\n</ul>\n<p>This method transforms the contained value of the <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> variant:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.map_err\" title=\"method std::result::Result::map_err\"><code>map_err</code></a> transforms <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> into <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, F&gt;</code></a> by\napplying the provided function to the contained value of <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> and\nleaving <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> values unchanged</li>\n</ul>\n<p>These methods transform a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> into a value of a possibly\ndifferent type <code>U</code>:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.map_or\" title=\"method std::result::Result::map_or\"><code>map_or</code></a> applies the provided function to the contained value of\n<a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>, or returns the provided default value if the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is\n<a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a></li>\n<li><a href=\"enum.Result.html#method.map_or_else\" title=\"method std::result::Result::map_or_else\"><code>map_or_else</code></a> applies the provided function to the contained value\nof <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>, or applies the provided default fallback function to the\ncontained value of <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a></li>\n</ul>\n<h3 id=\"boolean-operators\"><a class=\"doc-anchor\" href=\"#boolean-operators\">§</a>Boolean operators</h3>\n<p>These methods treat the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> as a boolean value, where <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>\nacts like <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>true</code></a> and <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> acts like <a href=\"../primitive.bool.html\" title=\"primitive bool\"><code>false</code></a>. There are two\ncategories of these methods: ones that take a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> as input, and\nones that take a function as input (to be lazily evaluated).</p>\n<p>The <a href=\"enum.Result.html#method.and\" title=\"method std::result::Result::and\"><code>and</code></a> and <a href=\"enum.Result.html#method.or\" title=\"method std::result::Result::or\"><code>or</code></a> methods take another <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> as input, and\nproduce a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> as output. The <a href=\"enum.Result.html#method.and\" title=\"method std::result::Result::and\"><code>and</code></a> method can produce a\n<a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;U, E&gt;</code></a> value having a different inner type <code>U</code> than\n<a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>. The <a href=\"enum.Result.html#method.or\" title=\"method std::result::Result::or\"><code>or</code></a> method can produce a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, F&gt;</code></a>\nvalue having a different error type <code>F</code> than <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>.</p>\n<div><table><thead><tr><th>method</th><th>self</th><th>input</th><th>output</th></tr></thead><tbody>\n<tr><td><a href=\"enum.Result.html#method.and\" title=\"method std::result::Result::and\"><code>and</code></a></td><td><code>Err(e)</code></td><td>(ignored)</td><td><code>Err(e)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.and\" title=\"method std::result::Result::and\"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.and\" title=\"method std::result::Result::and\"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.or\" title=\"method std::result::Result::or\"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.or\" title=\"method std::result::Result::or\"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.or\" title=\"method std::result::Result::or\"><code>or</code></a></td><td><code>Ok(x)</code></td><td>(ignored)</td><td><code>Ok(x)</code></td></tr>\n</tbody></table>\n</div>\n<p>The <a href=\"enum.Result.html#method.and_then\" title=\"method std::result::Result::and_then\"><code>and_then</code></a> and <a href=\"enum.Result.html#method.or_else\" title=\"method std::result::Result::or_else\"><code>or_else</code></a> methods take a function as input, and\nonly evaluate the function when they need to produce a new value. The\n<a href=\"enum.Result.html#method.and_then\" title=\"method std::result::Result::and_then\"><code>and_then</code></a> method can produce a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;U, E&gt;</code></a> value having a\ndifferent inner type <code>U</code> than <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>. The <a href=\"enum.Result.html#method.or_else\" title=\"method std::result::Result::or_else\"><code>or_else</code></a> method\ncan produce a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, F&gt;</code></a> value having a different error type <code>F</code>\nthan <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>.</p>\n<div><table><thead><tr><th>method</th><th>self</th><th>function input</th><th>function result</th><th>output</th></tr></thead><tbody>\n<tr><td><a href=\"enum.Result.html#method.and_then\" title=\"method std::result::Result::and_then\"><code>and_then</code></a></td><td><code>Err(e)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Err(e)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.and_then\" title=\"method std::result::Result::and_then\"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.and_then\" title=\"method std::result::Result::and_then\"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.or_else\" title=\"method std::result::Result::or_else\"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.or_else\" title=\"method std::result::Result::or_else\"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>\n<tr><td><a href=\"enum.Result.html#method.or_else\" title=\"method std::result::Result::or_else\"><code>or_else</code></a></td><td><code>Ok(x)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Ok(x)</code></td></tr>\n</tbody></table>\n</div><h3 id=\"comparison-operators\"><a class=\"doc-anchor\" href=\"#comparison-operators\">§</a>Comparison operators</h3>\n<p>If <code>T</code> and <code>E</code> both implement <a href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a> then <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> will\nderive its <a href=\"../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\"><code>PartialOrd</code></a> implementation.  With this order, an <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>\ncompares as less than any <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>, while two <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> or two <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>\ncompare as their contained values would in <code>T</code> or <code>E</code> respectively.  If <code>T</code>\nand <code>E</code> both also implement <a href=\"../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a>, then so does <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>(<span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>) &lt; <span class=\"prelude-val\">Err</span>(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>x: <span class=\"prelude-ty\">Result</span>&lt;i32, ()&gt; = <span class=\"prelude-val\">Ok</span>(<span class=\"number\">0</span>);\n<span class=\"kw\">let </span>y = <span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(x &lt; y);\n<span class=\"kw\">let </span>x: <span class=\"prelude-ty\">Result</span>&lt;(), i32&gt; = <span class=\"prelude-val\">Err</span>(<span class=\"number\">0</span>);\n<span class=\"kw\">let </span>y = <span class=\"prelude-val\">Err</span>(<span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(x &lt; y);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(Ok(1)+%3C+Err(0));%0A++++let+x:+Result%3Ci32,+()%3E+=+Ok(0);%0A++++let+y+=+Ok(1);%0A++++assert!(x+%3C+y);%0A++++let+x:+Result%3C(),+i32%3E+=+Err(0);%0A++++let+y+=+Err(1);%0A++++assert!(x+%3C+y);%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"iterating-over-result\"><a class=\"doc-anchor\" href=\"#iterating-over-result\">§</a>Iterating over <code>Result</code></h3>\n<p>A <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> can be iterated over. This can be helpful if you need an\niterator that is conditionally empty. The iterator will either produce\na single value (when the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>), or produce no values\n(when the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>). For example, <a href=\"enum.Result.html#method.into_iter\" title=\"method std::result::Result::into_iter\"><code>into_iter</code></a> acts like\n<a href=\"../iter/fn.once.html\" title=\"fn std::iter::once\"><code>once(v)</code></a> if the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok(v)</code></a>, and like <a href=\"../iter/fn.empty.html\" title=\"fn std::iter::empty\"><code>empty()</code></a> if the\n<a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> is <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>.</p>\n<p>Iterators over <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a> come in three types:</p>\n<ul>\n<li><a href=\"enum.Result.html#method.into_iter\" title=\"method std::result::Result::into_iter\"><code>into_iter</code></a> consumes the <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> and produces the contained\nvalue</li>\n<li><a href=\"enum.Result.html#method.iter\" title=\"method std::result::Result::iter\"><code>iter</code></a> produces an immutable reference of type <code>&amp;T</code> to the\ncontained value</li>\n<li><a href=\"enum.Result.html#method.iter_mut\" title=\"method std::result::Result::iter_mut\"><code>iter_mut</code></a> produces a mutable reference of type <code>&amp;mut T</code> to the\ncontained value</li>\n</ul>\n<p>See <a href=\"../option/index.html#iterating-over-option\" title=\"mod std::option\">Iterating over <code>Option</code></a> for examples of how this can be useful.</p>\n<p>You might want to use an iterator chain to do multiple instances of an\noperation that can fail, but would like to ignore failures while\ncontinuing to process the successful results. In this example, we take\nadvantage of the iterable nature of <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> to select only the\n<a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> values using <a href=\"../iter/trait.Iterator.html#method.flatten\" title=\"method std::iter::Iterator::flatten\"><code>flatten</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>results = <span class=\"macro\">vec!</span>[];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>errs = <span class=\"macro\">vec!</span>[];\n<span class=\"kw\">let </span>nums: Vec&lt;<span class=\"kw\">_</span>&gt; = [<span class=\"string\">\"17\"</span>, <span class=\"string\">\"not a number\"</span>, <span class=\"string\">\"99\"</span>, <span class=\"string\">\"-27\"</span>, <span class=\"string\">\"768\"</span>]\n   .into_iter()\n   .map(u8::from_str)\n   <span class=\"comment\">// Save clones of the raw `Result` values to inspect\n   </span>.inspect(|x| results.push(x.clone()))\n   <span class=\"comment\">// Challenge: explain how this captures only the `Err` values\n   </span>.inspect(|x| errs.extend(x.clone().err()))\n   .flatten()\n   .collect();\n<span class=\"macro\">assert_eq!</span>(errs.len(), <span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(nums, [<span class=\"number\">17</span>, <span class=\"number\">99</span>]);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"results {results:?}\"</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"errs {errs:?}\"</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"nums {nums:?}\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::str::FromStr;%0A++++let+mut+results+=+vec!%5B%5D;%0A++++let+mut+errs+=+vec!%5B%5D;%0A++++let+nums:+Vec%3C_%3E+=+%5B%2217%22,+%22not+a+number%22,+%2299%22,+%22-27%22,+%22768%22%5D%0A+++++++.into_iter()%0A+++++++.map(u8::from_str)%0A+++++++//+Save+clones+of+the+raw+%60Result%60+values+to+inspect%0A+++++++.inspect(%7Cx%7C+results.push(x.clone()))%0A+++++++//+Challenge:+explain+how+this+captures+only+the+%60Err%60+values%0A+++++++.inspect(%7Cx%7C+errs.extend(x.clone().err()))%0A+++++++.flatten()%0A+++++++.collect();%0A++++assert_eq!(errs.len(),+3);%0A++++assert_eq!(nums,+%5B17,+99%5D);%0A++++println!(%22results+%7Bresults:?%7D%22);%0A++++println!(%22errs+%7Berrs:?%7D%22);%0A++++println!(%22nums+%7Bnums:?%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"collecting-into-result\"><a class=\"doc-anchor\" href=\"#collecting-into-result\">§</a>Collecting into <code>Result</code></h3>\n<p><a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> implements the <a href=\"enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E\" title=\"enum std::result::Result\"><code>FromIterator</code></a> trait,\nwhich allows an iterator over <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> values to be collected into a\n<a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> of a collection of each contained value of the original\n<a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> values, or <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> if any of the elements was <a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Ok</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">4</span>), <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"err!\"</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">8</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Result</span>&lt;Vec&lt;<span class=\"kw\">_</span>&gt;, <span class=\"kw-2\">&amp;</span>str&gt; = v.into_iter().collect();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"err!\"</span>));\n<span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Ok</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">4</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">8</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Result</span>&lt;Vec&lt;<span class=\"kw\">_</span>&gt;, <span class=\"kw-2\">&amp;</span>str&gt; = v.into_iter().collect();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">Ok</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BOk(2),+Ok(4),+Err(%22err!%22),+Ok(8)%5D;%0A++++let+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+Err(%22err!%22));%0A++++let+v+=+%5BOk(2),+Ok(4),+Ok(8)%5D;%0A++++let+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0A++++assert_eq!(res,+Ok(vec!%5B2,+4,+8%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> also implements the <a href=\"enum.Result.html#impl-Product%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E\" title=\"enum std::result::Result\"><code>Product</code></a> and\n<a href=\"enum.Result.html#impl-Sum%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E\" title=\"enum std::result::Result\"><code>Sum</code></a> traits, allowing an iterator over <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> values\nto provide the <a href=\"../iter/trait.Iterator.html#method.product\" title=\"method std::iter::Iterator::product\"><code>product</code></a> and\n<a href=\"../iter/trait.Iterator.html#method.sum\" title=\"method std::iter::Iterator::sum\"><code>sum</code></a> methods.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Err</span>(<span class=\"string\">\"error!\"</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>), <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"foo\"</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Result</span>&lt;i32, <span class=\"kw-2\">&amp;</span>str&gt; = v.into_iter().sum();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">Err</span>(<span class=\"string\">\"error!\"</span>));\n<span class=\"kw\">let </span>v = [<span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">2</span>), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">21</span>)];\n<span class=\"kw\">let </span>res: <span class=\"prelude-ty\">Result</span>&lt;i32, <span class=\"kw-2\">&amp;</span>str&gt; = v.into_iter().product();\n<span class=\"macro\">assert_eq!</span>(res, <span class=\"prelude-val\">Ok</span>(<span class=\"number\">42</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%5BErr(%22error!%22),+Ok(1),+Ok(2),+Ok(3),+Err(%22foo%22)%5D;%0A++++let+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().sum();%0A++++assert_eq!(res,+Err(%22error!%22));%0A++++let+v+=+%5BOk(1),+Ok(2),+Ok(21)%5D;%0A++++let+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().product();%0A++++assert_eq!(res,+Ok(42));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct std::result::IntoIter\">IntoIter</a></div><div class=\"desc docblock-short\">An iterator over the value in a <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> variant of a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct std::result::Iter\">Iter</a></div><div class=\"desc docblock-short\">An iterator over a reference to the <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> variant of a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct std::result::IterMut\">IterMut</a></div><div class=\"desc docblock-short\">An iterator over a mutable reference to the <a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a> variant of a <a href=\"enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a>.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.Result.html\" title=\"enum std::result::Result\">Result</a></div><div class=\"desc docblock-short\"><code>Result</code> is a type that represents either success (<a href=\"enum.Result.html#variant.Ok\" title=\"variant std::result::Result::Ok\"><code>Ok</code></a>) or failure (<a href=\"enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a>).</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:07.585Z"
}