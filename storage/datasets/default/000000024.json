{
	"title": "Defining an Enum - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch06-01-defining-an-enum.html",
	"markdown": "# Defining an Enum - The Rust Programming Language\n\nWhere structs give you a way of grouping together related fields and data, like a `Rectangle` with its `width` and `height`, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that `Rectangle` is one of a set of possible shapes that also includes `Circle` and `Triangle`. To do this, Rust allows us to encode these possibilities as an enum.\n\nLet’s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. Because these are the only possibilities for an IP address that our program will come across, we can _enumerate_ all possible variants, which is where enumeration gets its name.\n\nAny IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate because an enum value can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.\n\nWe can express this concept in code by defining an `IpAddrKind` enumeration and listing the possible kinds an IP address can be, `V4` and `V6`. These are the variants of the enum:\n\n```rust\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nfn main() {\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n}\n\nfn route(ip_kind: IpAddrKind) {}\n```\n\n`IpAddrKind` is now a custom data type that we can use elsewhere in our code.\n\n### [Enum Values](#enum-values)\n\nWe can create instances of each of the two variants of `IpAddrKind` like this:\n\n```rust\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nfn main() {\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n}\n\nfn route(ip_kind: IpAddrKind) {}\n```\n\nNote that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. This is useful because now both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type: `IpAddrKind`. We can then, for instance, define a function that takes any `IpAddrKind`:\n\n```rust\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nfn main() {\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n}\n\nfn route(ip_kind: IpAddrKind) {}\n```\n\nAnd we can call this function with either variant:\n\n```rust\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nfn main() {\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n}\n\nfn route(ip_kind: IpAddrKind) {}\n```\n\nUsing enums has even more advantages. Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address _data_; we only know what _kind_ it is. Given that you just learned about structs in Chapter 5, you might be tempted to tackle this problem with structs as shown in Listing 6-1.\n\n```rust\nfn main() {\n    enum IpAddrKind {\n        V4,\n        V6,\n    }\n\n    struct IpAddr {\n        kind: IpAddrKind,\n        address: String,\n    }\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\n```\n\nListing 6-1: Storing the data and `IpAddrKind` variant of an IP address using a `struct`\n\nHere, we’ve defined a struct `IpAddr` that has two fields: a `kind` field that is of type `IpAddrKind` (the enum we defined previously) and an `address` field of type `String`. We have two instances of this struct. The first is `home`, and it has the value `IpAddrKind::V4` as its `kind` with associated address data of `127.0.0.1`. The second instance is `loopback`. It has the other variant of `IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with it. We’ve used a struct to bundle the `kind` and `address` values together, so now the variant is associated with the value.\n\nHowever, representing the same concept using just an enum is more concise: rather than an enum inside a struct, we can put data directly into each enum variant. This new definition of the `IpAddr` enum says that both `V4` and `V6` variants will have associated `String` values:\n\n```rust\nfn main() {\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n}\n```\n\nWe attach data to each variant of the enum directly, so there is no need for an extra struct. Here, it’s also easier to see another detail of how enums work: the name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, `IpAddr::V4()` is a function call that takes a `String` argument and returns an instance of the `IpAddr` type. We automatically get this constructor function defined as a result of defining the enum.\n\nThere’s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but still express `V6` addresses as one `String` value, we wouldn’t be able to with a struct. Enums handle this case with ease:\n\n```rust\nfn main() {\n    enum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n}\n```\n\nWe’ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that [the standard library has a definition we can use!](../std/net/enum.IpAddr.html) Let’s look at how the standard library defines `IpAddr`: it has the exact enum and variants that we’ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n}\n```\n\nThis code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.\n\nNote that even though the standard library contains a definition for `IpAddr`, we can still create and use our own definition without conflict because we haven’t brought the standard library’s definition into our scope. We’ll talk more about bringing types into scope in Chapter 7.\n\nLet’s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {}\n```\n\nListing 6-2: A `Message` enum whose variants each store different amounts and types of values\n\nThis enum has four variants with different types:\n\n-   `Quit` has no data associated with it at all.\n-   `Move` has named fields, like a struct does.\n-   `Write` includes a single `String`.\n-   `ChangeColor` includes three `i32` values.\n\nDefining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the `struct` keyword and all the variants are grouped together under the `Message` type. The following structs could hold the same data that the preceding enum variants hold:\n\n```rust\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\nfn main() {}\n```\n\nBut if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the `Message` enum defined in Listing 6-2, which is a single type.\n\nThere is one more similarity between enums and structs: just as we’re able to define methods on structs using `impl`, we’re also able to define methods on enums. Here’s a method named `call` that we could define on our `Message` enum:\n\n```rust\nfn main() {\n    enum Message {\n        Quit,\n        Move { x: i32, y: i32 },\n        Write(String),\n        ChangeColor(i32, i32, i32),\n    }\n\n    impl Message {\n        fn call(&self) {\n            // method body would be defined here\n        }\n    }\n\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n}\n```\n\nThe body of the method would use `self` to get the value that we called the method on. In this example, we’ve created a variable `m` that has the value `Message::Write(String::from(\"hello\"))`, and that is what `self` will be in the body of the `call` method when `m.call()` runs.\n\nLet’s look at another enum in the standard library that is very common and useful: `Option`.\n\n### [The `Option` Enum and Its Advantages Over Null Values](#the-option-enum-and-its-advantages-over-null-values)\n\nThis section explores a case study of `Option`, which is another enum defined by the standard library. The `Option` type encodes the very common scenario in which a value could be something or it could be nothing.\n\nFor example, if you request the first item in a non-empty list, you would get a value. If you request the first item in an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.\n\nProgramming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. _Null_ is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.\n\nIn his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, has this to say:\n\n> I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\n\nThe problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.\n\nHowever, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.\n\nThe problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is `Option<T>`, and it is [defined by the standard library](../std/option/enum.Option.html) as follows:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Option<T> {\n    None,\n    Some(T),\n}\n}\n```\n\nThe `Option<T>` enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: you can use `Some` and `None` directly without the `Option::` prefix. The `Option<T>` enum is still just a regular enum, and `Some(T)` and `None` are still variants of type `Option<T>`.\n\nThe `<T>` syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter, and we’ll cover generics in more detail in Chapter 10. For now, all you need to know is that `<T>` means that the `Some` variant of the `Option` enum can hold one piece of data of any type, and that each concrete type that gets used in place of `T` makes the overall `Option<T>` type a different type. Here are some examples of using `Option` values to hold number types and string types:\n\n```rust\nfn main() {\n    let some_number = Some(5);\n    let some_char = Some('e');\n\n    let absent_number: Option<i32> = None;\n}\n```\n\nThe type of `some_number` is `Option<i32>`. The type of `some_char` is `Option<char>`, which is a different type. Rust can infer these types because we’ve specified a value inside the `Some` variant. For `absent_number`, Rust requires us to annotate the overall `Option` type: the compiler can’t infer the type that the corresponding `Some` variant will hold by looking only at a `None` value. Here, we tell Rust that we mean for `absent_number` to be of type `Option<i32>`.\n\nWhen we have a `Some` value, we know that a value is present and the value is held within the `Some`. When we have a `None` value, in some sense it means the same thing as null: we don’t have a valid value. So why is having `Option<T>` any better than having null?\n\nIn short, because `Option<T>` and `T` (where `T` can be any type) are different types, the compiler won’t let us use an `Option<T>` value as if it were definitely a valid value. For example, this code won’t compile, because it’s trying to add an `i8` to an `Option<i8>`:\n\n```rust\nfn main() {\n    let x: i8 = 5;\n    let y: Option<i8> = Some(5);\n\n    let sum = x + y;\n}\n```\n\nIf we run this code, we get an error message like this one:\n\n```console\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0277]: cannot add `Option<i8>` to `i8`\n --> src/main.rs:5:17\n  |\n5 |     let sum = x + y;\n  |                 ^ no implementation for `i8 + Option<i8>`\n  |\n  = help: the trait `Add<Option<i8>>` is not implemented for `i8`\n  = help: the following other types implement trait `Add<Rhs>`:\n            <i8 as Add>\n            <i8 as Add<&i8>>\n            <&'a i8 as Add<i8>>\n            <&i8 as Add<&i8>>\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n\n```\n\nIntense! In effect, this error message means that Rust doesn’t understand how to add an `i8` and an `Option<i8>`, because they’re different types. When we have a value of a type like `i8` in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an `Option<i8>` (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.\n\nIn other words, you have to convert an `Option<T>` to a `T` before you can perform `T` operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.\n\nEliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value `Option<T>`. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an `Option<T>`, you _can_ safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.\n\nSo how do you get the `T` value out of a `Some` variant when you have a value of type `Option<T>` so that you can use that value? The `Option<T>` enum has a large number of methods that are useful in a variety of situations; you can check them out in [its documentation](../std/option/enum.Option.html). Becoming familiar with the methods on `Option<T>` will be extremely useful in your journey with Rust.\n\nIn general, in order to use an `Option<T>` value, you want to have code that will handle each variant. You want some code that will run only when you have a `Some(T)` value, and this code is allowed to use the inner `T`. You want some other code to run only if you have a `None` value, and that code doesn’t have a `T` value available. The `match` expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Defining an Enum - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"defining-an-enum\"><a class=\"header\" href=\"#defining-an-enum\">Defining an Enum</a></h2>\n<p>Where structs give you a way of grouping together related fields and data, like\na <code class=\"hljs\">Rectangle</code> with its <code class=\"hljs\">width</code> and <code class=\"hljs\">height</code>, enums give you a way of saying a\nvalue is one of a possible set of values. For example, we may want to say that\n<code class=\"hljs\">Rectangle</code> is one of a set of possible shapes that also includes <code class=\"hljs\">Circle</code> and\n<code class=\"hljs\">Triangle</code>. To do this, Rust allows us to encode these possibilities as an enum.</p>\n<p>Let’s look at a situation we might want to express in code and see why enums\nare useful and more appropriate than structs in this case. Say we need to work\nwith IP addresses. Currently, two major standards are used for IP addresses:\nversion four and version six. Because these are the only possibilities for an\nIP address that our program will come across, we can <em>enumerate</em> all possible\nvariants, which is where enumeration gets its name.</p>\n<p>Any IP address can be either a version four or a version six address, but not\nboth at the same time. That property of IP addresses makes the enum data\nstructure appropriate because an enum value can only be one of its variants.\nBoth version four and version six addresses are still fundamentally IP\naddresses, so they should be treated as the same type when the code is handling\nsituations that apply to any kind of IP address.</p>\n<p>We can express this concept in code by defining an <code class=\"hljs\">IpAddrKind</code> enumeration and\nlisting the possible kinds an IP address can be, <code class=\"hljs\">V4</code> and <code class=\"hljs\">V6</code>. These are the\nvariants of the enum:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddrKind</span></span> {\n    V4,\n    V6,\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> four = IpAddrKind::V4;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = IpAddrKind::V6;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    route(IpAddrKind::V4);\n</span><span class=\"boring\">    route(IpAddrKind::V6);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">route</span></span>(ip_kind: IpAddrKind) {}</span></code></pre></pre>\n<p><code class=\"hljs\">IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>\n<h3 id=\"enum-values\"><a class=\"header\" href=\"#enum-values\">Enum Values</a></h3>\n<p>We can create instances of each of the two variants of <code class=\"hljs\">IpAddrKind</code> like this:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddrKind</span></span> {\n</span><span class=\"boring\">    V4,\n</span><span class=\"boring\">    V6,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> four = IpAddrKind::V4;\n    <span class=\"hljs-keyword\">let</span> six = IpAddrKind::V6;\n<span class=\"boring\">\n</span><span class=\"boring\">    route(IpAddrKind::V4);\n</span><span class=\"boring\">    route(IpAddrKind::V6);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">route</span></span>(ip_kind: IpAddrKind) {}</span></code></pre></pre>\n<p>Note that the variants of the enum are namespaced under its identifier, and we\nuse a double colon to separate the two. This is useful because now both values\n<code class=\"hljs\">IpAddrKind::V4</code> and <code class=\"hljs\">IpAddrKind::V6</code> are of the same type: <code class=\"hljs\">IpAddrKind</code>. We\ncan then, for instance, define a function that takes any <code class=\"hljs\">IpAddrKind</code>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddrKind</span></span> {\n</span><span class=\"boring\">    V4,\n</span><span class=\"boring\">    V6,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> four = IpAddrKind::V4;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = IpAddrKind::V6;\n</span><span class=\"boring\">\n</span><span class=\"boring\">    route(IpAddrKind::V4);\n</span><span class=\"boring\">    route(IpAddrKind::V6);\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">route</span></span>(ip_kind: IpAddrKind) {}</code></pre></pre>\n<p>And we can call this function with either variant:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddrKind</span></span> {\n</span><span class=\"boring\">    V4,\n</span><span class=\"boring\">    V6,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> four = IpAddrKind::V4;\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> six = IpAddrKind::V6;\n</span><span class=\"boring\">\n</span>    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n<span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">route</span></span>(ip_kind: IpAddrKind) {}</span></code></pre></pre>\n<p>Using enums has even more advantages. Thinking more about our IP address type,\nat the moment we don’t have a way to store the actual IP address <em>data</em>; we\nonly know what <em>kind</em> it is. Given that you just learned about structs in\nChapter 5, you might be tempted to tackle this problem with structs as shown in\nListing 6-1.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddrKind</span></span> {\n        V4,\n        V6,\n    }\n\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">IpAddr</span></span> {\n        kind: IpAddrKind,\n        address: <span class=\"hljs-built_in\">String</span>,\n    }\n\n    <span class=\"hljs-keyword\">let</span> home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"127.0.0.1\"</span>),\n    };\n\n    <span class=\"hljs-keyword\">let</span> loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"::1\"</span>),\n    };\n<span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 6-1: Storing the data and <code class=\"hljs\">IpAddrKind</code> variant of\nan IP address using a <code class=\"hljs\">struct</code></span></p>\n<p>Here, we’ve defined a struct <code class=\"hljs\">IpAddr</code> that has two fields: a <code class=\"hljs\">kind</code> field that\nis of type <code class=\"hljs\">IpAddrKind</code> (the enum we defined previously) and an <code class=\"hljs\">address</code> field\nof type <code class=\"hljs\">String</code>. We have two instances of this struct. The first is <code class=\"hljs\">home</code>,\nand it has the value <code class=\"hljs\">IpAddrKind::V4</code> as its <code class=\"hljs\">kind</code> with associated address\ndata of <code class=\"hljs\">127.0.0.1</code>. The second instance is <code class=\"hljs\">loopback</code>. It has the other\nvariant of <code class=\"hljs\">IpAddrKind</code> as its <code class=\"hljs\">kind</code> value, <code class=\"hljs\">V6</code>, and has address <code class=\"hljs\">::1</code>\nassociated with it. We’ve used a struct to bundle the <code class=\"hljs\">kind</code> and <code class=\"hljs\">address</code>\nvalues together, so now the variant is associated with the value.</p>\n<p>However, representing the same concept using just an enum is more concise:\nrather than an enum inside a struct, we can put data directly into each enum\nvariant. This new definition of the <code class=\"hljs\">IpAddr</code> enum says that both <code class=\"hljs\">V4</code> and <code class=\"hljs\">V6</code>\nvariants will have associated <code class=\"hljs\">String</code> values:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddr</span></span> {\n        V4(<span class=\"hljs-built_in\">String</span>),\n        V6(<span class=\"hljs-built_in\">String</span>),\n    }\n\n    <span class=\"hljs-keyword\">let</span> home = IpAddr::V4(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"127.0.0.1\"</span>));\n\n    <span class=\"hljs-keyword\">let</span> loopback = IpAddr::V6(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"::1\"</span>));\n<span class=\"boring\">}</span></code></pre></pre>\n<p>We attach data to each variant of the enum directly, so there is no need for an\nextra struct. Here, it’s also easier to see another detail of how enums work:\nthe name of each enum variant that we define also becomes a function that\nconstructs an instance of the enum. That is, <code class=\"hljs\">IpAddr::V4()</code> is a function call\nthat takes a <code class=\"hljs\">String</code> argument and returns an instance of the <code class=\"hljs\">IpAddr</code> type. We\nautomatically get this constructor function defined as a result of defining the\nenum.</p>\n<p>There’s another advantage to using an enum rather than a struct: each variant\ncan have different types and amounts of associated data. Version four IP\naddresses will always have four numeric components that will have values\nbetween 0 and 255. If we wanted to store <code class=\"hljs\">V4</code> addresses as four <code class=\"hljs\">u8</code> values but\nstill express <code class=\"hljs\">V6</code> addresses as one <code class=\"hljs\">String</code> value, we wouldn’t be able to with\na struct. Enums handle this case with ease:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddr</span></span> {\n        V4(<span class=\"hljs-built_in\">u8</span>, <span class=\"hljs-built_in\">u8</span>, <span class=\"hljs-built_in\">u8</span>, <span class=\"hljs-built_in\">u8</span>),\n        V6(<span class=\"hljs-built_in\">String</span>),\n    }\n\n    <span class=\"hljs-keyword\">let</span> home = IpAddr::V4(<span class=\"hljs-number\">127</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">let</span> loopback = IpAddr::V6(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"::1\"</span>));\n<span class=\"boring\">}</span></code></pre></pre>\n<p>We’ve shown several different ways to define data structures to store version\nfour and version six IP addresses. However, as it turns out, wanting to store\nIP addresses and encode which kind they are is so common that <a href=\"../std/net/enum.IpAddr.html\">the standard\nlibrary has a definition we can use!</a><!-- ignore --> Let’s look at how\nthe standard library defines <code class=\"hljs\">IpAddr</code>: it has the exact enum and variants that\nwe’ve defined and used, but it embeds the address data inside the variants in\nthe form of two different structs, which are defined differently for each\nvariant:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Ipv4Addr</span></span> {\n    <span class=\"hljs-comment\">// --snip--</span>\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Ipv6Addr</span></span> {\n    <span class=\"hljs-comment\">// --snip--</span>\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">IpAddr</span></span> {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This code illustrates that you can put any kind of data inside an enum variant:\nstrings, numeric types, or structs, for example. You can even include another\nenum! Also, standard library types are often not much more complicated than\nwhat you might come up with.</p>\n<p>Note that even though the standard library contains a definition for <code class=\"hljs\">IpAddr</code>,\nwe can still create and use our own definition without conflict because we\nhaven’t brought the standard library’s definition into our scope. We’ll talk\nmore about bringing types into scope in Chapter 7.</p>\n<p>Let’s look at another example of an enum in Listing 6-2: this one has a wide\nvariety of types embedded in its variants.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n    Quit,\n    Move { x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span> },\n    Write(<span class=\"hljs-built_in\">String</span>),\n    ChangeColor(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>),\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 6-2: A <code class=\"hljs\">Message</code> enum whose variants each store\ndifferent amounts and types of values</span></p>\n<p>This enum has four variants with different types:</p>\n<ul>\n<li><code class=\"hljs\">Quit</code> has no data associated with it at all.</li>\n<li><code class=\"hljs\">Move</code> has named fields, like a struct does.</li>\n<li><code class=\"hljs\">Write</code> includes a single <code class=\"hljs\">String</code>.</li>\n<li><code class=\"hljs\">ChangeColor</code> includes three <code class=\"hljs\">i32</code> values.</li>\n</ul>\n<p>Defining an enum with variants such as the ones in Listing 6-2 is similar to\ndefining different kinds of struct definitions, except the enum doesn’t use the\n<code class=\"hljs\">struct</code> keyword and all the variants are grouped together under the <code class=\"hljs\">Message</code>\ntype. The following structs could hold the same data that the preceding enum\nvariants hold:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">QuitMessage</span></span>; <span class=\"hljs-comment\">// unit struct</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MoveMessage</span></span> {\n    x: <span class=\"hljs-built_in\">i32</span>,\n    y: <span class=\"hljs-built_in\">i32</span>,\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">WriteMessage</span></span>(<span class=\"hljs-built_in\">String</span>); <span class=\"hljs-comment\">// tuple struct</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ChangeColorMessage</span></span>(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>); <span class=\"hljs-comment\">// tuple struct</span>\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p>But if we used the different structs, each of which has its own type, we\ncouldn’t as easily define a function to take any of these kinds of messages as\nwe could with the <code class=\"hljs\">Message</code> enum defined in Listing 6-2, which is a single type.</p>\n<p>There is one more similarity between enums and structs: just as we’re able to\ndefine methods on structs using <code class=\"hljs\">impl</code>, we’re also able to define methods on\nenums. Here’s a method named <code class=\"hljs\">call</code> that we could define on our <code class=\"hljs\">Message</code> enum:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Message</span></span> {\n</span><span class=\"boring\">        Quit,\n</span><span class=\"boring\">        Move { x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span> },\n</span><span class=\"boring\">        Write(<span class=\"hljs-built_in\">String</span>),\n</span><span class=\"boring\">        ChangeColor(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>),\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span>    <span class=\"hljs-keyword\">impl</span> Message {\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">call</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n            <span class=\"hljs-comment\">// method body would be defined here</span>\n        }\n    }\n\n    <span class=\"hljs-keyword\">let</span> m = Message::Write(<span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"hello\"</span>));\n    m.call();\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The body of the method would use <code class=\"hljs\">self</code> to get the value that we called the\nmethod on. In this example, we’ve created a variable <code class=\"hljs\">m</code> that has the value\n<code class=\"hljs\">Message::Write(String::from(\"hello\"))</code>, and that is what <code class=\"hljs\">self</code> will be in the\nbody of the <code class=\"hljs\">call</code> method when <code class=\"hljs\">m.call()</code> runs.</p>\n<p>Let’s look at another enum in the standard library that is very common and\nuseful: <code class=\"hljs\">Option</code>.</p>\n<h3 id=\"the-option-enum-and-its-advantages-over-null-values\"><a class=\"header\" href=\"#the-option-enum-and-its-advantages-over-null-values\">The <code>Option</code> Enum and Its Advantages Over Null Values</a></h3>\n<p>This section explores a case study of <code class=\"hljs\">Option</code>, which is another enum defined\nby the standard library. The <code class=\"hljs\">Option</code> type encodes the very common scenario in\nwhich a value could be something or it could be nothing.</p>\n<p>For example, if you request the first item in a non-empty list, you would get\na value. If you request the first item in an empty list, you would get nothing.\nExpressing this concept in terms of the type system means the compiler can\ncheck whether you’ve handled all the cases you should be handling; this\nfunctionality can prevent bugs that are extremely common in other programming\nlanguages.</p>\n<p>Programming language design is often thought of in terms of which features you\ninclude, but the features you exclude are important too. Rust doesn’t have the\nnull feature that many other languages have. <em>Null</em> is a value that means there\nis no value there. In languages with null, variables can always be in one of\ntwo states: null or not-null.</p>\n<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony\nHoare, the inventor of null, has this to say:</p>\n<blockquote>\n<p>I call it my billion-dollar mistake. At that time, I was designing the first\ncomprehensive type system for references in an object-oriented language. My\ngoal was to ensure that all use of references should be absolutely safe, with\nchecking performed automatically by the compiler. But I couldn’t resist the\ntemptation to put in a null reference, simply because it was so easy to\nimplement. This has led to innumerable errors, vulnerabilities, and system\ncrashes, which have probably caused a billion dollars of pain and damage in\nthe last forty years.</p>\n</blockquote>\n<p>The problem with null values is that if you try to use a null value as a\nnot-null value, you’ll get an error of some kind. Because this null or not-null\nproperty is pervasive, it’s extremely easy to make this kind of error.</p>\n<p>However, the concept that null is trying to express is still a useful one: a\nnull is a value that is currently invalid or absent for some reason.</p>\n<p>The problem isn’t really with the concept but with the particular\nimplementation. As such, Rust does not have nulls, but it does have an enum\nthat can encode the concept of a value being present or absent. This enum is\n<code class=\"hljs\">Option&lt;T&gt;</code>, and it is <a href=\"../std/option/enum.Option.html\">defined by the standard library</a><!-- ignore -->\nas follows:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">Option</span></span>&lt;T&gt; {\n    <span class=\"hljs-literal\">None</span>,\n    <span class=\"hljs-literal\">Some</span>(T),\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The <code class=\"hljs\">Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you\ndon’t need to bring it into scope explicitly. Its variants are also included in\nthe prelude: you can use <code class=\"hljs\">Some</code> and <code class=\"hljs\">None</code> directly without the <code class=\"hljs\">Option::</code>\nprefix. The <code class=\"hljs\">Option&lt;T&gt;</code> enum is still just a regular enum, and <code class=\"hljs\">Some(T)</code> and\n<code class=\"hljs\">None</code> are still variants of type <code class=\"hljs\">Option&lt;T&gt;</code>.</p>\n<p>The <code class=\"hljs\">&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a\ngeneric type parameter, and we’ll cover generics in more detail in Chapter 10.\nFor now, all you need to know is that <code class=\"hljs\">&lt;T&gt;</code> means that the <code class=\"hljs\">Some</code> variant of\nthe <code class=\"hljs\">Option</code> enum can hold one piece of data of any type, and that each\nconcrete type that gets used in place of <code class=\"hljs\">T</code> makes the overall <code class=\"hljs\">Option&lt;T&gt;</code> type\na different type. Here are some examples of using <code class=\"hljs\">Option</code> values to hold\nnumber types and string types:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> some_number = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> some_char = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-string\">'e'</span>);\n\n    <span class=\"hljs-keyword\">let</span> absent_number: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; = <span class=\"hljs-literal\">None</span>;\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The type of <code class=\"hljs\">some_number</code> is <code class=\"hljs\">Option&lt;i32&gt;</code>. The type of <code class=\"hljs\">some_char</code> is\n<code class=\"hljs\">Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because\nwe’ve specified a value inside the <code class=\"hljs\">Some</code> variant. For <code class=\"hljs\">absent_number</code>, Rust\nrequires us to annotate the overall <code class=\"hljs\">Option</code> type: the compiler can’t infer the\ntype that the corresponding <code class=\"hljs\">Some</code> variant will hold by looking only at a\n<code class=\"hljs\">None</code> value. Here, we tell Rust that we mean for <code class=\"hljs\">absent_number</code> to be of type\n<code class=\"hljs\">Option&lt;i32&gt;</code>.</p>\n<p>When we have a <code class=\"hljs\">Some</code> value, we know that a value is present and the value is\nheld within the <code class=\"hljs\">Some</code>. When we have a <code class=\"hljs\">None</code> value, in some sense it means the\nsame thing as null: we don’t have a valid value. So why is having <code class=\"hljs\">Option&lt;T&gt;</code>\nany better than having null?</p>\n<p>In short, because <code class=\"hljs\">Option&lt;T&gt;</code> and <code class=\"hljs\">T</code> (where <code class=\"hljs\">T</code> can be any type) are different\ntypes, the compiler won’t let us use an <code class=\"hljs\">Option&lt;T&gt;</code> value as if it were\ndefinitely a valid value. For example, this code won’t compile, because it’s\ntrying to add an <code class=\"hljs\">i8</code> to an <code class=\"hljs\">Option&lt;i8&gt;</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>    <span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">i8</span> = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> y: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i8</span>&gt; = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">5</span>);\n\n    <span class=\"hljs-keyword\">let</span> sum = x + y;\n<span class=\"boring\">}</span></code></pre>\n<p>If we run this code, we get an error message like this one:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0277]: cannot add `Option&lt;i8&gt;` to `i8`\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:5:17</span>\n  |\n5 |     let sum = x + y;\n  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`\n  |\n  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`\n  = help: the following other types implement trait `Add&lt;Rhs&gt;`:\n            &lt;i8 as Add&gt;\n            &lt;i8 as Add&lt;&amp;i8&gt;&gt;\n            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;\n            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n</code></pre>\n<p>Intense! In effect, this error message means that Rust doesn’t understand how\nto add an <code class=\"hljs\">i8</code> and an <code class=\"hljs\">Option&lt;i8&gt;</code>, because they’re different types. When we\nhave a value of a type like <code class=\"hljs\">i8</code> in Rust, the compiler will ensure that we\nalways have a valid value. We can proceed confidently without having to check\nfor null before using that value. Only when we have an <code class=\"hljs\">Option&lt;i8&gt;</code> (or\nwhatever type of value we’re working with) do we have to worry about possibly\nnot having a value, and the compiler will make sure we handle that case before\nusing the value.</p>\n<p>In other words, you have to convert an <code class=\"hljs\">Option&lt;T&gt;</code> to a <code class=\"hljs\">T</code> before you can\nperform <code class=\"hljs\">T</code> operations with it. Generally, this helps catch one of the most\ncommon issues with null: assuming that something isn’t null when it actually is.</p>\n<p>Eliminating the risk of incorrectly assuming a not-null value helps you to be\nmore confident in your code. In order to have a value that can possibly be\nnull, you must explicitly opt in by making the type of that value <code class=\"hljs\">Option&lt;T&gt;</code>.\nThen, when you use that value, you are required to explicitly handle the case\nwhen the value is null. Everywhere that a value has a type that isn’t an\n<code class=\"hljs\">Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a\ndeliberate design decision for Rust to limit null’s pervasiveness and increase\nthe safety of Rust code.</p>\n<p>So how do you get the <code class=\"hljs\">T</code> value out of a <code class=\"hljs\">Some</code> variant when you have a value\nof type <code class=\"hljs\">Option&lt;T&gt;</code> so that you can use that value? The <code class=\"hljs\">Option&lt;T&gt;</code> enum has a\nlarge number of methods that are useful in a variety of situations; you can\ncheck them out in <a href=\"../std/option/enum.Option.html\">its documentation</a><!-- ignore -->. Becoming familiar\nwith the methods on <code class=\"hljs\">Option&lt;T&gt;</code> will be extremely useful in your journey with\nRust.</p>\n<p>In general, in order to use an <code class=\"hljs\">Option&lt;T&gt;</code> value, you want to have code that\nwill handle each variant. You want some code that will run only when you have a\n<code class=\"hljs\">Some(T)</code> value, and this code is allowed to use the inner <code class=\"hljs\">T</code>. You want some\nother code to run only if you have a <code class=\"hljs\">None</code> value, and that code doesn’t have a\n<code class=\"hljs\">T</code> value available. The <code class=\"hljs\">match</code> expression is a control flow construct that\ndoes just this when used with enums: it will run different code depending on\nwhich variant of the enum it has, and that code can use the data inside the\nmatching value.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch06-00-enums.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch06-02-match.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch06-00-enums.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch06-02-match.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:17.141Z"
}