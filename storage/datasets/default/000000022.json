{
	"title": "Defining and Instantiating Structs - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html",
	"markdown": "# Defining and Instantiating Structs - The Rust Programming Language\n\nStructs are similar to tuples, discussed in [“The Tuple Type”](about:blank/ch03-02-data-types.html#the-tuple-type) section, in that both hold multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values of an instance.\n\nTo define a struct, we enter the keyword `struct` and name the entire struct. A struct’s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call _fields_. For example, Listing 5-1 shows a struct that stores information about a user account.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {}\n```\n\nListing 5-1: A `User` struct definition\n\nTo use a struct after we’ve defined it, we create an _instance_ of that struct by specifying concrete values for each of the fields. We create an instance by stating the name of the struct and then add curly brackets containing _key: value_ pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type. For example, we can declare a particular user as shown in Listing 5-2.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n}\n```\n\nListing 5-2: Creating an instance of the `User` struct\n\nTo get a specific value from a struct, we use dot notation. For example, to access this user’s email address, we use `user1.email`. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the `email` field of a mutable `User` instance.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let mut user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n\n    user1.email = String::from(\"anotheremail@example.com\");\n}\n```\n\nListing 5-3: Changing the value in the `email` field of a `User` instance\n\nNote that the entire instance must be mutable; Rust doesn’t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.\n\nListing 5-4 shows a `build_user` function that returns a `User` instance with the given email and username. The `active` field gets the value of `true`, and the `sign_in_count` gets a value of `1`.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n\nfn main() {\n    let user1 = build_user(\n        String::from(\"someone@example.com\"),\n        String::from(\"someusername123\"),\n    );\n}\n```\n\nListing 5-4: A `build_user` function that takes an email and username and returns a `User` instance\n\nIt makes sense to name the function parameters with the same name as the struct fields, but having to repeat the `email` and `username` field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there’s a convenient shorthand!\n\n### [Using the Field Init Shorthand](#using-the-field-init-shorthand)\n\nBecause the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the _field init shorthand_ syntax to rewrite `build_user` so it behaves exactly the same but doesn’t have the repetition of `username` and `email`, as shown in Listing 5-5.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n\nfn main() {\n    let user1 = build_user(\n        String::from(\"someone@example.com\"),\n        String::from(\"someusername123\"),\n    );\n}\n```\n\nListing 5-5: A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields\n\nHere, we’re creating a new instance of the `User` struct, which has a field named `email`. We want to set the `email` field’s value to the value in the `email` parameter of the `build_user` function. Because the `email` field and the `email` parameter have the same name, we only need to write `email` rather than `email: email`.\n\n### [Creating Instances from Other Instances with Struct Update Syntax](#creating-instances-from-other-instances-with-struct-update-syntax)\n\nIt’s often useful to create a new instance of a struct that includes most of the values from another instance, but changes some. You can do this using _struct update syntax_.\n\nFirst, in Listing 5-6 we show how to create a new `User` instance in `user2` regularly, without the update syntax. We set a new value for `email` but otherwise use the same values from `user1` that we created in Listing 5-2.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    // --snip--\n\n    let user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n\n    let user2 = User {\n        active: user1.active,\n        username: user1.username,\n        email: String::from(\"another@example.com\"),\n        sign_in_count: user1.sign_in_count,\n    };\n}\n```\n\nListing 5-6: Creating a new `User` instance using all but one of the values from `user1`\n\nUsing struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax `..` specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    // --snip--\n\n    let user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n```\n\nListing 5-7: Using struct update syntax to set a new `email` value for a `User` instance but to use the rest of the values from `user1`\n\nThe code in Listing 5-7 also creates an instance in `user2` that has a different value for `email` but has the same values for the `username`, `active`, and `sign_in_count` fields from `user1`. The `..user1` must come last to specify that any remaining fields should get their values from the corresponding fields in `user1`, but we can choose to specify values for as many fields as we want in any order, regardless of the order of the fields in the struct’s definition.\n\nNote that the struct update syntax uses `=` like an assignment; this is because it moves the data, just as we saw in the [“Variables and Data Interacting with Move”](about:blank/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move) section. In this example, we can no longer use `user1` as a whole after creating `user2` because the `String` in the `username` field of `user1` was moved into `user2`. If we had given `user2` new `String` values for both `email` and `username`, and thus only used the `active` and `sign_in_count` values from `user1`, then `user1` would still be valid after creating `user2`. Both `active` and `sign_in_count` are types that implement the `Copy` trait, so the behavior we discussed in the [“Stack-Only Data: Copy”](about:blank/ch04-01-what-is-ownership.html#stack-only-data-copy) section would apply.\n\n### [Using Tuple Structs Without Named Fields to Create Different Types](#using-tuple-structs-without-named-fields-to-create-different-types)\n\nRust also supports structs that look similar to tuples, called _tuple structs_. Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples, and when naming each field as in a regular struct would be verbose or redundant.\n\nTo define a tuple struct, start with the `struct` keyword and the struct name followed by the types in the tuple. For example, here we define and use two tuple structs named `Color` and `Point`:\n\nFilename: src/main.rs\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n```\n\nNote that the `black` and `origin` values are different types because they’re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct might have the same types. For example, a function that takes a parameter of type `Color` cannot take a `Point` as an argument, even though both types are made up of three `i32` values. Otherwise, tuple struct instances are similar to tuples in that you can destructure them into their individual pieces, and you can use a `.` followed by the index to access an individual value.\n\n### [Unit-Like Structs Without Any Fields](#unit-like-structs-without-any-fields)\n\nYou can also define structs that don’t have any fields! These are called _unit-like structs_ because they behave similarly to `()`, the unit type that we mentioned in [“The Tuple Type”](about:blank/ch03-02-data-types.html#the-tuple-type) section. Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself. We’ll discuss traits in Chapter 10. Here’s an example of declaring and instantiating a unit struct named `AlwaysEqual`:\n\nFilename: src/main.rs\n\n```rust\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```\n\nTo define `AlwaysEqual`, we use the `struct` keyword, the name we want, and then a semicolon. No need for curly brackets or parentheses! Then we can get an instance of `AlwaysEqual` in the `subject` variable in a similar way: using the name we defined, without any curly brackets or parentheses. Imagine that later we’ll implement behavior for this type such that every instance of `AlwaysEqual` is always equal to every instance of any other type, perhaps to have a known result for testing purposes. We wouldn’t need any data to implement that behavior! You’ll see in Chapter 10 how to define traits and implement them on any type, including unit-like structs.\n\n### [Ownership of Struct Data](#ownership-of-struct-data)\n\nIn the `User` struct definition in Listing 5-1, we used the owned `String` type rather than the `&str` string slice type. This is a deliberate choice because we want each instance of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.\n\nIt’s also possible for structs to store references to data owned by something else, but to do so requires the use of _lifetimes_, a Rust feature that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let’s say you try to store a reference in a struct without specifying lifetimes, like the following; this won’t work:\n\nFilename: src/main.rs\n\n```rust\nstruct User {\n    active: bool,\n    username: &str,\n    email: &str,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: \"someusername123\",\n        email: \"someone@example.com\",\n        sign_in_count: 1,\n    };\n}\n```\n\nThe compiler will complain that it needs lifetime specifiers:\n\n```console\n$ cargo run\n   Compiling structs v0.1.0 (file:///projects/structs)\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:3:15\n  |\n3 |     username: &str,\n  |               ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User<'a> {\n2 |     active: bool,\n3 ~     username: &'a str,\n  |\n\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:4:12\n  |\n4 |     email: &str,\n  |            ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User<'a> {\n2 |     active: bool,\n3 |     username: &str,\n4 ~     email: &'a str,\n  |\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `structs` (bin \"structs\") due to 2 previous errors\n\n```\n\nIn Chapter 10, we’ll discuss how to fix these errors so you can store references in structs, but for now, we’ll fix errors like these using owned types like `String` instead of references like `&str`.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Defining and Instantiating Structs - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"defining-and-instantiating-structs\"><a class=\"header\" href=\"#defining-and-instantiating-structs\">Defining and Instantiating Structs</a></h2>\n<p>Structs are similar to tuples, discussed in <a href=\"ch03-02-data-types.html#the-tuple-type\">“The Tuple Type”</a><!--\nignore --> section, in that both hold multiple related values. Like tuples, the\npieces of a struct can be different types. Unlike with tuples, in a struct\nyou’ll name each piece of data so it’s clear what the values mean. Adding these\nnames means that structs are more flexible than tuples: you don’t have to rely\non the order of the data to specify or access the values of an instance.</p>\n<p>To define a struct, we enter the keyword <code class=\"hljs\">struct</code> and name the entire struct. A\nstruct’s name should describe the significance of the pieces of data being\ngrouped together. Then, inside curly brackets, we define the names and types of\nthe pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a\nstruct that stores information about a user account.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n    active: <span class=\"hljs-built_in\">bool</span>,\n    username: <span class=\"hljs-built_in\">String</span>,\n    email: <span class=\"hljs-built_in\">String</span>,\n    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 5-1: A <code class=\"hljs\">User</code> struct definition</span></p>\n<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct\nby specifying concrete values for each of the fields. We create an instance by\nstating the name of the struct and then add curly brackets containing <em>key:\nvalue</em> pairs, where the keys are the names of the fields and the values are the\ndata we want to store in those fields. We don’t have to specify the fields in\nthe same order in which we declared them in the struct. In other words, the\nstruct definition is like a general template for the type, and instances fill\nin that template with particular data to create values of the type. For\nexample, we can declare a particular user as shown in Listing 5-2.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n</span><span class=\"boring\">    active: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">    username: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    email: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> user1 = User {\n        active: <span class=\"hljs-literal\">true</span>,\n        username: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someusername123\"</span>),\n        email: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someone@example.com\"</span>),\n        sign_in_count: <span class=\"hljs-number\">1</span>,\n    };\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 5-2: Creating an instance of the <code class=\"hljs\">User</code>\nstruct</span></p>\n<p>To get a specific value from a struct, we use dot notation. For example, to\naccess this user’s email address, we use <code class=\"hljs\">user1.email</code>. If the instance is\nmutable, we can change a value by using the dot notation and assigning into a\nparticular field. Listing 5-3 shows how to change the value in the <code class=\"hljs\">email</code>\nfield of a mutable <code class=\"hljs\">User</code> instance.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n</span><span class=\"boring\">    active: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">    username: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    email: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> user1 = User {\n        active: <span class=\"hljs-literal\">true</span>,\n        username: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someusername123\"</span>),\n        email: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someone@example.com\"</span>),\n        sign_in_count: <span class=\"hljs-number\">1</span>,\n    };\n\n    user1.email = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"anotheremail@example.com\"</span>);\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 5-3: Changing the value in the <code class=\"hljs\">email</code> field of a\n<code class=\"hljs\">User</code> instance</span></p>\n<p>Note that the entire instance must be mutable; Rust doesn’t allow us to mark\nonly certain fields as mutable. As with any expression, we can construct a new\ninstance of the struct as the last expression in the function body to\nimplicitly return that new instance.</p>\n<p>Listing 5-4 shows a <code class=\"hljs\">build_user</code> function that returns a <code class=\"hljs\">User</code> instance with\nthe given email and username. The <code class=\"hljs\">active</code> field gets the value of <code class=\"hljs\">true</code>, and\nthe <code class=\"hljs\">sign_in_count</code> gets a value of <code class=\"hljs\">1</code>.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n</span><span class=\"boring\">    active: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">    username: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    email: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build_user</span></span>(email: <span class=\"hljs-built_in\">String</span>, username: <span class=\"hljs-built_in\">String</span>) -&gt; User {\n    User {\n        active: <span class=\"hljs-literal\">true</span>,\n        username: username,\n        email: email,\n        sign_in_count: <span class=\"hljs-number\">1</span>,\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> user1 = build_user(\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someone@example.com\"</span>),\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someusername123\"</span>),\n</span><span class=\"boring\">    );\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 5-4: A <code class=\"hljs\">build_user</code> function that takes an email\nand username and returns a <code class=\"hljs\">User</code> instance</span></p>\n<p>It makes sense to name the function parameters with the same name as the struct\nfields, but having to repeat the <code class=\"hljs\">email</code> and <code class=\"hljs\">username</code> field names and\nvariables is a bit tedious. If the struct had more fields, repeating each name\nwould get even more annoying. Luckily, there’s a convenient shorthand!</p>\n<!-- Old heading. Do not remove or links may break. -->\n<p><a id=\"using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name\"></a></p>\n<h3 id=\"using-the-field-init-shorthand\"><a class=\"header\" href=\"#using-the-field-init-shorthand\">Using the Field Init Shorthand</a></h3>\n<p>Because the parameter names and the struct field names are exactly the same in\nListing 5-4, we can use the <em>field init shorthand</em> syntax to rewrite\n<code class=\"hljs\">build_user</code> so it behaves exactly the same but doesn’t have the repetition of\n<code class=\"hljs\">username</code> and <code class=\"hljs\">email</code>, as shown in Listing 5-5.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n</span><span class=\"boring\">    active: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">    username: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    email: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">build_user</span></span>(email: <span class=\"hljs-built_in\">String</span>, username: <span class=\"hljs-built_in\">String</span>) -&gt; User {\n    User {\n        active: <span class=\"hljs-literal\">true</span>,\n        username,\n        email,\n        sign_in_count: <span class=\"hljs-number\">1</span>,\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> user1 = build_user(\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someone@example.com\"</span>),\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someusername123\"</span>),\n</span><span class=\"boring\">    );\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 5-5: A <code class=\"hljs\">build_user</code> function that uses field init\nshorthand because the <code class=\"hljs\">username</code> and <code class=\"hljs\">email</code> parameters have the same name as\nstruct fields</span></p>\n<p>Here, we’re creating a new instance of the <code class=\"hljs\">User</code> struct, which has a field\nnamed <code class=\"hljs\">email</code>. We want to set the <code class=\"hljs\">email</code> field’s value to the value in the\n<code class=\"hljs\">email</code> parameter of the <code class=\"hljs\">build_user</code> function. Because the <code class=\"hljs\">email</code> field and\nthe <code class=\"hljs\">email</code> parameter have the same name, we only need to write <code class=\"hljs\">email</code> rather\nthan <code class=\"hljs\">email: email</code>.</p>\n<h3 id=\"creating-instances-from-other-instances-with-struct-update-syntax\"><a class=\"header\" href=\"#creating-instances-from-other-instances-with-struct-update-syntax\">Creating Instances from Other Instances with Struct Update Syntax</a></h3>\n<p>It’s often useful to create a new instance of a struct that includes most of\nthe values from another instance, but changes some. You can do this using\n<em>struct update syntax</em>.</p>\n<p>First, in Listing 5-6 we show how to create a new <code class=\"hljs\">User</code> instance in <code class=\"hljs\">user2</code>\nregularly, without the update syntax. We set a new value for <code class=\"hljs\">email</code> but\notherwise use the same values from <code class=\"hljs\">user1</code> that we created in Listing 5-2.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n</span><span class=\"boring\">    active: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">    username: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    email: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> user1 = User {\n</span><span class=\"boring\">        email: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someone@example.com\"</span>),\n</span><span class=\"boring\">        username: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someusername123\"</span>),\n</span><span class=\"boring\">        active: <span class=\"hljs-literal\">true</span>,\n</span><span class=\"boring\">        sign_in_count: <span class=\"hljs-number\">1</span>,\n</span><span class=\"boring\">    };\n</span>\n    <span class=\"hljs-keyword\">let</span> user2 = User {\n        active: user1.active,\n        username: user1.username,\n        email: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"another@example.com\"</span>),\n        sign_in_count: user1.sign_in_count,\n    };\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 5-6: Creating a new <code class=\"hljs\">User</code> instance using all but one of\nthe values from <code class=\"hljs\">user1</code></span></p>\n<p>Using struct update syntax, we can achieve the same effect with less code, as\nshown in Listing 5-7. The syntax <code class=\"hljs\">..</code> specifies that the remaining fields not\nexplicitly set should have the same value as the fields in the given instance.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n</span><span class=\"boring\">    active: <span class=\"hljs-built_in\">bool</span>,\n</span><span class=\"boring\">    username: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    email: <span class=\"hljs-built_in\">String</span>,\n</span><span class=\"boring\">    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> user1 = User {\n</span><span class=\"boring\">        email: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someone@example.com\"</span>),\n</span><span class=\"boring\">        username: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"someusername123\"</span>),\n</span><span class=\"boring\">        active: <span class=\"hljs-literal\">true</span>,\n</span><span class=\"boring\">        sign_in_count: <span class=\"hljs-number\">1</span>,\n</span><span class=\"boring\">    };\n</span>\n    <span class=\"hljs-keyword\">let</span> user2 = User {\n        email: <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"another@example.com\"</span>),\n        ..user1\n    };\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 5-7: Using struct update syntax to set a new\n<code class=\"hljs\">email</code> value for a <code class=\"hljs\">User</code> instance but to use the rest of the values from\n<code class=\"hljs\">user1</code></span></p>\n<p>The code in Listing 5-7 also creates an instance in <code class=\"hljs\">user2</code> that has a\ndifferent value for <code class=\"hljs\">email</code> but has the same values for the <code class=\"hljs\">username</code>,\n<code class=\"hljs\">active</code>, and <code class=\"hljs\">sign_in_count</code> fields from <code class=\"hljs\">user1</code>. The <code class=\"hljs\">..user1</code> must come last\nto specify that any remaining fields should get their values from the\ncorresponding fields in <code class=\"hljs\">user1</code>, but we can choose to specify values for as\nmany fields as we want in any order, regardless of the order of the fields in\nthe struct’s definition.</p>\n<p>Note that the struct update syntax uses <code class=\"hljs\">=</code> like an assignment; this is because\nit moves the data, just as we saw in the <a href=\"ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move\">“Variables and Data Interacting with\nMove”</a><!-- ignore --> section. In this example, we can no longer use\n<code class=\"hljs\">user1</code> as a whole after creating <code class=\"hljs\">user2</code> because the <code class=\"hljs\">String</code> in the\n<code class=\"hljs\">username</code> field of <code class=\"hljs\">user1</code> was moved into <code class=\"hljs\">user2</code>. If we had given <code class=\"hljs\">user2</code> new\n<code class=\"hljs\">String</code> values for both <code class=\"hljs\">email</code> and <code class=\"hljs\">username</code>, and thus only used the\n<code class=\"hljs\">active</code> and <code class=\"hljs\">sign_in_count</code> values from <code class=\"hljs\">user1</code>, then <code class=\"hljs\">user1</code> would still be\nvalid after creating <code class=\"hljs\">user2</code>. Both <code class=\"hljs\">active</code> and <code class=\"hljs\">sign_in_count</code> are types that\nimplement the <code class=\"hljs\">Copy</code> trait, so the behavior we discussed in the <a href=\"ch04-01-what-is-ownership.html#stack-only-data-copy\">“Stack-Only\nData: Copy”</a><!-- ignore --> section would apply.</p>\n<h3 id=\"using-tuple-structs-without-named-fields-to-create-different-types\"><a class=\"header\" href=\"#using-tuple-structs-without-named-fields-to-create-different-types\">Using Tuple Structs Without Named Fields to Create Different Types</a></h3>\n<p>Rust also supports structs that look similar to tuples, called <em>tuple structs</em>.\nTuple structs have the added meaning the struct name provides but don’t have\nnames associated with their fields; rather, they just have the types of the\nfields. Tuple structs are useful when you want to give the whole tuple a name\nand make the tuple a different type from other tuples, and when naming each\nfield as in a regular struct would be verbose or redundant.</p>\n<p>To define a tuple struct, start with the <code class=\"hljs\">struct</code> keyword and the struct name\nfollowed by the types in the tuple. For example, here we define and use two\ntuple structs named <code class=\"hljs\">Color</code> and <code class=\"hljs\">Point</code>:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Color</span></span>(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>);\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span>(<span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>, <span class=\"hljs-built_in\">i32</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> black = Color(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">let</span> origin = Point(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n}</code></pre></pre>\n<p>Note that the <code class=\"hljs\">black</code> and <code class=\"hljs\">origin</code> values are different types because they’re\ninstances of different tuple structs. Each struct you define is its own type,\neven though the fields within the struct might have the same types. For\nexample, a function that takes a parameter of type <code class=\"hljs\">Color</code> cannot take a\n<code class=\"hljs\">Point</code> as an argument, even though both types are made up of three <code class=\"hljs\">i32</code>\nvalues. Otherwise, tuple struct instances are similar to tuples in that you can\ndestructure them into their individual pieces, and you can use a <code class=\"hljs\">.</code> followed\nby the index to access an individual value.</p>\n<h3 id=\"unit-like-structs-without-any-fields\"><a class=\"header\" href=\"#unit-like-structs-without-any-fields\">Unit-Like Structs Without Any Fields</a></h3>\n<p>You can also define structs that don’t have any fields! These are called\n<em>unit-like structs</em> because they behave similarly to <code class=\"hljs\">()</code>, the unit type that\nwe mentioned in <a href=\"ch03-02-data-types.html#the-tuple-type\">“The Tuple Type”</a><!-- ignore --> section. Unit-like\nstructs can be useful when you need to implement a trait on some type but don’t\nhave any data that you want to store in the type itself. We’ll discuss traits\nin Chapter 10. Here’s an example of declaring and instantiating a unit struct\nnamed <code class=\"hljs\">AlwaysEqual</code>:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AlwaysEqual</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> subject = AlwaysEqual;\n}</code></pre></pre>\n<p>To define <code class=\"hljs\">AlwaysEqual</code>, we use the <code class=\"hljs\">struct</code> keyword, the name we want, and\nthen a semicolon. No need for curly brackets or parentheses! Then we can get an\ninstance of <code class=\"hljs\">AlwaysEqual</code> in the <code class=\"hljs\">subject</code> variable in a similar way: using the\nname we defined, without any curly brackets or parentheses. Imagine that later\nwe’ll implement behavior for this type such that every instance of\n<code class=\"hljs\">AlwaysEqual</code> is always equal to every instance of any other type, perhaps to\nhave a known result for testing purposes. We wouldn’t need any data to\nimplement that behavior! You’ll see in Chapter 10 how to define traits and\nimplement them on any type, including unit-like structs.</p>\n<section class=\"note\" aria-role=\"note\">\n<h3 id=\"ownership-of-struct-data\"><a class=\"header\" href=\"#ownership-of-struct-data\">Ownership of Struct Data</a></h3>\n<p>In the <code class=\"hljs\">User</code> struct definition in Listing 5-1, we used the owned <code class=\"hljs\">String</code>\ntype rather than the <code class=\"hljs\">&amp;str</code> string slice type. This is a deliberate choice\nbecause we want each instance of this struct to own all of its data and for\nthat data to be valid for as long as the entire struct is valid.</p>\n<p>It’s also possible for structs to store references to data owned by something\nelse, but to do so requires the use of <em>lifetimes</em>, a Rust feature that we’ll\ndiscuss in Chapter 10. Lifetimes ensure that the data referenced by a struct\nis valid for as long as the struct is. Let’s say you try to store a reference\nin a struct without specifying lifetimes, like the following; this won’t work:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">User</span></span> {\n    active: <span class=\"hljs-built_in\">bool</span>,\n    username: &amp;<span class=\"hljs-built_in\">str</span>,\n    email: &amp;<span class=\"hljs-built_in\">str</span>,\n    sign_in_count: <span class=\"hljs-built_in\">u64</span>,\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> user1 = User {\n        active: <span class=\"hljs-literal\">true</span>,\n        username: <span class=\"hljs-string\">\"someusername123\"</span>,\n        email: <span class=\"hljs-string\">\"someone@example.com\"</span>,\n        sign_in_count: <span class=\"hljs-number\">1</span>,\n    };\n}</code></pre>\n<p>The compiler will complain that it needs lifetime specifiers:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling structs v0.1.0 (file:///projects/structs)\nerror[E0106]: missing lifetime specifier\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:3:15</span>\n  |\n3 |     username: &amp;str,\n  |               ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User&lt;'a&gt; {\n2 |     active: bool,\n3 ~     username: &amp;'a str,\n  |\n\nerror[E0106]: missing lifetime specifier\n<span class=\"hljs-meta\"> --&gt;</span><span class=\"bash\"> src/main.rs:4:12</span>\n  |\n4 |     email: &amp;str,\n  |            ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User&lt;'a&gt; {\n2 |     active: bool,\n3 |     username: &amp;str,\n4 ~     email: &amp;'a str,\n  |\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `structs` (bin \"structs\") due to 2 previous errors\n</code></pre>\n<p>In Chapter 10, we’ll discuss how to fix these errors so you can store\nreferences in structs, but for now, we’ll fix errors like these using owned\ntypes like <code class=\"hljs\">String</code> instead of references like <code class=\"hljs\">&amp;str</code>.</p>\n</section>\n<!-- manual-regeneration\nfor the error above\nafter running update-rustc.sh:\npbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt\npaste above\nadd `> ` before every line -->\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch05-00-structs.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch05-02-example-structs.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch05-00-structs.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch05-02-example-structs.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:16.356Z"
}