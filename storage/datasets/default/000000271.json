{
	"title": "std::fmt - Rust",
	"url": "https://doc.rust-lang.org/stable/std/fmt/index.html",
	"markdown": "# std::fmt - Rust\n\n## Module [std](../index.html)::[fmt](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/alloc/lib.rs.html#245) ·\n\nExpand description\n\nUtilities for formatting and printing `String`s.\n\nThis module contains the runtime support for the [`format!`](../macro.format.html \"macro std::format\") syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.\n\n## [§](#usage)Usage\n\nThe [`format!`](../macro.format.html \"macro std::format\") macro is intended to be familiar to those coming from C’s `printf`/`fprintf` functions or Python’s `str.format` function.\n\nSome examples of the [`format!`](../macro.format.html \"macro std::format\") extension are:\n\n```\nformat!(\"Hello\");                 // => \"Hello\"\nformat!(\"Hello, {}!\", \"world\");   // => \"Hello, world!\"\nformat!(\"The number is {}\", 1);   // => \"The number is 1\"\nformat!(\"{:?}\", (3, 4));          // => \"(3, 4)\"\nformat!(\"{value}\", value=4);      // => \"4\"\nlet people = \"Rustaceans\";\nformat!(\"Hello {people}!\");       // => \"Hello Rustaceans!\"\nformat!(\"{} {}\", 1, 2);           // => \"1 2\"\nformat!(\"{:04}\", 42);             // => \"0042\" with leading zeros\nformat!(\"{:#?}\", (100, 200));     // => \"(\n                                  //       100,\n                                  //       200,\n                                  //     )\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!(%22Hello%22);+++++++++++++++++//+=%3E+%22Hello%22%0A++++format!(%22Hello,+%7B%7D!%22,+%22world%22);+++//+=%3E+%22Hello,+world!%22%0A++++format!(%22The+number+is+%7B%7D%22,+1);+++//+=%3E+%22The+number+is+1%22%0A++++format!(%22%7B:?%7D%22,+(3,+4));++++++++++//+=%3E+%22(3,+4)%22%0A++++format!(%22%7Bvalue%7D%22,+value=4);++++++//+=%3E+%224%22%0A++++let+people+=+%22Rustaceans%22;%0A++++format!(%22Hello+%7Bpeople%7D!%22);+++++++//+=%3E+%22Hello+Rustaceans!%22%0A++++format!(%22%7B%7D+%7B%7D%22,+1,+2);+++++++++++//+=%3E+%221+2%22%0A++++format!(%22%7B:04%7D%22,+42);+++++++++++++//+=%3E+%220042%22+with+leading+zeros%0A++++format!(%22%7B:%23?%7D%22,+(100,+200));+++++//+=%3E+%22(%0A++++++++++++++++++++++++++++++++++++++//+++++++100,%0A++++++++++++++++++++++++++++++++++++++//+++++++200,%0A++++++++++++++++++++++++++++++++++++++//+++++)%22%0A%7D&edition=2021)\n\nFrom these, you can see that the first argument is a format string. It is required by the compiler for this to be a string literal; it cannot be a variable passed in (in order to perform validity checking). The compiler will then parse the format string and determine if the list of arguments provided is suitable to pass to this format string.\n\nTo convert a single value to a string, use the [`to_string`](about:blank/string/trait.ToString.html#tymethod.to_string \"ToString::to_string\") method. This will use the [`Display`](trait.Display.html \"trait std::fmt::Display\") formatting trait.\n\n### [§](#positional-parameters)Positional parameters\n\nEach formatting argument is allowed to specify which value argument it’s referencing, and if omitted it is assumed to be “the next argument”. For example, the format string `{} {} {}` would take three parameters, and they would be formatted in the same order as they’re given. The format string `{2} {1} {0}`, however, would format arguments in reverse order.\n\nThings can get a little tricky once you start intermingling the two types of positional specifiers. The “next argument” specifier can be thought of as an iterator over the argument. Each time a “next argument” specifier is seen, the iterator advances. This leads to behavior like this:\n\n```\nformat!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!(%22%7B1%7D+%7B%7D+%7B0%7D+%7B%7D%22,+1,+2);+//+=%3E+%222+1+1+2%22%0A%7D&edition=2021)\n\nThe internal iterator over the argument has not been advanced by the time the first `{}` is seen, so it prints the first argument. Then upon reaching the second `{}`, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.\n\nA format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.\n\n### [§](#named-parameters)Named parameters\n\nRust itself does not have a Python-like equivalent of named parameters to a function, but the [`format!`](../macro.format.html \"macro std::format\") macro is a syntax extension that allows it to leverage named parameters. Named parameters are listed at the end of the argument list and have the syntax:\n\n```text\nidentifier '=' expression\n\n```\n\nFor example, the following [`format!`](../macro.format.html \"macro std::format\") expressions all use named arguments:\n\n```\nformat!(\"{argument}\", argument = \"test\");   // => \"test\"\nformat!(\"{name} {}\", 1, name = 2);          // => \"2 1\"\nformat!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!(%22%7Bargument%7D%22,+argument+=+%22test%22);+++//+=%3E+%22test%22%0A++++format!(%22%7Bname%7D+%7B%7D%22,+1,+name+=+2);++++++++++//+=%3E+%222+1%22%0A++++format!(%22%7Ba%7D+%7Bc%7D+%7Bb%7D%22,+a=%22a%22,+b=%27b%27,+c=3);++//+=%3E+%22a+3+b%22%0A%7D&edition=2021)\n\nIf a named parameter does not appear in the argument list, `format!` will reference a variable with that name in the current scope.\n\n```\nlet argument = 2 + 2;\nformat!(\"{argument}\");   // => \"4\"\n\nfn make_string(a: u32, b: &str) -> String {\n    format!(\"{b} {a}\")\n}\nmake_string(927, \"label\"); // => \"label 927\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+argument+=+2+%2B+2;%0A++++format!(%22%7Bargument%7D%22);+++//+=%3E+%224%22%0A++++%0A++++fn+make_string(a:+u32,+b:+%26str)+-%3E+String+%7B%0A++++++++format!(%22%7Bb%7D+%7Ba%7D%22)%0A++++%7D%0A++++make_string(927,+%22label%22);+//+=%3E+%22label+927%22%0A%7D&edition=2021)\n\nIt is not valid to put positional parameters (those without names) after arguments that have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.\n\n## [§](#formatting-parameters)Formatting Parameters\n\nEach argument being formatted can be transformed by a number of formatting parameters (corresponding to `format_spec` in [the syntax](#syntax)). These parameters affect the string representation of what’s being formatted.\n\n### [§](#width)Width\n\n```\n// All of these print \"Hello x    !\"\nprintln!(\"Hello {:5}!\", \"x\");\nprintln!(\"Hello {:1$}!\", \"x\", 5);\nprintln!(\"Hello {1:0$}!\", 5, \"x\");\nprintln!(\"Hello {:width$}!\", \"x\", width = 5);\nlet width = 5;\nprintln!(\"Hello {:width$}!\", \"x\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+All+of+these+print+%22Hello+x++++!%22%0Afn+main()+%7B%0A++++println!(%22Hello+%7B:5%7D!%22,+%22x%22);%0A++++println!(%22Hello+%7B:1%24%7D!%22,+%22x%22,+5);%0A++++println!(%22Hello+%7B1:0%24%7D!%22,+5,+%22x%22);%0A++++println!(%22Hello+%7B:width%24%7D!%22,+%22x%22,+width+=+5);%0A++++let+width+=+5;%0A++++println!(%22Hello+%7B:width%24%7D!%22,+%22x%22);%0A%7D&edition=2021)\n\nThis is a parameter for the “minimum width” that the format should take up. If the value’s string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space (see below).\n\nThe value for the width can also be provided as a [`usize`](../primitive.usize.html \"primitive usize\") in the list of parameters by adding a postfix `$`, indicating that the second argument is a [`usize`](../primitive.usize.html \"primitive usize\") specifying the width.\n\nReferring to an argument with the dollar syntax does not affect the “next argument” counter, so it’s usually a good idea to refer to arguments by position, or use named arguments.\n\n### [§](#fillalignment)Fill/Alignment\n\n```\nassert_eq!(format!(\"Hello {:<5}!\", \"x\"),  \"Hello x    !\");\nassert_eq!(format!(\"Hello {:-<5}!\", \"x\"), \"Hello x----!\");\nassert_eq!(format!(\"Hello {:^5}!\", \"x\"),  \"Hello   x  !\");\nassert_eq!(format!(\"Hello {:>5}!\", \"x\"),  \"Hello     x!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22Hello+%7B:%3C5%7D!%22,+%22x%22),++%22Hello+x++++!%22);%0A++++assert_eq!(format!(%22Hello+%7B:-%3C5%7D!%22,+%22x%22),+%22Hello+x----!%22);%0A++++assert_eq!(format!(%22Hello+%7B:%5E5%7D!%22,+%22x%22),++%22Hello+++x++!%22);%0A++++assert_eq!(format!(%22Hello+%7B:%3E5%7D!%22,+%22x%22),++%22Hello+++++x!%22);%0A%7D&edition=2021)\n\nThe optional fill character and alignment is provided normally in conjunction with the [`width`](#width) parameter. It must be defined before `width`, right after the `:`. This indicates that if the value being formatted is smaller than `width` some extra characters will be printed around it. Filling comes in the following variants for different alignments:\n\n-   `[fill]<` - the argument is left-aligned in `width` columns\n-   `[fill]^` - the argument is center-aligned in `width` columns\n-   `[fill]>` - the argument is right-aligned in `width` columns\n\nThe default [fill/alignment](#fillalignment) for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the `0` flag (see below) is specified for numerics, then the implicit fill character is `0`.\n\nNote that alignment might not be implemented by some types. In particular, it is not generally implemented for the `Debug` trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:\n\n```\nprintln!(\"Hello {:^15}!\", format!(\"{:?}\", Some(\"hi\"))); // => \"Hello   Some(\"hi\")   !\"\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22Hello+%7B:%5E15%7D!%22,+format!(%22%7B:?%7D%22,+Some(%22hi%22)));+//+=%3E+%22Hello+++Some(%22hi%22)+++!%22%0A%7D&edition=2021)\n\n### [§](#sign0)Sign/`#`/`0`\n\n```\nassert_eq!(format!(\"Hello {:+}!\", 5), \"Hello +5!\");\nassert_eq!(format!(\"{:#x}!\", 27), \"0x1b!\");\nassert_eq!(format!(\"Hello {:05}!\", 5),  \"Hello 00005!\");\nassert_eq!(format!(\"Hello {:05}!\", -5), \"Hello -0005!\");\nassert_eq!(format!(\"{:#010x}!\", 27), \"0x0000001b!\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22Hello+%7B:%2B%7D!%22,+5),+%22Hello+%2B5!%22);%0A++++assert_eq!(format!(%22%7B:%23x%7D!%22,+27),+%220x1b!%22);%0A++++assert_eq!(format!(%22Hello+%7B:05%7D!%22,+5),++%22Hello+00005!%22);%0A++++assert_eq!(format!(%22Hello+%7B:05%7D!%22,+-5),+%22Hello+-0005!%22);%0A++++assert_eq!(format!(%22%7B:%23010x%7D!%22,+27),+%220x0000001b!%22);%0A%7D&edition=2021)\n\nThese are all flags altering the behavior of the formatter.\n\n-   `+` - This is intended for numeric types and indicates that the sign should always be printed. By default only the negative sign of signed values is printed, and the sign of positive or unsigned values is omitted. This flag indicates that the correct sign (`+` or `-`) should always be printed.\n    \n-   `-` - Currently not used\n    \n-   `#` - This flag indicates that the “alternate” form of printing should be used. The alternate forms are:\n    \n    -   `#?` - pretty-print the [`Debug`](trait.Debug.html \"trait std::fmt::Debug\") formatting (adds linebreaks and indentation)\n    -   `#x` - precedes the argument with a `0x`\n    -   `#X` - precedes the argument with a `0x`\n    -   `#b` - precedes the argument with a `0b`\n    -   `#o` - precedes the argument with a `0o`\n    \n    See [Formatting traits](#formatting-traits) for a description of what the `?`, `x`, `X`, `b`, and `o` flags do.\n    \n-   `0` - This is used to indicate for integer formats that the padding to `width` should both be done with a `0` character as well as be sign-aware. A format like `{:08}` would yield `00000001` for the integer `1`, while the same format would yield `-0000001` for the integer `-1`. Notice that the negative version has one fewer zero than the positive version. Note that padding zeros are always placed after the sign (if any) and before the digits. When used together with the `#` flag, a similar rule applies: padding zeros are inserted after the prefix but before the digits. The prefix is included in the total width. This flag overrides the [fill character and alignment flag](#fillalignment).\n    \n\n### [§](#precision)Precision\n\nFor non-numeric types, this can be considered a “maximum width”. If the resulting string is longer than this width, then it is truncated down to this many characters and that truncated value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n\nFor integral types, this is ignored.\n\nFor floating-point types, this indicates how many digits after the decimal point should be printed.\n\nThere are three possible ways to specify the desired `precision`:\n\n1.  An integer `.N`:\n    \n    the integer `N` itself is the precision.\n    \n2.  An integer or name followed by dollar sign `.N$`:\n    \n    use format _argument_ `N` (which must be a `usize`) as the precision.\n    \n3.  An asterisk `.*`:\n    \n    `.*` means that this `{...}` is associated with _two_ format inputs rather than one:\n    \n    -   If a format string in the fashion of `{:<spec>.*}` is used, then the first input holds the `usize` precision, and the second holds the value to print.\n    -   If a format string in the fashion of `{<arg>:<spec>.*}` is used, then the `<arg>` part refers to the value to print, and the `precision` is taken like it was specified with an omitted positional parameter (`{}` instead of `{<arg>:}`).\n\nFor example, the following calls all print the same thing `Hello x is 0.01000`:\n\n```\n// Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\nprintln!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n\n// Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\nprintln!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n\n// Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\nprintln!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n\n// Hello {next arg -> arg 0 (\"x\")} is {second of next two args -> arg 2 (0.01) with precision\n//                          specified in first of next two args -> arg 1 (5)}\nprintln!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n\n// Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision\n//                          specified in next arg -> arg 0 (5)}\nprintln!(\"Hello {1} is {2:.*}\",  5, \"x\", 0.01);\n\n// Hello {next arg -> arg 0 (\"x\")} is {arg 2 (0.01) with precision\n//                          specified in next arg -> arg 1 (5)}\nprintln!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n\n// Hello {next arg -> arg 0 (\"x\")} is {arg \"number\" (0.01) with precision specified\n//                          in arg \"prec\" (5)}\nprintln!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Hello+%7Barg+0+(%22x%22)%7D+is+%7Barg+1+(0.01)+with+precision+specified+inline+(5)%7D%0Afn+main()+%7B%0A++++println!(%22Hello+%7B0%7D+is+%7B1:.5%7D%22,+%22x%22,+0.01);%0A++++%0A++++//+Hello+%7Barg+1+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+arg+0+(5)%7D%0A++++println!(%22Hello+%7B1%7D+is+%7B2:.0%24%7D%22,+5,+%22x%22,+0.01);%0A++++%0A++++//+Hello+%7Barg+0+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+arg+1+(5)%7D%0A++++println!(%22Hello+%7B0%7D+is+%7B2:.1%24%7D%22,+%22x%22,+5,+0.01);%0A++++%0A++++//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Bsecond+of+next+two+args+-%3E+arg+2+(0.01)+with+precision%0A++++//++++++++++++++++++++++++++specified+in+first+of+next+two+args+-%3E+arg+1+(5)%7D%0A++++println!(%22Hello+%7B%7D+is+%7B:.*%7D%22,++++%22x%22,+5,+0.01);%0A++++%0A++++//+Hello+%7Barg+1+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision%0A++++//++++++++++++++++++++++++++specified+in+next+arg+-%3E+arg+0+(5)%7D%0A++++println!(%22Hello+%7B1%7D+is+%7B2:.*%7D%22,++5,+%22x%22,+0.01);%0A++++%0A++++//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision%0A++++//++++++++++++++++++++++++++specified+in+next+arg+-%3E+arg+1+(5)%7D%0A++++println!(%22Hello+%7B%7D+is+%7B2:.*%7D%22,+++%22x%22,+5,+0.01);%0A++++%0A++++//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Barg+%22number%22+(0.01)+with+precision+specified%0A++++//++++++++++++++++++++++++++in+arg+%22prec%22+(5)%7D%0A++++println!(%22Hello+%7B%7D+is+%7Bnumber:.prec%24%7D%22,+%22x%22,+prec+=+5,+number+=+0.01);%0A%7D&edition=2021)\n\nWhile these:\n\n```\nprintln!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\nprintln!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\nprintln!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D,+%60%7Bname:.*%7D%60+has+3+fractional+digits%22,+%22Hello%22,+3,+name=1234.56);%0A++++println!(%22%7B%7D,+%60%7Bname:.*%7D%60+has+3+characters%22,+%22Hello%22,+3,+name=%221234.56%22);%0A++++println!(%22%7B%7D,+%60%7Bname:%3E8.*%7D%60+has+3+right-aligned+characters%22,+%22Hello%22,+3,+name=%221234.56%22);%0A%7D&edition=2021)\n\nprint three significantly different things:\n\n```text\nHello, `1234.560` has 3 fractional digits\nHello, `123` has 3 characters\nHello, `     123` has 3 right-aligned characters\n\n```\n\nWhen truncating these values, Rust uses [round half-to-even](https://en.wikipedia.org/wiki/Rounding#Rounding_half_to_even), which is the default rounding mode in IEEE 754. For example,\n\n```\nprint!(\"{0:.1$e}\", 12345, 3);\nprint!(\"{0:.1$e}\", 12355, 3);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++print!(%22%7B0:.1%24e%7D%22,+12345,+3);%0A++++print!(%22%7B0:.1%24e%7D%22,+12355,+3);%0A%7D&edition=2021)\n\nWould return:\n\n### [§](#localization)Localization\n\nIn some programming languages, the behavior of string formatting functions depends on the operating system’s locale setting. The format functions provided by Rust’s standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.\n\nFor example, the following code will always print `1.5` even if the system locale uses a decimal separator other than a dot.\n\n```\nprintln!(\"The value is {}\", 1.5);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22The+value+is+%7B%7D%22,+1.5);%0A%7D&edition=2021)\n\n## [§](#escaping)Escaping\n\nThe literal characters `{` and `}` may be included in a string by preceding them with the same character. For example, the `{` character is escaped with `{{` and the `}` character is escaped with `}}`.\n\n```\nassert_eq!(format!(\"Hello {{}}\"), \"Hello {}\");\nassert_eq!(format!(\"{{ Hello\"), \"{ Hello\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22Hello+%7B%7B%7D%7D%22),+%22Hello+%7B%7D%22);%0A++++assert_eq!(format!(%22%7B%7B+Hello%22),+%22%7B+Hello%22);%0A%7D&edition=2021)\n\n## [§](#syntax)Syntax\n\nTo summarize, here you can find the full grammar of format strings. The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by `{}` instead of the C-like `%`. The actual grammar for the formatting syntax is:\n\n```text\nformat_string := text [ maybe_format text ] *\nmaybe_format := '{' '{' | '}' '}' | format\nformat := '{' [ argument ] [ ':' format_spec ] [ ws ] * '}'\nargument := integer | identifier\n\nformat_spec := [[fill]align][sign]['#']['0'][width]['.' precision]type\nfill := character\nalign := '<' | '^' | '>'\nsign := '+' | '-'\nwidth := count\nprecision := count | '*'\ntype := '' | '?' | 'x?' | 'X?' | identifier\ncount := parameter | integer\nparameter := argument '$'\n\n```\n\nIn the above grammar,\n\n-   `text` must not contain any `'{'` or `'}'` characters,\n-   `ws` is any character for which [`char::is_whitespace`](about:blank/primitive.char.html#method.is_whitespace \"method char::is_whitespace\") returns `true`, has no semantic meaning and is completely optional,\n-   `integer` is a decimal integer that may contain leading zeroes and must fit into an `usize` and\n-   `identifier` is an `IDENTIFIER_OR_KEYWORD` (not an `IDENTIFIER`) as defined by the [Rust language reference](https://doc.rust-lang.org/reference/identifiers.html).\n\n## [§](#formatting-traits)Formatting traits\n\nWhen requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via `{:x}` (like [`i8`](../primitive.i8.html \"primitive i8\") as well as [`isize`](../primitive.isize.html \"primitive isize\")). The current mapping of types to traits is:\n\n-   _nothing_ ⇒ [`Display`](trait.Display.html \"trait std::fmt::Display\")\n-   `?` ⇒ [`Debug`](trait.Debug.html \"trait std::fmt::Debug\")\n-   `x?` ⇒ [`Debug`](trait.Debug.html \"trait std::fmt::Debug\") with lower-case hexadecimal integers\n-   `X?` ⇒ [`Debug`](trait.Debug.html \"trait std::fmt::Debug\") with upper-case hexadecimal integers\n-   `o` ⇒ [`Octal`](trait.Octal.html \"trait std::fmt::Octal\")\n-   `x` ⇒ [`LowerHex`](trait.LowerHex.html \"trait std::fmt::LowerHex\")\n-   `X` ⇒ [`UpperHex`](trait.UpperHex.html \"trait std::fmt::UpperHex\")\n-   `p` ⇒ [`Pointer`](trait.Pointer.html \"trait std::fmt::Pointer\")\n-   `b` ⇒ [`Binary`](trait.Binary.html \"trait std::fmt::Binary\")\n-   `e` ⇒ [`LowerExp`](trait.LowerExp.html \"trait std::fmt::LowerExp\")\n-   `E` ⇒ [`UpperExp`](trait.UpperExp.html \"trait std::fmt::UpperExp\")\n\nWhat this means is that any type of argument which implements the [`fmt::Binary`](trait.Binary.html \"trait std::fmt::Binary\") trait can then be formatted with `{:b}`. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in `{}` or `{:6}`), then the format trait used is the [`Display`](trait.Display.html \"trait std::fmt::Display\") trait.\n\nWhen implementing a format trait for your own type, you will have to implement a method of the signature:\n\n```\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::fmt;%0A++++struct+Foo;+//+our+custom+type%0A++++impl+fmt::Display+for+Foo+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C%27_%3E)+-%3E+fmt::Result+%7B%0A++++write!(f,+%22testing,+testing%22)%0A++++%7D+%7D%0A%7D&edition=2021)\n\nYour type will be passed as `self` by-reference, and then the function should emit output into the Formatter `f` which implements `fmt::Write`. It is up to each format trait implementation to correctly adhere to the requested formatting parameters. The values of these parameters can be accessed with methods of the [`Formatter`](struct.Formatter.html \"struct std::fmt::Formatter\") struct. In order to help with this, the [`Formatter`](struct.Formatter.html \"struct std::fmt::Formatter\") struct also provides some helper methods.\n\nAdditionally, the return value of this function is [`fmt::Result`](type.Result.html \"fmt::Result\") which is a type alias of `[Result](../result/enum.Result.html \"std::result::Result\")<(), [std::fmt::Error](struct.Error.html \"fmt::Error\")>`. Formatting implementations should ensure that they propagate errors from the [`Formatter`](struct.Formatter.html \"struct std::fmt::Formatter\") (e.g., when calling [`write!`](../macro.write.html \"macro std::write\")). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in [`Formatter`](struct.Formatter.html \"struct std::fmt::Formatter\") returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a [`Result`](type.Result.html \"type std::fmt::Result\") because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.\n\nAn example of implementing the formatting traits would look like:\n\n```\nuse std::fmt;\n\n#[derive(Debug)]\nstruct Vector2D {\n    x: isize,\n    y: isize,\n}\n\nimpl fmt::Display for Vector2D {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // The `f` value implements the `Write` trait, which is what the\n        // write! macro is expecting. Note that this formatting ignores the\n        // various flags provided to format strings.\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n\n// Different traits allow different forms of output of a type. The meaning\n// of this format is to print the magnitude of a vector.\nimpl fmt::Binary for Vector2D {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n        let magnitude = magnitude.sqrt();\n\n        // Respect the formatting flags by using the helper method\n        // `pad_integral` on the Formatter object. See the method\n        // documentation for details, and the function `pad` can be used\n        // to pad strings.\n        let decimals = f.precision().unwrap_or(3);\n        let string = format!(\"{magnitude:.decimals$}\");\n        f.pad_integral(true, \"\", &string)\n    }\n}\n\nfn main() {\n    let myvector = Vector2D { x: 3, y: 4 };\n\n    println!(\"{myvector}\");       // => \"(3, 4)\"\n    println!(\"{myvector:?}\");     // => \"Vector2D {x: 3, y:4}\"\n    println!(\"{myvector:10.3b}\"); // => \"     5.000\"\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fmt;%0A%0A%23%5Bderive(Debug)%5D%0Astruct+Vector2D+%7B%0A++++x:+isize,%0A++++y:+isize,%0A%7D%0A%0Aimpl+fmt::Display+for+Vector2D+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C%27_%3E)+-%3E+fmt::Result+%7B%0A++++++++//+The+%60f%60+value+implements+the+%60Write%60+trait,+which+is+what+the%0A++++++++//+write!+macro+is+expecting.+Note+that+this+formatting+ignores+the%0A++++++++//+various+flags+provided+to+format+strings.%0A++++++++write!(f,+%22(%7B%7D,+%7B%7D)%22,+self.x,+self.y)%0A++++%7D%0A%7D%0A%0A//+Different+traits+allow+different+forms+of+output+of+a+type.+The+meaning%0A//+of+this+format+is+to+print+the+magnitude+of+a+vector.%0Aimpl+fmt::Binary+for+Vector2D+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C%27_%3E)+-%3E+fmt::Result+%7B%0A++++++++let+magnitude+=+(self.x+*+self.x+%2B+self.y+*+self.y)+as+f64;%0A++++++++let+magnitude+=+magnitude.sqrt();%0A%0A++++++++//+Respect+the+formatting+flags+by+using+the+helper+method%0A++++++++//+%60pad_integral%60+on+the+Formatter+object.+See+the+method%0A++++++++//+documentation+for+details,+and+the+function+%60pad%60+can+be+used%0A++++++++//+to+pad+strings.%0A++++++++let+decimals+=+f.precision().unwrap_or(3);%0A++++++++let+string+=+format!(%22%7Bmagnitude:.decimals%24%7D%22);%0A++++++++f.pad_integral(true,+%22%22,+%26string)%0A++++%7D%0A%7D%0A%0Afn+main()+%7B%0A++++let+myvector+=+Vector2D+%7B+x:+3,+y:+4+%7D;%0A%0A++++println!(%22%7Bmyvector%7D%22);+++++++//+=%3E+%22(3,+4)%22%0A++++println!(%22%7Bmyvector:?%7D%22);+++++//+=%3E+%22Vector2D+%7Bx:+3,+y:4%7D%22%0A++++println!(%22%7Bmyvector:10.3b%7D%22);+//+=%3E+%22+++++5.000%22%0A%7D&edition=2021)\n\n#### [§](#fmtdisplay-vs-fmtdebug)`fmt::Display` vs `fmt::Debug`\n\nThese two formatting traits have distinct purposes:\n\n-   [`fmt::Display`](trait.Display.html \"trait std::fmt::Display\") implementations assert that the type can be faithfully represented as a UTF-8 string at all times. It is **not** expected that all types implement the [`Display`](trait.Display.html \"trait std::fmt::Display\") trait.\n-   [`fmt::Debug`](trait.Debug.html \"trait std::fmt::Debug\") implementations should be implemented for **all** public types. Output will typically represent the internal state as faithfully as possible. The purpose of the [`Debug`](trait.Debug.html \"trait std::fmt::Debug\") trait is to facilitate debugging Rust code. In most cases, using `#[derive(Debug)]` is sufficient and recommended.\n\nSome examples of the output from both traits:\n\n```\nassert_eq!(format!(\"{} {:?}\", 3, 4), \"3 4\");\nassert_eq!(format!(\"{} {:?}\", 'a', 'b'), \"a 'b'\");\nassert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+3,+4),+%223+4%22);%0A++++assert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+%27a%27,+%27b%27),+%22a+%27b%27%22);%0A++++assert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+%22foo%5Cn%22,+%22bar%5Cn%22),+%22foo%5Cn+%5C%22bar%5C%5Cn%5C%22%22);%0A%7D&edition=2021)\n\nThere are a number of related macros in the [`format!`](../macro.format.html \"macro std::format\") family. The ones that are currently implemented are:\n\n[ⓘ](# \"This example is not tested\")\n\n```\nformat!      // described above\nwrite!       // first argument is either a &mut io::Write or a &mut fmt::Write, the destination\nwriteln!     // same as write but appends a newline\nprint!       // the format string is printed to the standard output\nprintln!     // same as print but appends a newline\neprint!      // the format string is printed to the standard error\neprintln!    // same as eprint but appends a newline\nformat_args! // described below.\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!++++++//+described+above%0A++++write!+++++++//+first+argument+is+either+a+%26mut+io::Write+or+a+%26mut+fmt::Write,+the+destination%0A++++writeln!+++++//+same+as+write+but+appends+a+newline%0A++++print!+++++++//+the+format+string+is+printed+to+the+standard+output%0A++++println!+++++//+same+as+print+but+appends+a+newline%0A++++eprint!++++++//+the+format+string+is+printed+to+the+standard+error%0A++++eprintln!++++//+same+as+eprint+but+appends+a+newline%0A++++format_args!+//+described+below.%0A%7D&edition=2021)\n\n#### [§](#write)`write!`\n\n[`write!`](../macro.write.html \"macro std::write\") and [`writeln!`](../macro.writeln.html \"macro std::writeln\") are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the [`write_fmt`](about:blank/std/io/trait.Write.html#method.write_fmt) function defined on the [`std::io::Write`](../../std/io/trait.Write.html) and the [`std::fmt::Write`](../../std/fmt/trait.Write.html) trait. Example usage is:\n\n```\nuse std::io::Write;\nlet mut w = Vec::new();\nwrite!(&mut w, \"Hello {}!\", \"world\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn+main()+%7B%0A++++use+std::io::Write;%0A++++let+mut+w+=+Vec::new();%0A++++write!(%26mut+w,+%22Hello+%7B%7D!%22,+%22world%22);%0A%7D&edition=2021)\n\n#### [§](#print)`print!`\n\nThis and [`println!`](../../std/macro.println.html \"println!\") emit their output to stdout. Similarly to the [`write!`](../macro.write.html \"macro std::write\") macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:\n\n```\nprint!(\"Hello {}!\", \"world\");\nprintln!(\"I have a newline {}\", \"character at the end\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++print!(%22Hello+%7B%7D!%22,+%22world%22);%0A++++println!(%22I+have+a+newline+%7B%7D%22,+%22character+at+the+end%22);%0A%7D&edition=2021)\n\n#### [§](#eprint)`eprint!`\n\nThe [`eprint!`](../../std/macro.eprint.html \"eprint!\") and [`eprintln!`](../../std/macro.eprintln.html \"eprintln!\") macros are identical to [`print!`](../../std/macro.print.html \"print!\") and [`println!`](../../std/macro.println.html \"println!\"), respectively, except they emit their output to stderr.\n\n#### [§](#format_args)`format_args!`\n\n[`format_args!`](../../std/macro.format_args.html \"format_args!\") is a curious macro used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:\n\n```\nuse std::fmt;\nuse std::io::{self, Write};\n\nlet mut some_writer = io::stdout();\nwrite!(&mut some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n\nfn my_fmt_fn(args: fmt::Arguments<'_>) {\n    write!(&mut io::stdout(), \"{args}\");\n}\nmy_fmt_fn(format_args!(\", or a {} too\", \"function\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn+main()+%7B%0A++++use+std::fmt;%0A++++use+std::io::%7Bself,+Write%7D;%0A++++%0A++++let+mut+some_writer+=+io::stdout();%0A++++write!(%26mut+some_writer,+%22%7B%7D%22,+format_args!(%22print+with+a+%7B%7D%22,+%22macro%22));%0A++++%0A++++fn+my_fmt_fn(args:+fmt::Arguments%3C%27_%3E)+%7B%0A++++++++write!(%26mut+io::stdout(),+%22%7Bargs%7D%22);%0A++++%7D%0A++++my_fmt_fn(format_args!(%22,+or+a+%7B%7D+too%22,+%22function%22));%0A%7D&edition=2021)\n\nThe result of the [`format_args!`](../../std/macro.format_args.html \"format_args!\") macro is a value of type [`fmt::Arguments`](struct.Arguments.html \"fmt::Arguments\"). This structure can then be passed to the [`write`](fn.write.html \"fmt::write\") and [`format`](fn.format.html \"fmt::format\") functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.\n\nFor example, a logging library could use the standard formatting syntax, but it would internally pass around this structure until it has been determined where output should go to.\n\n-   This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.\n    \n-   A struct to help with [`fmt::Debug`](trait.Debug.html \"trait std::fmt::Debug\") implementations.\n    \n-   A struct to help with [`fmt::Debug`](trait.Debug.html \"trait std::fmt::Debug\") implementations.\n    \n-   A struct to help with [`fmt::Debug`](trait.Debug.html \"trait std::fmt::Debug\") implementations.\n    \n-   A struct to help with [`fmt::Debug`](trait.Debug.html \"trait std::fmt::Debug\") implementations.\n    \n-   A struct to help with [`fmt::Debug`](trait.Debug.html \"trait std::fmt::Debug\") implementations.\n    \n-   The error type which is returned from formatting a message into a stream.\n    \n-   Configuration for formatting.\n    \n\n-   Possible alignments returned by `Formatter::align`\n    \n\n-   `b` formatting.\n    \n-   `?` formatting.\n    \n-   Format trait for an empty format, `{}`.\n    \n-   `e` formatting.\n    \n-   `x` formatting.\n    \n-   `o` formatting.\n    \n-   `p` formatting.\n    \n-   `E` formatting.\n    \n-   `X` formatting.\n    \n-   A trait for writing or formatting into Unicode-accepting buffers or streams.\n    \n\n-   The `format` function takes an [`Arguments`](struct.Arguments.html \"struct std::fmt::Arguments\") struct and returns the resulting formatted string.\n    \n-   The `write` function takes an output stream, and an `Arguments` struct that can be precompiled with the `format_args!` macro.\n    \n\n-   The type returned by formatter methods.\n    \n\n-   Derive macro generating an impl of the trait `Debug`.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Utilities for formatting and printing `String`s.\"><title>std::fmt - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module fmt</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module fmt</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li><li><a href=\"#traits\">Traits</a></li><li><a href=\"#functions\">Functions</a></li><li><a href=\"#types\">Type Aliases</a></li><li><a href=\"#derives\">Derive Macros</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">fmt</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/lib.rs.html#245\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Utilities for formatting and printing <code>String</code>s.</p>\n<p>This module contains the runtime support for the <a href=\"../macro.format.html\" title=\"macro std::format\"><code>format!</code></a> syntax extension.\nThis macro is implemented in the compiler to emit calls to this module in\norder to format arguments at runtime into strings.</p>\n<h2 id=\"usage\"><a class=\"doc-anchor\" href=\"#usage\">§</a>Usage</h2>\n<p>The <a href=\"../macro.format.html\" title=\"macro std::format\"><code>format!</code></a> macro is intended to be familiar to those coming from C’s\n<code>printf</code>/<code>fprintf</code> functions or Python’s <code>str.format</code> function.</p>\n<p>Some examples of the <a href=\"../macro.format.html\" title=\"macro std::format\"><code>format!</code></a> extension are:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">format!</span>(<span class=\"string\">\"Hello\"</span>);                 <span class=\"comment\">// =&gt; \"Hello\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"Hello, {}!\"</span>, <span class=\"string\">\"world\"</span>);   <span class=\"comment\">// =&gt; \"Hello, world!\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"The number is {}\"</span>, <span class=\"number\">1</span>);   <span class=\"comment\">// =&gt; \"The number is 1\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{:?}\"</span>, (<span class=\"number\">3</span>, <span class=\"number\">4</span>));          <span class=\"comment\">// =&gt; \"(3, 4)\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{value}\"</span>, value=<span class=\"number\">4</span>);      <span class=\"comment\">// =&gt; \"4\"\n</span><span class=\"kw\">let </span>people = <span class=\"string\">\"Rustaceans\"</span>;\n<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {people}!\"</span>);       <span class=\"comment\">// =&gt; \"Hello Rustaceans!\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{} {}\"</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);           <span class=\"comment\">// =&gt; \"1 2\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{:04}\"</span>, <span class=\"number\">42</span>);             <span class=\"comment\">// =&gt; \"0042\" with leading zeros\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{:#?}\"</span>, (<span class=\"number\">100</span>, <span class=\"number\">200</span>));     <span class=\"comment\">// =&gt; \"(\n                                  //       100,\n                                  //       200,\n                                  //     )\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!(%22Hello%22);+++++++++++++++++//+=%3E+%22Hello%22%0A++++format!(%22Hello,+%7B%7D!%22,+%22world%22);+++//+=%3E+%22Hello,+world!%22%0A++++format!(%22The+number+is+%7B%7D%22,+1);+++//+=%3E+%22The+number+is+1%22%0A++++format!(%22%7B:?%7D%22,+(3,+4));++++++++++//+=%3E+%22(3,+4)%22%0A++++format!(%22%7Bvalue%7D%22,+value=4);++++++//+=%3E+%224%22%0A++++let+people+=+%22Rustaceans%22;%0A++++format!(%22Hello+%7Bpeople%7D!%22);+++++++//+=%3E+%22Hello+Rustaceans!%22%0A++++format!(%22%7B%7D+%7B%7D%22,+1,+2);+++++++++++//+=%3E+%221+2%22%0A++++format!(%22%7B:04%7D%22,+42);+++++++++++++//+=%3E+%220042%22+with+leading+zeros%0A++++format!(%22%7B:%23?%7D%22,+(100,+200));+++++//+=%3E+%22(%0A++++++++++++++++++++++++++++++++++++++//+++++++100,%0A++++++++++++++++++++++++++++++++++++++//+++++++200,%0A++++++++++++++++++++++++++++++++++++++//+++++)%22%0A%7D&amp;edition=2021\">Run</a></div>\n<p>From these, you can see that the first argument is a format string. It is\nrequired by the compiler for this to be a string literal; it cannot be a\nvariable passed in (in order to perform validity checking). The compiler\nwill then parse the format string and determine if the list of arguments\nprovided is suitable to pass to this format string.</p>\n<p>To convert a single value to a string, use the <a href=\"../string/trait.ToString.html#tymethod.to_string\" title=\"ToString::to_string\"><code>to_string</code></a> method. This\nwill use the <a href=\"trait.Display.html\" title=\"trait std::fmt::Display\"><code>Display</code></a> formatting trait.</p>\n<h3 id=\"positional-parameters\"><a class=\"doc-anchor\" href=\"#positional-parameters\">§</a>Positional parameters</h3>\n<p>Each formatting argument is allowed to specify which value argument it’s\nreferencing, and if omitted it is assumed to be “the next argument”. For\nexample, the format string <code>{} {} {}</code> would take three parameters, and they\nwould be formatted in the same order as they’re given. The format string\n<code>{2} {1} {0}</code>, however, would format arguments in reverse order.</p>\n<p>Things can get a little tricky once you start intermingling the two types of\npositional specifiers. The “next argument” specifier can be thought of as an\niterator over the argument. Each time a “next argument” specifier is seen,\nthe iterator advances. This leads to behavior like this:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">format!</span>(<span class=\"string\">\"{1} {} {0} {}\"</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// =&gt; \"2 1 1 2\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!(%22%7B1%7D+%7B%7D+%7B0%7D+%7B%7D%22,+1,+2);+//+=%3E+%222+1+1+2%22%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The internal iterator over the argument has not been advanced by the time\nthe first <code>{}</code> is seen, so it prints the first argument. Then upon reaching\nthe second <code>{}</code>, the iterator has advanced forward to the second argument.\nEssentially, parameters that explicitly name their argument do not affect\nparameters that do not name an argument in terms of positional specifiers.</p>\n<p>A format string is required to use all of its arguments, otherwise it is a\ncompile-time error. You may refer to the same argument more than once in the\nformat string.</p>\n<h3 id=\"named-parameters\"><a class=\"doc-anchor\" href=\"#named-parameters\">§</a>Named parameters</h3>\n<p>Rust itself does not have a Python-like equivalent of named parameters to a\nfunction, but the <a href=\"../macro.format.html\" title=\"macro std::format\"><code>format!</code></a> macro is a syntax extension that allows it to\nleverage named parameters. Named parameters are listed at the end of the\nargument list and have the syntax:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>identifier '=' expression\n</code></pre></div>\n<p>For example, the following <a href=\"../macro.format.html\" title=\"macro std::format\"><code>format!</code></a> expressions all use named arguments:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">format!</span>(<span class=\"string\">\"{argument}\"</span>, argument = <span class=\"string\">\"test\"</span>);   <span class=\"comment\">// =&gt; \"test\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{name} {}\"</span>, <span class=\"number\">1</span>, name = <span class=\"number\">2</span>);          <span class=\"comment\">// =&gt; \"2 1\"\n</span><span class=\"macro\">format!</span>(<span class=\"string\">\"{a} {c} {b}\"</span>, a=<span class=\"string\">\"a\"</span>, b=<span class=\"string\">'b'</span>, c=<span class=\"number\">3</span>);  <span class=\"comment\">// =&gt; \"a 3 b\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!(%22%7Bargument%7D%22,+argument+=+%22test%22);+++//+=%3E+%22test%22%0A++++format!(%22%7Bname%7D+%7B%7D%22,+1,+name+=+2);++++++++++//+=%3E+%222+1%22%0A++++format!(%22%7Ba%7D+%7Bc%7D+%7Bb%7D%22,+a=%22a%22,+b='b',+c=3);++//+=%3E+%22a+3+b%22%0A%7D&amp;edition=2021\">Run</a></div>\n<p>If a named parameter does not appear in the argument list, <code>format!</code> will\nreference a variable with that name in the current scope.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>argument = <span class=\"number\">2 </span>+ <span class=\"number\">2</span>;\n<span class=\"macro\">format!</span>(<span class=\"string\">\"{argument}\"</span>);   <span class=\"comment\">// =&gt; \"4\"\n\n</span><span class=\"kw\">fn </span>make_string(a: u32, b: <span class=\"kw-2\">&amp;</span>str) -&gt; String {\n    <span class=\"macro\">format!</span>(<span class=\"string\">\"{b} {a}\"</span>)\n}\nmake_string(<span class=\"number\">927</span>, <span class=\"string\">\"label\"</span>); <span class=\"comment\">// =&gt; \"label 927\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+argument+=+2+%2B+2;%0A++++format!(%22%7Bargument%7D%22);+++//+=%3E+%224%22%0A++++%0A++++fn+make_string(a:+u32,+b:+%26str)+-%3E+String+%7B%0A++++++++format!(%22%7Bb%7D+%7Ba%7D%22)%0A++++%7D%0A++++make_string(927,+%22label%22);+//+=%3E+%22label+927%22%0A%7D&amp;edition=2021\">Run</a></div>\n<p>It is not valid to put positional parameters (those without names) after\narguments that have names. Like with positional parameters, it is not\nvalid to provide named parameters that are unused by the format string.</p>\n<h2 id=\"formatting-parameters\"><a class=\"doc-anchor\" href=\"#formatting-parameters\">§</a>Formatting Parameters</h2>\n<p>Each argument being formatted can be transformed by a number of formatting\nparameters (corresponding to <code>format_spec</code> in <a href=\"#syntax\">the syntax</a>). These\nparameters affect the string representation of what’s being formatted.</p>\n<h3 id=\"width\"><a class=\"doc-anchor\" href=\"#width\">§</a>Width</h3>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// All of these print \"Hello x    !\"\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {:5}!\"</span>, <span class=\"string\">\"x\"</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {:1$}!\"</span>, <span class=\"string\">\"x\"</span>, <span class=\"number\">5</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {1:0$}!\"</span>, <span class=\"number\">5</span>, <span class=\"string\">\"x\"</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {:width$}!\"</span>, <span class=\"string\">\"x\"</span>, width = <span class=\"number\">5</span>);\n<span class=\"kw\">let </span>width = <span class=\"number\">5</span>;\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {:width$}!\"</span>, <span class=\"string\">\"x\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+All+of+these+print+%22Hello+x++++!%22%0Afn+main()+%7B%0A++++println!(%22Hello+%7B:5%7D!%22,+%22x%22);%0A++++println!(%22Hello+%7B:1%24%7D!%22,+%22x%22,+5);%0A++++println!(%22Hello+%7B1:0%24%7D!%22,+5,+%22x%22);%0A++++println!(%22Hello+%7B:width%24%7D!%22,+%22x%22,+width+=+5);%0A++++let+width+=+5;%0A++++println!(%22Hello+%7B:width%24%7D!%22,+%22x%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>This is a parameter for the “minimum width” that the format should take up.\nIf the value’s string does not fill up this many characters, then the\npadding specified by fill/alignment will be used to take up the required\nspace (see below).</p>\n<p>The value for the width can also be provided as a <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a> in the list of\nparameters by adding a postfix <code>$</code>, indicating that the second argument is\na <a href=\"../primitive.usize.html\" title=\"primitive usize\"><code>usize</code></a> specifying the width.</p>\n<p>Referring to an argument with the dollar syntax does not affect the “next\nargument” counter, so it’s usually a good idea to refer to arguments by\nposition, or use named arguments.</p>\n<h3 id=\"fillalignment\"><a class=\"doc-anchor\" href=\"#fillalignment\">§</a>Fill/Alignment</h3>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:&lt;5}!\"</span>, <span class=\"string\">\"x\"</span>),  <span class=\"string\">\"Hello x    !\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:-&lt;5}!\"</span>, <span class=\"string\">\"x\"</span>), <span class=\"string\">\"Hello x----!\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:^5}!\"</span>, <span class=\"string\">\"x\"</span>),  <span class=\"string\">\"Hello   x  !\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:&gt;5}!\"</span>, <span class=\"string\">\"x\"</span>),  <span class=\"string\">\"Hello     x!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22Hello+%7B:%3C5%7D!%22,+%22x%22),++%22Hello+x++++!%22);%0A++++assert_eq!(format!(%22Hello+%7B:-%3C5%7D!%22,+%22x%22),+%22Hello+x----!%22);%0A++++assert_eq!(format!(%22Hello+%7B:%5E5%7D!%22,+%22x%22),++%22Hello+++x++!%22);%0A++++assert_eq!(format!(%22Hello+%7B:%3E5%7D!%22,+%22x%22),++%22Hello+++++x!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The optional fill character and alignment is provided normally in conjunction with the\n<a href=\"#width\"><code>width</code></a> parameter. It must be defined before <code>width</code>, right after the <code>:</code>.\nThis indicates that if the value being formatted is smaller than\n<code>width</code> some extra characters will be printed around it.\nFilling comes in the following variants for different alignments:</p>\n<ul>\n<li><code>[fill]&lt;</code> - the argument is left-aligned in <code>width</code> columns</li>\n<li><code>[fill]^</code> - the argument is center-aligned in <code>width</code> columns</li>\n<li><code>[fill]&gt;</code> - the argument is right-aligned in <code>width</code> columns</li>\n</ul>\n<p>The default <a href=\"#fillalignment\">fill/alignment</a> for non-numerics is a space and\nleft-aligned. The\ndefault for numeric formatters is also a space character but with right-alignment. If\nthe <code>0</code> flag (see below) is specified for numerics, then the implicit fill character is\n<code>0</code>.</p>\n<p>Note that alignment might not be implemented by some types. In particular, it\nis not generally implemented for the <code>Debug</code> trait.  A good way to ensure\npadding is applied is to format your input, then pad this resulting string\nto obtain your output:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {:^15}!\"</span>, <span class=\"macro\">format!</span>(<span class=\"string\">\"{:?}\"</span>, <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"hi\"</span>))); <span class=\"comment\">// =&gt; \"Hello   Some(\"hi\")   !\"</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22Hello+%7B:%5E15%7D!%22,+format!(%22%7B:?%7D%22,+Some(%22hi%22)));+//+=%3E+%22Hello+++Some(%22hi%22)+++!%22%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"sign0\"><a class=\"doc-anchor\" href=\"#sign0\">§</a>Sign/<code>#</code>/<code>0</code></h3>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:+}!\"</span>, <span class=\"number\">5</span>), <span class=\"string\">\"Hello +5!\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"{:#x}!\"</span>, <span class=\"number\">27</span>), <span class=\"string\">\"0x1b!\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:05}!\"</span>, <span class=\"number\">5</span>),  <span class=\"string\">\"Hello 00005!\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {:05}!\"</span>, -<span class=\"number\">5</span>), <span class=\"string\">\"Hello -0005!\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"{:#010x}!\"</span>, <span class=\"number\">27</span>), <span class=\"string\">\"0x0000001b!\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22Hello+%7B:%2B%7D!%22,+5),+%22Hello+%2B5!%22);%0A++++assert_eq!(format!(%22%7B:%23x%7D!%22,+27),+%220x1b!%22);%0A++++assert_eq!(format!(%22Hello+%7B:05%7D!%22,+5),++%22Hello+00005!%22);%0A++++assert_eq!(format!(%22Hello+%7B:05%7D!%22,+-5),+%22Hello+-0005!%22);%0A++++assert_eq!(format!(%22%7B:%23010x%7D!%22,+27),+%220x0000001b!%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>These are all flags altering the behavior of the formatter.</p>\n<ul>\n<li>\n<p><code>+</code> - This is intended for numeric types and indicates that the sign\nshould always be printed. By default only the negative sign of signed values\nis printed, and the sign of positive or unsigned values is omitted.\nThis flag indicates that the correct sign (<code>+</code> or <code>-</code>) should always be printed.</p>\n</li>\n<li>\n<p><code>-</code> - Currently not used</p>\n</li>\n<li>\n<p><code>#</code> - This flag indicates that the “alternate” form of printing should\nbe used. The alternate forms are:</p>\n<ul>\n<li><code>#?</code> - pretty-print the <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a> formatting (adds linebreaks and indentation)</li>\n<li><code>#x</code> - precedes the argument with a <code>0x</code></li>\n<li><code>#X</code> - precedes the argument with a <code>0x</code></li>\n<li><code>#b</code> - precedes the argument with a <code>0b</code></li>\n<li><code>#o</code> - precedes the argument with a <code>0o</code></li>\n</ul>\n<p>See <a href=\"#formatting-traits\">Formatting traits</a> for a description of what the <code>?</code>, <code>x</code>, <code>X</code>,\n<code>b</code>, and <code>o</code> flags do.</p>\n</li>\n<li>\n<p><code>0</code> - This is used to indicate for integer formats that the padding to <code>width</code> should\nboth be done with a <code>0</code> character as well as be sign-aware. A format\nlike <code>{:08}</code> would yield <code>00000001</code> for the integer <code>1</code>, while the\nsame format would yield <code>-0000001</code> for the integer <code>-1</code>. Notice that\nthe negative version has one fewer zero than the positive version.\nNote that padding zeros are always placed after the sign (if any)\nand before the digits. When used together with the <code>#</code> flag, a similar\nrule applies: padding zeros are inserted after the prefix but before\nthe digits. The prefix is included in the total width.\nThis flag overrides the <a href=\"#fillalignment\">fill character and alignment flag</a>.</p>\n</li>\n</ul>\n<h3 id=\"precision\"><a class=\"doc-anchor\" href=\"#precision\">§</a>Precision</h3>\n<p>For non-numeric types, this can be considered a “maximum width”. If the resulting string is\nlonger than this width, then it is truncated down to this many characters and that truncated\nvalue is emitted with proper <code>fill</code>, <code>alignment</code> and <code>width</code> if those parameters are set.</p>\n<p>For integral types, this is ignored.</p>\n<p>For floating-point types, this indicates how many digits after the decimal point should be\nprinted.</p>\n<p>There are three possible ways to specify the desired <code>precision</code>:</p>\n<ol>\n<li>\n<p>An integer <code>.N</code>:</p>\n<p>the integer <code>N</code> itself is the precision.</p>\n</li>\n<li>\n<p>An integer or name followed by dollar sign <code>.N$</code>:</p>\n<p>use format <em>argument</em> <code>N</code> (which must be a <code>usize</code>) as the precision.</p>\n</li>\n<li>\n<p>An asterisk <code>.*</code>:</p>\n<p><code>.*</code> means that this <code>{...}</code> is associated with <em>two</em> format inputs rather than one:</p>\n<ul>\n<li>If a format string in the fashion of <code>{:&lt;spec&gt;.*}</code> is used, then the first input holds\nthe <code>usize</code> precision, and the second holds the value to print.</li>\n<li>If a format string in the fashion of <code>{&lt;arg&gt;:&lt;spec&gt;.*}</code> is used, then the <code>&lt;arg&gt;</code> part\nrefers to the value to print, and the <code>precision</code> is taken like it was specified with an\nomitted positional parameter (<code>{}</code> instead of <code>{&lt;arg&gt;:}</code>).</li>\n</ul>\n</li>\n</ol>\n<p>For example, the following calls all print the same thing <code>Hello x is 0.01000</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {0} is {1:.5}\"</span>, <span class=\"string\">\"x\"</span>, <span class=\"number\">0.01</span>);\n\n<span class=\"comment\">// Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {1} is {2:.0$}\"</span>, <span class=\"number\">5</span>, <span class=\"string\">\"x\"</span>, <span class=\"number\">0.01</span>);\n\n<span class=\"comment\">// Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {0} is {2:.1$}\"</span>, <span class=\"string\">\"x\"</span>, <span class=\"number\">5</span>, <span class=\"number\">0.01</span>);\n\n<span class=\"comment\">// Hello {next arg -&gt; arg 0 (\"x\")} is {second of next two args -&gt; arg 2 (0.01) with precision\n//                          specified in first of next two args -&gt; arg 1 (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {} is {:.*}\"</span>,    <span class=\"string\">\"x\"</span>, <span class=\"number\">5</span>, <span class=\"number\">0.01</span>);\n\n<span class=\"comment\">// Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision\n//                          specified in next arg -&gt; arg 0 (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {1} is {2:.*}\"</span>,  <span class=\"number\">5</span>, <span class=\"string\">\"x\"</span>, <span class=\"number\">0.01</span>);\n\n<span class=\"comment\">// Hello {next arg -&gt; arg 0 (\"x\")} is {arg 2 (0.01) with precision\n//                          specified in next arg -&gt; arg 1 (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {} is {2:.*}\"</span>,   <span class=\"string\">\"x\"</span>, <span class=\"number\">5</span>, <span class=\"number\">0.01</span>);\n\n<span class=\"comment\">// Hello {next arg -&gt; arg 0 (\"x\")} is {arg \"number\" (0.01) with precision specified\n//                          in arg \"prec\" (5)}\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Hello {} is {number:.prec$}\"</span>, <span class=\"string\">\"x\"</span>, prec = <span class=\"number\">5</span>, number = <span class=\"number\">0.01</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Hello+%7Barg+0+(%22x%22)%7D+is+%7Barg+1+(0.01)+with+precision+specified+inline+(5)%7D%0Afn+main()+%7B%0A++++println!(%22Hello+%7B0%7D+is+%7B1:.5%7D%22,+%22x%22,+0.01);%0A++++%0A++++//+Hello+%7Barg+1+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+arg+0+(5)%7D%0A++++println!(%22Hello+%7B1%7D+is+%7B2:.0%24%7D%22,+5,+%22x%22,+0.01);%0A++++%0A++++//+Hello+%7Barg+0+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+arg+1+(5)%7D%0A++++println!(%22Hello+%7B0%7D+is+%7B2:.1%24%7D%22,+%22x%22,+5,+0.01);%0A++++%0A++++//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Bsecond+of+next+two+args+-%3E+arg+2+(0.01)+with+precision%0A++++//++++++++++++++++++++++++++specified+in+first+of+next+two+args+-%3E+arg+1+(5)%7D%0A++++println!(%22Hello+%7B%7D+is+%7B:.*%7D%22,++++%22x%22,+5,+0.01);%0A++++%0A++++//+Hello+%7Barg+1+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision%0A++++//++++++++++++++++++++++++++specified+in+next+arg+-%3E+arg+0+(5)%7D%0A++++println!(%22Hello+%7B1%7D+is+%7B2:.*%7D%22,++5,+%22x%22,+0.01);%0A++++%0A++++//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision%0A++++//++++++++++++++++++++++++++specified+in+next+arg+-%3E+arg+1+(5)%7D%0A++++println!(%22Hello+%7B%7D+is+%7B2:.*%7D%22,+++%22x%22,+5,+0.01);%0A++++%0A++++//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Barg+%22number%22+(0.01)+with+precision+specified%0A++++//++++++++++++++++++++++++++in+arg+%22prec%22+(5)%7D%0A++++println!(%22Hello+%7B%7D+is+%7Bnumber:.prec%24%7D%22,+%22x%22,+prec+=+5,+number+=+0.01);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>While these:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"{}, `{name:.*}` has 3 fractional digits\"</span>, <span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>, name=<span class=\"number\">1234.56</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}, `{name:.*}` has 3 characters\"</span>, <span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>, name=<span class=\"string\">\"1234.56\"</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}, `{name:&gt;8.*}` has 3 right-aligned characters\"</span>, <span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>, name=<span class=\"string\">\"1234.56\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D,+%60%7Bname:.*%7D%60+has+3+fractional+digits%22,+%22Hello%22,+3,+name=1234.56);%0A++++println!(%22%7B%7D,+%60%7Bname:.*%7D%60+has+3+characters%22,+%22Hello%22,+3,+name=%221234.56%22);%0A++++println!(%22%7B%7D,+%60%7Bname:%3E8.*%7D%60+has+3+right-aligned+characters%22,+%22Hello%22,+3,+name=%221234.56%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>print three significantly different things:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>Hello, `1234.560` has 3 fractional digits\nHello, `123` has 3 characters\nHello, `     123` has 3 right-aligned characters\n</code></pre></div>\n<p>When truncating these values, Rust uses <a href=\"https://en.wikipedia.org/wiki/Rounding#Rounding_half_to_even\">round half-to-even</a>,\nwhich is the default rounding mode in IEEE 754.\nFor example,</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">print!</span>(<span class=\"string\">\"{0:.1$e}\"</span>, <span class=\"number\">12345</span>, <span class=\"number\">3</span>);\n<span class=\"macro\">print!</span>(<span class=\"string\">\"{0:.1$e}\"</span>, <span class=\"number\">12355</span>, <span class=\"number\">3</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++print!(%22%7B0:.1%24e%7D%22,+12345,+3);%0A++++print!(%22%7B0:.1%24e%7D%22,+12355,+3);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Would return:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>1.234e4\n1.236e4\n</code></pre></div><h3 id=\"localization\"><a class=\"doc-anchor\" href=\"#localization\">§</a>Localization</h3>\n<p>In some programming languages, the behavior of string formatting functions\ndepends on the operating system’s locale setting. The format functions\nprovided by Rust’s standard library do not have any concept of locale and\nwill produce the same results on all systems regardless of user\nconfiguration.</p>\n<p>For example, the following code will always print <code>1.5</code> even if the system\nlocale uses a decimal separator other than a dot.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">println!</span>(<span class=\"string\">\"The value is {}\"</span>, <span class=\"number\">1.5</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22The+value+is+%7B%7D%22,+1.5);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"escaping\"><a class=\"doc-anchor\" href=\"#escaping\">§</a>Escaping</h2>\n<p>The literal characters <code>{</code> and <code>}</code> may be included in a string by preceding\nthem with the same character. For example, the <code>{</code> character is escaped with\n<code>{{</code> and the <code>}</code> character is escaped with <code>}}</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"Hello {{}}\"</span>), <span class=\"string\">\"Hello {}\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"{{ Hello\"</span>), <span class=\"string\">\"{ Hello\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22Hello+%7B%7B%7D%7D%22),+%22Hello+%7B%7D%22);%0A++++assert_eq!(format!(%22%7B%7B+Hello%22),+%22%7B+Hello%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"syntax\"><a class=\"doc-anchor\" href=\"#syntax\">§</a>Syntax</h2>\n<p>To summarize, here you can find the full grammar of format strings.\nThe syntax for the formatting language used is drawn from other languages,\nso it should not be too alien. Arguments are formatted with Python-like\nsyntax, meaning that arguments are surrounded by <code>{}</code> instead of the C-like\n<code>%</code>. The actual grammar for the formatting syntax is:</p>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>format_string := text [ maybe_format text ] *\nmaybe_format := '{' '{' | '}' '}' | format\nformat := '{' [ argument ] [ ':' format_spec ] [ ws ] * '}'\nargument := integer | identifier\n\nformat_spec := [[fill]align][sign]['#']['0'][width]['.' precision]type\nfill := character\nalign := '&lt;' | '^' | '&gt;'\nsign := '+' | '-'\nwidth := count\nprecision := count | '*'\ntype := '' | '?' | 'x?' | 'X?' | identifier\ncount := parameter | integer\nparameter := argument '$'\n</code></pre></div>\n<p>In the above grammar,</p>\n<ul>\n<li><code>text</code> must not contain any <code>'{'</code> or <code>'}'</code> characters,</li>\n<li><code>ws</code> is any character for which <a href=\"../primitive.char.html#method.is_whitespace\" title=\"method char::is_whitespace\"><code>char::is_whitespace</code></a> returns <code>true</code>, has no semantic\nmeaning and is completely optional,</li>\n<li><code>integer</code> is a decimal integer that may contain leading zeroes and must fit into an <code>usize</code> and</li>\n<li><code>identifier</code> is an <code>IDENTIFIER_OR_KEYWORD</code> (not an <code>IDENTIFIER</code>) as defined by the <a href=\"https://doc.rust-lang.org/reference/identifiers.html\">Rust language reference</a>.</li>\n</ul>\n<h2 id=\"formatting-traits\"><a class=\"doc-anchor\" href=\"#formatting-traits\">§</a>Formatting traits</h2>\n<p>When requesting that an argument be formatted with a particular type, you\nare actually requesting that an argument ascribes to a particular trait.\nThis allows multiple actual types to be formatted via <code>{:x}</code> (like <a href=\"../primitive.i8.html\" title=\"primitive i8\"><code>i8</code></a> as\nwell as <a href=\"../primitive.isize.html\" title=\"primitive isize\"><code>isize</code></a>). The current mapping of types to traits is:</p>\n<ul>\n<li><em>nothing</em> ⇒ <a href=\"trait.Display.html\" title=\"trait std::fmt::Display\"><code>Display</code></a></li>\n<li><code>?</code> ⇒ <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a></li>\n<li><code>x?</code> ⇒ <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a> with lower-case hexadecimal integers</li>\n<li><code>X?</code> ⇒ <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a> with upper-case hexadecimal integers</li>\n<li><code>o</code> ⇒ <a href=\"trait.Octal.html\" title=\"trait std::fmt::Octal\"><code>Octal</code></a></li>\n<li><code>x</code> ⇒ <a href=\"trait.LowerHex.html\" title=\"trait std::fmt::LowerHex\"><code>LowerHex</code></a></li>\n<li><code>X</code> ⇒ <a href=\"trait.UpperHex.html\" title=\"trait std::fmt::UpperHex\"><code>UpperHex</code></a></li>\n<li><code>p</code> ⇒ <a href=\"trait.Pointer.html\" title=\"trait std::fmt::Pointer\"><code>Pointer</code></a></li>\n<li><code>b</code> ⇒ <a href=\"trait.Binary.html\" title=\"trait std::fmt::Binary\"><code>Binary</code></a></li>\n<li><code>e</code> ⇒ <a href=\"trait.LowerExp.html\" title=\"trait std::fmt::LowerExp\"><code>LowerExp</code></a></li>\n<li><code>E</code> ⇒ <a href=\"trait.UpperExp.html\" title=\"trait std::fmt::UpperExp\"><code>UpperExp</code></a></li>\n</ul>\n<p>What this means is that any type of argument which implements the\n<a href=\"trait.Binary.html\" title=\"trait std::fmt::Binary\"><code>fmt::Binary</code></a> trait can then be formatted with <code>{:b}</code>. Implementations\nare provided for these traits for a number of primitive types by the\nstandard library as well. If no format is specified (as in <code>{}</code> or <code>{:6}</code>),\nthen the format trait used is the <a href=\"trait.Display.html\" title=\"trait std::fmt::Display\"><code>Display</code></a> trait.</p>\n<p>When implementing a format trait for your own type, you will have to\nimplement a method of the signature:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>fmt(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, f: <span class=\"kw-2\">&amp;mut </span>fmt::Formatter&lt;<span class=\"lifetime\">'_</span>&gt;) -&gt; fmt::Result {</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::fmt;%0A++++struct+Foo;+//+our+custom+type%0A++++impl+fmt::Display+for+Foo+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C'_%3E)+-%3E+fmt::Result+%7B%0A++++write!(f,+%22testing,+testing%22)%0A++++%7D+%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Your type will be passed as <code>self</code> by-reference, and then the function\nshould emit output into the Formatter <code>f</code> which implements <code>fmt::Write</code>. It is up to each\nformat trait implementation to correctly adhere to the requested formatting parameters.\nThe values of these parameters can be accessed with methods of the\n<a href=\"struct.Formatter.html\" title=\"struct std::fmt::Formatter\"><code>Formatter</code></a> struct. In order to help with this, the <a href=\"struct.Formatter.html\" title=\"struct std::fmt::Formatter\"><code>Formatter</code></a> struct also\nprovides some helper methods.</p>\n<p>Additionally, the return value of this function is <a href=\"type.Result.html\" title=\"fmt::Result\"><code>fmt::Result</code></a> which is a\ntype alias of <code><a href=\"../result/enum.Result.html\" title=\"std::result::Result\">Result</a>&lt;(), <a href=\"struct.Error.html\" title=\"fmt::Error\">std::fmt::Error</a>&gt;</code>. Formatting implementations\nshould ensure that they propagate errors from the <a href=\"struct.Formatter.html\" title=\"struct std::fmt::Formatter\"><code>Formatter</code></a> (e.g., when\ncalling <a href=\"../macro.write.html\" title=\"macro std::write\"><code>write!</code></a>). However, they should never return errors spuriously. That\nis, a formatting implementation must and may only return an error if the\npassed-in <a href=\"struct.Formatter.html\" title=\"struct std::fmt::Formatter\"><code>Formatter</code></a> returns an error. This is because, contrary to what\nthe function signature might suggest, string formatting is an infallible\noperation. This function only returns a <a href=\"type.Result.html\" title=\"type std::fmt::Result\"><code>Result</code></a> because writing to the\nunderlying stream might fail and it must provide a way to propagate the fact\nthat an error has occurred back up the stack.</p>\n<p>An example of implementing the formatting traits would look\nlike:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fmt;\n\n<span class=\"attr\">#[derive(Debug)]\n</span><span class=\"kw\">struct </span>Vector2D {\n    x: isize,\n    y: isize,\n}\n\n<span class=\"kw\">impl </span>fmt::Display <span class=\"kw\">for </span>Vector2D {\n    <span class=\"kw\">fn </span>fmt(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, f: <span class=\"kw-2\">&amp;mut </span>fmt::Formatter&lt;<span class=\"lifetime\">'_</span>&gt;) -&gt; fmt::Result {\n        <span class=\"comment\">// The `f` value implements the `Write` trait, which is what the\n        // write! macro is expecting. Note that this formatting ignores the\n        // various flags provided to format strings.\n        </span><span class=\"macro\">write!</span>(f, <span class=\"string\">\"({}, {})\"</span>, <span class=\"self\">self</span>.x, <span class=\"self\">self</span>.y)\n    }\n}\n\n<span class=\"comment\">// Different traits allow different forms of output of a type. The meaning\n// of this format is to print the magnitude of a vector.\n</span><span class=\"kw\">impl </span>fmt::Binary <span class=\"kw\">for </span>Vector2D {\n    <span class=\"kw\">fn </span>fmt(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, f: <span class=\"kw-2\">&amp;mut </span>fmt::Formatter&lt;<span class=\"lifetime\">'_</span>&gt;) -&gt; fmt::Result {\n        <span class=\"kw\">let </span>magnitude = (<span class=\"self\">self</span>.x * <span class=\"self\">self</span>.x + <span class=\"self\">self</span>.y * <span class=\"self\">self</span>.y) <span class=\"kw\">as </span>f64;\n        <span class=\"kw\">let </span>magnitude = magnitude.sqrt();\n\n        <span class=\"comment\">// Respect the formatting flags by using the helper method\n        // `pad_integral` on the Formatter object. See the method\n        // documentation for details, and the function `pad` can be used\n        // to pad strings.\n        </span><span class=\"kw\">let </span>decimals = f.precision().unwrap_or(<span class=\"number\">3</span>);\n        <span class=\"kw\">let </span>string = <span class=\"macro\">format!</span>(<span class=\"string\">\"{magnitude:.decimals$}\"</span>);\n        f.pad_integral(<span class=\"bool-val\">true</span>, <span class=\"string\">\"\"</span>, <span class=\"kw-2\">&amp;</span>string)\n    }\n}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>myvector = Vector2D { x: <span class=\"number\">3</span>, y: <span class=\"number\">4 </span>};\n\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{myvector}\"</span>);       <span class=\"comment\">// =&gt; \"(3, 4)\"\n    </span><span class=\"macro\">println!</span>(<span class=\"string\">\"{myvector:?}\"</span>);     <span class=\"comment\">// =&gt; \"Vector2D {x: 3, y:4}\"\n    </span><span class=\"macro\">println!</span>(<span class=\"string\">\"{myvector:10.3b}\"</span>); <span class=\"comment\">// =&gt; \"     5.000\"\n</span>}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fmt;%0A%0A%23%5Bderive(Debug)%5D%0Astruct+Vector2D+%7B%0A++++x:+isize,%0A++++y:+isize,%0A%7D%0A%0Aimpl+fmt::Display+for+Vector2D+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C'_%3E)+-%3E+fmt::Result+%7B%0A++++++++//+The+%60f%60+value+implements+the+%60Write%60+trait,+which+is+what+the%0A++++++++//+write!+macro+is+expecting.+Note+that+this+formatting+ignores+the%0A++++++++//+various+flags+provided+to+format+strings.%0A++++++++write!(f,+%22(%7B%7D,+%7B%7D)%22,+self.x,+self.y)%0A++++%7D%0A%7D%0A%0A//+Different+traits+allow+different+forms+of+output+of+a+type.+The+meaning%0A//+of+this+format+is+to+print+the+magnitude+of+a+vector.%0Aimpl+fmt::Binary+for+Vector2D+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C'_%3E)+-%3E+fmt::Result+%7B%0A++++++++let+magnitude+=+(self.x+*+self.x+%2B+self.y+*+self.y)+as+f64;%0A++++++++let+magnitude+=+magnitude.sqrt();%0A%0A++++++++//+Respect+the+formatting+flags+by+using+the+helper+method%0A++++++++//+%60pad_integral%60+on+the+Formatter+object.+See+the+method%0A++++++++//+documentation+for+details,+and+the+function+%60pad%60+can+be+used%0A++++++++//+to+pad+strings.%0A++++++++let+decimals+=+f.precision().unwrap_or(3);%0A++++++++let+string+=+format!(%22%7Bmagnitude:.decimals%24%7D%22);%0A++++++++f.pad_integral(true,+%22%22,+%26string)%0A++++%7D%0A%7D%0A%0Afn+main()+%7B%0A++++let+myvector+=+Vector2D+%7B+x:+3,+y:+4+%7D;%0A%0A++++println!(%22%7Bmyvector%7D%22);+++++++//+=%3E+%22(3,+4)%22%0A++++println!(%22%7Bmyvector:?%7D%22);+++++//+=%3E+%22Vector2D+%7Bx:+3,+y:4%7D%22%0A++++println!(%22%7Bmyvector:10.3b%7D%22);+//+=%3E+%22+++++5.000%22%0A%7D&amp;edition=2021\">Run</a></div>\n<h4 id=\"fmtdisplay-vs-fmtdebug\"><a class=\"doc-anchor\" href=\"#fmtdisplay-vs-fmtdebug\">§</a><code>fmt::Display</code> vs <code>fmt::Debug</code></h4>\n<p>These two formatting traits have distinct purposes:</p>\n<ul>\n<li><a href=\"trait.Display.html\" title=\"trait std::fmt::Display\"><code>fmt::Display</code></a> implementations assert that the type can be faithfully\nrepresented as a UTF-8 string at all times. It is <strong>not</strong> expected that\nall types implement the <a href=\"trait.Display.html\" title=\"trait std::fmt::Display\"><code>Display</code></a> trait.</li>\n<li><a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> implementations should be implemented for <strong>all</strong> public types.\nOutput will typically represent the internal state as faithfully as possible.\nThe purpose of the <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>Debug</code></a> trait is to facilitate debugging Rust code. In\nmost cases, using <code>#[derive(Debug)]</code> is sufficient and recommended.</li>\n</ul>\n<p>Some examples of the output from both traits:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"{} {:?}\"</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>), <span class=\"string\">\"3 4\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"{} {:?}\"</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>), <span class=\"string\">\"a 'b'\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"macro\">format!</span>(<span class=\"string\">\"{} {:?}\"</span>, <span class=\"string\">\"foo\\n\"</span>, <span class=\"string\">\"bar\\n\"</span>), <span class=\"string\">\"foo\\n \\\"bar\\\\n\\\"\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+3,+4),+%223+4%22);%0A++++assert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+'a',+'b'),+%22a+'b'%22);%0A++++assert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+%22foo%5Cn%22,+%22bar%5Cn%22),+%22foo%5Cn+%5C%22bar%5C%5Cn%5C%22%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<h2 id=\"related-macros\"><a class=\"doc-anchor\" href=\"#related-macros\">§</a>Related macros</h2>\n<p>There are a number of related macros in the <a href=\"../macro.format.html\" title=\"macro std::format\"><code>format!</code></a> family. The ones that\nare currently implemented are:</p>\n\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">format!</span>      <span class=\"comment\">// described above\n</span><span class=\"macro\">write!</span>       <span class=\"comment\">// first argument is either a &amp;mut io::Write or a &amp;mut fmt::Write, the destination\n</span><span class=\"macro\">writeln!</span>     <span class=\"comment\">// same as write but appends a newline\n</span><span class=\"macro\">print!</span>       <span class=\"comment\">// the format string is printed to the standard output\n</span><span class=\"macro\">println!</span>     <span class=\"comment\">// same as print but appends a newline\n</span><span class=\"macro\">eprint!</span>      <span class=\"comment\">// the format string is printed to the standard error\n</span><span class=\"macro\">eprintln!</span>    <span class=\"comment\">// same as eprint but appends a newline\n</span><span class=\"macro\">format_args!</span> <span class=\"comment\">// described below.</span></code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++format!++++++//+described+above%0A++++write!+++++++//+first+argument+is+either+a+%26mut+io::Write+or+a+%26mut+fmt::Write,+the+destination%0A++++writeln!+++++//+same+as+write+but+appends+a+newline%0A++++print!+++++++//+the+format+string+is+printed+to+the+standard+output%0A++++println!+++++//+same+as+print+but+appends+a+newline%0A++++eprint!++++++//+the+format+string+is+printed+to+the+standard+error%0A++++eprintln!++++//+same+as+eprint+but+appends+a+newline%0A++++format_args!+//+described+below.%0A%7D&amp;edition=2021\">Run</a></div>\n<h4 id=\"write\"><a class=\"doc-anchor\" href=\"#write\">§</a><code>write!</code></h4>\n<p><a href=\"../macro.write.html\" title=\"macro std::write\"><code>write!</code></a> and <a href=\"../macro.writeln.html\" title=\"macro std::writeln\"><code>writeln!</code></a> are two macros which are used to emit the format string\nto a specified stream. This is used to prevent intermediate allocations of\nformat strings and instead directly write the output. Under the hood, this\nfunction is actually invoking the <a href=\"../../std/io/trait.Write.html#method.write_fmt\"><code>write_fmt</code></a> function defined on the\n<a href=\"../../std/io/trait.Write.html\"><code>std::io::Write</code></a> and the <a href=\"../../std/fmt/trait.Write.html\"><code>std::fmt::Write</code></a> trait. Example usage is:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io::Write;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>w = Vec::new();\n<span class=\"macro\">write!</span>(<span class=\"kw-2\">&amp;mut </span>w, <span class=\"string\">\"Hello {}!\"</span>, <span class=\"string\">\"world\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn+main()+%7B%0A++++use+std::io::Write;%0A++++let+mut+w+=+Vec::new();%0A++++write!(%26mut+w,+%22Hello+%7B%7D!%22,+%22world%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<h4 id=\"print\"><a class=\"doc-anchor\" href=\"#print\">§</a><code>print!</code></h4>\n<p>This and <a href=\"../../std/macro.println.html\" title=\"println!\"><code>println!</code></a> emit their output to stdout. Similarly to the <a href=\"../macro.write.html\" title=\"macro std::write\"><code>write!</code></a>\nmacro, the goal of these macros is to avoid intermediate allocations when\nprinting output. Example usage is:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">print!</span>(<span class=\"string\">\"Hello {}!\"</span>, <span class=\"string\">\"world\"</span>);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"I have a newline {}\"</span>, <span class=\"string\">\"character at the end\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++print!(%22Hello+%7B%7D!%22,+%22world%22);%0A++++println!(%22I+have+a+newline+%7B%7D%22,+%22character+at+the+end%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<h4 id=\"eprint\"><a class=\"doc-anchor\" href=\"#eprint\">§</a><code>eprint!</code></h4>\n<p>The <a href=\"../../std/macro.eprint.html\" title=\"eprint!\"><code>eprint!</code></a> and <a href=\"../../std/macro.eprintln.html\" title=\"eprintln!\"><code>eprintln!</code></a> macros are identical to\n<a href=\"../../std/macro.print.html\" title=\"print!\"><code>print!</code></a> and <a href=\"../../std/macro.println.html\" title=\"println!\"><code>println!</code></a>, respectively, except they emit their\noutput to stderr.</p>\n<h4 id=\"format_args\"><a class=\"doc-anchor\" href=\"#format_args\">§</a><code>format_args!</code></h4>\n<p><a href=\"../../std/macro.format_args.html\" title=\"format_args!\"><code>format_args!</code></a> is a curious macro used to safely pass around\nan opaque object describing the format string. This object\ndoes not require any heap allocations to create, and it only\nreferences information on the stack. Under the hood, all of\nthe related macros are implemented in terms of this. First\noff, some example usage is:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fmt;\n<span class=\"kw\">use </span>std::io::{<span class=\"self\">self</span>, Write};\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>some_writer = io::stdout();\n<span class=\"macro\">write!</span>(<span class=\"kw-2\">&amp;mut </span>some_writer, <span class=\"string\">\"{}\"</span>, <span class=\"macro\">format_args!</span>(<span class=\"string\">\"print with a {}\"</span>, <span class=\"string\">\"macro\"</span>));\n\n<span class=\"kw\">fn </span>my_fmt_fn(args: fmt::Arguments&lt;<span class=\"lifetime\">'_</span>&gt;) {\n    <span class=\"macro\">write!</span>(<span class=\"kw-2\">&amp;mut </span>io::stdout(), <span class=\"string\">\"{args}\"</span>);\n}\nmy_fmt_fn(<span class=\"macro\">format_args!</span>(<span class=\"string\">\", or a {} too\"</span>, <span class=\"string\">\"function\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn+main()+%7B%0A++++use+std::fmt;%0A++++use+std::io::%7Bself,+Write%7D;%0A++++%0A++++let+mut+some_writer+=+io::stdout();%0A++++write!(%26mut+some_writer,+%22%7B%7D%22,+format_args!(%22print+with+a+%7B%7D%22,+%22macro%22));%0A++++%0A++++fn+my_fmt_fn(args:+fmt::Arguments%3C'_%3E)+%7B%0A++++++++write!(%26mut+io::stdout(),+%22%7Bargs%7D%22);%0A++++%7D%0A++++my_fmt_fn(format_args!(%22,+or+a+%7B%7D+too%22,+%22function%22));%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The result of the <a href=\"../../std/macro.format_args.html\" title=\"format_args!\"><code>format_args!</code></a> macro is a value of type <a href=\"struct.Arguments.html\" title=\"fmt::Arguments\"><code>fmt::Arguments</code></a>.\nThis structure can then be passed to the <a href=\"fn.write.html\" title=\"fmt::write\"><code>write</code></a> and <a href=\"fn.format.html\" title=\"fmt::format\"><code>format</code></a> functions\ninside this module in order to process the format string.\nThe goal of this macro is to even further prevent intermediate allocations\nwhen dealing with formatting strings.</p>\n<p>For example, a logging library could use the standard formatting syntax, but\nit would internally pass around this structure until it has been determined\nwhere output should go to.</p>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Arguments.html\" title=\"struct std::fmt::Arguments\">Arguments</a></div><div class=\"desc docblock-short\">This structure represents a safely precompiled version of a format string\nand its arguments. This cannot be generated at runtime because it cannot\nsafely be done, so no constructors are given and the fields are private\nto prevent modification.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.DebugList.html\" title=\"struct std::fmt::DebugList\">DebugList</a></div><div class=\"desc docblock-short\">A struct to help with <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> implementations.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.DebugMap.html\" title=\"struct std::fmt::DebugMap\">DebugMap</a></div><div class=\"desc docblock-short\">A struct to help with <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> implementations.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.DebugSet.html\" title=\"struct std::fmt::DebugSet\">DebugSet</a></div><div class=\"desc docblock-short\">A struct to help with <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> implementations.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.DebugStruct.html\" title=\"struct std::fmt::DebugStruct\">DebugStruct</a></div><div class=\"desc docblock-short\">A struct to help with <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> implementations.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.DebugTuple.html\" title=\"struct std::fmt::DebugTuple\">DebugTuple</a></div><div class=\"desc docblock-short\">A struct to help with <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> implementations.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Error.html\" title=\"struct std::fmt::Error\">Error</a></div><div class=\"desc docblock-short\">The error type which is returned from formatting a message into a stream.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a></div><div class=\"desc docblock-short\">Configuration for formatting.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.FormatterFn.html\" title=\"struct std::fmt::FormatterFn\">FormatterFn</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">Implements <a href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\"><code>fmt::Debug</code></a> and <a href=\"trait.Display.html\" title=\"trait std::fmt::Display\"><code>fmt::Display</code></a> using a function.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.Alignment.html\" title=\"enum std::fmt::Alignment\">Alignment</a></div><div class=\"desc docblock-short\">Possible alignments returned by <code>Formatter::align</code></div></li></ul><h2 id=\"traits\" class=\"section-header\">Traits<a href=\"#traits\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Binary.html\" title=\"trait std::fmt::Binary\">Binary</a></div><div class=\"desc docblock-short\"><code>b</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a></div><div class=\"desc docblock-short\"><code>?</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Display.html\" title=\"trait std::fmt::Display\">Display</a></div><div class=\"desc docblock-short\">Format trait for an empty format, <code>{}</code>.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.LowerExp.html\" title=\"trait std::fmt::LowerExp\">LowerExp</a></div><div class=\"desc docblock-short\"><code>e</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.LowerHex.html\" title=\"trait std::fmt::LowerHex\">LowerHex</a></div><div class=\"desc docblock-short\"><code>x</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Octal.html\" title=\"trait std::fmt::Octal\">Octal</a></div><div class=\"desc docblock-short\"><code>o</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Pointer.html\" title=\"trait std::fmt::Pointer\">Pointer</a></div><div class=\"desc docblock-short\"><code>p</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.UpperExp.html\" title=\"trait std::fmt::UpperExp\">UpperExp</a></div><div class=\"desc docblock-short\"><code>E</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.UpperHex.html\" title=\"trait std::fmt::UpperHex\">UpperHex</a></div><div class=\"desc docblock-short\"><code>X</code> formatting.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Write.html\" title=\"trait std::fmt::Write\">Write</a></div><div class=\"desc docblock-short\">A trait for writing or formatting into Unicode-accepting buffers or streams.</div></li></ul><h2 id=\"functions\" class=\"section-header\">Functions<a href=\"#functions\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.format.html\" title=\"fn std::fmt::format\">format</a></div><div class=\"desc docblock-short\">The <code>format</code> function takes an <a href=\"struct.Arguments.html\" title=\"struct std::fmt::Arguments\"><code>Arguments</code></a> struct and returns the resulting\nformatted string.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.write.html\" title=\"fn std::fmt::write\">write</a></div><div class=\"desc docblock-short\">The <code>write</code> function takes an output stream, and an <code>Arguments</code> struct\nthat can be precompiled with the <code>format_args!</code> macro.</div></li></ul><h2 id=\"types\" class=\"section-header\">Type Aliases<a href=\"#types\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"type\" href=\"type.Result.html\" title=\"type std::fmt::Result\">Result</a></div><div class=\"desc docblock-short\">The type returned by formatter methods.</div></li></ul><h2 id=\"derives\" class=\"section-header\">Derive Macros<a href=\"#derives\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"derive\" href=\"derive.Debug.html\" title=\"derive std::fmt::Debug\">Debug</a></div><div class=\"desc docblock-short\">Derive macro generating an impl of the trait <code>Debug</code>.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:10:56.632Z"
}