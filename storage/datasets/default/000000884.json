{
	"title": "Subtyping and Variance - The Rustonomicon",
	"url": "https://doc.rust-lang.org/stable/nomicon/subtyping.html",
	"markdown": "# Subtyping and Variance - The Rustonomicon\n\nRust uses lifetimes to track the relationships between borrows and ownership. However, a naive implementation of lifetimes would be either too restrictive, or permit undefined behavior.\n\nIn order to allow flexible usage of lifetimes while also preventing their misuse, Rust uses **subtyping** and **variance**.\n\nLet's start with an example.\n\n```rust\n// Note: debug expects two parameters with the *same* lifetime\nfn debug<'a>(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nfn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        let world = &world; // 'world has a shorter lifetime than 'static\n        debug(hello, world);\n    }\n}\n```\n\nIn a conservative implementation of lifetimes, since `hello` and `world` have different lifetimes, we might see the following error:\n\n```text\nerror[E0308]: mismatched types\n --> src/main.rs:10:16\n   |\n10 |         debug(hello, world);\n   |                      ^\n   |                      |\n   |                      expected `&'static str`, found struct `&'world str`\n\n```\n\nThis would be rather unfortunate. In this case, what we want is to accept any type that lives _at least as long_ as `'world`. Let's try using subtyping with our lifetimes.\n\n## [Subtyping](#subtyping)\n\nSubtyping is the idea that one type can be used in place of another.\n\nLet's define that `Sub` is a subtype of `Super` (we'll be using the notation `Sub <: Super` throughout this chapter).\n\nWhat this is suggesting to us is that the set of _requirements_ that `Super` defines are completely satisfied by `Sub`. `Sub` may then have more requirements.\n\nNow, in order to use subtyping with lifetimes, we need to define the requirement of a lifetime:\n\n> `'a` defines a region of code.\n\nNow that we have a defined set of requirements for lifetimes, we can define how they relate to each other:\n\n> `'long <: 'short` if and only if `'long` defines a region of code that **completely contains** `'short`.\n\n`'long` may define a region larger than `'short`, but that still fits our definition.\n\n> As we will see throughout the rest of this chapter, subtyping is a lot more complicated and subtle than this, but this simple rule is a very good 99% intuition. And unless you write unsafe code, the compiler will automatically handle all the corner cases for you.\n\n> But this is the Rustonomicon. We're writing unsafe code, so we need to understand how this stuff really works, and how we can mess it up.\n\nGoing back to our example above, we can say that `'static <: 'world`. For now, let's also accept the idea that subtypes of lifetimes can be passed through references (more on this in [Variance](#variance)), _e.g._ `&'static str` is a subtype of `&'world str`, then we can \"downgrade\" `&'static str` into a `&'world str`. With that, the example above will compile:\n\n```rust\nfn debug<'a>(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nfn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        let world = &world; // 'world has a shorter lifetime than 'static\n        debug(hello, world); // hello silently downgrades from `&'static str` into `&'world str`\n    }\n}\n```\n\n## [Variance](#variance)\n\nAbove, we glossed over the fact that `'static <: 'b` implied that `&'static T <: &'b T`. This uses a property known as _variance_. It's not always as simple as this example, though. To understand that, let's try to extend this example a bit:\n\n```rust\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}\n\nfn main() {\n    let mut hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        assign(&mut hello, &world);\n    }\n    println!(\"{hello}\"); // use after free ðŸ˜¿\n}\n```\n\nIn `assign`, we are setting the `hello` reference to point to `world`. But then `world` goes out of scope, before the later use of `hello` in the println!\n\nThis is a classic use-after-free bug!\n\nOur first instinct might be to blame the `assign` impl, but there's really nothing wrong here. It shouldn't be surprising that we might want to assign a `T` into a `T`.\n\nThe problem is that we cannot assume that `&mut &'static str` and `&mut &'b str` are compatible. This means that `&mut &'static str` **cannot** be a _subtype_ of `&mut &'b str`, even if `'static` is a subtype of `'b`.\n\nVariance is the concept that Rust borrows to define relationships about subtypes through their generic parameters.\n\n> NOTE: For convenience we will define a generic type `F<T>` so that we can easily talk about `T`. Hopefully this is clear in context.\n\nThe type `F`'s _variance_ is how the subtyping of its inputs affects the subtyping of its outputs. There are three kinds of variance in Rust. Given two types `Sub` and `Super`, where `Sub` is a subtype of `Super`:\n\n-   `F` is **covariant** if `F<Sub>` is a subtype of `F<Super>` (the subtype property is passed through)\n-   `F` is **contravariant** if `F<Super>` is a subtype of `F<Sub>` (the subtype property is \"inverted\")\n-   `F` is **invariant** otherwise (no subtyping relationship exists)\n\nIf we remember from the above examples, it was ok for us to treat `&'a T` as a subtype of `&'b T` if `'a <: 'b`, therefore we can say that `&'a T` is _covariant_ over `'a`.\n\nAlso, we saw that it was not ok for us to treat `&mut &'a U` as a subtype of `&mut &'b U`, therefore we can say that `&mut T` is _invariant_ over `T`\n\nHere is a table of some other generic types and their variances:\n\n|  | 'a | T | U |\n| --- | --- | --- | --- |\n| `&'a T` | covariant | covariant |  |\n| `&'a mut T` | covariant | invariant |  |\n| `Box<T>` |  | covariant |  |\n| `Vec<T>` |  | covariant |  |\n| `UnsafeCell<T>` |  | invariant |  |\n| `Cell<T>` |  | invariant |  |\n| `fn(T) -> U` |  | **contra**variant | covariant |\n| `*const T` |  | covariant |  |\n| `*mut T` |  | invariant |  |\n\nSome of these can be explained simply in relation to the others:\n\n-   `Vec<T>` and all other owning pointers and collections follow the same logic as `Box<T>`\n-   `Cell<T>` and all other interior mutability types follow the same logic as `UnsafeCell<T>`\n-   `UnsafeCell<T>` having interior mutability gives it the same variance properties as `&mut T`\n-   `*const T` follows the logic of `&T`\n-   `*mut T` follows the logic of `&mut T` (or `UnsafeCell<T>`)\n\nFor more types, see the [\"Variance\" section](about:blank/reference/subtyping.html#variance) on the reference.\n\n> NOTE: the _only_ source of contravariance in the language is the arguments to a function, which is why it really doesn't come up much in practice. Invoking contravariance involves higher-order programming with function pointers that take references with specific lifetimes (as opposed to the usual \"any lifetime\", which gets into higher rank lifetimes, which work independently of subtyping).\n\nNow that we have some more formal understanding of variance, let's go through some more examples in more detail.\n\n```rust\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}\n\nfn main() {\n    let mut hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        assign(&mut hello, &world);\n    }\n    println!(\"{hello}\");\n}\n```\n\nAnd what do we get when we run this?\n\n```text\nerror[E0597]: `world` does not live long enough\n  --> src/main.rs:9:28\n   |\n6  |     let mut hello: &'static str = \"hello\";\n   |                    ------------ type annotation requires that `world` is borrowed for `'static`\n...\n9  |         assign(&mut hello, &world);\n   |                            ^^^^^^ borrowed value does not live long enough\n10 |     }\n   |     - `world` dropped here while still borrowed\n\n```\n\nGood, it doesn't compile! Let's break down what's happening here in detail.\n\nFirst let's look at the `assign` function:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}\n}\n```\n\nAll it does is take a mutable reference and a value and overwrite the referent with it. What's important about this function is that it creates a type equality constraint. It clearly says in its signature the referent and the value must be the _exact same_ type.\n\nMeanwhile, in the caller we pass in `&mut &'static str` and `&'world str`.\n\nBecause `&mut T` is invariant over `T`, the compiler concludes it can't apply any subtyping to the first argument, and so `T` must be exactly `&'static str`.\n\nThis is counter to the `&T` case:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn debug<T: std::fmt::Debug>(a: T, b: T) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n}\n```\n\nwhere similarly `a` and `b` must have the same type `T`. But since `&'a T` _is_ covariant over `'a`, we are allowed to perform subtyping. So the compiler decides that `&'static str` can become `&'b str` if and only if `&'static str` is a subtype of `&'b str`, which will hold if `'static <: 'b`. This is true, so the compiler is happy to continue compiling this code.\n\nAs it turns out, the argument for why it's ok for Box (and Vec, HashMap, etc.) to be covariant is pretty similar to the argument for why it's ok for lifetimes to be covariant: as soon as you try to stuff them in something like a mutable reference, they inherit invariance and you're prevented from doing anything bad.\n\nHowever Box makes it easier to focus on the by-value aspect of references that we partially glossed over.\n\nUnlike a lot of languages which allow values to be freely aliased at all times, Rust has a very strict rule: if you're allowed to mutate or move a value, you are guaranteed to be the only one with access to it.\n\nConsider the following code:\n\n```rust\nlet hello: Box<&'static str> = Box::new(\"hello\");\n\nlet mut world: Box<&'b str>;\nworld = hello;\n```\n\nThere is no problem at all with the fact that we have forgotten that `hello` was alive for `'static`, because as soon as we moved `hello` to a variable that only knew it was alive for `'b`, **we destroyed the only thing in the universe that remembered it lived for longer**!\n\nOnly one thing left to explain: function pointers.\n\nTo see why `fn(T) -> U` should be covariant over `U`, consider the following signature:\n\n```rust\nfn get_str() -> &'a str;\n```\n\nThis function claims to produce a `str` bound by some lifetime `'a`. As such, it is perfectly valid to provide a function with the following signature instead:\n\n```rust\nfn get_static() -> &'static str;\n```\n\nSo when the function is called, all it's expecting is a `&str` which lives at least the lifetime of `'a`, it doesn't matter if the value actually lives longer.\n\nHowever, the same logic does not apply to _arguments_. Consider trying to satisfy:\n\n```rust\nfn store_ref(&'a str);\n```\n\nwith:\n\n```rust\nfn store_static(&'static str);\n```\n\nThe first function can accept any string reference as long as it lives at least for `'a`, but the second cannot accept a string reference that lives for any duration less than `'static`, which would cause a conflict. Covariance doesn't work here. But if we flip it around, it actually _does_ work! If we need a function that can handle `&'static str`, a function that can handle _any_ reference lifetime will surely work fine.\n\nLet's see this in practice\n\n```rust\nuse std::cell::RefCell;\nthread_local! {\n    pub static StaticVecs: RefCell<Vec<&'static str>> = RefCell::new(Vec::new());\n}\n\n/// saves the input given into a thread local `Vec<&'static str>`\nfn store(input: &'static str) {\n    StaticVecs.with_borrow_mut(|v| v.push(input));\n}\n\n/// Calls the function with it's input (must have the same lifetime!)\nfn demo<'a>(input: &'a str, f: fn(&'a str)) {\n    f(input);\n}\n\nfn main() {\n    demo(\"hello\", store); // \"hello\" is 'static. Can call `store` fine\n\n    {\n        let smuggle = String::from(\"smuggle\");\n\n        // `&smuggle` is not static. If we were to call `store` with `&smuggle`,\n        // we would have pushed an invalid lifetime into the `StaticVecs`.\n        // Therefore, `fn(&'static str)` cannot be a subtype of `fn(&'a str)`\n        demo(&smuggle, store);\n    }\n\n    // use after free ðŸ˜¿\n    StaticVecs.with_borrow(|v| println!(\"{v:?}\"));\n}\n```\n\nAnd that's why function types, unlike anything else in the language, are **contra**variant over their arguments.\n\nNow, this is all well and good for the types the standard library provides, but how is variance determined for types that _you_ define? A struct, informally speaking, inherits the variance of its fields. If a struct `MyType` has a generic argument `A` that is used in a field `a`, then MyType's variance over `A` is exactly `a`'s variance over `A`.\n\nHowever if `A` is used in multiple fields:\n\n-   If all uses of `A` are covariant, then MyType is covariant over `A`\n-   If all uses of `A` are contravariant, then MyType is contravariant over `A`\n-   Otherwise, MyType is invariant over `A`\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::cell::Cell;\n\nstruct MyType<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed> {\n    a: &'a A,     // covariant over 'a and A\n    b: &'b mut B, // covariant over 'b and invariant over B\n\n    c: *const C,  // covariant over C\n    d: *mut D,    // invariant over D\n\n    e: E,         // covariant over E\n    f: Vec<F>,    // covariant over F\n    g: Cell<G>,   // invariant over G\n\n    h1: H,        // would also be covariant over H except...\n    h2: Cell<H>,  // invariant over H, because invariance wins all conflicts\n\n    i: fn(In) -> Out,       // contravariant over In, covariant over Out\n\n    k1: fn(Mixed) -> usize, // would be contravariant over Mixed except..\n    k2: Mixed,              // invariant over Mixed, because invariance wins all conflicts\n}\n}\n```",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Subtyping and Variance - The Rustonomicon</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"The Dark Arts of Advanced and Unsafe Rust Programming\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"theme/nomicon.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"intro.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"meet-safe-and-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Meet Safe and Unsafe</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"safe-unsafe-meaning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> How Safe and Unsafe Interact</a></li><li class=\"chapter-item expanded \"><a href=\"what-unsafe-does.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> What Unsafe Can Do</a></li><li class=\"chapter-item expanded \"><a href=\"working-with-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Working with Unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Data Layout</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"repr-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> repr(Rust)</a></li><li class=\"chapter-item expanded \"><a href=\"exotic-sizes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Exotically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"other-reprs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Other reprs</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"references.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> References</a></li><li class=\"chapter-item expanded \"><a href=\"aliasing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Aliasing</a></li><li class=\"chapter-item expanded \"><a href=\"lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-mismatch.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Limits of Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Lifetime Elision</a></li><li class=\"chapter-item expanded \"><a href=\"unbounded-lifetimes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.6.</strong> Unbounded Lifetimes</a></li><li class=\"chapter-item expanded \"><a href=\"hrtb.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class=\"chapter-item expanded \"><a href=\"subtyping.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">3.8.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"dropck.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.9.</strong> Drop Check</a></li><li class=\"chapter-item expanded \"><a href=\"phantom-data.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.10.</strong> PhantomData</a></li><li class=\"chapter-item expanded \"><a href=\"borrow-splitting.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.11.</strong> Splitting Borrows</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"conversions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Type Conversions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> Coercions</a></li><li class=\"chapter-item expanded \"><a href=\"dot-operator.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> The Dot Operator</a></li><li class=\"chapter-item expanded \"><a href=\"casts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> Casts</a></li><li class=\"chapter-item expanded \"><a href=\"transmutes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.4.</strong> Transmutes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"uninitialized.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Uninitialized Memory</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"checked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Checked</a></li><li class=\"chapter-item expanded \"><a href=\"drop-flags.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> Drop Flags</a></li><li class=\"chapter-item expanded \"><a href=\"unchecked-uninit.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Unchecked</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"obrm.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Ownership Based Resource Management</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"constructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Constructors</a></li><li class=\"chapter-item expanded \"><a href=\"destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"leaking.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Leaking</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"unwinding.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Unwinding</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"exception-safety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Exception Safety</a></li><li class=\"chapter-item expanded \"><a href=\"poisoning.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Poisoning</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"races.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Races</a></li><li class=\"chapter-item expanded \"><a href=\"send-and-sync.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Send and Sync</a></li><li class=\"chapter-item expanded \"><a href=\"atomics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Atomics</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"vec/vec.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Implementing Vec</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"vec/vec-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-alloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Allocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-push-pop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> Push and Pop</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-dealloc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.4.</strong> Deallocating</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.5.</strong> Deref</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-insert-remove.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.6.</strong> Insert and Remove</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-into-iter.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.7.</strong> IntoIter</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-raw.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.8.</strong> RawVec</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-drain.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.9.</strong> Drain</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-zsts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.10.</strong> Handling Zero-Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"vec/vec-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.11.</strong> Final Code</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-and-mutex.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Implementing Arc and Mutex</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Arc</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Layout</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-base.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Base Code</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-clone.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Cloning</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Dropping</a></li><li class=\"chapter-item expanded \"><a href=\"arc-mutex/arc-final.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Final Code</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ffi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> FFI</a></li><li class=\"chapter-item expanded \"><a href=\"beneath-std.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Beneath std</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"panic-handler.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rustonomicon</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/nomicon\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"subtyping-and-variance\"><a class=\"header\" href=\"#subtyping-and-variance\">Subtyping and Variance</a></h1>\n<p>Rust uses lifetimes to track the relationships between borrows and ownership.\nHowever, a naive implementation of lifetimes would be either too restrictive,\nor permit undefined behavior.</p>\n<p>In order to allow flexible usage of lifetimes\nwhile also preventing their misuse, Rust uses <strong>subtyping</strong> and <strong>variance</strong>.</p>\n<p>Let's start with an example.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-comment\">// Note: debug expects two parameters with the *same* lifetime</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">debug</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(a: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>, b: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a = {a:?} b = {b:?}\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> hello: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"hello\"</span>;\n    {\n        <span class=\"hljs-keyword\">let</span> world = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"world\"</span>);\n        <span class=\"hljs-keyword\">let</span> world = &amp;world; <span class=\"hljs-comment\">// 'world has a shorter lifetime than 'static</span>\n        debug(hello, world);\n    }\n}</code></pre></pre>\n<p>In a conservative implementation of lifetimes, since <code class=\"hljs\">hello</code> and <code class=\"hljs\">world</code> have different lifetimes,\nwe might see the following error:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error[E0308]: mismatched types\n --&gt; src/main.rs:10:16\n   |\n10 |         debug(hello, world);\n   |                      ^\n   |                      |\n   |                      expected `&amp;'static str`, found struct `&amp;'world str`\n</code></pre>\n<p>This would be rather unfortunate. In this case,\nwhat we want is to accept any type that lives <em>at least as long</em> as <code class=\"hljs\">'world</code>.\nLet's try using subtyping with our lifetimes.</p>\n<h2 id=\"subtyping\"><a class=\"header\" href=\"#subtyping\">Subtyping</a></h2>\n<p>Subtyping is the idea that one type can be used in place of another.</p>\n<p>Let's define that <code class=\"hljs\">Sub</code> is a subtype of <code class=\"hljs\">Super</code> (we'll be using the notation <code class=\"hljs\">Sub &lt;: Super</code> throughout this chapter).</p>\n<p>What this is suggesting to us is that the set of <em>requirements</em> that <code class=\"hljs\">Super</code> defines\nare completely satisfied by <code class=\"hljs\">Sub</code>. <code class=\"hljs\">Sub</code> may then have more requirements.</p>\n<p>Now, in order to use subtyping with lifetimes, we need to define the requirement of a lifetime:</p>\n<blockquote>\n<p><code class=\"hljs\">'a</code> defines a region of code.</p>\n</blockquote>\n<p>Now that we have a defined set of requirements for lifetimes, we can define how they relate to each other:</p>\n<blockquote>\n<p><code class=\"hljs\">'long &lt;: 'short</code> if and only if <code class=\"hljs\">'long</code> defines a region of code that <strong>completely contains</strong> <code class=\"hljs\">'short</code>.</p>\n</blockquote>\n<p><code class=\"hljs\">'long</code> may define a region larger than <code class=\"hljs\">'short</code>, but that still fits our definition.</p>\n<blockquote>\n<p>As we will see throughout the rest of this chapter,\nsubtyping is a lot more complicated and subtle than this,\nbut this simple rule is a very good 99% intuition.\nAnd unless you write unsafe code, the compiler will automatically handle all the corner cases for you.</p>\n</blockquote>\n<blockquote>\n<p>But this is the Rustonomicon. We're writing unsafe code,\nso we need to understand how this stuff really works, and how we can mess it up.</p>\n</blockquote>\n<p>Going back to our example above, we can say that <code class=\"hljs\">'static &lt;: 'world</code>.\nFor now, let's also accept the idea that subtypes of lifetimes can be passed through references\n(more on this in <a href=\"#variance\">Variance</a>),\n<em>e.g.</em> <code class=\"hljs\">&amp;'static str</code> is a subtype of <code class=\"hljs\">&amp;'world str</code>, then we can \"downgrade\" <code class=\"hljs\">&amp;'static str</code> into a <code class=\"hljs\">&amp;'world str</code>.\nWith that, the example above will compile:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust edition2021 hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">debug</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(a: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>, b: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a = {a:?} b = {b:?}\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> hello: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"hello\"</span>;\n    {\n        <span class=\"hljs-keyword\">let</span> world = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"world\"</span>);\n        <span class=\"hljs-keyword\">let</span> world = &amp;world; <span class=\"hljs-comment\">// 'world has a shorter lifetime than 'static</span>\n        debug(hello, world); <span class=\"hljs-comment\">// hello silently downgrades from `&amp;'static str` into `&amp;'world str`</span>\n    }\n}</code></pre></pre>\n<h2 id=\"variance\"><a class=\"header\" href=\"#variance\">Variance</a></h2>\n<p>Above, we glossed over the fact that <code class=\"hljs\">'static &lt;: 'b</code> implied that <code class=\"hljs\">&amp;'static T &lt;: &amp;'b T</code>. This uses a property known as <em>variance</em>.\nIt's not always as simple as this example, though. To understand that, let's try to extend this example a bit:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust compile_fail E0597 edition2021 hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">assign</span></span>&lt;T&gt;(input: &amp;<span class=\"hljs-keyword\">mut</span> T, val: T) {\n    *input = val;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> hello: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"hello\"</span>;\n    {\n        <span class=\"hljs-keyword\">let</span> world = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"world\"</span>);\n        assign(&amp;<span class=\"hljs-keyword\">mut</span> hello, &amp;world);\n    }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{hello}\"</span>); <span class=\"hljs-comment\">// use after free ðŸ˜¿</span>\n}</code></pre></pre>\n<p>In <code class=\"hljs\">assign</code>, we are setting the <code class=\"hljs\">hello</code> reference to point to <code class=\"hljs\">world</code>.\nBut then <code class=\"hljs\">world</code> goes out of scope, before the later use of <code class=\"hljs\">hello</code> in the println!</p>\n<p>This is a classic use-after-free bug!</p>\n<p>Our first instinct might be to blame the <code class=\"hljs\">assign</code> impl, but there's really nothing wrong here.\nIt shouldn't be surprising that we might want to assign a <code class=\"hljs\">T</code> into a <code class=\"hljs\">T</code>.</p>\n<p>The problem is that we cannot assume that <code class=\"hljs\">&amp;mut &amp;'static str</code> and <code class=\"hljs\">&amp;mut &amp;'b str</code> are compatible.\nThis means that <code class=\"hljs\">&amp;mut &amp;'static str</code> <strong>cannot</strong> be a <em>subtype</em> of <code class=\"hljs\">&amp;mut &amp;'b str</code>,\neven if <code class=\"hljs\">'static</code> is a subtype of <code class=\"hljs\">'b</code>.</p>\n<p>Variance is the concept that Rust borrows to define relationships about subtypes through their generic parameters.</p>\n<blockquote>\n<p>NOTE: For convenience we will define a generic type <code class=\"hljs\">F&lt;T&gt;</code> so\nthat we can easily talk about <code class=\"hljs\">T</code>. Hopefully this is clear in context.</p>\n</blockquote>\n<p>The type <code class=\"hljs\">F</code>'s <em>variance</em> is how the subtyping of its inputs affects the\nsubtyping of its outputs. There are three kinds of variance in Rust. Given two\ntypes <code class=\"hljs\">Sub</code> and <code class=\"hljs\">Super</code>, where <code class=\"hljs\">Sub</code> is a subtype of <code class=\"hljs\">Super</code>:</p>\n<ul>\n<li><code class=\"hljs\">F</code> is <strong>covariant</strong> if <code class=\"hljs\">F&lt;Sub&gt;</code> is a subtype of <code class=\"hljs\">F&lt;Super&gt;</code> (the subtype property is passed through)</li>\n<li><code class=\"hljs\">F</code> is <strong>contravariant</strong> if <code class=\"hljs\">F&lt;Super&gt;</code> is a subtype of <code class=\"hljs\">F&lt;Sub&gt;</code> (the subtype property is \"inverted\")</li>\n<li><code class=\"hljs\">F</code> is <strong>invariant</strong> otherwise (no subtyping relationship exists)</li>\n</ul>\n<p>If we remember from the above examples,\nit was ok for us to treat <code class=\"hljs\">&amp;'a T</code> as a subtype of <code class=\"hljs\">&amp;'b T</code> if <code class=\"hljs\">'a &lt;: 'b</code>,\ntherefore we can say that <code class=\"hljs\">&amp;'a T</code> is <em>covariant</em> over <code class=\"hljs\">'a</code>.</p>\n<p>Also, we saw that it was not ok for us to treat <code class=\"hljs\">&amp;mut &amp;'a U</code> as a subtype of <code class=\"hljs\">&amp;mut &amp;'b U</code>,\ntherefore we can say that <code class=\"hljs\">&amp;mut T</code> is <em>invariant</em> over <code class=\"hljs\">T</code></p>\n<p>Here is a table of some other generic types and their variances:</p>\n<div class=\"table-wrapper\"><table><thead><tr><th></th><th style=\"text-align: center\">'a</th><th style=\"text-align: center\">T</th><th style=\"text-align: center\">U</th></tr></thead><tbody>\n<tr><td><code class=\"hljs\">&amp;'a T </code></td><td style=\"text-align: center\">covariant</td><td style=\"text-align: center\">covariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">&amp;'a mut T</code></td><td style=\"text-align: center\">covariant</td><td style=\"text-align: center\">invariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">Box&lt;T&gt;</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\">covariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">Vec&lt;T&gt;</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\">covariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">UnsafeCell&lt;T&gt;</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\">invariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">Cell&lt;T&gt;</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\">invariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">fn(T) -&gt; U</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\"><strong>contra</strong>variant</td><td style=\"text-align: center\">covariant</td></tr>\n<tr><td><code class=\"hljs\">*const T</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\">covariant</td><td style=\"text-align: center\"></td></tr>\n<tr><td><code class=\"hljs\">*mut T</code></td><td style=\"text-align: center\"></td><td style=\"text-align: center\">invariant</td><td style=\"text-align: center\"></td></tr>\n</tbody></table>\n</div>\n<p>Some of these can be explained simply in relation to the others:</p>\n<ul>\n<li><code class=\"hljs\">Vec&lt;T&gt;</code> and all other owning pointers and collections follow the same logic as <code class=\"hljs\">Box&lt;T&gt;</code></li>\n<li><code class=\"hljs\">Cell&lt;T&gt;</code> and all other interior mutability types follow the same logic as <code class=\"hljs\">UnsafeCell&lt;T&gt;</code></li>\n<li><code class=\"hljs\">UnsafeCell&lt;T&gt;</code> having interior mutability gives it the same variance properties as <code class=\"hljs\">&amp;mut T</code></li>\n<li><code class=\"hljs\">*const T</code> follows the logic of <code class=\"hljs\">&amp;T</code></li>\n<li><code class=\"hljs\">*mut T</code> follows the logic of <code class=\"hljs\">&amp;mut T</code> (or <code class=\"hljs\">UnsafeCell&lt;T&gt;</code>)</li>\n</ul>\n<p>For more types, see the <a href=\"../reference/subtyping.html#variance\">\"Variance\" section</a> on the reference.</p>\n<blockquote>\n<p>NOTE: the <em>only</em> source of contravariance in the language is the arguments to\na function, which is why it really doesn't come up much in practice. Invoking\ncontravariance involves higher-order programming with function pointers that\ntake references with specific lifetimes (as opposed to the usual \"any lifetime\",\nwhich gets into higher rank lifetimes, which work independently of subtyping).</p>\n</blockquote>\n<p>Now that we have some more formal understanding of variance,\nlet's go through some more examples in more detail.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust compile_fail E0597 edition2021 hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">assign</span></span>&lt;T&gt;(input: &amp;<span class=\"hljs-keyword\">mut</span> T, val: T) {\n    *input = val;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> hello: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"hello\"</span>;\n    {\n        <span class=\"hljs-keyword\">let</span> world = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"world\"</span>);\n        assign(&amp;<span class=\"hljs-keyword\">mut</span> hello, &amp;world);\n    }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{hello}\"</span>);\n}</code></pre></pre>\n<p>And what do we get when we run this?</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">error[E0597]: `world` does not live long enough\n  --&gt; src/main.rs:9:28\n   |\n6  |     let mut hello: &amp;'static str = \"hello\";\n   |                    ------------ type annotation requires that `world` is borrowed for `'static`\n...\n9  |         assign(&amp;mut hello, &amp;world);\n   |                            ^^^^^^ borrowed value does not live long enough\n10 |     }\n   |     - `world` dropped here while still borrowed\n</code></pre>\n<p>Good, it doesn't compile! Let's break down what's happening here in detail.</p>\n<p>First let's look at the <code class=\"hljs\">assign</code> function:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">assign</span></span>&lt;T&gt;(input: &amp;<span class=\"hljs-keyword\">mut</span> T, val: T) {\n    *input = val;\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>All it does is take a mutable reference and a value and overwrite the referent with it.\nWhat's important about this function is that it creates a type equality constraint. It\nclearly says in its signature the referent and the value must be the <em>exact same</em> type.</p>\n<p>Meanwhile, in the caller we pass in <code class=\"hljs\">&amp;mut &amp;'static str</code> and <code class=\"hljs\">&amp;'world str</code>.</p>\n<p>Because <code class=\"hljs\">&amp;mut T</code> is invariant over <code class=\"hljs\">T</code>, the compiler concludes it can't apply any subtyping\nto the first argument, and so <code class=\"hljs\">T</code> must be exactly <code class=\"hljs\">&amp;'static str</code>.</p>\n<p>This is counter to the <code class=\"hljs\">&amp;T</code> case:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">debug</span></span>&lt;T: std::fmt::<span class=\"hljs-built_in\">Debug</span>&gt;(a: T, b: T) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a = {a:?} b = {b:?}\"</span>);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>where similarly <code class=\"hljs\">a</code> and <code class=\"hljs\">b</code> must have the same type <code class=\"hljs\">T</code>.\nBut since <code class=\"hljs\">&amp;'a T</code> <em>is</em> covariant over <code class=\"hljs\">'a</code>, we are allowed to perform subtyping.\nSo the compiler decides that <code class=\"hljs\">&amp;'static str</code> can become <code class=\"hljs\">&amp;'b str</code> if and only if\n<code class=\"hljs\">&amp;'static str</code> is a subtype of <code class=\"hljs\">&amp;'b str</code>, which will hold if <code class=\"hljs\">'static &lt;: 'b</code>.\nThis is true, so the compiler is happy to continue compiling this code.</p>\n<p>As it turns out, the argument for why it's ok for Box (and Vec, HashMap, etc.) to be covariant is pretty similar to the argument for why it's ok for lifetimes to be covariant: as soon as you try to stuff them in something like a mutable reference, they inherit invariance and you're prevented from doing anything bad.</p>\n<p>However Box makes it easier to focus on the by-value aspect of references that we partially glossed over.</p>\n<p>Unlike a lot of languages which allow values to be freely aliased at all times, Rust has a very strict rule: if you're allowed to mutate or move a value, you are guaranteed to be the only one with access to it.</p>\n<p>Consider the following code:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">let</span> hello: <span class=\"hljs-built_in\">Box</span>&lt;&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt; = <span class=\"hljs-built_in\">Box</span>::new(<span class=\"hljs-string\">\"hello\"</span>);\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> world: <span class=\"hljs-built_in\">Box</span>&lt;&amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-built_in\">str</span>&gt;;\nworld = hello;</code></pre>\n<p>There is no problem at all with the fact that we have forgotten that <code class=\"hljs\">hello</code> was alive for <code class=\"hljs\">'static</code>,\nbecause as soon as we moved <code class=\"hljs\">hello</code> to a variable that only knew it was alive for <code class=\"hljs\">'b</code>,\n<strong>we destroyed the only thing in the universe that remembered it lived for longer</strong>!</p>\n<p>Only one thing left to explain: function pointers.</p>\n<p>To see why <code class=\"hljs\">fn(T) -&gt; U</code> should be covariant over <code class=\"hljs\">U</code>, consider the following signature:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get_str</span></span>() -&gt; &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>;</code></pre>\n<p>This function claims to produce a <code class=\"hljs\">str</code> bound by some lifetime <code class=\"hljs\">'a</code>. As such, it is perfectly valid to\nprovide a function with the following signature instead:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get_static</span></span>() -&gt; &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>;</code></pre>\n<p>So when the function is called, all it's expecting is a <code class=\"hljs\">&amp;str</code> which lives at least the lifetime of <code class=\"hljs\">'a</code>,\nit doesn't matter if the value actually lives longer.</p>\n<p>However, the same logic does not apply to <em>arguments</em>. Consider trying to satisfy:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">store_ref</span></span>(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>);</code></pre>\n<p>with:</p>\n<!-- ignore: simplified code -->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">store_static</span></span>(&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>);</code></pre>\n<p>The first function can accept any string reference as long as it lives at least for <code class=\"hljs\">'a</code>,\nbut the second cannot accept a string reference that lives for any duration less than <code class=\"hljs\">'static</code>,\nwhich would cause a conflict.\nCovariance doesn't work here. But if we flip it around, it actually <em>does</em>\nwork! If we need a function that can handle <code class=\"hljs\">&amp;'static str</code>, a function that can handle <em>any</em> reference lifetime\nwill surely work fine.</p>\n<p>Let's see this in practice</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust compile_fail edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n</span>thread_local! {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">static</span> StaticVecs: RefCell&lt;<span class=\"hljs-built_in\">Vec</span>&lt;&amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>&gt;&gt; = RefCell::new(<span class=\"hljs-built_in\">Vec</span>::new());\n}\n\n<span class=\"hljs-comment\">/// saves the input given into a thread local `Vec&lt;&amp;'static str&gt;`</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">store</span></span>(input: &amp;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-built_in\">str</span>) {\n    StaticVecs.with_borrow_mut(|v| v.push(input));\n}\n\n<span class=\"hljs-comment\">/// Calls the function with it's input (must have the same lifetime!)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">demo</span></span>&lt;<span class=\"hljs-symbol\">'a</span>&gt;(input: &amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>, f: <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(&amp;<span class=\"hljs-symbol\">'a</span> <span class=\"hljs-built_in\">str</span>)) {\n    f(input);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    demo(<span class=\"hljs-string\">\"hello\"</span>, store); <span class=\"hljs-comment\">// \"hello\" is 'static. Can call `store` fine</span>\n\n    {\n        <span class=\"hljs-keyword\">let</span> smuggle = <span class=\"hljs-built_in\">String</span>::from(<span class=\"hljs-string\">\"smuggle\"</span>);\n\n        <span class=\"hljs-comment\">// `&amp;smuggle` is not static. If we were to call `store` with `&amp;smuggle`,</span>\n        <span class=\"hljs-comment\">// we would have pushed an invalid lifetime into the `StaticVecs`.</span>\n        <span class=\"hljs-comment\">// Therefore, `fn(&amp;'static str)` cannot be a subtype of `fn(&amp;'a str)`</span>\n        demo(&amp;smuggle, store);\n    }\n\n    <span class=\"hljs-comment\">// use after free ðŸ˜¿</span>\n    StaticVecs.with_borrow(|v| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{v:?}\"</span>));\n}</code></pre></pre>\n<p>And that's why function types, unlike anything else in the language, are\n<strong>contra</strong>variant over their arguments.</p>\n<p>Now, this is all well and good for the types the standard library provides, but\nhow is variance determined for types that <em>you</em> define? A struct, informally\nspeaking, inherits the variance of its fields. If a struct <code class=\"hljs\">MyType</code>\nhas a generic argument <code class=\"hljs\">A</code> that is used in a field <code class=\"hljs\">a</code>, then MyType's variance\nover <code class=\"hljs\">A</code> is exactly <code class=\"hljs\">a</code>'s variance over <code class=\"hljs\">A</code>.</p>\n<p>However if <code class=\"hljs\">A</code> is used in multiple fields:</p>\n<ul>\n<li>If all uses of <code class=\"hljs\">A</code> are covariant, then MyType is covariant over <code class=\"hljs\">A</code></li>\n<li>If all uses of <code class=\"hljs\">A</code> are contravariant, then MyType is contravariant over <code class=\"hljs\">A</code></li>\n<li>Otherwise, MyType is invariant over <code class=\"hljs\">A</code></li>\n</ul>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::cell::Cell;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyType</span></span>&lt;<span class=\"hljs-symbol\">'a</span>, <span class=\"hljs-symbol\">'b</span>, A: <span class=\"hljs-symbol\">'a</span>, B: <span class=\"hljs-symbol\">'b</span>, C, D, E, F, G, H, In, Out, Mixed&gt; {\n    a: &amp;<span class=\"hljs-symbol\">'a</span> A,     <span class=\"hljs-comment\">// covariant over 'a and A</span>\n    b: &amp;<span class=\"hljs-symbol\">'b</span> <span class=\"hljs-keyword\">mut</span> B, <span class=\"hljs-comment\">// covariant over 'b and invariant over B</span>\n\n    c: *<span class=\"hljs-keyword\">const</span> C,  <span class=\"hljs-comment\">// covariant over C</span>\n    d: *<span class=\"hljs-keyword\">mut</span> D,    <span class=\"hljs-comment\">// invariant over D</span>\n\n    e: E,         <span class=\"hljs-comment\">// covariant over E</span>\n    f: <span class=\"hljs-built_in\">Vec</span>&lt;F&gt;,    <span class=\"hljs-comment\">// covariant over F</span>\n    g: Cell&lt;G&gt;,   <span class=\"hljs-comment\">// invariant over G</span>\n\n    h1: H,        <span class=\"hljs-comment\">// would also be covariant over H except...</span>\n    h2: Cell&lt;H&gt;,  <span class=\"hljs-comment\">// invariant over H, because invariance wins all conflicts</span>\n\n    i: <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(In) -&gt; Out,       <span class=\"hljs-comment\">// contravariant over In, covariant over Out</span>\n\n    k1: <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(Mixed) -&gt; <span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-comment\">// would be contravariant over Mixed except..</span>\n    k2: Mixed,              <span class=\"hljs-comment\">// invariant over Mixed, because invariance wins all conflicts</span>\n}\n<span class=\"boring\">}</span></code></pre></pre>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"hrtb.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"dropck.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"hrtb.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"dropck.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:14:06.288Z"
}