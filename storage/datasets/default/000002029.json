{
	"title": "core::arch::x86 - Rust",
	"url": "https://doc.rust-lang.org/stable/core/arch/x86/index.html",
	"markdown": "# core::arch::x86 - Rust\n\n## Module [core](../../index.html)::[arch](../index.html)::[x86](#)\n\n1.27.0 · [source](about:blank/src/core/stdarch/crates/core_arch/src/mod.rs.html#28) ·\n\nAvailable on **x86** only.\n\nExpand description\n\n-   Result of the `cpuid` instruction.\n    \n-   128-bit wide set of four `f32` types, x86-specific\n    \n-   128-bit wide set of two `f64` types, x86-specific\n    \n-   128-bit wide integer vector type, x86-specific\n    \n-   256-bit wide set of eight `f32` types, x86-specific\n    \n-   256-bit wide set of four `f64` types, x86-specific\n    \n-   256-bit wide integer vector type, x86-specific\n    \n-   512-bit wide set of sixteen `f32` types, x86-specific\n    \n-   512-bit wide set of eight `f64` types, x86-specific\n    \n-   512-bit wide integer vector type, x86-specific\n    \n-   [\\_\\_m128bh](struct.__m128bh.html \"struct core::arch::x86::__m128bh\")Experimentalx86 or x86-64\n    \n    128-bit wide set of eight `u16` types, x86-specific\n    \n-   [\\_\\_m256bh](struct.__m256bh.html \"struct core::arch::x86::__m256bh\")Experimentalx86 or x86-64\n    \n    256-bit wide set of 16 `u16` types, x86-specific\n    \n-   [\\_\\_m512bh](struct.__m512bh.html \"struct core::arch::x86::__m512bh\")Experimentalx86 or x86-64\n    \n    512-bit wide set of 32 `u16` types, x86-specific\n    \n\n-   Equal (ordered, non-signaling)\n    \n-   Equal (ordered, signaling)\n    \n-   Equal (unordered, non-signaling)\n    \n-   Equal (unordered, signaling)\n    \n-   False (ordered, non-signaling)\n    \n-   False (ordered, signaling)\n    \n-   Greater-than-or-equal (ordered, non-signaling)\n    \n-   Greater-than-or-equal (ordered, signaling)\n    \n-   Greater-than (ordered, non-signaling)\n    \n-   Greater-than (ordered, signaling)\n    \n-   Less-than-or-equal (ordered, non-signaling)\n    \n-   Less-than-or-equal (ordered, signaling)\n    \n-   Less-than (ordered, non-signaling)\n    \n-   Less-than (ordered, signaling)\n    \n-   Not-equal (ordered, non-signaling)\n    \n-   Not-equal (ordered, signaling)\n    \n-   Not-equal (unordered, non-signaling)\n    \n-   Not-equal (unordered, signaling)\n    \n-   Not-greater-than-or-equal (unordered, non-signaling)\n    \n-   Not-greater-than-or-equal (unordered, signaling)\n    \n-   Not-greater-than (unordered, non-signaling)\n    \n-   Not-greater-than (unordered, signaling)\n    \n-   Not-less-than-or-equal (unordered, non-signaling)\n    \n-   Not-less-than-or-equal (unordered, signaling)\n    \n-   Not-less-than (unordered, non-signaling)\n    \n-   Not-less-than (unordered, signaling)\n    \n-   Ordered (non-signaling)\n    \n-   Ordered (signaling)\n    \n-   True (unordered, non-signaling)\n    \n-   True (unordered, signaling)\n    \n-   Unordered (non-signaling)\n    \n-   Unordered (signaling)\n    \n\n-   round up and do not suppress exceptions\n    \n-   use MXCSR.RC; see `vendor::_MM_SET_ROUNDING_MODE`\n    \n-   round down and do not suppress exceptions\n    \n-   use MXCSR.RC and suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`\n    \n-   round to nearest and do not suppress exceptions\n    \n-   suppress exceptions\n    \n-   do not suppress exceptions\n    \n-   use MXCSR.RC and do not suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`\n    \n-   round to nearest\n    \n-   round down\n    \n-   round up\n    \n-   truncate\n    \n-   truncate and do not suppress exceptions\n    \n\n-   **Mask only**: return the bit mask\n    \n-   For each character in `a`, find if it is in `b` _(Default)_\n    \n-   The strings defined by `a` and `b` are equal\n    \n-   Search for the defined substring in the target\n    \n-   For each character in `a`, determine if `b[0] <= c <= b[1] or b[1] <= c <= b[2]...`\n    \n-   **Index only**: return the least significant bit _(Default)_\n    \n-   Negates results only before the end of the string\n    \n-   Do not negate results before the end of the string\n    \n-   **Index only**: return the most significant bit\n    \n-   Negates results\n    \n-   Do not negate results _(Default)_\n    \n-   String contains signed 8-bit characters\n    \n-   String contains unsigned 16-bit characters\n    \n-   String contains unsigned 8-bit characters _(Default)_\n    \n-   **Mask only**: return the byte mask\n    \n-   String contains unsigned 16-bit characters\n    \n-   `XFEATURE_ENABLED_MASK` for `XCR`\n    \n-   Equal\n    \n-   False\n    \n-   Less-than-or-equal\n    \n-   Less-than\n    \n-   Not-equal\n    \n-   Not less-than-or-equal\n    \n-   Not less-than\n    \n-   True\n    \n-   interval \\[1, 2)\n    \n-   interval \\[0.5, 1)\n    \n-   interval \\[0.5, 2)\n    \n-   interval \\[0.75, 1.5)\n    \n-   DEST = NaN if sign(SRC) = 1\n    \n-   sign = sign(SRC)\n    \n-   sign = 0\n    \n\n-   Transaction abort due to the transaction using too much memory.\n    \n-   Transaction abort due to a memory conflict with another thread.\n    \n-   Transaction abort due to a debug trap.\n    \n-   Transaction explicitly aborted with xabort. The parameter passed to xabort is available with `_xabort_code(status)`.\n    \n-   Transaction abort in a inner nested transaction.\n    \n-   Transaction retry is possible.\n    \n-   Transaction successfully started.\n    \n\n-   Transpose the 4x4 matrix formed by 4 rows of \\_\\_m128 in place.\n    \n\n-   Returns the result of the `cpuid` instruction for a given `leaf` (`EAX`) and `sub_leaf` (`ECX`).\n    \n-   Returns the highest-supported `leaf` (`EAX`) and sub-leaf (`ECX`) `cpuid` values.\n    \n-   Reads the current value of the processor’s time-stamp counter and the `IA32_TSC_AUX MSR`.\n    \n-   Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag).\n    \n-   Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry or overflow flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag).\n    \n-   Bitwise logical `AND` of inverted `a` with `b`.\n    \n-   Extracts bits of `a` specified by `control` into the least significant bits of the result.\n    \n-   Extracts bits in range \\[`start`, `start` + `length`) from `a` into the least significant bits of the result.\n    \n-   Returns the bit in position `b` of the memory addressed by `p`.\n    \n-   Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit.\n    \n-   Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`.\n    \n-   Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`.\n    \n-   Clears all bits below the least significant zero bit of `x`.\n    \n-   Clears all bits below the least significant zero bit of `x`.\n    \n-   Sets all bits of `x` to 1 except for the least significant zero bit.\n    \n-   Sets all bits of `x` to 1 except for the least significant zero bit.\n    \n-   Sets the least significant zero bit of `x` and clears all other bits.\n    \n-   Sets the least significant zero bit of `x` and clears all other bits.\n    \n-   Sets the least significant zero bit of `x` and clears all bits above that bit.\n    \n-   Sets the least significant zero bit of `x` and clears all bits above that bit.\n    \n-   Sets the least significant zero bit of `x`.\n    \n-   Sets the least significant zero bit of `x`.\n    \n-   Sets all bits of `x` below the least significant one.\n    \n-   Sets all bits of `x` below the least significant one.\n    \n-   Extracts lowest set isolated bit.\n    \n-   Clears least significant bit and sets all other bits.\n    \n-   Clears least significant bit and sets all other bits.\n    \n-   Gets mask up to lowest set bit.\n    \n-   Resets the lowest set bit of `x`.\n    \n-   Returns an integer with the reversed byte order of x\n    \n-   Zeroes higher bits of `a` >= `index`.\n    \n-   [\\_fxrstor](fn._fxrstor.html \"fn core::arch::x86::_fxrstor\")⚠(x86 or x86-64) and `fxsr`\n    \n    Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the 512-byte-long 16-byte-aligned memory region `mem_addr`.\n    \n-   [\\_fxsave](fn._fxsave.html \"fn core::arch::x86::_fxsave\")⚠(x86 or x86-64) and `fxsr`\n    \n    Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the 512-byte-long 16-byte-aligned memory region `mem_addr`.\n    \n-   Counts the leading most significant zero bits.\n    \n-   Computes the absolute values of packed 8-bit integers in `a`.\n    \n-   Computes the absolute values of packed 16-bit integers in `a`.\n    \n-   Computes the absolute values of packed 32-bit integers in `a`.\n    \n-   Adds packed 8-bit integers in `a` and `b`.\n    \n-   Adds packed 16-bit integers in `a` and `b`.\n    \n-   Adds packed 32-bit integers in `a` and `b`.\n    \n-   Adds packed 64-bit integers in `a` and `b`.\n    \n-   Adds packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Adds packed single-precision (32-bit) floating-point elements in `a` and `b`.\n    \n-   Adds packed 8-bit integers in `a` and `b` using saturation.\n    \n-   Adds packed 16-bit integers in `a` and `b` using saturation.\n    \n-   Adds packed unsigned 8-bit integers in `a` and `b` using saturation.\n    \n-   Adds packed unsigned 16-bit integers in `a` and `b` using saturation.\n    \n-   Alternatively adds and subtracts packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`.\n    \n-   Alternatively adds and subtracts packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`.\n    \n-   Concatenates pairs of 16-byte blocks in `a` and `b` into a 32-byte temporary result, shifts the result right by `n` bytes, and returns the low 16 bytes.\n    \n-   Computes the bitwise AND of a packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Computes the bitwise AND of packed single-precision (32-bit) floating-point elements in `a` and `b`.\n    \n-   Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`.\n    \n-   Computes the bitwise NOT of packed double-precision (64-bit) floating-point elements in `a`, and then AND with `b`.\n    \n-   Computes the bitwise NOT of packed single-precision (32-bit) floating-point elements in `a` and then AND with `b`.\n    \n-   Computes the bitwise NOT of 256 bits (representing integer data) in `a` and then AND with `b`.\n    \n-   Averages packed unsigned 8-bit integers in `a` and `b`.\n    \n-   Averages packed unsigned 16-bit integers in `a` and `b`.\n    \n-   Blends packed 16-bit integers from `a` and `b` using control mask `IMM8`.\n    \n-   Blends packed 32-bit integers from `a` and `b` using control mask `IMM8`.\n    \n-   Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using control mask `imm8`.\n    \n-   Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using control mask `imm8`.\n    \n-   Blends packed 8-bit integers from `a` and `b` using `mask`.\n    \n-   Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using `c` as a mask.\n    \n-   Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using `c` as a mask.\n    \n-   Broadcasts 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of the returned vector.\n    \n-   Broadcasts 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of the returned vector.\n    \n-   Broadcasts a double-precision (64-bit) floating-point element from memory to all elements of the returned vector.\n    \n-   Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector.\n    \n-   Broadcasts the low packed 8-bit integer from `a` to all elements of the 256-bit returned value.\n    \n-   Broadcasts the low packed 32-bit integer from `a` to all elements of the 256-bit returned value.\n    \n-   Broadcasts the low packed 64-bit integer from `a` to all elements of the 256-bit returned value.\n    \n-   Broadcasts the low double-precision (64-bit) floating-point element from `a` to all elements of the 256-bit returned value.\n    \n-   Broadcasts 128 bits of integer data from a to all 128-bit lanes in the 256-bit returned value.\n    \n-   Broadcasts the low single-precision (32-bit) floating-point element from `a` to all elements of the 256-bit returned value.\n    \n-   Broadcasts the low packed 16-bit integer from a to all elements of the 256-bit returned value\n    \n-   Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.\n    \n-   Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.\n    \n-   Casts vector of type \\_\\_m128d to type \\_\\_m256d; the upper 128 bits of the result are undefined.\n    \n-   Casts vector of type \\_\\_m256d to type \\_\\_m128d.\n    \n-   Cast vector of type \\_\\_m256d to type \\_\\_m256.\n    \n-   Casts vector of type \\_\\_m256d to type \\_\\_m256i.\n    \n-   Casts vector of type \\_\\_m128 to type \\_\\_m256; the upper 128 bits of the result are undefined.\n    \n-   Casts vector of type \\_\\_m256 to type \\_\\_m128.\n    \n-   Cast vector of type \\_\\_m256 to type \\_\\_m256d.\n    \n-   Casts vector of type \\_\\_m256 to type \\_\\_m256i.\n    \n-   Casts vector of type \\_\\_m128i to type \\_\\_m256i; the upper 128 bits of the result are undefined.\n    \n-   Casts vector of type \\_\\_m256i to type \\_\\_m256d.\n    \n-   Casts vector of type \\_\\_m256i to type \\_\\_m256.\n    \n-   Casts vector of type \\_\\_m256i to type \\_\\_m128i.\n    \n-   Rounds packed double-precision (64-bit) floating point elements in `a` toward positive infinity.\n    \n-   Rounds packed single-precision (32-bit) floating point elements in `a` toward positive infinity.\n    \n-   Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `IMM5`.\n    \n-   Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `IMM5`.\n    \n-   Compares packed 8-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 16-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 32-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 64-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 8-bit integers in `a` and `b` for greater-than.\n    \n-   Compares packed 16-bit integers in `a` and `b` for greater-than.\n    \n-   Compares packed 32-bit integers in `a` and `b` for greater-than.\n    \n-   Compares packed 64-bit integers in `a` and `b` for greater-than.\n    \n-   Sign-extend 8-bit integers to 16-bit integers.\n    \n-   Sign-extend 8-bit integers to 32-bit integers.\n    \n-   Sign-extend 8-bit integers to 64-bit integers.\n    \n-   Sign-extend 16-bit integers to 32-bit integers.\n    \n-   Sign-extend 16-bit integers to 64-bit integers.\n    \n-   Sign-extend 32-bit integers to 64-bit integers.\n    \n-   Converts packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements.\n    \n-   Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements.\n    \n-   Zero-extend unsigned 8-bit integers in `a` to 16-bit integers.\n    \n-   Zero-extend the lower eight unsigned 8-bit integers in `a` to 32-bit integers. The upper eight elements of `a` are unused.\n    \n-   Zero-extend the lower four unsigned 8-bit integers in `a` to 64-bit integers. The upper twelve elements of `a` are unused.\n    \n-   Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit integers, and stores the results in `dst`.\n    \n-   Zero-extend the lower four unsigned 16-bit integers in `a` to 64-bit integers. The upper four elements of `a` are unused.\n    \n-   Zero-extend unsigned 32-bit integers in `a` to 64-bit integers.\n    \n-   Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers.\n    \n-   Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements.\n    \n-   Converts the 8 x 16-bit half-precision float values in the 128-bit vector `a` into 8 x 32-bit float values stored in a 256-bit wide vector.\n    \n-   Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers.\n    \n-   Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements.\n    \n-   Converts the 8 x 32-bit float values in the 256-bit vector `a` into 8 x 16-bit half-precision float values stored in a 128-bit wide vector.\n    \n-   Returns the first element of the input vector of `[4 x double]`.\n    \n-   Returns the first element of the input vector of `[8 x i32]`.\n    \n-   Returns the first element of the input vector of `[8 x float]`.\n    \n-   Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation.\n    \n-   Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation.\n    \n-   Computes the division of each of the 4 packed 64-bit floating-point elements in `a` by the corresponding packed elements in `b`.\n    \n-   Computes the division of each of the 8 packed 32-bit floating-point elements in `a` by the corresponding packed elements in `b`.\n    \n-   Conditionally multiplies the packed single-precision (32-bit) floating-point elements in `a` and `b` using the high 4 bits in `imm8`, sum the four products, and conditionally return the sum using the low 4 bits of `imm8`.\n    \n-   Extracts an 8-bit integer from `a`, selected with `INDEX`. Returns a 32-bit integer containing the zero-extended integer data.\n    \n-   Extracts a 16-bit integer from `a`, selected with `INDEX`. Returns a 32-bit integer containing the zero-extended integer data.\n    \n-   Extracts a 32-bit integer from `a`, selected with `INDEX`.\n    \n-   Extracts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a`, selected with `imm8`.\n    \n-   Extracts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `a`, selected with `imm8`.\n    \n-   Extracts 128 bits (composed of integer data) from `a`, selected with `imm8`.\n    \n-   Extracts 128 bits (of integer data) from `a` selected with `IMM1`.\n    \n-   Rounds packed double-precision (64-bit) floating point elements in `a` toward negative infinity.\n    \n-   Rounds packed single-precision (32-bit) floating point elements in `a` toward negative infinity.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.\n    \n-   Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`.\n    \n-   Horizontally adds adjacent pairs of 32-bit integers in `a` and `b`.\n    \n-   Horizontal addition of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations.\n    \n-   Horizontal addition of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5; while sums of elements from `b` are locations 2, 3, 6, 7.\n    \n-   Horizontally adds adjacent pairs of 16-bit integers in `a` and `b` using saturation.\n    \n-   Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`.\n    \n-   Horizontally subtract adjacent pairs of 32-bit integers in `a` and `b`.\n    \n-   Horizontal subtraction of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations.\n    \n-   Horizontal subtraction of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5; while sums of elements from `b` are locations 2, 3, 6, 7.\n    \n-   Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b` using saturation.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Copies `a` to result, and inserts the 8-bit integer `i` into result at the location specified by `index`.\n    \n-   Copies `a` to result, and inserts the 16-bit integer `i` into result at the location specified by `index`.\n    \n-   Copies `a` to result, and inserts the 32-bit integer `i` into result at the location specified by `index`.\n    \n-   Copies `a` to result, then inserts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `b` into result at the location specified by `imm8`.\n    \n-   Copies `a` to result, then inserts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `b` into result at the location specified by `imm8`.\n    \n-   Copies `a` to result, then inserts 128 bits from `b` into result at the location specified by `imm8`.\n    \n-   Copies `a` to `dst`, then insert 128 bits (of integer data) from `b` at the location specified by `IMM1`.\n    \n-   Loads 256-bits of integer data from unaligned memory into result. This intrinsic may perform better than `_mm256_loadu_si256` when the data crosses a cache line boundary.\n    \n-   Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Loads 256-bits of integer data from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Loads two 128-bit values (composed of 4 packed single-precision (32-bit) floating-point elements) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.\n    \n-   Loads two 128-bit values (composed of 2 packed double-precision (64-bit) floating-point elements) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.\n    \n-   Loads two 128-bit values (composed of integer data) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.\n    \n-   Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Loads 256-bits of integer data from memory into result. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Multiplies packed signed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers.\n    \n-   Vertically multiplies each unsigned 8-bit integer from `a` with the corresponding signed 8-bit integer from `b`, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element).\n    \n-   Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element).\n    \n-   Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set).\n    \n-   Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set).\n    \n-   Stores packed 32-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element).\n    \n-   Stores packed 64-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element).\n    \n-   Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`.\n    \n-   Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`.\n    \n-   Compares packed 8-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed 16-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed 32-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed unsigned 16-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed unsigned 32-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed maximum values\n    \n-   Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed maximum values\n    \n-   Compares packed 8-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed 16-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed 32-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed unsigned 16-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed unsigned 32-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed minimum values\n    \n-   Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed minimum values\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from `a`, and returns the results.\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results.\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results.\n    \n-   Creates mask from the most significant bit of each 8-bit element in `a`, return the result.\n    \n-   Sets each bit of the returned mask based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in `a`.\n    \n-   Sets each bit of the returned mask based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in `a`.\n    \n-   Computes the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in `a` compared to those in `b`, and stores the 16-bit results in dst. Eight SADs are performed for each 128-bit lane using one quadruplet from `b` and eight quadruplets from `a`. One quadruplet is selected from `b` starting at on the offset specified in `imm8`. Eight quadruplets are formed from sequential 8-bit integers selected from `a` starting at the offset specified in `imm8`.\n    \n-   Multiplies the low 32-bit integers from each packed 64-bit element in `a` and `b`\n    \n-   Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`.\n    \n-   Multiplies the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers.\n    \n-   Multiplies the packed unsigned 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers.\n    \n-   Multiplies packed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and return bits `[16:1]`.\n    \n-   Multiplies the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers, and returns the low 16 bits of the intermediate integers\n    \n-   Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate 64-bit integers, and returns the low 32 bits of the intermediate integers\n    \n-   Computes the bitwise OR packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Computes the bitwise OR packed single-precision (32-bit) floating-point elements in `a` and `b`.\n    \n-   Computes the bitwise OR of 256 bits (representing integer data) in `a` and `b`\n    \n-   Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation\n    \n-   Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation\n    \n-   Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation\n    \n-   Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using unsigned saturation\n    \n-   Shuffles 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) selected by `imm8` from `a` and `b`.\n    \n-   Shuffles 256 bits (composed of 8 packed single-precision (32-bit) floating-point elements) selected by `imm8` from `a` and `b`.\n    \n-   Shuffles 128-bits (composed of integer data) selected by `imm8` from `a` and `b`.\n    \n-   Shuffles 128-bits of integer data selected by `imm8` from `a` and `b`.\n    \n-   Permutes 64-bit integers from `a` using control mask `imm8`.\n    \n-   Shuffles 64-bit floating-point elements in `a` across lanes using the control in `imm8`.\n    \n-   Shuffles double-precision (64-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`.\n    \n-   Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`.\n    \n-   Permutes packed 32-bit integers from `a` according to the content of `b`.\n    \n-   Shuffles eight 32-bit floating-point elements in `a` across lanes using the corresponding 32-bit integer index in `idx`.\n    \n-   Shuffles double-precision (64-bit) floating-point elements in `a` within 256-bit lanes using the control in `b`.\n    \n-   Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `b`.\n    \n-   Computes the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`, and returns the results. The maximum relative error for this approximation is less than 1.5\\*2^-12.\n    \n-   Rounds packed double-precision (64-bit) floating point elements in `a` according to the flag `ROUNDING`. The value of `ROUNDING` may be as follows:\n    \n-   Rounds packed single-precision (32-bit) floating point elements in `a` according to the flag `ROUNDING`. The value of `ROUNDING` may be as follows:\n    \n-   Computes the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`, and returns the results. The maximum relative error for this approximation is less than 1.5\\*2^-12.\n    \n-   Computes the absolute differences of packed unsigned 8-bit integers in `a` and `b`, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of the 64-bit return value\n    \n-   Broadcasts 8-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastb`.\n    \n-   Broadcasts 16-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastw`.\n    \n-   Broadcasts 32-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastd`.\n    \n-   Broadcasts 64-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastq`.\n    \n-   Broadcasts double-precision (64-bit) floating-point value `a` to all elements of returned vector.\n    \n-   Broadcasts single-precision (32-bit) floating-point value `a` to all elements of returned vector.\n    \n-   Sets packed 8-bit integers in returned vector with the supplied values.\n    \n-   Sets packed 16-bit integers in returned vector with the supplied values.\n    \n-   Sets packed 32-bit integers in returned vector with the supplied values.\n    \n-   Sets packed 64-bit integers in returned vector with the supplied values.\n    \n-   Sets packed \\_\\_m256 returned vector with the supplied values.\n    \n-   Sets packed \\_\\_m256d returned vector with the supplied values.\n    \n-   Sets packed \\_\\_m256i returned vector with the supplied values.\n    \n-   Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values.\n    \n-   Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values.\n    \n-   Sets packed 8-bit integers in returned vector with the supplied values in reverse order.\n    \n-   Sets packed 16-bit integers in returned vector with the supplied values in reverse order.\n    \n-   Sets packed 32-bit integers in returned vector with the supplied values in reverse order.\n    \n-   Sets packed 64-bit integers in returned vector with the supplied values in reverse order.\n    \n-   Sets packed \\_\\_m256 returned vector with the supplied values.\n    \n-   Sets packed \\_\\_m256d returned vector with the supplied values.\n    \n-   Sets packed \\_\\_m256i returned vector with the supplied values.\n    \n-   Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values in reverse order.\n    \n-   Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values in reverse order.\n    \n-   Returns vector of type \\_\\_m256d with all elements set to zero.\n    \n-   Returns vector of type \\_\\_m256 with all elements set to zero.\n    \n-   Returns vector of type \\_\\_m256i with all elements set to zero.\n    \n-   Shuffles bytes from `a` according to the content of `b`.\n    \n-   Shuffles 32-bit integers in 128-bit lanes of `a` using the control in `imm8`.\n    \n-   Shuffles double-precision (64-bit) floating-point elements within 128-bit lanes using the control in `imm8`.\n    \n-   Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`.\n    \n-   Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of `a` using the control in `imm8`. The low 64 bits of 128-bit lanes of `a` are copied to the output.\n    \n-   Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of `a` using the control in `imm8`. The high 64 bits of 128-bit lanes of `a` are copied to the output.\n    \n-   Negates packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and returns the results. Results are zeroed out when the corresponding element in `b` is zero.\n    \n-   Negates packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and returns the results. Results are zeroed out when the corresponding element in `b` is zero.\n    \n-   Negates packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and returns the results. Results are zeroed out when the corresponding element in `b` is zero.\n    \n-   Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros, and returns the result\n    \n-   Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros, and returns the result\n    \n-   Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros, and returns the result\n    \n-   Shifts packed 16-bit integers in `a` left by `IMM8` while shifting in zeros, return the results;\n    \n-   Shifts packed 32-bit integers in `a` left by `IMM8` while shifting in zeros, return the results;\n    \n-   Shifts packed 64-bit integers in `a` left by `IMM8` while shifting in zeros, return the results;\n    \n-   Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result.\n    \n-   Shifts packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result.\n    \n-   Returns the square root of packed double-precision (64-bit) floating point elements in `a`.\n    \n-   Returns the square root of packed single-precision (32-bit) floating point elements in `a`.\n    \n-   Shifts packed 16-bit integers in `a` right by `count` while shifting in sign bits.\n    \n-   Shifts packed 32-bit integers in `a` right by `count` while shifting in sign bits.\n    \n-   Shifts packed 16-bit integers in `a` right by `IMM8` while shifting in sign bits.\n    \n-   Shifts packed 32-bit integers in `a` right by `IMM8` while shifting in sign bits.\n    \n-   Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits.\n    \n-   Shifts packed 16-bit integers in `a` right by `count` while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` right by `count` while shifting in zeros.\n    \n-   Shifts packed 64-bit integers in `a` right by `count` while shifting in zeros.\n    \n-   Shifts packed 16-bit integers in `a` right by `IMM8` while shifting in zeros\n    \n-   Shifts packed 32-bit integers in `a` right by `IMM8` while shifting in zeros\n    \n-   Shifts packed 64-bit integers in `a` right by `IMM8` while shifting in zeros\n    \n-   Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,\n    \n-   Shifts packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,\n    \n-   Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Stores 256-bits of integer data from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Stores the high and low 128-bit halves (each composed of 4 packed single-precision (32-bit) floating-point elements) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.\n    \n-   Stores the high and low 128-bit halves (each composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.\n    \n-   Stores the high and low 128-bit halves (each composed of integer data) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.\n    \n-   Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Stores 256-bits of integer data from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Moves double-precision values from a 256-bit vector of `[4 x double]` to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon).\n    \n-   Moves single-precision floating point values from a 256-bit vector of `[8 x float]` to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon).\n    \n-   Moves integer data from a 256-bit integer vector to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)\n    \n-   Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n    \n-   Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n    \n-   Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`\n    \n-   Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`\n    \n-   Subtracts packed double-precision (64-bit) floating-point elements in `b` from packed elements in `a`.\n    \n-   Subtracts packed single-precision (32-bit) floating-point elements in `b` from packed elements in `a`.\n    \n-   Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation.\n    \n-   Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation.\n    \n-   Subtract packed unsigned 8-bit integers in `b` from packed 8-bit integers in `a` using saturation.\n    \n-   Subtract packed unsigned 16-bit integers in `b` from packed 16-bit integers in `a` using saturation.\n    \n-   Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value.\n    \n-   Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value.\n    \n-   Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return the `CF` value.\n    \n-   Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0.\n    \n-   Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0.\n    \n-   Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0.\n    \n-   Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value.\n    \n-   Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value.\n    \n-   Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return the `ZF` value.\n    \n-   Returns vector of type `__m256d` with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Returns vector of type `__m256` with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Returns vector of type \\_\\_m256i with with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Unpacks and interleave 8-bit integers from the high half of each 128-bit lane in `a` and `b`.\n    \n-   Unpacks and interleave 16-bit integers from the high half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave 32-bit integers from the high half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave 64-bit integers from the high half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`.\n    \n-   Unpacks and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`.\n    \n-   Unpacks and interleave 8-bit integers from the low half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave 16-bit integers from the low half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave 32-bit integers from the low half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave 64-bit integers from the low half of each 128-bit lane of `a` and `b`.\n    \n-   Unpacks and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`.\n    \n-   Unpacks and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`.\n    \n-   Computes the bitwise XOR of packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Computes the bitwise XOR of packed single-precision (32-bit) floating-point elements in `a` and `b`.\n    \n-   Computes the bitwise XOR of 256 bits (representing integer data) in `a` and `b`\n    \n-   Zeroes the contents of all XMM or YMM registers.\n    \n-   Zeroes the upper 128 bits of all YMM registers; the lower 128-bits of the registers are unmodified.\n    \n-   Constructs a 256-bit floating-point vector of `[4 x double]` from a 128-bit floating-point vector of `[2 x double]`. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero.\n    \n-   Constructs a 256-bit floating-point vector of `[8 x float]` from a 128-bit floating-point vector of `[4 x float]`. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero.\n    \n-   Constructs a 256-bit integer vector from a 128-bit integer vector. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero.\n    \n-   Computes the absolute value of packed 8-bit signed integers in `a` and return the unsigned results.\n    \n-   Computes the absolute value of each of the packed 16-bit signed integers in `a` and return the 16-bit unsigned integer\n    \n-   Computes the absolute value of each of the packed 32-bit signed integers in `a` and return the 32-bit unsigned integer\n    \n-   Adds packed 8-bit integers in `a` and `b`.\n    \n-   Adds packed 16-bit integers in `a` and `b`.\n    \n-   Adds packed 32-bit integers in `a` and `b`.\n    \n-   Adds packed 64-bit integers in `a` and `b`.\n    \n-   Adds packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Adds \\_\\_m128 vectors.\n    \n-   Returns a new vector with the low element of `a` replaced by the sum of the low elements of `a` and `b`.\n    \n-   Adds the first component of `a` and `b`, the other components are copied from `a`.\n    \n-   Adds packed 8-bit integers in `a` and `b` using saturation.\n    \n-   Adds packed 16-bit integers in `a` and `b` using saturation.\n    \n-   Adds packed unsigned 8-bit integers in `a` and `b` using saturation.\n    \n-   Adds packed unsigned 16-bit integers in `a` and `b` using saturation.\n    \n-   Alternatively add and subtract packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`.\n    \n-   Alternatively add and subtract packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`.\n    \n-   Performs one round of an AES decryption flow on data (state) in `a`.\n    \n-   Performs the last round of an AES decryption flow on data (state) in `a`.\n    \n-   Performs one round of an AES encryption flow on data (state) in `a`.\n    \n-   Performs the last round of an AES encryption flow on data (state) in `a`.\n    \n-   Performs the `InvMixColumns` transformation on `a`.\n    \n-   Assist in expanding the AES cipher key.\n    \n-   Concatenate 16-byte blocks in `a` and `b` into a 32-byte temporary result, shift the result right by `n` bytes, and returns the low 16 bytes.\n    \n-   Computes the bitwise AND of packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Bitwise AND of packed single-precision (32-bit) floating-point elements.\n    \n-   Computes the bitwise AND of 128 bits (representing integer data) in `a` and `b`.\n    \n-   Computes the bitwise NOT of `a` and then AND with `b`.\n    \n-   Bitwise AND-NOT of packed single-precision (32-bit) floating-point elements.\n    \n-   Computes the bitwise NOT of 128 bits (representing integer data) in `a` and then AND with `b`.\n    \n-   Averages packed unsigned 8-bit integers in `a` and `b`.\n    \n-   Averages packed unsigned 16-bit integers in `a` and `b`.\n    \n-   Blend packed 16-bit integers from `a` and `b` using the mask `IMM8`.\n    \n-   Blends packed 32-bit integers from `a` and `b` using control mask `IMM4`.\n    \n-   Blend packed double-precision (64-bit) floating-point elements from `a` and `b` using control mask `IMM2`\n    \n-   Blend packed single-precision (32-bit) floating-point elements from `a` and `b` using mask `IMM4`\n    \n-   Blend packed 8-bit integers from `a` and `b` using `mask`\n    \n-   Blend packed double-precision (64-bit) floating-point elements from `a` and `b` using `mask`\n    \n-   Blend packed single-precision (32-bit) floating-point elements from `a` and `b` using `mask`\n    \n-   Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector.\n    \n-   Broadcasts the low packed 8-bit integer from `a` to all elements of the 128-bit returned value.\n    \n-   Broadcasts the low packed 32-bit integer from `a` to all elements of the 128-bit returned value.\n    \n-   Broadcasts the low packed 64-bit integer from `a` to all elements of the 128-bit returned value.\n    \n-   Broadcasts the low double-precision (64-bit) floating-point element from `a` to all elements of the 128-bit returned value.\n    \n-   Broadcasts the low single-precision (32-bit) floating-point element from `a` to all elements of the 128-bit returned value.\n    \n-   Broadcasts the low packed 16-bit integer from a to all elements of the 128-bit returned value\n    \n-   Shifts `a` left by `IMM8` bytes while shifting in zeros.\n    \n-   Shifts `a` right by `IMM8` bytes while shifting in zeros.\n    \n-   Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit floating-point vector of `[4 x float]`.\n    \n-   Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit integer vector.\n    \n-   Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit floating-point vector of `[2 x double]`.\n    \n-   Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit integer vector.\n    \n-   Casts a 128-bit integer vector into a 128-bit floating-point vector of `[2 x double]`.\n    \n-   Casts a 128-bit integer vector into a 128-bit floating-point vector of `[4 x float]`.\n    \n-   Round the packed double-precision (64-bit) floating-point elements in `a` up to an integer value, and stores the results as packed double-precision floating-point elements.\n    \n-   Round the packed single-precision (32-bit) floating-point elements in `a` up to an integer value, and stores the results as packed single-precision floating-point elements.\n    \n-   Round the lower double-precision (64-bit) floating-point element in `b` up to an integer value, store the result as a double-precision floating-point element in the lower element of the intrinsic result, and copies the upper element from `a` to the upper element of the intrinsic result.\n    \n-   Round the lower single-precision (32-bit) floating-point element in `b` up to an integer value, store the result as a single-precision floating-point element in the lower element of the intrinsic result, and copies the upper 3 packed elements from `a` to the upper elements of the intrinsic result.\n    \n-   Invalidates and flushes the cache line that contains `p` from all levels of the cache hierarchy.\n    \n-   Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2).\n    \n-   Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `IMM5`.\n    \n-   Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `IMM5`.\n    \n-   Compares the lower double-precision (64-bit) floating-point element in `a` and `b` based on the comparison operand specified by `IMM5`, store the result in the lower element of returned vector, and copies the upper element from `a` to the upper element of returned vector.\n    \n-   Compares the lower single-precision (32-bit) floating-point element in `a` and `b` based on the comparison operand specified by `IMM5`, store the result in the lower element of returned vector, and copies the upper 3 packed elements from `a` to the upper elements of returned vector.\n    \n-   Compares packed 8-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 16-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 32-bit integers in `a` and `b` for equality.\n    \n-   Compares packed 64-bit integers in `a` and `b` for equality\n    \n-   Compares corresponding elements in `a` and `b` for equality.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input elements were equal, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the equality comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for equality. The lowest 32 bits of the result will be `0xffffffff` if the two inputs are equal, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `IMM8`, and return `1` if `b` did not contain a null character and the resulting mask was zero, and `0` otherwise.\n    \n-   Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `IMM8`, and return `1` if the resulting mask was non-zero, and `0` otherwise.\n    \n-   Compares packed strings `a` and `b` with lengths `la` and `lb` using the control in `IMM8` and return the generated index. Similar to [`_mm_cmpistri`](fn._mm_cmpistri.html) with the exception that [`_mm_cmpistri`](fn._mm_cmpistri.html) implicitly determines the length of `a` and `b`.\n    \n-   Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `IMM8`, and return the generated mask.\n    \n-   Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `IMM8`, and return bit `0` of the resulting bit mask.\n    \n-   Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `IMM8`, and return `1` if any character in a was null, and `0` otherwise.\n    \n-   Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `IMM8`, and return `1` if any character in `b` was null, and `0` otherwise.\n    \n-   Compares corresponding elements in `a` and `b` for greater-than-or-equal.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is greater than or equal to the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the greater-than-or-equal comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for greater than or equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares packed 8-bit integers in `a` and `b` for greater-than.\n    \n-   Compares packed 16-bit integers in `a` and `b` for greater-than.\n    \n-   Compares packed 32-bit integers in `a` and `b` for greater-than.\n    \n-   Compares packed 64-bit integers in `a` and `b` for greater-than, return the results.\n    \n-   Compares corresponding elements in `a` and `b` for greater-than.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is greater than the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the greater-than comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for greater than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8`, and return `1` if `b` did not contain a null character and the resulting mask was zero, and `0` otherwise.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8`, and return `1` if the resulting mask was non-zero, and `0` otherwise.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8` and return the generated index. Similar to [`_mm_cmpestri`](fn._mm_cmpestri.html \"fn core::arch::x86::_mm_cmpestri\") with the exception that [`_mm_cmpestri`](fn._mm_cmpestri.html \"fn core::arch::x86::_mm_cmpestri\") requires the lengths of `a` and `b` to be explicitly specified.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8`, and return the generated mask.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8`, and return bit `0` of the resulting bit mask.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8`, and returns `1` if any character in `a` was null, and `0` otherwise.\n    \n-   Compares packed strings with implicit lengths in `a` and `b` using the control in `IMM8`, and return `1` if any character in `b` was null. and `0` otherwise.\n    \n-   Compares corresponding elements in `a` and `b` for less-than-or-equal\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is less than or equal to the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the less-than-or-equal comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for less than or equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares packed 8-bit integers in `a` and `b` for less-than.\n    \n-   Compares packed 16-bit integers in `a` and `b` for less-than.\n    \n-   Compares packed 32-bit integers in `a` and `b` for less-than.\n    \n-   Compares corresponding elements in `a` and `b` for less-than.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is less than the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the less-than comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for less than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` for not-equal.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input elements are **not** equal, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the not-equal comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for inequality. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` for not-greater-than-or-equal.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is **not** greater than or equal to the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the not-greater-than-or-equal comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for not-greater-than-or-equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` for not-greater-than.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is **not** greater than the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the not-greater-than comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for not-greater-than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` for not-less-than-or-equal.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is **not** less than or equal to the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the not-less-than-or-equal comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for not-less-than-or-equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` for not-less-than.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is **not** less than the corresponding element in `b`, or `0` otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the not-less-than comparison of the lower elements of `a` and `b`.\n    \n-   Compares the lowest `f32` of both inputs for not-less-than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` to see if neither is `NaN`.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. Returns four floats that have one of two possible bit patterns. The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are ordered (i.e., neither of them is a NaN), or 0 otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If neither are equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise.\n    \n-   Checks if the lowest `f32` of both inputs are ordered. The lowest 32 bits of the result will be `0xffffffff` if neither of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares corresponding elements in `a` and `b` to see if either is `NaN`.\n    \n-   Compares each of the four floats in `a` to the corresponding element in `b`. Returns four floats that have one of two possible bit patterns. The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are unordered (i.e., at least on of them is a NaN), or 0 otherwise.\n    \n-   Returns a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If either is equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise.\n    \n-   Checks if the lowest `f32` of both inputs are unordered. The lowest 32 bits of the result will be `0xffffffff` if any of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.\n    \n-   Compares the lower element of `a` and `b` for equality.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are equal, or `0` otherwise.\n    \n-   Compares the lower element of `a` and `b` for greater-than-or-equal.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise.\n    \n-   Compares the lower element of `a` and `b` for greater-than.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise.\n    \n-   Compares the lower element of `a` and `b` for less-than-or-equal.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise.\n    \n-   Compares the lower element of `a` and `b` for less-than.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise.\n    \n-   Compares the lower element of `a` and `b` for not-equal.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are **not** equal, or `0` otherwise.\n    \n-   Starting with the initial value in `crc`, return the accumulated CRC32-C value for unsigned 8-bit integer `v`.\n    \n-   Starting with the initial value in `crc`, return the accumulated CRC32-C value for unsigned 16-bit integer `v`.\n    \n-   Starting with the initial value in `crc`, return the accumulated CRC32-C value for unsigned 32-bit integer `v`.\n    \n\n-   Sign extend packed 8-bit integers in `a` to packed 16-bit integers\n    \n-   Sign extend packed 8-bit integers in `a` to packed 32-bit integers\n    \n-   Sign extend packed 8-bit integers in the low 8 bytes of `a` to packed 64-bit integers\n    \n-   Sign extend packed 16-bit integers in `a` to packed 32-bit integers\n    \n-   Sign extend packed 16-bit integers in `a` to packed 64-bit integers\n    \n-   Sign extend packed 32-bit integers in `a` to packed 64-bit integers\n    \n-   Converts the lower two packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements.\n    \n-   Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements.\n    \n-   Zeroes extend packed unsigned 8-bit integers in `a` to packed 16-bit integers\n    \n-   Zeroes extend packed unsigned 8-bit integers in `a` to packed 32-bit integers\n    \n-   Zeroes extend packed unsigned 8-bit integers in `a` to packed 64-bit integers\n    \n-   Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit integers\n    \n-   Zeroes extend packed unsigned 16-bit integers in `a` to packed 64-bit integers\n    \n-   Zeroes extend packed unsigned 32-bit integers in `a` to packed 64-bit integers\n    \n-   Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers.\n    \n-   Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements\n    \n-   Converts the 4 x 16-bit half-precision float values in the lowest 64-bit of the 128-bit vector `a` into 4 x 32-bit float values stored in a 128-bit wide vector.\n    \n-   Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers.\n    \n-   Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements.\n    \n-   Converts the 4 x 32-bit float values in the 128-bit vector `a` into 4 x 16-bit half-precision float values stored in the lowest 64-bit of a 128-bit vector.\n    \n-   Returns the lower double-precision (64-bit) floating-point element of `a`.\n    \n-   Converts the lower double-precision (64-bit) floating-point element in a to a 32-bit integer.\n    \n-   Converts the lower double-precision (64-bit) floating-point element in `b` to a single-precision (32-bit) floating-point element, store the result in the lower element of the return value, and copies the upper element from `a` to the upper element the return value.\n    \n-   Returns `a` with its lower element replaced by `b` after converting it to an `f64`.\n    \n-   Returns a vector whose lowest element is `a` and all higher elements are `0`.\n    \n-   Converts a 32 bit integer to a 32 bit float. The result vector is the input vector `a` with the lowest 32 bit float replaced by the converted integer.\n    \n-   Returns the lowest element of `a`.\n    \n-   Extracts the lowest 32 bit float from the input vector.\n    \n-   Converts the lower single-precision (32-bit) floating-point element in `b` to a double-precision (64-bit) floating-point element, store the result in the lower element of the return value, and copies the upper element from `a` to the upper element the return value.\n    \n-   Converts the lowest 32 bit float in the input vector to a 32 bit integer.\n    \n\n-   Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation.\n    \n-   Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation.\n    \n-   Converts the lower double-precision (64-bit) floating-point element in `a` to a 32-bit integer with truncation.\n    \n-   Converts the lowest 32 bit float in the input vector to a 32 bit integer with truncation.\n    \n-   Divide packed double-precision (64-bit) floating-point elements in `a` by packed elements in `b`.\n    \n-   Divides \\_\\_m128 vectors.\n    \n-   Returns a new vector with the low element of `a` replaced by the result of diving the lower element of `a` by the lower element of `b`.\n    \n-   Divides the first component of `b` by `a`, the other components are copied from `a`.\n    \n-   Returns the dot product of two \\_\\_m128d vectors.\n    \n-   Returns the dot product of two \\_\\_m128 vectors.\n    \n-   Extracts an 8-bit integer from `a`, selected with `IMM8`. Returns a 32-bit integer containing the zero-extended integer data.\n    \n-   Returns the `imm8` element of `a`.\n    \n-   Extracts an 32-bit integer from `a` selected with `IMM8`\n    \n-   Extracts a single-precision (32-bit) floating-point element from `a`, selected with `IMM8`. The returned `i32` stores the float’s bit-pattern, and may be converted back to a floating point number via casting.\n    \n-   Extracts the bit range specified by `y` from the lower 64 bits of `x`.\n    \n-   Round the packed double-precision (64-bit) floating-point elements in `a` down to an integer value, and stores the results as packed double-precision floating-point elements.\n    \n-   Round the packed single-precision (32-bit) floating-point elements in `a` down to an integer value, and stores the results as packed single-precision floating-point elements.\n    \n-   Round the lower double-precision (64-bit) floating-point element in `b` down to an integer value, store the result as a double-precision floating-point element in the lower element of the intrinsic result, and copies the upper element from `a` to the upper element of the intrinsic result.\n    \n-   Round the lower single-precision (32-bit) floating-point element in `b` down to an integer value, store the result as a single-precision floating-point element in the lower element of the intrinsic result, and copies the upper 3 packed elements from `a` to the upper elements of the intrinsic result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`.\n    \n-   Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to the lower element in `c`. Stores the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result.\n    \n-   Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to the lower element in `c`. Stores the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result.\n    \n-   Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and subtract the lower element in `c` from the intermediate result. Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result.\n    \n-   Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and subtract the lower element in `c` from the intermediate result. Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`.\n    \n-   Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to the lower element in `c`. Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result.\n    \n-   Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to the lower element in `c`. Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.\n    \n-   Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result.\n    \n-   Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result. Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result.\n    \n-   Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result. Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result.\n    \n-   [\\_mm\\_getcsr](fn._mm_getcsr.html \"fn core::arch::x86::_mm_getcsr\")⚠Deprecated(x86 or x86-64) and `sse`\n    \n    Gets the unsigned 32-bit value of the MXCSR control and status register.\n    \n-   Horizontally adds the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`.\n    \n-   Horizontally adds the adjacent pairs of values contained in 2 packed 128-bit vectors of `[4 x i32]`.\n    \n-   Horizontally adds adjacent pairs of double-precision (64-bit) floating-point elements in `a` and `b`, and pack the results.\n    \n-   Horizontally adds adjacent pairs of single-precision (32-bit) floating-point elements in `a` and `b`, and pack the results.\n    \n-   Horizontally adds the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`. Positive sums greater than 7FFFh are saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.\n    \n-   Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`.\n    \n-   Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of `[4 x i32]`.\n    \n-   Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in `a` and `b`, and pack the results.\n    \n-   Horizontally adds adjacent pairs of single-precision (32-bit) floating-point elements in `a` and `b`, and pack the results.\n    \n-   Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`. Positive differences greater than 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are saturated to 8000h.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.\n    \n-   Returns a copy of `a` with the 8-bit integer from `i` inserted at a location specified by `IMM8`.\n    \n-   Returns a new vector where the `imm8` element of `a` is replaced with `i`.\n    \n-   Returns a copy of `a` with the 32-bit integer from `i` inserted at a location specified by `IMM8`.\n    \n-   Select a single value in `b` to store at some position in `a`, Then zero elements according to `IMM8`.\n    \n-   Inserts the `[length:0]` bits of `y` into `x` at `index`.\n    \n-   Loads 128-bits of integer data from unaligned memory. This intrinsic may perform better than `_mm_loadu_si128` when the data crosses a cache line boundary.\n    \n-   Performs a serializing operation on all load-from-memory instructions that were issued prior to this instruction.\n    \n-   Loads a double-precision (64-bit) floating-point element from memory into both elements of returned vector.\n    \n-   Construct a `__m128` by duplicating the value read from `p` into all elements.\n    \n-   Loads 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into the returned vector. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Loads a double-precision (64-bit) floating-point element from memory into both elements of returned vector.\n    \n-   Loads four `f32` values from _aligned_ memory into a `__m128`. If the pointer is not aligned to a 128-bit boundary (16 bytes) a general protection fault will be triggered (fatal program crash).\n    \n\n-   Loads a 64-bit double-precision value to the low element of a 128-bit integer vector and clears the upper element.\n    \n-   Loads 128-bits of integer data from memory into a new vector.\n    \n-   Construct a `__m128` with the lowest element read from `p` and the other elements set to zero.\n    \n-   Loads a double-precision (64-bit) floating-point element from memory into both elements of return vector.\n    \n-   Loads a double-precision value into the high-order bits of a 128-bit vector of `[2 x double]`. The low-order bits are copied from the low-order bits of the first operand.\n    \n-   Loads 64-bit integer from memory into first element of returned vector.\n    \n-   Loads a double-precision value into the low-order bits of a 128-bit vector of `[2 x double]`. The high-order bits are copied from the high-order bits of the first operand.\n    \n-   Loads 2 double-precision (64-bit) floating-point elements from memory into the returned vector in reverse order. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Loads four `f32` values from aligned memory into a `__m128` in reverse order.\n    \n-   Loads 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into the returned vector. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Loads four `f32` values from memory into a `__m128`. There are no restrictions on memory alignment. For aligned memory [`_mm_load_ps`](fn._mm_load_ps.html) may be faster.\n    \n-   Loads unaligned 64-bits of integer data from memory into new vector.\n    \n-   Loads 128-bits of integer data from memory into a new vector.\n    \n-   Multiplies and then horizontally add signed 16 bit integers in `a` and `b`.\n    \n-   Multiplies corresponding pairs of packed 8-bit unsigned integer values contained in the first source operand and packed 8-bit signed integer values contained in the second source operand, add pairs of contiguous products with signed saturation, and writes the 16-bit sums to the corresponding bits in the destination.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8. If mask is set, load the value from `src` in that position instead.\n    \n-   Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element).\n    \n-   Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element).\n    \n-   Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set).\n    \n-   Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set).\n    \n-   Conditionally store 8-bit integer elements from `a` into memory using `mask`.\n    \n-   Stores packed 32-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element).\n    \n-   Stores packed 64-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element).\n    \n-   Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`.\n    \n-   Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`.\n    \n-   Compares packed 8-bit integers in `a` and `b` and returns packed maximum values in dst.\n    \n-   Compares packed 16-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed 32-bit integers in `a` and `b`, and returns packed maximum values.\n    \n-   Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed maximum values.\n    \n-   Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed maximum.\n    \n-   Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed maximum values.\n    \n-   Returns a new vector with the maximum values from corresponding elements in `a` and `b`.\n    \n-   Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding maximum values.\n    \n-   Returns a new vector with the low element of `a` replaced by the maximum of the lower elements of `a` and `b`.\n    \n-   Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the maximum value in the first element of the return value, the other elements are copied from `a`.\n    \n-   Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction.\n    \n-   Compares packed 8-bit integers in `a` and `b` and returns packed minimum values in dst.\n    \n-   Compares packed 16-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed 32-bit integers in `a` and `b`, and returns packed minimum values.\n    \n-   Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed minimum values.\n    \n-   Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed minimum.\n    \n-   Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed minimum values.\n    \n-   Returns a new vector with the minimum values from corresponding elements in `a` and `b`.\n    \n-   Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding minimum values.\n    \n-   Returns a new vector with the low element of `a` replaced by the minimum of the lower elements of `a` and `b`.\n    \n-   Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the minimum value in the first element of the return value, the other elements are copied from `a`.\n    \n-   Finds the minimum unsigned 16-bit element in the 128-bit \\_\\_m128i vector, returning a vector containing its value in its first position, and its index in its second position; all other elements are set to zero.\n    \n-   Returns a vector where the low element is extracted from `a` and its upper element is zero.\n    \n-   Constructs a 128-bit floating-point vector of `[2 x double]`. The lower 64 bits are set to the lower 64 bits of the second parameter. The upper 64 bits are set to the upper 64 bits of the first parameter.\n    \n-   Returns a `__m128` with the first component from `b` and the remaining components from `a`.\n    \n-   Duplicate the low double-precision (64-bit) floating-point element from `a`.\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from `a`.\n    \n-   Combine higher half of `a` and `b`. The higher half of `b` occupies the lower half of result.\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from `a`.\n    \n-   Combine lower half of `a` and `b`. The lower half of `b` occupies the higher half of result.\n    \n-   Returns a mask of the most significant bit of each element in `a`.\n    \n-   Returns a mask of the most significant bit of each element in `a`.\n    \n-   Returns a mask of the most significant bit of each element in `a`.\n    \n-   Subtracts 8-bit unsigned integer values and computes the absolute values of the differences to the corresponding bits in the destination. Then sums of the absolute differences are returned according to the bit fields in the immediate operand.\n    \n-   Multiplies the low 32-bit integers from each packed 64-bit element in `a` and `b`, and returns the signed 64-bit result.\n    \n-   Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`.\n    \n-   Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`.\n    \n-   Multiplies \\_\\_m128 vectors.\n    \n-   Returns a new vector with the low element of `a` replaced by multiplying the low elements of `a` and `b`.\n    \n-   Multiplies the first component of `a` and `b`, the other components are copied from `a`.\n    \n-   Multiplies the packed 16-bit integers in `a` and `b`.\n    \n-   Multiplies the packed unsigned 16-bit integers in `a` and `b`.\n    \n-   Multiplies packed 16-bit signed integer values, truncate the 32-bit product to the 18 most significant bits by right-shifting, round the truncated value by adding 1, and write bits `[16:1]` to the destination.\n    \n-   Multiplies the packed 16-bit integers in `a` and `b`.\n    \n-   Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate 64-bit integers, and returns the lowest 32-bit, whatever they might be, reinterpreted as a signed integer. While `pmulld __m128i::splat(2), __m128i::splat(2)` returns the obvious `__m128i::splat(4)`, due to wrapping arithmetic `pmulld __m128i::splat(i32::MAX), __m128i::splat(2)` would return a negative number.\n    \n-   Computes the bitwise OR of `a` and `b`.\n    \n-   Bitwise OR of packed single-precision (32-bit) floating-point elements.\n    \n-   Computes the bitwise OR of 128 bits (representing integer data) in `a` and `b`.\n    \n-   Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation.\n    \n-   Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation.\n    \n-   Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation.\n    \n-   Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using unsigned saturation\n    \n-   Provides a hint to the processor that the code sequence is a spin-wait loop.\n    \n-   Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `imm8`.\n    \n-   Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `imm8`.\n    \n-   Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `b`.\n    \n-   Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `b`.\n    \n-   Fetch the cache line that contains address `p` using the given `STRATEGY`.\n    \n-   Returns the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`.\n    \n-   Returns the approximate reciprocal of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged.\n    \n-   Round the packed double-precision (64-bit) floating-point elements in `a` using the `ROUNDING` parameter, and stores the results as packed double-precision floating-point elements. Rounding is done according to the rounding parameter, which can be one of:\n    \n-   Round the packed single-precision (32-bit) floating-point elements in `a` using the `ROUNDING` parameter, and stores the results as packed single-precision floating-point elements. Rounding is done according to the rounding parameter, which can be one of:\n    \n-   Round the lower double-precision (64-bit) floating-point element in `b` using the `ROUNDING` parameter, store the result as a double-precision floating-point element in the lower element of the intrinsic result, and copies the upper element from `a` to the upper element of the intrinsic result. Rounding is done according to the rounding parameter, which can be one of:\n    \n-   Round the lower single-precision (32-bit) floating-point element in `b` using the `ROUNDING` parameter, store the result as a single-precision floating-point element in the lower element of the intrinsic result, and copies the upper 3 packed elements from `a` to the upper elements of the intrinsic result. Rounding is done according to the rounding parameter, which can be one of:\n    \n-   Returns the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`.\n    \n-   Returns the approximate reciprocal square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged.\n    \n-   Sum the absolute differences of packed unsigned 8-bit integers.\n    \n-   Broadcasts 8-bit integer `a` to all elements.\n    \n-   Broadcasts 16-bit integer `a` to all elements.\n    \n-   Broadcasts 32-bit integer `a` to all elements.\n    \n-   Broadcasts 64-bit integer `a` to all elements.\n    \n-   Broadcasts double-precision (64-bit) floating-point value a to all elements of the return value.\n    \n-   Construct a `__m128` with all element set to `a`.\n    \n-   Sets packed 8-bit integers with the supplied values.\n    \n-   Sets packed 16-bit integers with the supplied values.\n    \n-   Sets packed 32-bit integers with the supplied values.\n    \n-   Sets packed 64-bit integers with the supplied values, from highest to lowest.\n    \n-   Sets packed double-precision (64-bit) floating-point elements in the return value with the supplied values.\n    \n-   Broadcasts double-precision (64-bit) floating-point value a to all elements of the return value.\n    \n-   Construct a `__m128` from four floating point values highest to lowest.\n    \n\n-   Copies double-precision (64-bit) floating-point element `a` to the lower element of the packed 64-bit return value.\n    \n-   Construct a `__m128` with the lowest element set to `a` and the rest set to zero.\n    \n-   [\\_mm\\_setcsr](fn._mm_setcsr.html \"fn core::arch::x86::_mm_setcsr\")⚠Deprecated(x86 or x86-64) and `sse`\n    \n    Sets the MXCSR register with the 32-bit unsigned integer value.\n    \n-   Sets packed 8-bit integers with the supplied values in reverse order.\n    \n-   Sets packed 16-bit integers with the supplied values in reverse order.\n    \n-   Sets packed 32-bit integers with the supplied values in reverse order.\n    \n-   Sets packed double-precision (64-bit) floating-point elements in the return value with the supplied values in reverse order.\n    \n-   Construct a `__m128` from four floating point values lowest to highest.\n    \n-   Returns packed double-precision (64-bit) floating-point elements with all zeros.\n    \n-   Construct a `__m128` with all elements initialized to zero.\n    \n-   Returns a vector with all elements set to zero.\n    \n-   Performs a serializing operation on all non-temporal (“streaming”) store instructions that were issued by the current thread prior to this instruction.\n    \n-   Performs an intermediate calculation for the next four SHA1 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and returning the result.\n    \n-   Performs the final calculation for the next four SHA1 message values (unsigned 32-bit integers) using the intermediate result in `a` and the previous message values in `b`, and returns the result.\n    \n-   Calculate SHA1 state variable E after four rounds of operation from the current SHA1 state variable `a`, add that value to the scheduled values (unsigned 32-bit integers) in `b`, and returns the result.\n    \n-   Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from `a` and some pre-computed sum of the next 4 round message values (unsigned 32-bit integers), and state variable E from `b`, and return the updated SHA1 state (A,B,C,D). `FUNC` contains the logic functions and round constants.\n    \n-   Performs an intermediate calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and return the result.\n    \n-   Performs the final calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and return the result.\n    \n-   Performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from `a`, an initial SHA256 state (A,B,E,F) from `b`, and a pre-computed sum of the next 2 round message values (unsigned 32-bit integers) and the corresponding round constants from `k`, and store the updated SHA256 state (A,B,E,F) in dst.\n    \n-   Shuffles bytes from `a` according to the content of `b`.\n    \n-   Shuffles 32-bit integers in `a` using the control in `IMM8`.\n    \n-   Constructs a 128-bit floating-point vector of `[2 x double]` from two 128-bit vector parameters of `[2 x double]`, using the immediate-value parameter as a specifier.\n    \n-   Shuffles packed single-precision (32-bit) floating-point elements in `a` and `b` using `MASK`.\n    \n-   Shuffles 16-bit integers in the high 64 bits of `a` using the control in `IMM8`.\n    \n-   Shuffles 16-bit integers in the low 64 bits of `a` using the control in `IMM8`.\n    \n-   Negates packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and returns the result. Elements in result are zeroed out when the corresponding element in `b` is zero.\n    \n-   Negates packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and returns the results. Elements in result are zeroed out when the corresponding element in `b` is zero.\n    \n-   Negates packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and returns the results. Element in result are zeroed out when the corresponding element in `b` is zero.\n    \n-   Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros.\n    \n-   Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros.\n    \n-   Shifts packed 16-bit integers in `a` left by `IMM8` while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` left by `IMM8` while shifting in zeros.\n    \n-   Shifts packed 64-bit integers in `a` left by `IMM8` while shifting in zeros.\n    \n-   Shifts `a` left by `IMM8` bytes while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result.\n    \n-   Shifts packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result.\n    \n-   Returns a new vector with the square root of each of the values in `a`.\n    \n-   Returns the square root of packed single-precision (32-bit) floating-point elements in `a`.\n    \n-   Returns a new vector with the low element of `a` replaced by the square root of the lower element `b`.\n    \n-   Returns the square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged.\n    \n-   Shifts packed 16-bit integers in `a` right by `count` while shifting in sign bits.\n    \n-   Shifts packed 32-bit integers in `a` right by `count` while shifting in sign bits.\n    \n-   Shifts packed 16-bit integers in `a` right by `IMM8` while shifting in sign bits.\n    \n-   Shifts packed 32-bit integers in `a` right by `IMM8` while shifting in sign bits.\n    \n-   Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits.\n    \n-   Shifts packed 16-bit integers in `a` right by `count` while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` right by `count` while shifting in zeros.\n    \n-   Shifts packed 64-bit integers in `a` right by `count` while shifting in zeros.\n    \n-   Shifts packed 16-bit integers in `a` right by `IMM8` while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` right by `IMM8` while shifting in zeros.\n    \n-   Shifts packed 64-bit integers in `a` right by `IMM8` while shifting in zeros.\n    \n-   Shifts `a` right by `IMM8` bytes while shifting in zeros.\n    \n-   Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,\n    \n-   Shifts packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,\n    \n-   Stores the lower double-precision (64-bit) floating-point element from `a` into 2 contiguous elements in memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Stores the lowest 32 bit float of `a` repeated four times into _aligned_ memory.\n    \n-   Stores 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Stores the lower double-precision (64-bit) floating-point element from `a` into 2 contiguous elements in memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Stores four 32-bit floats into _aligned_ memory.\n    \n\n-   Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a memory location.\n    \n-   Stores 128-bits of integer data from `a` into memory.\n    \n-   Stores the lowest 32 bit float of `a` into memory.\n    \n-   Stores the upper 64 bits of a 128-bit vector of `[2 x double]` to a memory location.\n    \n-   Stores the lower 64-bit integer `a` to a memory location.\n    \n-   Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a memory location.\n    \n-   Stores 2 double-precision (64-bit) floating-point elements from `a` into memory in reverse order. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Stores four 32-bit floats into _aligned_ memory in reverse order.\n    \n-   Stores 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Stores four 32-bit floats into memory. There are no restrictions on memory alignment. For aligned memory [`_mm_store_ps`](fn._mm_store_ps.html) may be faster.\n    \n-   Stores 128-bits of integer data from `a` into memory.\n    \n-   Stores a 128-bit floating point vector of `[2 x double]` to a 128-bit aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon).\n    \n-   Stores `a` into the memory at `mem_addr` using a non-temporal memory hint.\n    \n-   Non-temporal store of `a.0` into `p`.\n    \n-   Stores a 32-bit integer value in the specified memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon).\n    \n-   Stores a 128-bit integer vector to a 128-bit aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon).\n    \n-   Non-temporal store of `a.0` into `p`.\n    \n-   Subtracts packed 8-bit integers in `b` from packed 8-bit integers in `a`.\n    \n-   Subtracts packed 16-bit integers in `b` from packed 16-bit integers in `a`.\n    \n-   Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.\n    \n-   Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`.\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in `b` from `a`.\n    \n-   Subtracts \\_\\_m128 vectors.\n    \n-   Returns a new vector with the low element of `a` replaced by subtracting the low element by `b` from the low element of `a`.\n    \n-   Subtracts the first component of `b` from `a`, the other components are copied from `a`.\n    \n-   Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation.\n    \n-   Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation.\n    \n-   Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation.\n    \n-   Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation.\n    \n-   Tests whether the specified bits in `a` 128-bit integer vector are all ones.\n    \n-   Tests whether the specified bits in a 128-bit integer vector are all zeros.\n    \n-   Tests whether the specified bits in a 128-bit integer vector are neither all zeros nor all ones.\n    \n-   Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value.\n    \n-   Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value.\n    \n-   Tests whether the specified bits in a 128-bit integer vector are all ones.\n    \n-   Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0.\n    \n-   Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0.\n    \n-   Tests whether the specified bits in a 128-bit integer vector are neither all zeros nor all ones.\n    \n-   Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value.\n    \n-   Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value.\n    \n-   Tests whether the specified bits in a 128-bit integer vector are all zeros.\n    \n-   Counts the number of trailing least significant zero bits.\n    \n-   Compares the lower element of `a` and `b` for equality.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are equal, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN.\n    \n-   Compares the lower element of `a` and `b` for greater-than-or-equal.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN.\n    \n-   Compares the lower element of `a` and `b` for greater-than.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN.\n    \n-   Compares the lower element of `a` and `b` for less-than-or-equal.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN.\n    \n-   Compares the lower element of `a` and `b` for less-than.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN.\n    \n-   Compares the lower element of `a` and `b` for not-equal.\n    \n-   Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are **not** equal, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN.\n    \n-   Returns vector of type \\_\\_m128d with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Returns vector of type \\_\\_m128 with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Returns vector of type \\_\\_m128i with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Unpacks and interleave 8-bit integers from the high half of `a` and `b`.\n    \n-   Unpacks and interleave 16-bit integers from the high half of `a` and `b`.\n    \n-   Unpacks and interleave 32-bit integers from the high half of `a` and `b`.\n    \n-   Unpacks and interleave 64-bit integers from the high half of `a` and `b`.\n    \n-   The resulting `__m128d` element is composed by the low-order values of the two `__m128d` interleaved input elements, i.e.:\n    \n-   Unpacks and interleave single-precision (32-bit) floating-point elements from the higher half of `a` and `b`.\n    \n-   Unpacks and interleave 8-bit integers from the low half of `a` and `b`.\n    \n-   Unpacks and interleave 16-bit integers from the low half of `a` and `b`.\n    \n-   Unpacks and interleave 32-bit integers from the low half of `a` and `b`.\n    \n-   Unpacks and interleave 64-bit integers from the low half of `a` and `b`.\n    \n-   The resulting `__m128d` element is composed by the high-order values of the two `__m128d` interleaved input elements, i.e.:\n    \n-   Unpacks and interleave single-precision (32-bit) floating-point elements from the lower half of `a` and `b`.\n    \n-   Computes the bitwise XOR of `a` and `b`.\n    \n-   Bitwise exclusive OR of packed single-precision (32-bit) floating-point elements.\n    \n-   Computes the bitwise XOR of 128 bits (representing integer data) in `a` and `b`.\n    \n-   Unsigned multiply without affecting flags.\n    \n-   Scatter contiguous low order bits of `a` to the result at the positions specified by the `mask`.\n    \n-   Gathers the bits of `x` specified by the `mask` into the contiguous low order bit positions of the result.\n    \n-   Counts the bits that are set.\n    \n-   Read a hardware generated 16-bit random value and store the result in val. Returns 1 if a random value was generated, and 0 otherwise.\n    \n-   Read a hardware generated 32-bit random value and store the result in val. Returns 1 if a random value was generated, and 0 otherwise.\n    \n-   Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store in val. Return 1 if a random value was generated, and 0 otherwise.\n    \n-   Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store in val. Return 1 if a random value was generated, and 0 otherwise.\n    \n-   Reads the current value of the processor’s time-stamp counter.\n    \n-   Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry or overflow flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag).\n    \n-   Clears all bits below the least significant zero of `x` and sets all other bits.\n    \n-   Clears all bits below the least significant zero of `x` and sets all other bits.\n    \n-   Counts the number of trailing least significant zero bits.\n    \n-   Sets all bits below the least significant one of `x` and clears all other bits.\n    \n-   Sets all bits below the least significant one of `x` and clears all other bits.\n    \n-   [\\_xgetbv](fn._xgetbv.html \"fn core::arch::x86::_xgetbv\")⚠(x86 or x86-64) and `xsave`\n    \n    Reads the contents of the extended control register `XCR` specified in `xcr_no`.\n    \n-   [\\_xrstor](fn._xrstor.html \"fn core::arch::x86::_xrstor\")⚠(x86 or x86-64) and `xsave`\n    \n    Performs a full or partial restore of the enabled processor states using the state information stored in memory at `mem_addr`.\n    \n-   [\\_xrstors](fn._xrstors.html \"fn core::arch::x86::_xrstors\")⚠(x86 or x86-64) and `xsave,xsaves`\n    \n    Performs a full or partial restore of the enabled processor states using the state information stored in memory at `mem_addr`.\n    \n-   [\\_xsave](fn._xsave.html \"fn core::arch::x86::_xsave\")⚠(x86 or x86-64) and `xsave`\n    \n    Performs a full or partial save of the enabled processor states to memory at `mem_addr`.\n    \n-   [\\_xsavec](fn._xsavec.html \"fn core::arch::x86::_xsavec\")⚠(x86 or x86-64) and `xsave,xsavec`\n    \n    Performs a full or partial save of the enabled processor states to memory at `mem_addr`.\n    \n-   [\\_xsaveopt](fn._xsaveopt.html \"fn core::arch::x86::_xsaveopt\")⚠(x86 or x86-64) and `xsave,xsaveopt`\n    \n    Performs a full or partial save of the enabled processor states to memory at `mem_addr`.\n    \n-   [\\_xsaves](fn._xsaves.html \"fn core::arch::x86::_xsaves\")⚠(x86 or x86-64) and `xsave,xsaves`\n    \n    Performs a full or partial save of the enabled processor states to memory at `mem_addr`\n    \n-   [\\_xsetbv](fn._xsetbv.html \"fn core::arch::x86::_xsetbv\")⚠(x86 or x86-64) and `xsave`\n    \n    Copies 64-bits from `val` to the extended control register (`XCR`) specified by `a`.\n    \n-   A utility function for creating masks to use with Intel shuffle and permute intrinsics.\n    \n-   [\\_kadd\\_mask32](fn._kadd_mask32.html \"fn core::arch::x86::_kadd_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Add 32-bit masks in a and b, and store the result in k.\n    \n-   [\\_kadd\\_mask64](fn._kadd_mask64.html \"fn core::arch::x86::_kadd_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Add 64-bit masks in a and b, and store the result in k.\n    \n-   [\\_kand\\_mask16](fn._kand_mask16.html \"fn core::arch::x86::_kand_mask16\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise AND of 16-bit masks a and b, and store the result in k.\n    \n-   [\\_kand\\_mask32](fn._kand_mask32.html \"fn core::arch::x86::_kand_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise AND of 32-bit masks a and b, and store the result in k.\n    \n-   [\\_kand\\_mask64](fn._kand_mask64.html \"fn core::arch::x86::_kand_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise AND of 64-bit masks a and b, and store the result in k.\n    \n-   [\\_kandn\\_mask16](fn._kandn_mask16.html \"fn core::arch::x86::_kandn_mask16\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.\n    \n-   [\\_kandn\\_mask32](fn._kandn_mask32.html \"fn core::arch::x86::_kandn_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise NOT of 32-bit masks a and then AND with b, and store the result in k.\n    \n-   [\\_kandn\\_mask64](fn._kandn_mask64.html \"fn core::arch::x86::_kandn_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise NOT of 64-bit masks a and then AND with b, and store the result in k.\n    \n-   [\\_knot\\_mask16](fn._knot_mask16.html \"fn core::arch::x86::_knot_mask16\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise NOT of 16-bit mask a, and store the result in k.\n    \n-   [\\_knot\\_mask32](fn._knot_mask32.html \"fn core::arch::x86::_knot_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise NOT of 32-bit mask a, and store the result in k.\n    \n-   [\\_knot\\_mask64](fn._knot_mask64.html \"fn core::arch::x86::_knot_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise NOT of 64-bit mask a, and store the result in k.\n    \n-   [\\_kor\\_mask16](fn._kor_mask16.html \"fn core::arch::x86::_kor_mask16\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise OR of 16-bit masks a and b, and store the result in k.\n    \n-   [\\_kor\\_mask32](fn._kor_mask32.html \"fn core::arch::x86::_kor_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise OR of 32-bit masks a and b, and store the result in k.\n    \n-   [\\_kor\\_mask64](fn._kor_mask64.html \"fn core::arch::x86::_kor_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise OR of 64-bit masks a and b, and store the result in k.\n    \n-   [\\_kxnor\\_mask16](fn._kxnor_mask16.html \"fn core::arch::x86::_kxnor_mask16\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.\n    \n-   [\\_kxnor\\_mask32](fn._kxnor_mask32.html \"fn core::arch::x86::_kxnor_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise XNOR of 32-bit masks a and b, and store the result in k.\n    \n-   [\\_kxnor\\_mask64](fn._kxnor_mask64.html \"fn core::arch::x86::_kxnor_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise XNOR of 64-bit masks a and b, and store the result in k.\n    \n-   [\\_kxor\\_mask16](fn._kxor_mask16.html \"fn core::arch::x86::_kxor_mask16\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.\n    \n-   [\\_kxor\\_mask32](fn._kxor_mask32.html \"fn core::arch::x86::_kxor_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise XOR of 32-bit masks a and b, and store the result in k.\n    \n-   [\\_kxor\\_mask64](fn._kxor_mask64.html \"fn core::arch::x86::_kxor_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Compute the bitwise XOR of 64-bit masks a and b, and store the result in k.\n    \n-   [\\_load\\_mask32](fn._load_mask32.html \"fn core::arch::x86::_load_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Load 32-bit mask from memory into k.\n    \n-   [\\_load\\_mask64](fn._load_mask64.html \"fn core::arch::x86::_load_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Load 64-bit mask from memory into k.\n    \n-   [\\_mm256\\_abs\\_epi64](fn._mm256_abs_epi64.html \"fn core::arch::x86::_mm256_abs_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.\n    \n-   Performs one round of an AES decryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Performs the last round of an AES decryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Performs one round of an AES encryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Performs the last round of an AES encryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst.\n    \n-   Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst.\n    \n-   Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers. Then groups 8 8-bit values from `c`as indices into the bits of the corresponding 64-bit integer. It then selects these bits and packs them into the output.\n    \n-   Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.\n    \n-   Broadcast the 4 packed 32-bit integers from a to all elements of dst.\n    \n-   Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.\n    \n-   Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.\n    \n-   Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2) - in each of the 2 128-bit lanes.\n    \n-   Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two 256-bit vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in a 256-bit wide vector. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&avx512techs=AVX512_BF16&text=_mm256_cvtne2ps_pbh)\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm256_cvtneps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   [\\_mm256\\_dpbf16\\_ps](fn._mm256_dpbf16_ps.html \"fn core::arch::x86::_mm256_dpbf16_ps\")⚠Experimental(x86 or x86-64) and `avx512bf16,avx512vl`\n    \n    Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm256_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.\n    \n-   Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.\n    \n-   Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the result in dst.\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   [\\_mm256\\_getexp\\_pd](fn._mm256_getexp_pd.html \"fn core::arch::x86::_mm256_getexp_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   [\\_mm256\\_getexp\\_ps](fn._mm256_getexp_ps.html \"fn core::arch::x86::_mm256_getexp_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign. The mantissa is normalized to the interval specified by interv, which can take the following values: \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2) \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2) \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1) \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5) The sign is determined by sc which can take the following values: \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src) \\_MM\\_MANT\\_SIGN\\_zero // sign = 0 \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.\n    \n-   Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.\n    \n-   Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load 256-bits (composed of 32 packed 8-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load 256-bits (composed of 16 packed 16-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.\n    \n-   Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.\n    \n-   Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers. Then groups 8 8-bit values from `c`as indices into the bits of the corresponding 64-bit integer. It then selects these bits and packs them into the output.\n    \n-   Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.\n    \n-   Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of: (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements and store the results in single vector dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&avx512techs=AVX512_BF16&text=_mm256_mask_cvtne2ps_pbh)\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm256_mask_cvtneps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm256_mask_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load packed 32-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 64-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 8-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 16-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 32-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 64-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Store packed 32-bit integers from a into memory using writemask k. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed 64-bit integers from a into memory using writemask k. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed 8-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 16-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 32-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 64-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&avx512techs=AVX512_BF16&text=_mm256_maskz_cvtne2ps_pbh)\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm256_maskz_cvtneps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm256_maskz_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load packed 32-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 64-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 8-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 16-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 32-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 64-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm256\\_max\\_epi64](fn._mm256_max_epi64.html \"fn core::arch::x86::_mm256_max_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.\n    \n-   [\\_mm256\\_max\\_epu64](fn._mm256_max_epu64.html \"fn core::arch::x86::_mm256_max_epu64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.\n    \n-   [\\_mm256\\_min\\_epi64](fn._mm256_min_epi64.html \"fn core::arch::x86::_mm256_min_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.\n    \n-   [\\_mm256\\_min\\_epu64](fn._mm256_min_epu64.html \"fn core::arch::x86::_mm256_min_epu64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.\n    \n-   Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.\n    \n-   [\\_mm256\\_movm\\_epi8](fn._mm256_movm_epi8.html \"fn core::arch::x86::_mm256_movm_epi8\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n    \n-   Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.\n    \n-   [\\_mm256\\_or\\_epi32](fn._mm256_or_epi32.html \"fn core::arch::x86::_mm256_or_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   [\\_mm256\\_or\\_epi64](fn._mm256_or_epi64.html \"fn core::arch::x86::_mm256_or_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   [\\_mm256\\_rcp14\\_pd](fn._mm256_rcp14_pd.html \"fn core::arch::x86::_mm256_rcp14_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm256\\_rcp14\\_ps](fn._mm256_rcp14_ps.html \"fn core::arch::x86::_mm256_rcp14_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm256\\_rol\\_epi32](fn._mm256_rol_epi32.html \"fn core::arch::x86::_mm256_rol_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.\n    \n-   [\\_mm256\\_rol\\_epi64](fn._mm256_rol_epi64.html \"fn core::arch::x86::_mm256_rol_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   [\\_mm256\\_ror\\_epi32](fn._mm256_ror_epi32.html \"fn core::arch::x86::_mm256_ror_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.\n    \n-   [\\_mm256\\_ror\\_epi64](fn._mm256_ror_epi64.html \"fn core::arch::x86::_mm256_ror_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   [\\_mm256\\_scalef\\_pd](fn._mm256_scalef_pd.html \"fn core::arch::x86::_mm256_scalef_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   [\\_mm256\\_scalef\\_ps](fn._mm256_scalef_ps.html \"fn core::arch::x86::_mm256_scalef_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.\n    \n-   Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   [\\_mm256\\_sra\\_epi64](fn._mm256_sra_epi64.html \"fn core::arch::x86::_mm256_sra_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem\\_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.\n    \n-   Store 256-bits (composed of 32 packed 8-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 256-bits (composed of 16 packed 16-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.\n    \n-   Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   [\\_mm256\\_xor\\_epi32](fn._mm256_xor_epi32.html \"fn core::arch::x86::_mm256_xor_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   [\\_mm256\\_xor\\_epi64](fn._mm256_xor_epi64.html \"fn core::arch::x86::_mm256_xor_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst.\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst.\n    \n-   Computes the absolute values of packed 32-bit integers in `a`.\n    \n-   Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.\n    \n-   [\\_mm512\\_abs\\_pd](fn._mm512_abs_pd.html \"fn core::arch::x86::_mm512_abs_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst.\n    \n-   [\\_mm512\\_abs\\_ps](fn._mm512_abs_ps.html \"fn core::arch::x86::_mm512_abs_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst.\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst.\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst.\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst.\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst.\n    \n-   [\\_mm512\\_add\\_pd](fn._mm512_add_pd.html \"fn core::arch::x86::_mm512_add_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   [\\_mm512\\_add\\_ps](fn._mm512_add_ps.html \"fn core::arch::x86::_mm512_add_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst.\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst.\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst.\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst.\n    \n-   Performs one round of an AES decryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Performs the last round of an AES decryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Performs one round of an AES encryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Performs the last round of an AES encryption flow on each 128-bit word (state) in `a` using the corresponding 128-bit word (key) in `round_key`.\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst.\n    \n-   Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst.\n    \n-   Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   Compute the bitwise AND of 512 bits (composed of packed 64-bit integers) in a and b, and store the results in dst.\n    \n-   Compute the bitwise AND of 512 bits (representing integer data) in a and b, and store the result in dst.\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst.\n    \n-   Compute the bitwise NOT of 512 bits (composed of packed 64-bit integers) in a and then AND with b, and store the results in dst.\n    \n-   Compute the bitwise NOT of 512 bits (representing integer data) in a and then AND with b, and store the result in dst.\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst.\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst.\n    \n-   Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers. Then groups 8 8-bit values from `c`as indices into the bits of the corresponding 64-bit integer. It then selects these bits and packs them into the output.\n    \n-   Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.\n    \n-   Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst.\n    \n-   Broadcast the 4 packed 32-bit integers from a to all elements of dst.\n    \n-   Broadcast the 4 packed 64-bit integers from a to all elements of dst.\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst.\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst.\n    \n-   Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.\n    \n-   Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst.\n    \n-   Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst.\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst.\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst.\n    \n-   Shift 128-bit lanes in a left by imm8 bytes while shifting in zeros, and store the results in dst.\n    \n-   Shift 128-bit lanes in a right by imm8 bytes while shifting in zeros, and store the results in dst.\n    \n-   Cast vector of type \\_\\_m128d to type \\_\\_m512d; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m256d to type \\_\\_m512d; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512d to type \\_\\_m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512d to type \\_\\_m256d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512d to type \\_\\_m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512d to type \\_\\_m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m128 to type \\_\\_m512; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m256 to type \\_\\_m512; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512 to type \\_\\_m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512 to type \\_\\_m256. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512 to type \\_\\_m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512 to type \\_\\_m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m128i to type \\_\\_m512i; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m256i to type \\_\\_m512i; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512i to type \\_\\_m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512i to type \\_\\_m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512i to type \\_\\_m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m512i to type \\_\\_m256i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2) - in each of the 4 128-bit lanes.\n    \n-   Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by `IMM8`, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst.\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst.\n    \n-   Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst.\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst.\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst.\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst.\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst.\n    \n-   Zero extend packed unsigned 8-bit integers in the low 8 byte sof a to packed 64-bit integers, and store the results in dst.\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst.\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst.\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Performs element-by-element conversion of the lower half of packed 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two 512-bit vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in a  \n    512-bit wide vector. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&avx512techs=AVX512_BF16&text=_mm512_cvtne2ps_pbh)\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm512_cvtneps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst. The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.\n    \n-   Copy the lower 32-bit integer in a to dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   [\\_mm512\\_div\\_pd](fn._mm512_div_pd.html \"fn core::arch::x86::_mm512_div_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst.\n    \n-   [\\_mm512\\_div\\_ps](fn._mm512_div_ps.html \"fn core::arch::x86::_mm512_div_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, =and store the results in dst.\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.\n    \n-   [\\_mm512\\_dpbf16\\_ps](fn._mm512_dpbf16_ps.html \"fn core::arch::x86::_mm512_dpbf16_ps\")⚠Experimental(x86 or x86-64) and `avx512bf16,avx512f`\n    \n    Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst.Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm512_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.\n    \n-   Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.\n    \n-   Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the result in dst.\n    \n-   Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the result in dst.\n    \n-   Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the result in dst.\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign. The mantissa is normalized to the interval specified by interv, which can take the following values: \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2) \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2) \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1) \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5) The sign is determined by sc which can take the following values: \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src) \\_MM\\_MANT\\_SIGN\\_zero // sign = 0 \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.\n    \n-   Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.\n    \n-   Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.\n    \n-   Copy a to dst, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into dst at the location specified by imm8.\n    \n-   Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.\n    \n-   Copy a to dst, then insert 256 bits (composed of 4 packed 64-bit integers) from b into dst at the location specified by imm8.\n    \n-   Converts integer mask into bitmask, storing the result in dst.\n    \n-   [\\_mm512\\_kand](fn._mm512_kand.html \"fn core::arch::x86::_mm512_kand\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise AND of 16-bit masks a and b, and store the result in k.\n    \n-   [\\_mm512\\_kandn](fn._mm512_kandn.html \"fn core::arch::x86::_mm512_kandn\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.\n    \n-   [\\_mm512\\_kmov](fn._mm512_kmov.html \"fn core::arch::x86::_mm512_kmov\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Copy 16-bit mask a to k.\n    \n-   [\\_mm512\\_knot](fn._mm512_knot.html \"fn core::arch::x86::_mm512_knot\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise NOT of 16-bit mask a, and store the result in k.\n    \n-   [\\_mm512\\_kor](fn._mm512_kor.html \"fn core::arch::x86::_mm512_kor\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise OR of 16-bit masks a and b, and store the result in k.\n    \n-   Performs bitwise OR between k1 and k2, storing the result in dst. CF flag is set if dst consists of all 1’s.\n    \n-   Unpack and interleave 8 bits from masks a and b, and store the 16-bit result in k.\n    \n-   [\\_mm512\\_kxnor](fn._mm512_kxnor.html \"fn core::arch::x86::_mm512_kxnor\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.\n    \n-   [\\_mm512\\_kxor](fn._mm512_kxor.html \"fn core::arch::x86::_mm512_kxor\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.\n    \n-   Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into dst. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into dst. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load 512-bits of integer data from memory into dst. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load 512-bits (composed of 64 packed 8-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load 512-bits (composed of 32 packed 16-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Loads 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Loads 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Load 512-bits of integer data from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.\n    \n-   Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.\n    \n-   Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst.\n    \n-   Vertically multiply each unsigned 8-bit integer from a with the corresponding signed 8-bit integer from b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst.\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Converts bit mask k1 into an integer value, storing the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Computes the absolute value of packed 32-bit integers in `a`, and store the unsigned results in `dst` using writemask `k` (elements are copied from `src` when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers. Then groups 8 8-bit values from `c`as indices into the bits of the corresponding 64-bit integer. It then selects these bits and packs them into the output.\n    \n-   Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.\n    \n-   Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed 64-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Performs element-by-element conversion of the lower half of 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&avx512techs=AVX512_BF16&text=_mm512_mask_cvtne2ps_pbh)\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm512_mask_cvtneps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 32-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm512_mask_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base\\_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load packed 32-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 64-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 8-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 16-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 32-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 64-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to \\_mm512\\_mask\\_permutexvar\\_epi32, and it is recommended that you use that intrinsic name.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Reduce the packed 32-bit integers in a by addition using mask k. Returns the sum of all active elements in a.\n    \n-   Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.\n    \n-   Reduce the packed 32-bit integers in a by bitwise AND using mask k. Returns the bitwise AND of all active elements in a.\n    \n-   Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.\n    \n-   Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.\n    \n-   Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.\n    \n-   Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.\n    \n-   Reduce the packed unsigned 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.\n    \n-   Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.\n    \n-   Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.\n    \n-   Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.\n    \n-   Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.\n    \n-   Reduce the packed 32-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.\n    \n-   Reduce the packed 64-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.\n    \n-   Reduce the packed 32-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.\n    \n-   Reduce the packed 64-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Store packed 32-bit integers from a into memory using writemask k. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed 64-bit integers from a into memory using writemask k. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed 8-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 16-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 32-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 64-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Computes the absolute value of packed 32-bit integers in `a`, and store the unsigned results in `dst` using zeromask `k` (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and stores the low 64 bytes (16 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and stores the low 64 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the 4 packed 64-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&avx512techs=AVX512_BF16&text=_mm512_maskz_cvtne2ps_pbh)\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm512_maskz_cvtneps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm512_maskz_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in a using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load packed 32-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 64-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 8-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 16-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 32-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 64-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.\n    \n-   [\\_mm512\\_max\\_pd](fn._mm512_max_pd.html \"fn core::arch::x86::_mm512_max_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.\n    \n-   [\\_mm512\\_max\\_ps](fn._mm512_max_ps.html \"fn core::arch::x86::_mm512_max_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.\n    \n-   [\\_mm512\\_min\\_pd](fn._mm512_min_pd.html \"fn core::arch::x86::_mm512_min_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst. Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.\n    \n-   [\\_mm512\\_min\\_ps](fn._mm512_min_ps.html \"fn core::arch::x86::_mm512_min_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst.\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.\n    \n-   Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.\n    \n-   Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.\n    \n-   Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n    \n-   Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst.\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst.\n    \n-   [\\_mm512\\_mul\\_pd](fn._mm512_mul_pd.html \"fn core::arch::x86::_mm512_mul_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   [\\_mm512\\_mul\\_ps](fn._mm512_mul_ps.html \"fn core::arch::x86::_mm512_mul_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst.\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst.\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst.\n    \n-   Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst.\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.\n    \n-   Compute the bitwise OR of 512 bits (representing integer data) in a and b, and store the result in dst.\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst.\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst. Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to \\_mm512\\_permutexvar\\_epi32, and it is recommended that you use that intrinsic name.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Reduce the packed 32-bit integers in a by addition. Returns the sum of all elements in a.\n    \n-   Reduce the packed 64-bit integers in a by addition. Returns the sum of all elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by addition. Returns the sum of all elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by addition. Returns the sum of all elements in a.\n    \n-   Reduce the packed 32-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.\n    \n-   Reduce the packed 64-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.\n    \n-   Reduce the packed signed 32-bit integers in a by maximum. Returns the maximum of all elements in a.\n    \n-   Reduce the packed signed 64-bit integers in a by maximum. Returns the maximum of all elements in a.\n    \n-   Reduce the packed unsigned 32-bit integers in a by maximum. Returns the maximum of all elements in a.\n    \n-   Reduce the packed unsigned 64-bit integers in a by maximum. Returns the maximum of all elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.\n    \n-   Reduce the packed signed 32-bit integers in a by minimum. Returns the minimum of all elements in a.\n    \n-   Reduce the packed signed 64-bit integers in a by minimum. Returns the minimum of all elements in a.\n    \n-   Reduce the packed unsigned 32-bit integers in a by minimum. Returns the minimum of all elements in a.\n    \n-   Reduce the packed unsigned 64-bit integers in a by minimum. Returns the minimum of all elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.\n    \n-   Reduce the packed 32-bit integers in a by multiplication. Returns the product of all elements in a.\n    \n-   Reduce the packed 64-bit integers in a by multiplication. Returns the product of all elements in a.\n    \n-   Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.\n    \n-   Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.\n    \n-   Reduce the packed 32-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.\n    \n-   Reduce the packed 64-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the absolute differences of packed unsigned 8-bit integers in a and b, then horizontally sum each consecutive 8 differences to produce eight unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in dst.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   Broadcast 8-bit integer a to all elements of dst.\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst.\n    \n-   Broadcast 32-bit integer `a` to all elements of `dst`.\n    \n-   Broadcast 64-bit integer `a` to all elements of `dst`.\n    \n-   Broadcast 64-bit float `a` to all elements of `dst`.\n    \n-   Broadcast 32-bit float `a` to all elements of `dst`.\n    \n-   Set packed 32-bit integers in dst with the repeated 4 element sequence.\n    \n-   Set packed 64-bit integers in dst with the repeated 4 element sequence.\n    \n-   Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence.\n    \n-   Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence.\n    \n-   Set packed 8-bit integers in dst with the supplied values.\n    \n-   Set packed 16-bit integers in dst with the supplied values.\n    \n-   Sets packed 32-bit integers in `dst` with the supplied values.\n    \n-   Set packed 64-bit integers in dst with the supplied values.\n    \n-   [\\_mm512\\_set\\_pd](fn._mm512_set_pd.html \"fn core::arch::x86::_mm512_set_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Set packed double-precision (64-bit) floating-point elements in dst with the supplied values.\n    \n-   [\\_mm512\\_set\\_ps](fn._mm512_set_ps.html \"fn core::arch::x86::_mm512_set_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Sets packed 32-bit integers in `dst` with the supplied values.\n    \n-   Set packed 32-bit integers in dst with the repeated 4 element sequence in reverse order.\n    \n-   Set packed 64-bit integers in dst with the repeated 4 element sequence in reverse order.\n    \n-   Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.\n    \n-   Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.\n    \n-   Sets packed 32-bit integers in `dst` with the supplied values in reverse order.\n    \n-   Set packed 64-bit integers in dst with the supplied values in reverse order.\n    \n-   Set packed double-precision (64-bit) floating-point elements in dst with the supplied values in reverse order.\n    \n-   Sets packed 32-bit integers in `dst` with the supplied values in reverse order.\n    \n-   Return vector of type `__m512` with all elements set to zero.\n    \n-   Return vector of type `__m512i` with all elements set to zero.\n    \n-   Returns vector of type `__m512d` with all elements set to zero.\n    \n-   Returns vector of type `__m512` with all elements set to zero.\n    \n-   Returns vector of type `__m512i` with all elements set to zero.\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.\n    \n-   Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst.\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst.\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits of integer data from a into memory. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits of integer data from a into memory. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits (composed of 64 packed 8-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 512-bits (composed of 32 packed 16-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Stores 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Stores 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary.\n    \n-   Store 512-bits of integer data from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Store 512-bits of integer data from a into memory using a non-temporal memory hint. mem\\_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst.\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst.\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst.\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst.\n    \n-   [\\_mm512\\_sub\\_pd](fn._mm512_sub_pd.html \"fn core::arch::x86::_mm512_sub_pd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.\n    \n-   [\\_mm512\\_sub\\_ps](fn._mm512_sub_ps.html \"fn core::arch::x86::_mm512_sub_ps\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.\n    \n-   Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.\n    \n-   Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst.\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst.\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst.\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst.\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.\n    \n-   Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Return vector of type \\_\\_m512 with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Return vector of type \\_\\_m512i with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Returns vector of type `__m512d` with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Returns vector of type `__m512` with indeterminate elements. Despite being “undefined”, this is some valid value and not equivalent to [`mem::MaybeUninit`](../../mem/union.MaybeUninit.html \"union core::mem::MaybeUninit\"). In practice, this is equivalent to [`mem::zeroed`](../../mem/fn.zeroed.html \"fn core::mem::zeroed\").\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.\n    \n-   Compute the bitwise XOR of 512 bits (representing integer data) in a and b, and store the result in dst.\n    \n-   Cast vector of type \\_\\_m128d to type \\_\\_m512d; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m256d to type \\_\\_m512d; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m128 to type \\_\\_m512; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m256 to type \\_\\_m512; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m128i to type \\_\\_m512i; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Cast vector of type \\_\\_m256i to type \\_\\_m512i; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.\n    \n-   Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_alignr\\_epi32](fn._mm_alignr_epi32.html \"fn core::arch::x86::_mm_alignr_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst.\n    \n-   [\\_mm\\_alignr\\_epi64](fn._mm_alignr_epi64.html \"fn core::arch::x86::_mm_alignr_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst.\n    \n-   Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers. Then groups 8 8-bit values from `c`as indices into the bits of the corresponding 64-bit integer. It then selects these bits and packs them into the output.\n    \n-   Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.\n    \n-   Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.\n    \n-   Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   [\\_mm\\_cmp\\_pd\\_mask](fn._mm_cmp_pd_mask.html \"fn core::arch::x86::_mm_cmp_pd_mask\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   [\\_mm\\_cmp\\_ps\\_mask](fn._mm_cmp_ps_mask.html \"fn core::arch::x86::_mm_cmp_ps_mask\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.\n    \n-   Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.\n    \n-   Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.\n    \n-   Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.\n    \n-   Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.\n    \n-   [\\_mm\\_cvtepu32\\_pd](fn._mm_cvtepu32_pd.html \"fn core::arch::x86::_mm_cvtepu32_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.\n    \n-   [\\_mm\\_cvti32\\_sd](fn._mm_cvti32_sd.html \"fn core::arch::x86::_mm_cvti32_sd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the signed 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   [\\_mm\\_cvti32\\_ss](fn._mm_cvti32_ss.html \"fn core::arch::x86::_mm_cvti32_ss\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_cvtne2ps\\_pbh](fn._mm_cvtne2ps_pbh.html \"fn core::arch::x86::_mm_cvtne2ps_pbh\")⚠Experimental(x86 or x86-64) and `avx512bf16,avx512vl`\n    \n    Convert packed single-precision (32-bit) floating-point elements in two 128-bit vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in a 128-bit wide vector. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&avx512techs=AVX512_BF16&text=_mm_cvtne2ps_pbh)\n    \n-   [\\_mm\\_cvtpd\\_epu32](fn._mm_cvtpd_epu32.html \"fn core::arch::x86::_mm_cvtpd_epu32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   [\\_mm\\_cvtps\\_epu32](fn._mm_cvtps_epu32.html \"fn core::arch::x86::_mm_cvtps_epu32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.\n    \n-   [\\_mm\\_cvtsd\\_i32](fn._mm_cvtsd_i32.html \"fn core::arch::x86::_mm_cvtsd_i32\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.\n    \n-   [\\_mm\\_cvtsd\\_u32](fn._mm_cvtsd_u32.html \"fn core::arch::x86::_mm_cvtsd_u32\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.\n    \n-   [\\_mm\\_cvtss\\_i32](fn._mm_cvtss_i32.html \"fn core::arch::x86::_mm_cvtss_i32\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.\n    \n-   [\\_mm\\_cvtss\\_u32](fn._mm_cvtss_u32.html \"fn core::arch::x86::_mm_cvtss_u32\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   [\\_mm\\_cvttpd\\_epu32](fn._mm_cvttpd_epu32.html \"fn core::arch::x86::_mm_cvttpd_epu32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.\n    \n-   [\\_mm\\_cvttps\\_epu32](fn._mm_cvttps_epu32.html \"fn core::arch::x86::_mm_cvttps_epu32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.\n    \n-   Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.\n    \n-   [\\_mm\\_cvtu32\\_sd](fn._mm_cvtu32_sd.html \"fn core::arch::x86::_mm_cvtu32_sd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the unsigned 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   [\\_mm\\_cvtu32\\_ss](fn._mm_cvtu32_ss.html \"fn core::arch::x86::_mm_cvtu32_ss\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.\n    \n-   [\\_mm\\_dbsad\\_epu8](fn._mm_dbsad_epu8.html \"fn core::arch::x86::_mm_dbsad_epu8\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_dpbf16\\_ps](fn._mm_dpbf16_ps.html \"fn core::arch::x86::_mm_dpbf16_ps\")⚠Experimental(x86 or x86-64) and `avx512bf16,avx512vl`\n    \n    Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst. [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm_dpbf16_ps)\n    \n-   [\\_mm\\_dpbusd\\_epi32](fn._mm_dpbusd_epi32.html \"fn core::arch::x86::_mm_dpbusd_epi32\")⚠Experimental(x86 or x86-64) and `avx512vnni,avx512vl`\n    \n    Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.\n    \n-   [\\_mm\\_dpbusds\\_epi32](fn._mm_dpbusds_epi32.html \"fn core::arch::x86::_mm_dpbusds_epi32\")⚠Experimental(x86 or x86-64) and `avx512vnni,avx512vl`\n    \n    Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.\n    \n-   [\\_mm\\_dpwssd\\_epi32](fn._mm_dpwssd_epi32.html \"fn core::arch::x86::_mm_dpwssd_epi32\")⚠Experimental(x86 or x86-64) and `avx512vnni,avx512vl`\n    \n    Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.\n    \n-   [\\_mm\\_dpwssds\\_epi32](fn._mm_dpwssds_epi32.html \"fn core::arch::x86::_mm_dpwssds_epi32\")⚠Experimental(x86 or x86-64) and `avx512vnni,avx512vl`\n    \n    Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.\n    \n-   [\\_mm\\_fixupimm\\_pd](fn._mm_fixupimm_pd.html \"fn core::arch::x86::_mm_fixupimm_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   [\\_mm\\_fixupimm\\_ps](fn._mm_fixupimm_ps.html \"fn core::arch::x86::_mm_fixupimm_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_getexp\\_pd](fn._mm_getexp_pd.html \"fn core::arch::x86::_mm_getexp_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   [\\_mm\\_getexp\\_ps](fn._mm_getexp_ps.html \"fn core::arch::x86::_mm_getexp_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   [\\_mm\\_getexp\\_sd](fn._mm_getexp_sd.html \"fn core::arch::x86::_mm_getexp_sd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.\n    \n-   [\\_mm\\_getexp\\_ss](fn._mm_getexp_ss.html \"fn core::arch::x86::_mm_getexp_ss\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.\n    \n-   [\\_mm\\_getmant\\_pd](fn._mm_getmant_pd.html \"fn core::arch::x86::_mm_getmant_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   [\\_mm\\_getmant\\_ps](fn._mm_getmant_ps.html \"fn core::arch::x86::_mm_getmant_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign. The mantissa is normalized to the interval specified by interv, which can take the following values: \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2) \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2) \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1) \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5) The sign is determined by sc which can take the following values: \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src) \\_MM\\_MANT\\_SIGN\\_zero // sign = 0 \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   [\\_mm\\_load\\_epi32](fn._mm_load_epi32.html \"fn core::arch::x86::_mm_load_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_load\\_epi64](fn._mm_load_epi64.html \"fn core::arch::x86::_mm_load_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_loadu\\_epi8](fn._mm_loadu_epi8.html \"fn core::arch::x86::_mm_loadu_epi8\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Load 128-bits (composed of 16 packed 8-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_loadu\\_epi16](fn._mm_loadu_epi16.html \"fn core::arch::x86::_mm_loadu_epi16\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Load 128-bits (composed of 8 packed 16-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_loadu\\_epi32](fn._mm_loadu_epi32.html \"fn core::arch::x86::_mm_loadu_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_loadu\\_epi64](fn._mm_loadu_epi64.html \"fn core::arch::x86::_mm_loadu_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_lzcnt\\_epi32](fn._mm_lzcnt_epi32.html \"fn core::arch::x86::_mm_lzcnt_epi32\")⚠Experimental(x86 or x86-64) and `avx512cd,avx512vl`\n    \n    Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.\n    \n-   [\\_mm\\_lzcnt\\_epi64](fn._mm_lzcnt_epi64.html \"fn core::arch::x86::_mm_lzcnt_epi64\")⚠Experimental(x86 or x86-64) and `avx512cd,avx512vl`\n    \n    Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.\n    \n-   Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.\n    \n-   Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`.\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set)\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_add\\_pd](fn._mm_mask_add_pd.html \"fn core::arch::x86::_mm_mask_add_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_add\\_ps](fn._mm_mask_add_ps.html \"fn core::arch::x86::_mm_mask_add_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers. Then groups 8 8-bit values from `c`as indices into the bits of the corresponding 64-bit integer. It then selects these bits and packs them into the output.\n    \n-   Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.\n    \n-   Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not seti).  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).\n    \n-   Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&avx512techs=AVX512_BF16&text=_mm_mask_cvtne2ps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base\\_addr.\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   [\\_mm\\_mask\\_div\\_pd](fn._mm_mask_div_pd.html \"fn core::arch::x86::_mm_mask_div_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_div\\_ps](fn._mm_mask_div_ps.html \"fn core::arch::x86::_mm_mask_div_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm_mask_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.\n    \n-   Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Load packed 32-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 64-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_mask\\_load\\_pd](fn._mm_mask_load_pd.html \"fn core::arch::x86::_mm_mask_load_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_mask\\_load\\_ps](fn._mm_mask_load_ps.html \"fn core::arch::x86::_mm_mask_load_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_mask\\_loadu\\_epi8](fn._mm_mask_loadu_epi8.html \"fn core::arch::x86::_mm_mask_loadu_epi8\")⚠Experimental(x86 or x86-64) and `avx512f,avx512bw,avx512vl,avx,sse`\n    \n    Load packed 8-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_mask\\_loadu\\_epi16](fn._mm_mask_loadu_epi16.html \"fn core::arch::x86::_mm_mask_loadu_epi16\")⚠Experimental(x86 or x86-64) and `avx512f,avx512bw,avx512vl,avx,sse`\n    \n    Load packed 16-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 32-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 64-bit integers from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_mask\\_loadu\\_pd](fn._mm_mask_loadu_pd.html \"fn core::arch::x86::_mm_mask_loadu_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_mask\\_loadu\\_ps](fn._mm_mask_loadu_ps.html \"fn core::arch::x86::_mm_mask_loadu_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_max\\_pd](fn._mm_mask_max_pd.html \"fn core::arch::x86::_mm_mask_max_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_max\\_ps](fn._mm_mask_max_ps.html \"fn core::arch::x86::_mm_mask_max_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_min\\_pd](fn._mm_mask_min_pd.html \"fn core::arch::x86::_mm_mask_min_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_min\\_ps](fn._mm_mask_min_ps.html \"fn core::arch::x86::_mm_mask_min_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_mov\\_pd](fn._mm_mask_mov_pd.html \"fn core::arch::x86::_mm_mask_mov_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_mov\\_ps](fn._mm_mask_mov_ps.html \"fn core::arch::x86::_mm_mask_mov_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_mul\\_pd](fn._mm_mask_mul_pd.html \"fn core::arch::x86::_mm_mask_mul_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_mul\\_ps](fn._mm_mask_mul_ps.html \"fn core::arch::x86::_mm_mask_mul_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_sqrt\\_pd](fn._mm_mask_sqrt_pd.html \"fn core::arch::x86::_mm_mask_sqrt_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_sqrt\\_ps](fn._mm_mask_sqrt_ps.html \"fn core::arch::x86::_mm_mask_sqrt_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Store packed 32-bit integers from a into memory using writemask k. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Store packed 64-bit integers from a into memory using writemask k. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_mask\\_store\\_pd](fn._mm_mask_store_pd.html \"fn core::arch::x86::_mm_mask_store_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_mask\\_store\\_ps](fn._mm_mask_store_ps.html \"fn core::arch::x86::_mm_mask_store_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_mask\\_storeu\\_epi8](fn._mm_mask_storeu_epi8.html \"fn core::arch::x86::_mm_mask_storeu_epi8\")⚠Experimental(x86 or x86-64) and `avx512f,avx512bw,avx512vl,avx,sse`\n    \n    Store packed 8-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_mask\\_storeu\\_epi16](fn._mm_mask_storeu_epi16.html \"fn core::arch::x86::_mm_mask_storeu_epi16\")⚠Experimental(x86 or x86-64) and `avx512f,avx512bw,avx512vl,avx,sse`\n    \n    Store packed 16-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 32-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Store packed 64-bit integers from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_mask\\_storeu\\_pd](fn._mm_mask_storeu_pd.html \"fn core::arch::x86::_mm_mask_storeu_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_mask\\_storeu\\_ps](fn._mm_mask_storeu_ps.html \"fn core::arch::x86::_mm_mask_storeu_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_sub\\_pd](fn._mm_mask_sub_pd.html \"fn core::arch::x86::_mm_mask_sub_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_mask\\_sub\\_ps](fn._mm_mask_sub_ps.html \"fn core::arch::x86::_mm_mask_sub_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.\n    \n-   Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_add\\_pd](fn._mm_maskz_add_pd.html \"fn core::arch::x86::_mm_maskz_add_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_add\\_ps](fn._mm_maskz_add_ps.html \"fn core::arch::x86::_mm_maskz_add_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.\n    \n-   Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the rounding\\[3:0\\] parameter, which can be one of:  \n    (\\_MM\\_FROUND\\_TO\\_NEAREST\\_INT |\\_MM\\_FROUND\\_NO\\_EXC) // round to nearest, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_NEG\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round down, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_POS\\_INF |\\_MM\\_FROUND\\_NO\\_EXC) // round up, and suppress exceptions  \n    (\\_MM\\_FROUND\\_TO\\_ZERO |\\_MM\\_FROUND\\_NO\\_EXC) // truncate, and suppress exceptions  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in th elow 4 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in two vectors a and b to packed BF16 (16-bit) floating-point elements, and store the results in single vector dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&avx512techs=AVX512_BF16&text=_mm_maskz_cvtne2ps_pbh)\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.\n    \n-   Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.\n    \n-   [\\_mm\\_maskz\\_div\\_pd](fn._mm_maskz_div_pd.html \"fn core::arch::x86::_mm_maskz_div_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_div\\_ps](fn._mm_maskz_div_ps.html \"fn core::arch::x86::_mm_maskz_div_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Compute dot-product of BF16 (16-bit) floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit) floating-point elements with elements in src, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). [Intel’s documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&avx512techs=AVX512_BF16&text=_mm_maskz_dpbf16_ps)\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 8-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 16-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 32-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active 64-bit integers from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem\\_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.\n    \n-   Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.\n    \n-   Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.\n    \n-   Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.\n    \n-   Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.\n    \n-   Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1\n    \n-   Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)\\*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.  \n    The mantissa is normalized to the interval specified by interv, which can take the following values:  \n    \\_MM\\_MANT\\_NORM\\_1\\_2 // interval \\[1, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_2 // interval \\[0.5, 2)  \n    \\_MM\\_MANT\\_NORM\\_p5\\_1 // interval \\[0.5, 1)  \n    \\_MM\\_MANT\\_NORM\\_p75\\_1p5 // interval \\[0.75, 1.5)  \n    The sign is determined by sc which can take the following values:  \n    \\_MM\\_MANT\\_SIGN\\_src // sign = sign(src)  \n    \\_MM\\_MANT\\_SIGN\\_zero // sign = 0  \n    \\_MM\\_MANT\\_SIGN\\_nan // dst = NaN if sign(src) = 1  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Performs an affine transformation on the packed bytes in x. That is computes a\\*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs an affine transformation on the inverted packed bytes in x. That is computes a\\*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix and b being a constant 8-bit immediate value. The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1. The inverse of 0 is 0. Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.\n    \n-   Performs a multiplication in GF(2^8) on the packed bytes. The field is in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.\n    \n-   Load packed 32-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   Load packed 64-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_maskz\\_load\\_pd](fn._mm_maskz_load_pd.html \"fn core::arch::x86::_mm_maskz_load_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_maskz\\_load\\_ps](fn._mm_maskz_load_ps.html \"fn core::arch::x86::_mm_maskz_load_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_maskz\\_loadu\\_epi8](fn._mm_maskz_loadu_epi8.html \"fn core::arch::x86::_mm_maskz_loadu_epi8\")⚠Experimental(x86 or x86-64) and `avx512f,avx512bw,avx512vl,avx,sse`\n    \n    Load packed 8-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_maskz\\_loadu\\_epi16](fn._mm_maskz_loadu_epi16.html \"fn core::arch::x86::_mm_maskz_loadu_epi16\")⚠Experimental(x86 or x86-64) and `avx512f,avx512bw,avx512vl,avx,sse`\n    \n    Load packed 16-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 32-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Load packed 64-bit integers from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_maskz\\_loadu\\_pd](fn._mm_maskz_loadu_pd.html \"fn core::arch::x86::_mm_maskz_loadu_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_maskz\\_loadu\\_ps](fn._mm_maskz_loadu_ps.html \"fn core::arch::x86::_mm_maskz_loadu_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl,avx,sse`\n    \n    Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_max\\_pd](fn._mm_maskz_max_pd.html \"fn core::arch::x86::_mm_maskz_max_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_max\\_ps](fn._mm_maskz_max_ps.html \"fn core::arch::x86::_mm_maskz_max_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_min\\_pd](fn._mm_maskz_min_pd.html \"fn core::arch::x86::_mm_maskz_min_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_min\\_ps](fn._mm_maskz_min_ps.html \"fn core::arch::x86::_mm_maskz_min_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_mov\\_pd](fn._mm_maskz_mov_pd.html \"fn core::arch::x86::_mm_maskz_mov_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_mov\\_ps](fn._mm_maskz_mov_ps.html \"fn core::arch::x86::_mm_maskz_mov_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_mul\\_pd](fn._mm_maskz_mul_pd.html \"fn core::arch::x86::_mm_maskz_mul_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_mul\\_ps](fn._mm_maskz_mul_ps.html \"fn core::arch::x86::_mm_maskz_mul_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_sub\\_pd](fn._mm_maskz_sub_pd.html \"fn core::arch::x86::_mm_maskz_sub_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_maskz\\_sub\\_ps](fn._mm_maskz_sub_ps.html \"fn core::arch::x86::_mm_maskz_sub_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.\n    \n-   Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n    \n-   [\\_mm\\_max\\_epi64](fn._mm_max_epi64.html \"fn core::arch::x86::_mm_max_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.\n    \n-   [\\_mm\\_max\\_epu64](fn._mm_max_epu64.html \"fn core::arch::x86::_mm_max_epu64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   [\\_mm\\_min\\_epu64](fn._mm_min_epu64.html \"fn core::arch::x86::_mm_min_epu64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.\n    \n-   Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst , and copy the upper element from a to the upper element of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Exceptions can be suppressed by passing \\_MM\\_FROUND\\_NO\\_EXC in the sae parameter.\n    \n-   [\\_mm\\_movepi8\\_mask](fn._mm_movepi8_mask.html \"fn core::arch::x86::_mm_movepi8_mask\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.\n    \n-   Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.\n    \n-   [\\_mm\\_movm\\_epi8](fn._mm_movm_epi8.html \"fn core::arch::x86::_mm_movm_epi8\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n    \n-   [\\_mm\\_movm\\_epi16](fn._mm_movm_epi16.html \"fn core::arch::x86::_mm_movm_epi16\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n    \n-   Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.\n    \n-   [\\_mm\\_or\\_epi32](fn._mm_or_epi32.html \"fn core::arch::x86::_mm_or_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   [\\_mm\\_or\\_epi64](fn._mm_or_epi64.html \"fn core::arch::x86::_mm_or_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.\n    \n-   Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.\n    \n-   Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\n    \n-   [\\_mm\\_popcnt\\_epi8](fn._mm_popcnt_epi8.html \"fn core::arch::x86::_mm_popcnt_epi8\")⚠Experimental(x86 or x86-64) and `avx512bitalg,avx512vl`\n    \n    For each packed 8-bit integer maps the value to the number of logical 1 bits.\n    \n-   [\\_mm\\_popcnt\\_epi16](fn._mm_popcnt_epi16.html \"fn core::arch::x86::_mm_popcnt_epi16\")⚠Experimental(x86 or x86-64) and `avx512bitalg,avx512vl`\n    \n    For each packed 16-bit integer maps the value to the number of logical 1 bits.\n    \n-   [\\_mm\\_popcnt\\_epi32](fn._mm_popcnt_epi32.html \"fn core::arch::x86::_mm_popcnt_epi32\")⚠Experimental(x86 or x86-64) and `avx512vpopcntdq,avx512vl`\n    \n    For each packed 32-bit integer maps the value to the number of logical 1 bits.\n    \n-   [\\_mm\\_popcnt\\_epi64](fn._mm_popcnt_epi64.html \"fn core::arch::x86::_mm_popcnt_epi64\")⚠Experimental(x86 or x86-64) and `avx512vpopcntdq,avx512vl`\n    \n    For each packed 64-bit integer maps the value to the number of logical 1 bits.\n    \n-   [\\_mm\\_rcp14\\_pd](fn._mm_rcp14_pd.html \"fn core::arch::x86::_mm_rcp14_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm\\_rcp14\\_ps](fn._mm_rcp14_ps.html \"fn core::arch::x86::_mm_rcp14_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm\\_rcp14\\_sd](fn._mm_rcp14_sd.html \"fn core::arch::x86::_mm_rcp14_sd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm\\_rcp14\\_ss](fn._mm_rcp14_ss.html \"fn core::arch::x86::_mm_rcp14_ss\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm\\_rol\\_epi32](fn._mm_rol_epi32.html \"fn core::arch::x86::_mm_rol_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.\n    \n-   [\\_mm\\_rol\\_epi64](fn._mm_rol_epi64.html \"fn core::arch::x86::_mm_rol_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.\n    \n-   [\\_mm\\_rolv\\_epi32](fn._mm_rolv_epi32.html \"fn core::arch::x86::_mm_rolv_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   [\\_mm\\_rolv\\_epi64](fn._mm_rolv_epi64.html \"fn core::arch::x86::_mm_rolv_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   [\\_mm\\_ror\\_epi32](fn._mm_ror_epi32.html \"fn core::arch::x86::_mm_ror_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.\n    \n-   [\\_mm\\_ror\\_epi64](fn._mm_ror_epi64.html \"fn core::arch::x86::_mm_ror_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.\n    \n-   [\\_mm\\_rorv\\_epi32](fn._mm_rorv_epi32.html \"fn core::arch::x86::_mm_rorv_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   [\\_mm\\_rorv\\_epi64](fn._mm_rorv_epi64.html \"fn core::arch::x86::_mm_rorv_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.\n    \n-   Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.  \n    Rounding is done according to the imm8\\[2:0\\] parameter, which can be one of:  \n    \\_MM\\_FROUND\\_TO\\_NEAREST\\_INT // round to nearest  \n    \\_MM\\_FROUND\\_TO\\_NEG\\_INF // round down  \n    \\_MM\\_FROUND\\_TO\\_POS\\_INF // round up  \n    \\_MM\\_FROUND\\_TO\\_ZERO // truncate  \n    \\_MM\\_FROUND\\_CUR\\_DIRECTION // use MXCSR.RC; see \\_MM\\_SET\\_ROUNDING\\_MODE\n    \n-   Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.\n    \n-   [\\_mm\\_scalef\\_pd](fn._mm_scalef_pd.html \"fn core::arch::x86::_mm_scalef_pd\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   [\\_mm\\_scalef\\_ps](fn._mm_scalef_ps.html \"fn core::arch::x86::_mm_scalef_ps\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.\n    \n-   Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_scalef\\_sd](fn._mm_scalef_sd.html \"fn core::arch::x86::_mm_scalef_sd\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   [\\_mm\\_scalef\\_ss](fn._mm_scalef_ss.html \"fn core::arch::x86::_mm_scalef_ss\")⚠Experimental(x86 or x86-64) and `avx512f`\n    \n    Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_shldi\\_epi16](fn._mm_shldi_epi16.html \"fn core::arch::x86::_mm_shldi_epi16\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).\n    \n-   [\\_mm\\_shldi\\_epi32](fn._mm_shldi_epi32.html \"fn core::arch::x86::_mm_shldi_epi32\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.\n    \n-   [\\_mm\\_shldi\\_epi64](fn._mm_shldi_epi64.html \"fn core::arch::x86::_mm_shldi_epi64\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).\n    \n-   [\\_mm\\_shldv\\_epi16](fn._mm_shldv_epi16.html \"fn core::arch::x86::_mm_shldv_epi16\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.\n    \n-   [\\_mm\\_shldv\\_epi32](fn._mm_shldv_epi32.html \"fn core::arch::x86::_mm_shldv_epi32\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.\n    \n-   [\\_mm\\_shldv\\_epi64](fn._mm_shldv_epi64.html \"fn core::arch::x86::_mm_shldv_epi64\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.\n    \n-   [\\_mm\\_shrdi\\_epi16](fn._mm_shrdi_epi16.html \"fn core::arch::x86::_mm_shrdi_epi16\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.\n    \n-   [\\_mm\\_shrdi\\_epi32](fn._mm_shrdi_epi32.html \"fn core::arch::x86::_mm_shrdi_epi32\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.\n    \n-   [\\_mm\\_shrdi\\_epi64](fn._mm_shrdi_epi64.html \"fn core::arch::x86::_mm_shrdi_epi64\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.\n    \n-   [\\_mm\\_shrdv\\_epi16](fn._mm_shrdv_epi16.html \"fn core::arch::x86::_mm_shrdv_epi16\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.\n    \n-   [\\_mm\\_shrdv\\_epi32](fn._mm_shrdv_epi32.html \"fn core::arch::x86::_mm_shrdv_epi32\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.\n    \n-   [\\_mm\\_shrdv\\_epi64](fn._mm_shrdv_epi64.html \"fn core::arch::x86::_mm_shrdv_epi64\")⚠Experimental(x86 or x86-64) and `avx512vbmi2,avx512vl`\n    \n    Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.\n    \n-   [\\_mm\\_sllv\\_epi16](fn._mm_sllv_epi16.html \"fn core::arch::x86::_mm_sllv_epi16\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   [\\_mm\\_sra\\_epi64](fn._mm_sra_epi64.html \"fn core::arch::x86::_mm_sra_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.\n    \n-   [\\_mm\\_srai\\_epi64](fn._mm_srai_epi64.html \"fn core::arch::x86::_mm_srai_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.\n    \n-   [\\_mm\\_srav\\_epi16](fn._mm_srav_epi16.html \"fn core::arch::x86::_mm_srav_epi16\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   [\\_mm\\_srav\\_epi64](fn._mm_srav_epi64.html \"fn core::arch::x86::_mm_srav_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.\n    \n-   [\\_mm\\_srlv\\_epi16](fn._mm_srlv_epi16.html \"fn core::arch::x86::_mm_srlv_epi16\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.\n    \n-   [\\_mm\\_store\\_epi32](fn._mm_store_epi32.html \"fn core::arch::x86::_mm_store_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_store\\_epi64](fn._mm_store_epi64.html \"fn core::arch::x86::_mm_store_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem\\_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.\n    \n-   [\\_mm\\_storeu\\_epi8](fn._mm_storeu_epi8.html \"fn core::arch::x86::_mm_storeu_epi8\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Store 128-bits (composed of 16 packed 8-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_storeu\\_epi16](fn._mm_storeu_epi16.html \"fn core::arch::x86::_mm_storeu_epi16\")⚠Experimental(x86 or x86-64) and `avx512bw,avx512vl`\n    \n    Store 128-bits (composed of 8 packed 16-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_storeu\\_epi32](fn._mm_storeu_epi32.html \"fn core::arch::x86::_mm_storeu_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   [\\_mm\\_storeu\\_epi64](fn._mm_storeu_epi64.html \"fn core::arch::x86::_mm_storeu_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem\\_addr does not need to be aligned on any particular boundary.\n    \n-   Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.\n    \n-   Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.\n    \n-   Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.\n    \n-   Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.\n    \n-   Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.\n    \n-   [\\_mm\\_xor\\_epi32](fn._mm_xor_epi32.html \"fn core::arch::x86::_mm_xor_epi32\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.\n    \n-   [\\_mm\\_xor\\_epi64](fn._mm_xor_epi64.html \"fn core::arch::x86::_mm_xor_epi64\")⚠Experimental(x86 or x86-64) and `avx512f,avx512vl`\n    \n    Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.\n    \n-   [\\_store\\_mask32](fn._store_mask32.html \"fn core::arch::x86::_store_mask32\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Store 32-bit mask from a into memory.\n    \n-   [\\_store\\_mask64](fn._store_mask64.html \"fn core::arch::x86::_store_mask64\")⚠Experimental(x86 or x86-64) and `avx512bw`\n    \n    Store 64-bit mask from a into memory.\n    \n-   [\\_xabort](fn._xabort.html \"fn core::arch::x86::_xabort\")⚠Experimental(x86 or x86-64) and `rtm`\n    \n    Forces a restricted transactional memory (RTM) region to abort.\n    \n-   Retrieves the parameter passed to [`_xabort`](fn._xabort.html \"fn core::arch::x86::_xabort\") when [`_xbegin`](fn._xbegin.html \"fn core::arch::x86::_xbegin\")’s status has the `_XABORT_EXPLICIT` flag set.\n    \n-   [\\_xbegin](fn._xbegin.html \"fn core::arch::x86::_xbegin\")⚠Experimental(x86 or x86-64) and `rtm`\n    \n    Specifies the start of a restricted transactional memory (RTM) code region and returns a value indicating status.\n    \n-   [\\_xend](fn._xend.html \"fn core::arch::x86::_xend\")⚠Experimental(x86 or x86-64) and `rtm`\n    \n    Specifies the end of a restricted transactional memory (RTM) code region.\n    \n-   [\\_xtest](fn._xtest.html \"fn core::arch::x86::_xtest\")⚠Experimental(x86 or x86-64) and `rtm`\n    \n    Queries whether the processor is executing in a transactional region identified by restricted transactional memory (RTM) or hardware lock elision (HLE).\n    \n-   Does the host support the `cpuid` instruction?\n    \n\n-   The `_MM_CMPINT_ENUM` type used to specify comparison operations in AVX-512 intrinsics.\n    \n-   The `MM_MANTISSA_NORM_ENUM` type used to specify mantissa normalized operations in AVX-512 intrinsics.\n    \n-   The `MM_MANTISSA_SIGN_ENUM` type used to specify mantissa signed operations in AVX-512 intrinsics.\n    \n-   The `MM_PERM_ENUM` type used to specify shuffle operations in AVX-512 intrinsics.\n    \n-   [\\_\\_mmask8](type.__mmask8.html \"type core::arch::x86::__mmask8\")Experimentalx86 or x86-64\n    \n    The `__mmask8` type used in AVX-512 intrinsics, a 8-bit integer\n    \n-   The `__mmask16` type used in AVX-512 intrinsics, a 16-bit integer\n    \n-   The `__mmask32` type used in AVX-512 intrinsics, a 32-bit integer\n    \n-   The `__mmask64` type used in AVX-512 intrinsics, a 64-bit integer",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Platform-specific intrinsics for the `x86` platform.\"><title>core::arch::x86 - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../\" data-static-root-path=\"../../../static.files/\" data-current-crate=\"core\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../core/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module x86</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../core/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../core/index.html\">core</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module x86</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li><li><a href=\"#constants\">Constants</a></li><li><a href=\"#functions\">Functions</a></li><li><a href=\"#types\">Type Aliases</a></li></ul></section><h2><a href=\"../index.html\">In core::arch</a></h2><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../aarch64/index.html\">aarch64</a></li><li><a href=\"../arm/index.html\">arm</a></li><li><a href=\"../loongarch64/index.html\">loongarch64</a></li><li><a href=\"../mips/index.html\">mips</a></li><li><a href=\"../mips64/index.html\">mips64</a></li><li><a href=\"../nvptx/index.html\">nvptx</a></li><li><a href=\"../powerpc/index.html\">powerpc</a></li><li><a href=\"../powerpc64/index.html\">powerpc64</a></li><li><a href=\"../riscv32/index.html\">riscv32</a></li><li><a href=\"../riscv64/index.html\">riscv64</a></li><li><a href=\"../wasm/index.html\">wasm</a></li><li><a href=\"../wasm32/index.html\">wasm32</a></li><li><a href=\"../wasm64/index.html\">wasm64</a></li><li><a href=\"../x86/index.html\">x86</a></li><li><a href=\"../x86_64/index.html\">x86_64</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.asm.html\">asm</a></li><li><a href=\"../macro.global_asm.html\">global_asm</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../core/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../../index.html\">core</a>::<wbr><a href=\"../index.html\">arch</a>::<wbr><a class=\"mod\" href=\"#\">x86</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"../../../src/core/stdarch/crates/core_arch/src/mod.rs.html#28\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>x86</strong> only.</div></span><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Platform-specific intrinsics for the <code>x86</code> platform.</p>\n<p>See the <a href=\"../index.html\">module documentation</a> for more details.</p>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.CpuidResult.html\" title=\"struct core::arch::x86::CpuidResult\">CpuidResult</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Result of the <code>cpuid</code> instruction.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m128.html\" title=\"struct core::arch::x86::__m128\">__m128</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">128-bit wide set of four <code>f32</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m128d.html\" title=\"struct core::arch::x86::__m128d\">__m128d</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">128-bit wide set of two <code>f64</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m128i.html\" title=\"struct core::arch::x86::__m128i\">__m128i</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">128-bit wide integer vector type, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m256.html\" title=\"struct core::arch::x86::__m256\">__m256</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">256-bit wide set of eight <code>f32</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m256d.html\" title=\"struct core::arch::x86::__m256d\">__m256d</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">256-bit wide set of four <code>f64</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m256i.html\" title=\"struct core::arch::x86::__m256i\">__m256i</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">256-bit wide integer vector type, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m512.html\" title=\"struct core::arch::x86::__m512\">__m512</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">512-bit wide set of sixteen <code>f32</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m512d.html\" title=\"struct core::arch::x86::__m512d\">__m512d</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">512-bit wide set of eight <code>f64</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m512i.html\" title=\"struct core::arch::x86::__m512i\">__m512i</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">512-bit wide integer vector type, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m128bh.html\" title=\"struct core::arch::x86::__m128bh\">__m128bh</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">128-bit wide set of eight <code>u16</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m256bh.html\" title=\"struct core::arch::x86::__m256bh\">__m256bh</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">256-bit wide set of 16 <code>u16</code> types, x86-specific</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.__m512bh.html\" title=\"struct core::arch::x86::__m512bh\">__m512bh</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">512-bit wide set of 32 <code>u16</code> types, x86-specific</div></li></ul><h2 id=\"constants\" class=\"section-header\">Constants<a href=\"#constants\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_EQ_OQ.html\" title=\"constant core::arch::x86::_CMP_EQ_OQ\">_CMP_EQ_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Equal (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_EQ_OS.html\" title=\"constant core::arch::x86::_CMP_EQ_OS\">_CMP_EQ_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Equal (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_EQ_UQ.html\" title=\"constant core::arch::x86::_CMP_EQ_UQ\">_CMP_EQ_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Equal (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_EQ_US.html\" title=\"constant core::arch::x86::_CMP_EQ_US\">_CMP_EQ_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Equal (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_FALSE_OQ.html\" title=\"constant core::arch::x86::_CMP_FALSE_OQ\">_CMP_FALSE_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">False (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_FALSE_OS.html\" title=\"constant core::arch::x86::_CMP_FALSE_OS\">_CMP_FALSE_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">False (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_GE_OQ.html\" title=\"constant core::arch::x86::_CMP_GE_OQ\">_CMP_GE_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Greater-than-or-equal (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_GE_OS.html\" title=\"constant core::arch::x86::_CMP_GE_OS\">_CMP_GE_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Greater-than-or-equal (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_GT_OQ.html\" title=\"constant core::arch::x86::_CMP_GT_OQ\">_CMP_GT_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Greater-than (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_GT_OS.html\" title=\"constant core::arch::x86::_CMP_GT_OS\">_CMP_GT_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Greater-than (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_LE_OQ.html\" title=\"constant core::arch::x86::_CMP_LE_OQ\">_CMP_LE_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Less-than-or-equal (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_LE_OS.html\" title=\"constant core::arch::x86::_CMP_LE_OS\">_CMP_LE_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Less-than-or-equal (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_LT_OQ.html\" title=\"constant core::arch::x86::_CMP_LT_OQ\">_CMP_LT_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Less-than (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_LT_OS.html\" title=\"constant core::arch::x86::_CMP_LT_OS\">_CMP_LT_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Less-than (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NEQ_OQ.html\" title=\"constant core::arch::x86::_CMP_NEQ_OQ\">_CMP_NEQ_OQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-equal (ordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NEQ_OS.html\" title=\"constant core::arch::x86::_CMP_NEQ_OS\">_CMP_NEQ_OS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-equal (ordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NEQ_UQ.html\" title=\"constant core::arch::x86::_CMP_NEQ_UQ\">_CMP_NEQ_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-equal (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NEQ_US.html\" title=\"constant core::arch::x86::_CMP_NEQ_US\">_CMP_NEQ_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-equal (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NGE_UQ.html\" title=\"constant core::arch::x86::_CMP_NGE_UQ\">_CMP_NGE_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-greater-than-or-equal (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NGE_US.html\" title=\"constant core::arch::x86::_CMP_NGE_US\">_CMP_NGE_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-greater-than-or-equal (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NGT_UQ.html\" title=\"constant core::arch::x86::_CMP_NGT_UQ\">_CMP_NGT_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-greater-than (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NGT_US.html\" title=\"constant core::arch::x86::_CMP_NGT_US\">_CMP_NGT_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-greater-than (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NLE_UQ.html\" title=\"constant core::arch::x86::_CMP_NLE_UQ\">_CMP_NLE_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-less-than-or-equal (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NLE_US.html\" title=\"constant core::arch::x86::_CMP_NLE_US\">_CMP_NLE_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-less-than-or-equal (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NLT_UQ.html\" title=\"constant core::arch::x86::_CMP_NLT_UQ\">_CMP_NLT_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-less-than (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_NLT_US.html\" title=\"constant core::arch::x86::_CMP_NLT_US\">_CMP_NLT_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-less-than (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_ORD_Q.html\" title=\"constant core::arch::x86::_CMP_ORD_Q\">_CMP_ORD_Q</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Ordered (non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_ORD_S.html\" title=\"constant core::arch::x86::_CMP_ORD_S\">_CMP_ORD_S</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Ordered (signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_TRUE_UQ.html\" title=\"constant core::arch::x86::_CMP_TRUE_UQ\">_CMP_TRUE_UQ</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">True (unordered, non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_TRUE_US.html\" title=\"constant core::arch::x86::_CMP_TRUE_US\">_CMP_TRUE_US</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">True (unordered, signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_UNORD_Q.html\" title=\"constant core::arch::x86::_CMP_UNORD_Q\">_CMP_UNORD_Q</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Unordered (non-signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._CMP_UNORD_S.html\" title=\"constant core::arch::x86::_CMP_UNORD_S\">_CMP_UNORD_S</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Unordered (signaling)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_DENORM.html\" title=\"constant core::arch::x86::_MM_EXCEPT_DENORM\">_MM_EXCEPT_DENORM</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_DIV_ZERO.html\" title=\"constant core::arch::x86::_MM_EXCEPT_DIV_ZERO\">_MM_EXCEPT_DIV_ZERO</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_INEXACT.html\" title=\"constant core::arch::x86::_MM_EXCEPT_INEXACT\">_MM_EXCEPT_INEXACT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_INVALID.html\" title=\"constant core::arch::x86::_MM_EXCEPT_INVALID\">_MM_EXCEPT_INVALID</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_MASK.html\" title=\"constant core::arch::x86::_MM_EXCEPT_MASK\">_MM_EXCEPT_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._MM_GET_EXCEPTION_STATE.html\"><code>_MM_GET_EXCEPTION_STATE</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_OVERFLOW.html\" title=\"constant core::arch::x86::_MM_EXCEPT_OVERFLOW\">_MM_EXCEPT_OVERFLOW</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_EXCEPT_UNDERFLOW.html\" title=\"constant core::arch::x86::_MM_EXCEPT_UNDERFLOW\">_MM_EXCEPT_UNDERFLOW</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FLUSH_ZERO_MASK.html\" title=\"constant core::arch::x86::_MM_FLUSH_ZERO_MASK\">_MM_FLUSH_ZERO_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._MM_GET_FLUSH_ZERO_MODE.html\"><code>_MM_GET_FLUSH_ZERO_MODE</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FLUSH_ZERO_OFF.html\" title=\"constant core::arch::x86::_MM_FLUSH_ZERO_OFF\">_MM_FLUSH_ZERO_OFF</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FLUSH_ZERO_ON.html\" title=\"constant core::arch::x86::_MM_FLUSH_ZERO_ON\">_MM_FLUSH_ZERO_ON</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_CEIL.html\" title=\"constant core::arch::x86::_MM_FROUND_CEIL\">_MM_FROUND_CEIL</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">round up and do not suppress exceptions</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_CUR_DIRECTION.html\" title=\"constant core::arch::x86::_MM_FROUND_CUR_DIRECTION\">_MM_FROUND_CUR_DIRECTION</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">use MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_FLOOR.html\" title=\"constant core::arch::x86::_MM_FROUND_FLOOR\">_MM_FROUND_FLOOR</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">round down and do not suppress exceptions</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_NEARBYINT.html\" title=\"constant core::arch::x86::_MM_FROUND_NEARBYINT\">_MM_FROUND_NEARBYINT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">use MXCSR.RC and suppress exceptions; see <code>vendor::_MM_SET_ROUNDING_MODE</code></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_NINT.html\" title=\"constant core::arch::x86::_MM_FROUND_NINT\">_MM_FROUND_NINT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">round to nearest and do not suppress exceptions</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_NO_EXC.html\" title=\"constant core::arch::x86::_MM_FROUND_NO_EXC\">_MM_FROUND_NO_EXC</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">suppress exceptions</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_RAISE_EXC.html\" title=\"constant core::arch::x86::_MM_FROUND_RAISE_EXC\">_MM_FROUND_RAISE_EXC</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">do not suppress exceptions</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_RINT.html\" title=\"constant core::arch::x86::_MM_FROUND_RINT\">_MM_FROUND_RINT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">use MXCSR.RC and do not suppress exceptions; see\n<code>vendor::_MM_SET_ROUNDING_MODE</code></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_TO_NEAREST_INT.html\" title=\"constant core::arch::x86::_MM_FROUND_TO_NEAREST_INT\">_MM_FROUND_TO_NEAREST_INT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">round to nearest</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_TO_NEG_INF.html\" title=\"constant core::arch::x86::_MM_FROUND_TO_NEG_INF\">_MM_FROUND_TO_NEG_INF</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">round down</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_TO_POS_INF.html\" title=\"constant core::arch::x86::_MM_FROUND_TO_POS_INF\">_MM_FROUND_TO_POS_INF</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">round up</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_TO_ZERO.html\" title=\"constant core::arch::x86::_MM_FROUND_TO_ZERO\">_MM_FROUND_TO_ZERO</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">truncate</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_FROUND_TRUNC.html\" title=\"constant core::arch::x86::_MM_FROUND_TRUNC\">_MM_FROUND_TRUNC</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">truncate and do not suppress exceptions</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_HINT_ET0.html\" title=\"constant core::arch::x86::_MM_HINT_ET0\">_MM_HINT_ET0</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_prefetch.html\"><code>_mm_prefetch</code></a>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_HINT_ET1.html\" title=\"constant core::arch::x86::_MM_HINT_ET1\">_MM_HINT_ET1</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_prefetch.html\"><code>_mm_prefetch</code></a>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_HINT_NTA.html\" title=\"constant core::arch::x86::_MM_HINT_NTA\">_MM_HINT_NTA</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_prefetch.html\"><code>_mm_prefetch</code></a>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_HINT_T0.html\" title=\"constant core::arch::x86::_MM_HINT_T0\">_MM_HINT_T0</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_prefetch.html\"><code>_mm_prefetch</code></a>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_HINT_T1.html\" title=\"constant core::arch::x86::_MM_HINT_T1\">_MM_HINT_T1</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_prefetch.html\"><code>_mm_prefetch</code></a>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_HINT_T2.html\" title=\"constant core::arch::x86::_MM_HINT_T2\">_MM_HINT_T2</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_prefetch.html\"><code>_mm_prefetch</code></a>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_DENORM.html\" title=\"constant core::arch::x86::_MM_MASK_DENORM\">_MM_MASK_DENORM</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_DIV_ZERO.html\" title=\"constant core::arch::x86::_MM_MASK_DIV_ZERO\">_MM_MASK_DIV_ZERO</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_INEXACT.html\" title=\"constant core::arch::x86::_MM_MASK_INEXACT\">_MM_MASK_INEXACT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_INVALID.html\" title=\"constant core::arch::x86::_MM_MASK_INVALID\">_MM_MASK_INVALID</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_MASK.html\" title=\"constant core::arch::x86::_MM_MASK_MASK\">_MM_MASK_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._MM_GET_EXCEPTION_MASK.html\"><code>_MM_GET_EXCEPTION_MASK</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_OVERFLOW.html\" title=\"constant core::arch::x86::_MM_MASK_OVERFLOW\">_MM_MASK_OVERFLOW</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MASK_UNDERFLOW.html\" title=\"constant core::arch::x86::_MM_MASK_UNDERFLOW\">_MM_MASK_UNDERFLOW</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_ROUND_DOWN.html\" title=\"constant core::arch::x86::_MM_ROUND_DOWN\">_MM_ROUND_DOWN</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_ROUND_MASK.html\" title=\"constant core::arch::x86::_MM_ROUND_MASK\">_MM_ROUND_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._MM_GET_ROUNDING_MODE.html\"><code>_MM_GET_ROUNDING_MODE</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_ROUND_NEAREST.html\" title=\"constant core::arch::x86::_MM_ROUND_NEAREST\">_MM_ROUND_NEAREST</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_ROUND_TOWARD_ZERO.html\" title=\"constant core::arch::x86::_MM_ROUND_TOWARD_ZERO\">_MM_ROUND_TOWARD_ZERO</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_ROUND_UP.html\" title=\"constant core::arch::x86::_MM_ROUND_UP\">_MM_ROUND_UP</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_BIT_MASK.html\" title=\"constant core::arch::x86::_SIDD_BIT_MASK\">_SIDD_BIT_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\"><strong>Mask only</strong>: return the bit mask</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_CMP_EQUAL_ANY.html\" title=\"constant core::arch::x86::_SIDD_CMP_EQUAL_ANY\">_SIDD_CMP_EQUAL_ANY</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">For each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_CMP_EQUAL_EACH.html\" title=\"constant core::arch::x86::_SIDD_CMP_EQUAL_EACH\">_SIDD_CMP_EQUAL_EACH</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The strings defined by <code>a</code> and <code>b</code> are equal</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_CMP_EQUAL_ORDERED.html\" title=\"constant core::arch::x86::_SIDD_CMP_EQUAL_ORDERED\">_SIDD_CMP_EQUAL_ORDERED</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Search for the defined substring in the target</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_CMP_RANGES.html\" title=\"constant core::arch::x86::_SIDD_CMP_RANGES\">_SIDD_CMP_RANGES</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">For each character in <code>a</code>, determine if\n<code>b[0] &lt;= c &lt;= b[1] or b[1] &lt;= c &lt;= b[2]...</code></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_LEAST_SIGNIFICANT.html\" title=\"constant core::arch::x86::_SIDD_LEAST_SIGNIFICANT\">_SIDD_LEAST_SIGNIFICANT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\"><strong>Index only</strong>: return the least significant bit <em>(Default)</em></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_MASKED_NEGATIVE_POLARITY.html\" title=\"constant core::arch::x86::_SIDD_MASKED_NEGATIVE_POLARITY\">_SIDD_MASKED_NEGATIVE_POLARITY</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Negates results only before the end of the string</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_MASKED_POSITIVE_POLARITY.html\" title=\"constant core::arch::x86::_SIDD_MASKED_POSITIVE_POLARITY\">_SIDD_MASKED_POSITIVE_POLARITY</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Do not negate results before the end of the string</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_MOST_SIGNIFICANT.html\" title=\"constant core::arch::x86::_SIDD_MOST_SIGNIFICANT\">_SIDD_MOST_SIGNIFICANT</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\"><strong>Index only</strong>: return the most significant bit</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_NEGATIVE_POLARITY.html\" title=\"constant core::arch::x86::_SIDD_NEGATIVE_POLARITY\">_SIDD_NEGATIVE_POLARITY</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Negates results</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_POSITIVE_POLARITY.html\" title=\"constant core::arch::x86::_SIDD_POSITIVE_POLARITY\">_SIDD_POSITIVE_POLARITY</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Do not negate results <em>(Default)</em></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_SBYTE_OPS.html\" title=\"constant core::arch::x86::_SIDD_SBYTE_OPS\">_SIDD_SBYTE_OPS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">String contains signed 8-bit characters</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_SWORD_OPS.html\" title=\"constant core::arch::x86::_SIDD_SWORD_OPS\">_SIDD_SWORD_OPS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">String contains unsigned 16-bit characters</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_UBYTE_OPS.html\" title=\"constant core::arch::x86::_SIDD_UBYTE_OPS\">_SIDD_UBYTE_OPS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">String contains unsigned 8-bit characters <em>(Default)</em></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_UNIT_MASK.html\" title=\"constant core::arch::x86::_SIDD_UNIT_MASK\">_SIDD_UNIT_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\"><strong>Mask only</strong>: return the byte mask</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._SIDD_UWORD_OPS.html\" title=\"constant core::arch::x86::_SIDD_UWORD_OPS\">_SIDD_UWORD_OPS</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">String contains unsigned 16-bit characters</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XCR_XFEATURE_ENABLED_MASK.html\" title=\"constant core::arch::x86::_XCR_XFEATURE_ENABLED_MASK\">_XCR_XFEATURE_ENABLED_MASK</a><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\"><code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_EQ.html\" title=\"constant core::arch::x86::_MM_CMPINT_EQ\">_MM_CMPINT_EQ</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Equal</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_FALSE.html\" title=\"constant core::arch::x86::_MM_CMPINT_FALSE\">_MM_CMPINT_FALSE</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">False</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_LE.html\" title=\"constant core::arch::x86::_MM_CMPINT_LE\">_MM_CMPINT_LE</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Less-than-or-equal</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_LT.html\" title=\"constant core::arch::x86::_MM_CMPINT_LT\">_MM_CMPINT_LT</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Less-than</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_NE.html\" title=\"constant core::arch::x86::_MM_CMPINT_NE\">_MM_CMPINT_NE</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not-equal</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_NLE.html\" title=\"constant core::arch::x86::_MM_CMPINT_NLE\">_MM_CMPINT_NLE</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not less-than-or-equal</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_NLT.html\" title=\"constant core::arch::x86::_MM_CMPINT_NLT\">_MM_CMPINT_NLT</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Not less-than</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_CMPINT_TRUE.html\" title=\"constant core::arch::x86::_MM_CMPINT_TRUE\">_MM_CMPINT_TRUE</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">True</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_NORM_1_2.html\" title=\"constant core::arch::x86::_MM_MANT_NORM_1_2\">_MM_MANT_NORM_1_2</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">interval [1, 2)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_NORM_P5_1.html\" title=\"constant core::arch::x86::_MM_MANT_NORM_P5_1\">_MM_MANT_NORM_P5_1</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">interval [0.5, 1)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_NORM_P5_2.html\" title=\"constant core::arch::x86::_MM_MANT_NORM_P5_2\">_MM_MANT_NORM_P5_2</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">interval [0.5, 2)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_NORM_P75_1P5.html\" title=\"constant core::arch::x86::_MM_MANT_NORM_P75_1P5\">_MM_MANT_NORM_P75_1P5</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">interval [0.75, 1.5)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_SIGN_NAN.html\" title=\"constant core::arch::x86::_MM_MANT_SIGN_NAN\">_MM_MANT_SIGN_NAN</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">DEST = NaN if sign(SRC) = 1</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_SIGN_SRC.html\" title=\"constant core::arch::x86::_MM_MANT_SIGN_SRC\">_MM_MANT_SIGN_SRC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">sign = sign(SRC)</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_MANT_SIGN_ZERO.html\" title=\"constant core::arch::x86::_MM_MANT_SIGN_ZERO\">_MM_MANT_SIGN_ZERO</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">sign = 0</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AAAA.html\" title=\"constant core::arch::x86::_MM_PERM_AAAA\">_MM_PERM_AAAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AAAB.html\" title=\"constant core::arch::x86::_MM_PERM_AAAB\">_MM_PERM_AAAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AAAC.html\" title=\"constant core::arch::x86::_MM_PERM_AAAC\">_MM_PERM_AAAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AAAD.html\" title=\"constant core::arch::x86::_MM_PERM_AAAD\">_MM_PERM_AAAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AABA.html\" title=\"constant core::arch::x86::_MM_PERM_AABA\">_MM_PERM_AABA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AABB.html\" title=\"constant core::arch::x86::_MM_PERM_AABB\">_MM_PERM_AABB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AABC.html\" title=\"constant core::arch::x86::_MM_PERM_AABC\">_MM_PERM_AABC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AABD.html\" title=\"constant core::arch::x86::_MM_PERM_AABD\">_MM_PERM_AABD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AACA.html\" title=\"constant core::arch::x86::_MM_PERM_AACA\">_MM_PERM_AACA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AACB.html\" title=\"constant core::arch::x86::_MM_PERM_AACB\">_MM_PERM_AACB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AACC.html\" title=\"constant core::arch::x86::_MM_PERM_AACC\">_MM_PERM_AACC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AACD.html\" title=\"constant core::arch::x86::_MM_PERM_AACD\">_MM_PERM_AACD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AADA.html\" title=\"constant core::arch::x86::_MM_PERM_AADA\">_MM_PERM_AADA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AADB.html\" title=\"constant core::arch::x86::_MM_PERM_AADB\">_MM_PERM_AADB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AADC.html\" title=\"constant core::arch::x86::_MM_PERM_AADC\">_MM_PERM_AADC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_AADD.html\" title=\"constant core::arch::x86::_MM_PERM_AADD\">_MM_PERM_AADD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABAA.html\" title=\"constant core::arch::x86::_MM_PERM_ABAA\">_MM_PERM_ABAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABAB.html\" title=\"constant core::arch::x86::_MM_PERM_ABAB\">_MM_PERM_ABAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABAC.html\" title=\"constant core::arch::x86::_MM_PERM_ABAC\">_MM_PERM_ABAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABAD.html\" title=\"constant core::arch::x86::_MM_PERM_ABAD\">_MM_PERM_ABAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABBA.html\" title=\"constant core::arch::x86::_MM_PERM_ABBA\">_MM_PERM_ABBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABBB.html\" title=\"constant core::arch::x86::_MM_PERM_ABBB\">_MM_PERM_ABBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABBC.html\" title=\"constant core::arch::x86::_MM_PERM_ABBC\">_MM_PERM_ABBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABBD.html\" title=\"constant core::arch::x86::_MM_PERM_ABBD\">_MM_PERM_ABBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABCA.html\" title=\"constant core::arch::x86::_MM_PERM_ABCA\">_MM_PERM_ABCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABCB.html\" title=\"constant core::arch::x86::_MM_PERM_ABCB\">_MM_PERM_ABCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABCC.html\" title=\"constant core::arch::x86::_MM_PERM_ABCC\">_MM_PERM_ABCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABCD.html\" title=\"constant core::arch::x86::_MM_PERM_ABCD\">_MM_PERM_ABCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABDA.html\" title=\"constant core::arch::x86::_MM_PERM_ABDA\">_MM_PERM_ABDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABDB.html\" title=\"constant core::arch::x86::_MM_PERM_ABDB\">_MM_PERM_ABDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABDC.html\" title=\"constant core::arch::x86::_MM_PERM_ABDC\">_MM_PERM_ABDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ABDD.html\" title=\"constant core::arch::x86::_MM_PERM_ABDD\">_MM_PERM_ABDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACAA.html\" title=\"constant core::arch::x86::_MM_PERM_ACAA\">_MM_PERM_ACAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACAB.html\" title=\"constant core::arch::x86::_MM_PERM_ACAB\">_MM_PERM_ACAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACAC.html\" title=\"constant core::arch::x86::_MM_PERM_ACAC\">_MM_PERM_ACAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACAD.html\" title=\"constant core::arch::x86::_MM_PERM_ACAD\">_MM_PERM_ACAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACBA.html\" title=\"constant core::arch::x86::_MM_PERM_ACBA\">_MM_PERM_ACBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACBB.html\" title=\"constant core::arch::x86::_MM_PERM_ACBB\">_MM_PERM_ACBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACBC.html\" title=\"constant core::arch::x86::_MM_PERM_ACBC\">_MM_PERM_ACBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACBD.html\" title=\"constant core::arch::x86::_MM_PERM_ACBD\">_MM_PERM_ACBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACCA.html\" title=\"constant core::arch::x86::_MM_PERM_ACCA\">_MM_PERM_ACCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACCB.html\" title=\"constant core::arch::x86::_MM_PERM_ACCB\">_MM_PERM_ACCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACCC.html\" title=\"constant core::arch::x86::_MM_PERM_ACCC\">_MM_PERM_ACCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACCD.html\" title=\"constant core::arch::x86::_MM_PERM_ACCD\">_MM_PERM_ACCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACDA.html\" title=\"constant core::arch::x86::_MM_PERM_ACDA\">_MM_PERM_ACDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACDB.html\" title=\"constant core::arch::x86::_MM_PERM_ACDB\">_MM_PERM_ACDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACDC.html\" title=\"constant core::arch::x86::_MM_PERM_ACDC\">_MM_PERM_ACDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ACDD.html\" title=\"constant core::arch::x86::_MM_PERM_ACDD\">_MM_PERM_ACDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADAA.html\" title=\"constant core::arch::x86::_MM_PERM_ADAA\">_MM_PERM_ADAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADAB.html\" title=\"constant core::arch::x86::_MM_PERM_ADAB\">_MM_PERM_ADAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADAC.html\" title=\"constant core::arch::x86::_MM_PERM_ADAC\">_MM_PERM_ADAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADAD.html\" title=\"constant core::arch::x86::_MM_PERM_ADAD\">_MM_PERM_ADAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADBA.html\" title=\"constant core::arch::x86::_MM_PERM_ADBA\">_MM_PERM_ADBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADBB.html\" title=\"constant core::arch::x86::_MM_PERM_ADBB\">_MM_PERM_ADBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADBC.html\" title=\"constant core::arch::x86::_MM_PERM_ADBC\">_MM_PERM_ADBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADBD.html\" title=\"constant core::arch::x86::_MM_PERM_ADBD\">_MM_PERM_ADBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADCA.html\" title=\"constant core::arch::x86::_MM_PERM_ADCA\">_MM_PERM_ADCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADCB.html\" title=\"constant core::arch::x86::_MM_PERM_ADCB\">_MM_PERM_ADCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADCC.html\" title=\"constant core::arch::x86::_MM_PERM_ADCC\">_MM_PERM_ADCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADCD.html\" title=\"constant core::arch::x86::_MM_PERM_ADCD\">_MM_PERM_ADCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADDA.html\" title=\"constant core::arch::x86::_MM_PERM_ADDA\">_MM_PERM_ADDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADDB.html\" title=\"constant core::arch::x86::_MM_PERM_ADDB\">_MM_PERM_ADDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADDC.html\" title=\"constant core::arch::x86::_MM_PERM_ADDC\">_MM_PERM_ADDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_ADDD.html\" title=\"constant core::arch::x86::_MM_PERM_ADDD\">_MM_PERM_ADDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BAAA.html\" title=\"constant core::arch::x86::_MM_PERM_BAAA\">_MM_PERM_BAAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BAAB.html\" title=\"constant core::arch::x86::_MM_PERM_BAAB\">_MM_PERM_BAAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BAAC.html\" title=\"constant core::arch::x86::_MM_PERM_BAAC\">_MM_PERM_BAAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BAAD.html\" title=\"constant core::arch::x86::_MM_PERM_BAAD\">_MM_PERM_BAAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BABA.html\" title=\"constant core::arch::x86::_MM_PERM_BABA\">_MM_PERM_BABA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BABB.html\" title=\"constant core::arch::x86::_MM_PERM_BABB\">_MM_PERM_BABB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BABC.html\" title=\"constant core::arch::x86::_MM_PERM_BABC\">_MM_PERM_BABC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BABD.html\" title=\"constant core::arch::x86::_MM_PERM_BABD\">_MM_PERM_BABD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BACA.html\" title=\"constant core::arch::x86::_MM_PERM_BACA\">_MM_PERM_BACA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BACB.html\" title=\"constant core::arch::x86::_MM_PERM_BACB\">_MM_PERM_BACB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BACC.html\" title=\"constant core::arch::x86::_MM_PERM_BACC\">_MM_PERM_BACC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BACD.html\" title=\"constant core::arch::x86::_MM_PERM_BACD\">_MM_PERM_BACD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BADA.html\" title=\"constant core::arch::x86::_MM_PERM_BADA\">_MM_PERM_BADA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BADB.html\" title=\"constant core::arch::x86::_MM_PERM_BADB\">_MM_PERM_BADB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BADC.html\" title=\"constant core::arch::x86::_MM_PERM_BADC\">_MM_PERM_BADC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BADD.html\" title=\"constant core::arch::x86::_MM_PERM_BADD\">_MM_PERM_BADD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBAA.html\" title=\"constant core::arch::x86::_MM_PERM_BBAA\">_MM_PERM_BBAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBAB.html\" title=\"constant core::arch::x86::_MM_PERM_BBAB\">_MM_PERM_BBAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBAC.html\" title=\"constant core::arch::x86::_MM_PERM_BBAC\">_MM_PERM_BBAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBAD.html\" title=\"constant core::arch::x86::_MM_PERM_BBAD\">_MM_PERM_BBAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBBA.html\" title=\"constant core::arch::x86::_MM_PERM_BBBA\">_MM_PERM_BBBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBBB.html\" title=\"constant core::arch::x86::_MM_PERM_BBBB\">_MM_PERM_BBBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBBC.html\" title=\"constant core::arch::x86::_MM_PERM_BBBC\">_MM_PERM_BBBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBBD.html\" title=\"constant core::arch::x86::_MM_PERM_BBBD\">_MM_PERM_BBBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBCA.html\" title=\"constant core::arch::x86::_MM_PERM_BBCA\">_MM_PERM_BBCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBCB.html\" title=\"constant core::arch::x86::_MM_PERM_BBCB\">_MM_PERM_BBCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBCC.html\" title=\"constant core::arch::x86::_MM_PERM_BBCC\">_MM_PERM_BBCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBCD.html\" title=\"constant core::arch::x86::_MM_PERM_BBCD\">_MM_PERM_BBCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBDA.html\" title=\"constant core::arch::x86::_MM_PERM_BBDA\">_MM_PERM_BBDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBDB.html\" title=\"constant core::arch::x86::_MM_PERM_BBDB\">_MM_PERM_BBDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBDC.html\" title=\"constant core::arch::x86::_MM_PERM_BBDC\">_MM_PERM_BBDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BBDD.html\" title=\"constant core::arch::x86::_MM_PERM_BBDD\">_MM_PERM_BBDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCAA.html\" title=\"constant core::arch::x86::_MM_PERM_BCAA\">_MM_PERM_BCAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCAB.html\" title=\"constant core::arch::x86::_MM_PERM_BCAB\">_MM_PERM_BCAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCAC.html\" title=\"constant core::arch::x86::_MM_PERM_BCAC\">_MM_PERM_BCAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCAD.html\" title=\"constant core::arch::x86::_MM_PERM_BCAD\">_MM_PERM_BCAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCBA.html\" title=\"constant core::arch::x86::_MM_PERM_BCBA\">_MM_PERM_BCBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCBB.html\" title=\"constant core::arch::x86::_MM_PERM_BCBB\">_MM_PERM_BCBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCBC.html\" title=\"constant core::arch::x86::_MM_PERM_BCBC\">_MM_PERM_BCBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCBD.html\" title=\"constant core::arch::x86::_MM_PERM_BCBD\">_MM_PERM_BCBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCCA.html\" title=\"constant core::arch::x86::_MM_PERM_BCCA\">_MM_PERM_BCCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCCB.html\" title=\"constant core::arch::x86::_MM_PERM_BCCB\">_MM_PERM_BCCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCCC.html\" title=\"constant core::arch::x86::_MM_PERM_BCCC\">_MM_PERM_BCCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCCD.html\" title=\"constant core::arch::x86::_MM_PERM_BCCD\">_MM_PERM_BCCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCDA.html\" title=\"constant core::arch::x86::_MM_PERM_BCDA\">_MM_PERM_BCDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCDB.html\" title=\"constant core::arch::x86::_MM_PERM_BCDB\">_MM_PERM_BCDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCDC.html\" title=\"constant core::arch::x86::_MM_PERM_BCDC\">_MM_PERM_BCDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BCDD.html\" title=\"constant core::arch::x86::_MM_PERM_BCDD\">_MM_PERM_BCDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDAA.html\" title=\"constant core::arch::x86::_MM_PERM_BDAA\">_MM_PERM_BDAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDAB.html\" title=\"constant core::arch::x86::_MM_PERM_BDAB\">_MM_PERM_BDAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDAC.html\" title=\"constant core::arch::x86::_MM_PERM_BDAC\">_MM_PERM_BDAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDAD.html\" title=\"constant core::arch::x86::_MM_PERM_BDAD\">_MM_PERM_BDAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDBA.html\" title=\"constant core::arch::x86::_MM_PERM_BDBA\">_MM_PERM_BDBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDBB.html\" title=\"constant core::arch::x86::_MM_PERM_BDBB\">_MM_PERM_BDBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDBC.html\" title=\"constant core::arch::x86::_MM_PERM_BDBC\">_MM_PERM_BDBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDBD.html\" title=\"constant core::arch::x86::_MM_PERM_BDBD\">_MM_PERM_BDBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDCA.html\" title=\"constant core::arch::x86::_MM_PERM_BDCA\">_MM_PERM_BDCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDCB.html\" title=\"constant core::arch::x86::_MM_PERM_BDCB\">_MM_PERM_BDCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDCC.html\" title=\"constant core::arch::x86::_MM_PERM_BDCC\">_MM_PERM_BDCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDCD.html\" title=\"constant core::arch::x86::_MM_PERM_BDCD\">_MM_PERM_BDCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDDA.html\" title=\"constant core::arch::x86::_MM_PERM_BDDA\">_MM_PERM_BDDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDDB.html\" title=\"constant core::arch::x86::_MM_PERM_BDDB\">_MM_PERM_BDDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDDC.html\" title=\"constant core::arch::x86::_MM_PERM_BDDC\">_MM_PERM_BDDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_BDDD.html\" title=\"constant core::arch::x86::_MM_PERM_BDDD\">_MM_PERM_BDDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CAAA.html\" title=\"constant core::arch::x86::_MM_PERM_CAAA\">_MM_PERM_CAAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CAAB.html\" title=\"constant core::arch::x86::_MM_PERM_CAAB\">_MM_PERM_CAAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CAAC.html\" title=\"constant core::arch::x86::_MM_PERM_CAAC\">_MM_PERM_CAAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CAAD.html\" title=\"constant core::arch::x86::_MM_PERM_CAAD\">_MM_PERM_CAAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CABA.html\" title=\"constant core::arch::x86::_MM_PERM_CABA\">_MM_PERM_CABA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CABB.html\" title=\"constant core::arch::x86::_MM_PERM_CABB\">_MM_PERM_CABB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CABC.html\" title=\"constant core::arch::x86::_MM_PERM_CABC\">_MM_PERM_CABC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CABD.html\" title=\"constant core::arch::x86::_MM_PERM_CABD\">_MM_PERM_CABD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CACA.html\" title=\"constant core::arch::x86::_MM_PERM_CACA\">_MM_PERM_CACA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CACB.html\" title=\"constant core::arch::x86::_MM_PERM_CACB\">_MM_PERM_CACB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CACC.html\" title=\"constant core::arch::x86::_MM_PERM_CACC\">_MM_PERM_CACC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CACD.html\" title=\"constant core::arch::x86::_MM_PERM_CACD\">_MM_PERM_CACD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CADA.html\" title=\"constant core::arch::x86::_MM_PERM_CADA\">_MM_PERM_CADA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CADB.html\" title=\"constant core::arch::x86::_MM_PERM_CADB\">_MM_PERM_CADB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CADC.html\" title=\"constant core::arch::x86::_MM_PERM_CADC\">_MM_PERM_CADC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CADD.html\" title=\"constant core::arch::x86::_MM_PERM_CADD\">_MM_PERM_CADD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBAA.html\" title=\"constant core::arch::x86::_MM_PERM_CBAA\">_MM_PERM_CBAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBAB.html\" title=\"constant core::arch::x86::_MM_PERM_CBAB\">_MM_PERM_CBAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBAC.html\" title=\"constant core::arch::x86::_MM_PERM_CBAC\">_MM_PERM_CBAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBAD.html\" title=\"constant core::arch::x86::_MM_PERM_CBAD\">_MM_PERM_CBAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBBA.html\" title=\"constant core::arch::x86::_MM_PERM_CBBA\">_MM_PERM_CBBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBBB.html\" title=\"constant core::arch::x86::_MM_PERM_CBBB\">_MM_PERM_CBBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBBC.html\" title=\"constant core::arch::x86::_MM_PERM_CBBC\">_MM_PERM_CBBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBBD.html\" title=\"constant core::arch::x86::_MM_PERM_CBBD\">_MM_PERM_CBBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBCA.html\" title=\"constant core::arch::x86::_MM_PERM_CBCA\">_MM_PERM_CBCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBCB.html\" title=\"constant core::arch::x86::_MM_PERM_CBCB\">_MM_PERM_CBCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBCC.html\" title=\"constant core::arch::x86::_MM_PERM_CBCC\">_MM_PERM_CBCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBCD.html\" title=\"constant core::arch::x86::_MM_PERM_CBCD\">_MM_PERM_CBCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBDA.html\" title=\"constant core::arch::x86::_MM_PERM_CBDA\">_MM_PERM_CBDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBDB.html\" title=\"constant core::arch::x86::_MM_PERM_CBDB\">_MM_PERM_CBDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBDC.html\" title=\"constant core::arch::x86::_MM_PERM_CBDC\">_MM_PERM_CBDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CBDD.html\" title=\"constant core::arch::x86::_MM_PERM_CBDD\">_MM_PERM_CBDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCAA.html\" title=\"constant core::arch::x86::_MM_PERM_CCAA\">_MM_PERM_CCAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCAB.html\" title=\"constant core::arch::x86::_MM_PERM_CCAB\">_MM_PERM_CCAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCAC.html\" title=\"constant core::arch::x86::_MM_PERM_CCAC\">_MM_PERM_CCAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCAD.html\" title=\"constant core::arch::x86::_MM_PERM_CCAD\">_MM_PERM_CCAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCBA.html\" title=\"constant core::arch::x86::_MM_PERM_CCBA\">_MM_PERM_CCBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCBB.html\" title=\"constant core::arch::x86::_MM_PERM_CCBB\">_MM_PERM_CCBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCBC.html\" title=\"constant core::arch::x86::_MM_PERM_CCBC\">_MM_PERM_CCBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCBD.html\" title=\"constant core::arch::x86::_MM_PERM_CCBD\">_MM_PERM_CCBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCCA.html\" title=\"constant core::arch::x86::_MM_PERM_CCCA\">_MM_PERM_CCCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCCB.html\" title=\"constant core::arch::x86::_MM_PERM_CCCB\">_MM_PERM_CCCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCCC.html\" title=\"constant core::arch::x86::_MM_PERM_CCCC\">_MM_PERM_CCCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCCD.html\" title=\"constant core::arch::x86::_MM_PERM_CCCD\">_MM_PERM_CCCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCDA.html\" title=\"constant core::arch::x86::_MM_PERM_CCDA\">_MM_PERM_CCDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCDB.html\" title=\"constant core::arch::x86::_MM_PERM_CCDB\">_MM_PERM_CCDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCDC.html\" title=\"constant core::arch::x86::_MM_PERM_CCDC\">_MM_PERM_CCDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CCDD.html\" title=\"constant core::arch::x86::_MM_PERM_CCDD\">_MM_PERM_CCDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDAA.html\" title=\"constant core::arch::x86::_MM_PERM_CDAA\">_MM_PERM_CDAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDAB.html\" title=\"constant core::arch::x86::_MM_PERM_CDAB\">_MM_PERM_CDAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDAC.html\" title=\"constant core::arch::x86::_MM_PERM_CDAC\">_MM_PERM_CDAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDAD.html\" title=\"constant core::arch::x86::_MM_PERM_CDAD\">_MM_PERM_CDAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDBA.html\" title=\"constant core::arch::x86::_MM_PERM_CDBA\">_MM_PERM_CDBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDBB.html\" title=\"constant core::arch::x86::_MM_PERM_CDBB\">_MM_PERM_CDBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDBC.html\" title=\"constant core::arch::x86::_MM_PERM_CDBC\">_MM_PERM_CDBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDBD.html\" title=\"constant core::arch::x86::_MM_PERM_CDBD\">_MM_PERM_CDBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDCA.html\" title=\"constant core::arch::x86::_MM_PERM_CDCA\">_MM_PERM_CDCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDCB.html\" title=\"constant core::arch::x86::_MM_PERM_CDCB\">_MM_PERM_CDCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDCC.html\" title=\"constant core::arch::x86::_MM_PERM_CDCC\">_MM_PERM_CDCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDCD.html\" title=\"constant core::arch::x86::_MM_PERM_CDCD\">_MM_PERM_CDCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDDA.html\" title=\"constant core::arch::x86::_MM_PERM_CDDA\">_MM_PERM_CDDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDDB.html\" title=\"constant core::arch::x86::_MM_PERM_CDDB\">_MM_PERM_CDDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDDC.html\" title=\"constant core::arch::x86::_MM_PERM_CDDC\">_MM_PERM_CDDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_CDDD.html\" title=\"constant core::arch::x86::_MM_PERM_CDDD\">_MM_PERM_CDDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DAAA.html\" title=\"constant core::arch::x86::_MM_PERM_DAAA\">_MM_PERM_DAAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DAAB.html\" title=\"constant core::arch::x86::_MM_PERM_DAAB\">_MM_PERM_DAAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DAAC.html\" title=\"constant core::arch::x86::_MM_PERM_DAAC\">_MM_PERM_DAAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DAAD.html\" title=\"constant core::arch::x86::_MM_PERM_DAAD\">_MM_PERM_DAAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DABA.html\" title=\"constant core::arch::x86::_MM_PERM_DABA\">_MM_PERM_DABA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DABB.html\" title=\"constant core::arch::x86::_MM_PERM_DABB\">_MM_PERM_DABB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DABC.html\" title=\"constant core::arch::x86::_MM_PERM_DABC\">_MM_PERM_DABC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DABD.html\" title=\"constant core::arch::x86::_MM_PERM_DABD\">_MM_PERM_DABD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DACA.html\" title=\"constant core::arch::x86::_MM_PERM_DACA\">_MM_PERM_DACA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DACB.html\" title=\"constant core::arch::x86::_MM_PERM_DACB\">_MM_PERM_DACB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DACC.html\" title=\"constant core::arch::x86::_MM_PERM_DACC\">_MM_PERM_DACC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DACD.html\" title=\"constant core::arch::x86::_MM_PERM_DACD\">_MM_PERM_DACD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DADA.html\" title=\"constant core::arch::x86::_MM_PERM_DADA\">_MM_PERM_DADA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DADB.html\" title=\"constant core::arch::x86::_MM_PERM_DADB\">_MM_PERM_DADB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DADC.html\" title=\"constant core::arch::x86::_MM_PERM_DADC\">_MM_PERM_DADC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DADD.html\" title=\"constant core::arch::x86::_MM_PERM_DADD\">_MM_PERM_DADD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBAA.html\" title=\"constant core::arch::x86::_MM_PERM_DBAA\">_MM_PERM_DBAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBAB.html\" title=\"constant core::arch::x86::_MM_PERM_DBAB\">_MM_PERM_DBAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBAC.html\" title=\"constant core::arch::x86::_MM_PERM_DBAC\">_MM_PERM_DBAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBAD.html\" title=\"constant core::arch::x86::_MM_PERM_DBAD\">_MM_PERM_DBAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBBA.html\" title=\"constant core::arch::x86::_MM_PERM_DBBA\">_MM_PERM_DBBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBBB.html\" title=\"constant core::arch::x86::_MM_PERM_DBBB\">_MM_PERM_DBBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBBC.html\" title=\"constant core::arch::x86::_MM_PERM_DBBC\">_MM_PERM_DBBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBBD.html\" title=\"constant core::arch::x86::_MM_PERM_DBBD\">_MM_PERM_DBBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBCA.html\" title=\"constant core::arch::x86::_MM_PERM_DBCA\">_MM_PERM_DBCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBCB.html\" title=\"constant core::arch::x86::_MM_PERM_DBCB\">_MM_PERM_DBCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBCC.html\" title=\"constant core::arch::x86::_MM_PERM_DBCC\">_MM_PERM_DBCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBCD.html\" title=\"constant core::arch::x86::_MM_PERM_DBCD\">_MM_PERM_DBCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBDA.html\" title=\"constant core::arch::x86::_MM_PERM_DBDA\">_MM_PERM_DBDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBDB.html\" title=\"constant core::arch::x86::_MM_PERM_DBDB\">_MM_PERM_DBDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBDC.html\" title=\"constant core::arch::x86::_MM_PERM_DBDC\">_MM_PERM_DBDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DBDD.html\" title=\"constant core::arch::x86::_MM_PERM_DBDD\">_MM_PERM_DBDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCAA.html\" title=\"constant core::arch::x86::_MM_PERM_DCAA\">_MM_PERM_DCAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCAB.html\" title=\"constant core::arch::x86::_MM_PERM_DCAB\">_MM_PERM_DCAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCAC.html\" title=\"constant core::arch::x86::_MM_PERM_DCAC\">_MM_PERM_DCAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCAD.html\" title=\"constant core::arch::x86::_MM_PERM_DCAD\">_MM_PERM_DCAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCBA.html\" title=\"constant core::arch::x86::_MM_PERM_DCBA\">_MM_PERM_DCBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCBB.html\" title=\"constant core::arch::x86::_MM_PERM_DCBB\">_MM_PERM_DCBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCBC.html\" title=\"constant core::arch::x86::_MM_PERM_DCBC\">_MM_PERM_DCBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCBD.html\" title=\"constant core::arch::x86::_MM_PERM_DCBD\">_MM_PERM_DCBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCCA.html\" title=\"constant core::arch::x86::_MM_PERM_DCCA\">_MM_PERM_DCCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCCB.html\" title=\"constant core::arch::x86::_MM_PERM_DCCB\">_MM_PERM_DCCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCCC.html\" title=\"constant core::arch::x86::_MM_PERM_DCCC\">_MM_PERM_DCCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCCD.html\" title=\"constant core::arch::x86::_MM_PERM_DCCD\">_MM_PERM_DCCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCDA.html\" title=\"constant core::arch::x86::_MM_PERM_DCDA\">_MM_PERM_DCDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCDB.html\" title=\"constant core::arch::x86::_MM_PERM_DCDB\">_MM_PERM_DCDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCDC.html\" title=\"constant core::arch::x86::_MM_PERM_DCDC\">_MM_PERM_DCDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DCDD.html\" title=\"constant core::arch::x86::_MM_PERM_DCDD\">_MM_PERM_DCDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDAA.html\" title=\"constant core::arch::x86::_MM_PERM_DDAA\">_MM_PERM_DDAA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDAB.html\" title=\"constant core::arch::x86::_MM_PERM_DDAB\">_MM_PERM_DDAB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDAC.html\" title=\"constant core::arch::x86::_MM_PERM_DDAC\">_MM_PERM_DDAC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDAD.html\" title=\"constant core::arch::x86::_MM_PERM_DDAD\">_MM_PERM_DDAD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDBA.html\" title=\"constant core::arch::x86::_MM_PERM_DDBA\">_MM_PERM_DDBA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDBB.html\" title=\"constant core::arch::x86::_MM_PERM_DDBB\">_MM_PERM_DDBB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDBC.html\" title=\"constant core::arch::x86::_MM_PERM_DDBC\">_MM_PERM_DDBC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDBD.html\" title=\"constant core::arch::x86::_MM_PERM_DDBD\">_MM_PERM_DDBD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDCA.html\" title=\"constant core::arch::x86::_MM_PERM_DDCA\">_MM_PERM_DDCA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDCB.html\" title=\"constant core::arch::x86::_MM_PERM_DDCB\">_MM_PERM_DDCB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDCC.html\" title=\"constant core::arch::x86::_MM_PERM_DDCC\">_MM_PERM_DDCC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDCD.html\" title=\"constant core::arch::x86::_MM_PERM_DDCD\">_MM_PERM_DDCD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDDA.html\" title=\"constant core::arch::x86::_MM_PERM_DDDA\">_MM_PERM_DDDA</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDDB.html\" title=\"constant core::arch::x86::_MM_PERM_DDDB\">_MM_PERM_DDDB</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDDC.html\" title=\"constant core::arch::x86::_MM_PERM_DDDC\">_MM_PERM_DDDC</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._MM_PERM_DDDD.html\" title=\"constant core::arch::x86::_MM_PERM_DDDD\">_MM_PERM_DDDD</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XABORT_CAPACITY.html\" title=\"constant core::arch::x86::_XABORT_CAPACITY\">_XABORT_CAPACITY</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction abort due to the transaction using too much memory.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XABORT_CONFLICT.html\" title=\"constant core::arch::x86::_XABORT_CONFLICT\">_XABORT_CONFLICT</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction abort due to a memory conflict with another thread.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XABORT_DEBUG.html\" title=\"constant core::arch::x86::_XABORT_DEBUG\">_XABORT_DEBUG</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction abort due to a debug trap.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XABORT_EXPLICIT.html\" title=\"constant core::arch::x86::_XABORT_EXPLICIT\">_XABORT_EXPLICIT</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction explicitly aborted with xabort. The parameter passed to xabort is available with\n<code>_xabort_code(status)</code>.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XABORT_NESTED.html\" title=\"constant core::arch::x86::_XABORT_NESTED\">_XABORT_NESTED</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction abort in a inner nested transaction.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XABORT_RETRY.html\" title=\"constant core::arch::x86::_XABORT_RETRY\">_XABORT_RETRY</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction retry is possible.</div></li><li><div class=\"item-name\"><a class=\"constant\" href=\"constant._XBEGIN_STARTED.html\" title=\"constant core::arch::x86::_XBEGIN_STARTED\">_XBEGIN_STARTED</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Transaction successfully started.</div></li></ul><h2 id=\"functions\" class=\"section-header\">Functions<a href=\"#functions\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_GET_EXCEPTION_MASK.html\" title=\"fn core::arch::x86::_MM_GET_EXCEPTION_MASK\">_MM_GET_EXCEPTION_MASK</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_GET_EXCEPTION_STATE.html\" title=\"fn core::arch::x86::_MM_GET_EXCEPTION_STATE\">_MM_GET_EXCEPTION_STATE</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_GET_FLUSH_ZERO_MODE.html\" title=\"fn core::arch::x86::_MM_GET_FLUSH_ZERO_MODE\">_MM_GET_FLUSH_ZERO_MODE</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_GET_ROUNDING_MODE.html\" title=\"fn core::arch::x86::_MM_GET_ROUNDING_MODE\">_MM_GET_ROUNDING_MODE</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_SET_EXCEPTION_MASK.html\" title=\"fn core::arch::x86::_MM_SET_EXCEPTION_MASK\">_MM_SET_EXCEPTION_MASK</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_SET_EXCEPTION_STATE.html\" title=\"fn core::arch::x86::_MM_SET_EXCEPTION_STATE\">_MM_SET_EXCEPTION_STATE</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_SET_FLUSH_ZERO_MODE.html\" title=\"fn core::arch::x86::_MM_SET_FLUSH_ZERO_MODE\">_MM_SET_FLUSH_ZERO_MODE</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_SET_ROUNDING_MODE.html\" title=\"fn core::arch::x86::_MM_SET_ROUNDING_MODE\">_MM_SET_ROUNDING_MODE</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">See <a href=\"fn._mm_setcsr.html\"><code>_mm_setcsr</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_TRANSPOSE4_PS.html\" title=\"fn core::arch::x86::_MM_TRANSPOSE4_PS\">_MM_TRANSPOSE4_PS</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Transpose the 4x4 matrix formed by 4 rows of __m128 in place.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.__cpuid.html\" title=\"fn core::arch::x86::__cpuid\">__cpuid</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">See <a href=\"fn.__cpuid_count.html\"><code>__cpuid_count</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.__cpuid_count.html\" title=\"fn core::arch::x86::__cpuid_count\">__cpuid_count</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns the result of the <code>cpuid</code> instruction for a given <code>leaf</code> (<code>EAX</code>)\nand\n<code>sub_leaf</code> (<code>ECX</code>).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.__get_cpuid_max.html\" title=\"fn core::arch::x86::__get_cpuid_max\">__get_cpuid_max</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>) <code>cpuid</code>\nvalues.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.__rdtscp.html\" title=\"fn core::arch::x86::__rdtscp\">__rdtscp</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Reads the current value of the processor’s time-stamp counter and\nthe <code>IA32_TSC_AUX MSR</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._addcarry_u32.html\" title=\"fn core::arch::x86::_addcarry_u32\">_addcarry_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Adds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>\n(carry flag), and store the unsigned 32-bit result in <code>out</code>, and the carry-out\nis returned (carry or overflow flag).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._addcarryx_u32.html\" title=\"fn core::arch::x86::_addcarryx_u32\">_addcarryx_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `adx` only\">(x86 or x86-64) and <code>adx</code></span></div><div class=\"desc docblock-short\">Adds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>\n(carry or overflow flag), and store the unsigned 32-bit result in <code>out</code>, and\nthe carry-out is returned (carry or overflow flag).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._andn_u32.html\" title=\"fn core::arch::x86::_andn_u32\">_andn_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Bitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bextr2_u32.html\" title=\"fn core::arch::x86::_bextr2_u32\">_bextr2_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Extracts bits of <code>a</code> specified by <code>control</code> into\nthe least significant bits of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bextr_u32.html\" title=\"fn core::arch::x86::_bextr_u32\">_bextr_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Extracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into\nthe least significant bits of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bittest.html\" title=\"fn core::arch::x86::_bittest\">_bittest</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bittestandcomplement.html\" title=\"fn core::arch::x86::_bittestandcomplement\">_bittestandcomplement</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then inverts that bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bittestandreset.html\" title=\"fn core::arch::x86::_bittestandreset\">_bittestandreset</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then resets that bit to <code>0</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bittestandset.html\" title=\"fn core::arch::x86::_bittestandset\">_bittestandset</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then sets the bit to <code>1</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcfill_u32.html\" title=\"fn core::arch::x86::_blcfill_u32\">_blcfill_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Clears all bits below the least significant zero bit of <code>x</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcfill_u64.html\" title=\"fn core::arch::x86::_blcfill_u64\">_blcfill_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Clears all bits below the least significant zero bit of <code>x</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blci_u32.html\" title=\"fn core::arch::x86::_blci_u32\">_blci_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets all bits of <code>x</code> to 1 except for the least significant zero bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blci_u64.html\" title=\"fn core::arch::x86::_blci_u64\">_blci_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets all bits of <code>x</code> to 1 except for the least significant zero bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcic_u32.html\" title=\"fn core::arch::x86::_blcic_u32\">_blcic_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets the least significant zero bit of <code>x</code> and clears all other bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcic_u64.html\" title=\"fn core::arch::x86::_blcic_u64\">_blcic_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets the least significant zero bit of <code>x</code> and clears all other bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcmsk_u32.html\" title=\"fn core::arch::x86::_blcmsk_u32\">_blcmsk_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets the least significant zero bit of <code>x</code> and clears all bits above\nthat bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcmsk_u64.html\" title=\"fn core::arch::x86::_blcmsk_u64\">_blcmsk_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets the least significant zero bit of <code>x</code> and clears all bits above\nthat bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcs_u32.html\" title=\"fn core::arch::x86::_blcs_u32\">_blcs_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets the least significant zero bit of <code>x</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blcs_u64.html\" title=\"fn core::arch::x86::_blcs_u64\">_blcs_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets the least significant zero bit of <code>x</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsfill_u32.html\" title=\"fn core::arch::x86::_blsfill_u32\">_blsfill_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets all bits of <code>x</code> below the least significant one.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsfill_u64.html\" title=\"fn core::arch::x86::_blsfill_u64\">_blsfill_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets all bits of <code>x</code> below the least significant one.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsi_u32.html\" title=\"fn core::arch::x86::_blsi_u32\">_blsi_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Extracts lowest set isolated bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsic_u32.html\" title=\"fn core::arch::x86::_blsic_u32\">_blsic_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Clears least significant bit and sets all other bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsic_u64.html\" title=\"fn core::arch::x86::_blsic_u64\">_blsic_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Clears least significant bit and sets all other bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsmsk_u32.html\" title=\"fn core::arch::x86::_blsmsk_u32\">_blsmsk_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Gets mask up to lowest set bit.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._blsr_u32.html\" title=\"fn core::arch::x86::_blsr_u32\">_blsr_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Resets the lowest set bit of <code>x</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bswap.html\" title=\"fn core::arch::x86::_bswap\">_bswap</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Returns an integer with the reversed byte order of x</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._bzhi_u32.html\" title=\"fn core::arch::x86::_bzhi_u32\">_bzhi_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi2` only\">(x86 or x86-64) and <code>bmi2</code></span></div><div class=\"desc docblock-short\">Zeroes higher bits of <code>a</code> &gt;= <code>index</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._fxrstor.html\" title=\"fn core::arch::x86::_fxrstor\">_fxrstor</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fxsr` only\">(x86 or x86-64) and <code>fxsr</code></span></div><div class=\"desc docblock-short\">Restores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from the\n512-byte-long 16-byte-aligned memory region <code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._fxsave.html\" title=\"fn core::arch::x86::_fxsave\">_fxsave</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fxsr` only\">(x86 or x86-64) and <code>fxsr</code></span></div><div class=\"desc docblock-short\">Saves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> registers to the\n512-byte-long 16-byte-aligned memory region <code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._lzcnt_u32.html\" title=\"fn core::arch::x86::_lzcnt_u32\">_lzcnt_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `lzcnt` only\">(x86 or x86-64) and <code>lzcnt</code></span></div><div class=\"desc docblock-short\">Counts the leading most significant zero bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_abs_epi8.html\" title=\"fn core::arch::x86::_mm256_abs_epi8\">_mm256_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the absolute values of packed 8-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_abs_epi16.html\" title=\"fn core::arch::x86::_mm256_abs_epi16\">_mm256_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the absolute values of packed 16-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_abs_epi32.html\" title=\"fn core::arch::x86::_mm256_abs_epi32\">_mm256_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the absolute values of packed 32-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_add_epi8.html\" title=\"fn core::arch::x86::_mm256_add_epi8\">_mm256_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed 8-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_add_epi16.html\" title=\"fn core::arch::x86::_mm256_add_epi16\">_mm256_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_add_epi32.html\" title=\"fn core::arch::x86::_mm256_add_epi32\">_mm256_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed 32-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_add_epi64.html\" title=\"fn core::arch::x86::_mm256_add_epi64\">_mm256_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed 64-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_add_pd.html\" title=\"fn core::arch::x86::_mm256_add_pd\">_mm256_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Adds packed double-precision (64-bit) floating-point elements\nin <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_add_ps.html\" title=\"fn core::arch::x86::_mm256_add_ps\">_mm256_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Adds packed single-precision (32-bit) floating-point elements in <code>a</code> and\n<code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_adds_epi8.html\" title=\"fn core::arch::x86::_mm256_adds_epi8\">_mm256_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_adds_epi16.html\" title=\"fn core::arch::x86::_mm256_adds_epi16\">_mm256_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_adds_epu8.html\" title=\"fn core::arch::x86::_mm256_adds_epu8\">_mm256_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_adds_epu16.html\" title=\"fn core::arch::x86::_mm256_adds_epu16\">_mm256_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Adds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_addsub_pd.html\" title=\"fn core::arch::x86::_mm256_addsub_pd\">_mm256_addsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Alternatively adds and subtracts packed double-precision (64-bit)\nfloating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_addsub_ps.html\" title=\"fn core::arch::x86::_mm256_addsub_ps\">_mm256_addsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Alternatively adds and subtracts packed single-precision (32-bit)\nfloating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_alignr_epi8.html\" title=\"fn core::arch::x86::_mm256_alignr_epi8\">_mm256_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Concatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte temporary\nresult, shifts the result right by <code>n</code> bytes, and returns the low 16 bytes.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_and_pd.html\" title=\"fn core::arch::x86::_mm256_and_pd\">_mm256_and_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of a packed double-precision (64-bit)\nfloating-point elements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_and_ps.html\" title=\"fn core::arch::x86::_mm256_and_ps\">_mm256_and_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of packed single-precision (32-bit) floating-point\nelements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_and_si256.html\" title=\"fn core::arch::x86::_mm256_and_si256\">_mm256_and_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing integer data)\nin <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_andnot_pd.html\" title=\"fn core::arch::x86::_mm256_andnot_pd\">_mm256_andnot_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise NOT of packed double-precision (64-bit) floating-point\nelements in <code>a</code>, and then AND with <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_andnot_ps.html\" title=\"fn core::arch::x86::_mm256_andnot_ps\">_mm256_andnot_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise NOT of packed single-precision (32-bit) floating-point\nelements in <code>a</code>\nand then AND with <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_andnot_si256.html\" title=\"fn core::arch::x86::_mm256_andnot_si256\">_mm256_andnot_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise NOT of 256 bits (representing integer data)\nin <code>a</code> and then AND with <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_avg_epu8.html\" title=\"fn core::arch::x86::_mm256_avg_epu8\">_mm256_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Averages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_avg_epu16.html\" title=\"fn core::arch::x86::_mm256_avg_epu16\">_mm256_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Averages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blend_epi16.html\" title=\"fn core::arch::x86::_mm256_blend_epi16\">_mm256_blend_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Blends packed 16-bit integers from <code>a</code> and <code>b</code> using control mask <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blend_epi32.html\" title=\"fn core::arch::x86::_mm256_blend_epi32\">_mm256_blend_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Blends packed 32-bit integers from <code>a</code> and <code>b</code> using control mask <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blend_pd.html\" title=\"fn core::arch::x86::_mm256_blend_pd\">_mm256_blend_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Blends packed double-precision (64-bit) floating-point elements from\n<code>a</code> and <code>b</code> using control mask <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blend_ps.html\" title=\"fn core::arch::x86::_mm256_blend_ps\">_mm256_blend_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Blends packed single-precision (32-bit) floating-point elements from\n<code>a</code> and <code>b</code> using control mask <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blendv_epi8.html\" title=\"fn core::arch::x86::_mm256_blendv_epi8\">_mm256_blendv_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Blends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blendv_pd.html\" title=\"fn core::arch::x86::_mm256_blendv_pd\">_mm256_blendv_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Blends packed double-precision (64-bit) floating-point elements from\n<code>a</code> and <code>b</code> using <code>c</code> as a mask.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_blendv_ps.html\" title=\"fn core::arch::x86::_mm256_blendv_ps\">_mm256_blendv_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Blends packed single-precision (32-bit) floating-point elements from\n<code>a</code> and <code>b</code> using <code>c</code> as a mask.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcast_pd.html\" title=\"fn core::arch::x86::_mm256_broadcast_pd\">_mm256_broadcast_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts 128 bits from memory (composed of 2 packed double-precision\n(64-bit) floating-point elements) to all elements of the returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcast_ps.html\" title=\"fn core::arch::x86::_mm256_broadcast_ps\">_mm256_broadcast_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts 128 bits from memory (composed of 4 packed single-precision\n(32-bit) floating-point elements) to all elements of the returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcast_sd.html\" title=\"fn core::arch::x86::_mm256_broadcast_sd\">_mm256_broadcast_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts a double-precision (64-bit) floating-point element from memory\nto all elements of the returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcast_ss.html\" title=\"fn core::arch::x86::_mm256_broadcast_ss\">_mm256_broadcast_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts a single-precision (32-bit) floating-point element from memory\nto all elements of the returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm256_broadcastb_epi8\">_mm256_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 8-bit integer from <code>a</code> to all elements of\nthe 256-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm256_broadcastd_epi32\">_mm256_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 32-bit integer from <code>a</code> to all elements of\nthe 256-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm256_broadcastq_epi64\">_mm256_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 64-bit integer from <code>a</code> to all elements of\nthe 256-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm256_broadcastsd_pd\">_mm256_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low double-precision (64-bit) floating-point element\nfrom <code>a</code> to all elements of the 256-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastsi128_si256.html\" title=\"fn core::arch::x86::_mm256_broadcastsi128_si256\">_mm256_broadcastsi128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts 128 bits of integer data from a to all 128-bit lanes in\nthe 256-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm256_broadcastss_ps\">_mm256_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low single-precision (32-bit) floating-point element\nfrom <code>a</code> to all elements of the 256-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm256_broadcastw_epi16\">_mm256_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 16-bit integer from a to all elements of\nthe 256-bit returned value</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_bslli_epi128.html\" title=\"fn core::arch::x86::_mm256_bslli_epi128\">_mm256_bslli_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_bsrli_epi128.html\" title=\"fn core::arch::x86::_mm256_bsrli_epi128\">_mm256_bsrli_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castpd128_pd256.html\" title=\"fn core::arch::x86::_mm256_castpd128_pd256\">_mm256_castpd128_pd256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m128d to type __m256d;\nthe upper 128 bits of the result are undefined.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castpd256_pd128.html\" title=\"fn core::arch::x86::_mm256_castpd256_pd128\">_mm256_castpd256_pd128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256d to type __m128d.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castpd_ps.html\" title=\"fn core::arch::x86::_mm256_castpd_ps\">_mm256_castpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256d to type __m256.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castpd_si256.html\" title=\"fn core::arch::x86::_mm256_castpd_si256\">_mm256_castpd_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256d to type __m256i.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castps128_ps256.html\" title=\"fn core::arch::x86::_mm256_castps128_ps256\">_mm256_castps128_ps256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m128 to type __m256;\nthe upper 128 bits of the result are undefined.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castps256_ps128.html\" title=\"fn core::arch::x86::_mm256_castps256_ps128\">_mm256_castps256_ps128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256 to type __m128.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castps_pd.html\" title=\"fn core::arch::x86::_mm256_castps_pd\">_mm256_castps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256 to type __m256d.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castps_si256.html\" title=\"fn core::arch::x86::_mm256_castps_si256\">_mm256_castps_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256 to type __m256i.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castsi128_si256.html\" title=\"fn core::arch::x86::_mm256_castsi128_si256\">_mm256_castsi128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m128i to type __m256i;\nthe upper 128 bits of the result are undefined.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castsi256_pd.html\" title=\"fn core::arch::x86::_mm256_castsi256_pd\">_mm256_castsi256_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256i to type __m256d.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castsi256_ps.html\" title=\"fn core::arch::x86::_mm256_castsi256_ps\">_mm256_castsi256_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256i to type __m256.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_castsi256_si128.html\" title=\"fn core::arch::x86::_mm256_castsi256_si128\">_mm256_castsi256_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Casts vector of type __m256i to type __m128i.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_ceil_pd.html\" title=\"fn core::arch::x86::_mm256_ceil_pd\">_mm256_ceil_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Rounds packed double-precision (64-bit) floating point elements in <code>a</code>\ntoward positive infinity.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_ceil_ps.html\" title=\"fn core::arch::x86::_mm256_ceil_ps\">_mm256_ceil_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Rounds packed single-precision (32-bit) floating point elements in <code>a</code>\ntoward positive infinity.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_pd.html\" title=\"fn core::arch::x86::_mm256_cmp_pd\">_mm256_cmp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Compares packed double-precision (64-bit) floating-point\nelements in <code>a</code> and <code>b</code> based on the comparison operand\nspecified by <code>IMM5</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_ps.html\" title=\"fn core::arch::x86::_mm256_cmp_ps\">_mm256_cmp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Compares packed single-precision (32-bit) floating-point\nelements in <code>a</code> and <code>b</code> based on the comparison operand\nspecified by <code>IMM5</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi8.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi8\">_mm256_cmpeq_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi16.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi16\">_mm256_cmpeq_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi32.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi32\">_mm256_cmpeq_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi64.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi64\">_mm256_cmpeq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi8.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi8\">_mm256_cmpgt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi16.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi16\">_mm256_cmpgt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi32.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi32\">_mm256_cmpgt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi64.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi64\">_mm256_cmpgt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 64-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtepi8_epi16\">_mm256_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Sign-extend 8-bit integers to 16-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtepi8_epi32\">_mm256_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Sign-extend 8-bit integers to 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm256_cvtepi8_epi64\">_mm256_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Sign-extend 8-bit integers to 64-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtepi16_epi32\">_mm256_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Sign-extend 16-bit integers to 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm256_cvtepi16_epi64\">_mm256_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Sign-extend 16-bit integers to 64-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm256_cvtepi32_epi64\">_mm256_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Sign-extend 32-bit integers to 64-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm256_cvtepi32_pd\">_mm256_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers in <code>a</code> to packed double-precision (64-bit)\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm256_cvtepi32_ps\">_mm256_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers in <code>a</code> to packed single-precision (32-bit)\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtepu8_epi16\">_mm256_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Zero-extend unsigned 8-bit integers in <code>a</code> to 16-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtepu8_epi32\">_mm256_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Zero-extend the lower eight unsigned 8-bit integers in <code>a</code> to 32-bit\nintegers. The upper eight elements of <code>a</code> are unused.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm256_cvtepu8_epi64\">_mm256_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Zero-extend the lower four unsigned 8-bit integers in <code>a</code> to 64-bit\nintegers. The upper twelve elements of <code>a</code> are unused.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtepu16_epi32\">_mm256_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 16-bit integers in <code>a</code> to packed 32-bit\nintegers, and stores the results in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm256_cvtepu16_epi64\">_mm256_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Zero-extend the lower four unsigned 16-bit integers in <code>a</code> to 64-bit\nintegers. The upper four elements of <code>a</code> are unused.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm256_cvtepu32_epi64\">_mm256_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Zero-extend unsigned 32-bit integers in <code>a</code> to 64-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtpd_epi32\">_mm256_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed double-precision (64-bit) floating-point elements in <code>a</code>\nto packed 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm256_cvtpd_ps\">_mm256_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed double-precision (64-bit) floating-point elements in <code>a</code>\nto packed single-precision (32-bit) floating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtph_ps.html\" title=\"fn core::arch::x86::_mm256_cvtph_ps\">_mm256_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `f16c` only\">(x86 or x86-64) and <code>f16c</code></span></div><div class=\"desc docblock-short\">Converts the 8 x 16-bit half-precision float values in the 128-bit vector\n<code>a</code> into 8 x 32-bit float values stored in a 256-bit wide vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtps_epi32\">_mm256_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed single-precision (32-bit) floating-point elements in <code>a</code>\nto packed 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtps_pd.html\" title=\"fn core::arch::x86::_mm256_cvtps_pd\">_mm256_cvtps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed single-precision (32-bit) floating-point elements in <code>a</code>\nto packed double-precision (64-bit) floating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtps_ph.html\" title=\"fn core::arch::x86::_mm256_cvtps_ph\">_mm256_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `f16c` only\">(x86 or x86-64) and <code>f16c</code></span></div><div class=\"desc docblock-short\">Converts the 8 x 32-bit float values in the 256-bit vector <code>a</code> into 8 x\n16-bit half-precision float values stored in a 128-bit wide vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsd_f64.html\" title=\"fn core::arch::x86::_mm256_cvtsd_f64\">_mm256_cvtsd_f64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns the first element of the input vector of <code>[4 x double]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsi256_si32.html\" title=\"fn core::arch::x86::_mm256_cvtsi256_si32\">_mm256_cvtsi256_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns the first element of the input vector of <code>[8 x i32]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtss_f32.html\" title=\"fn core::arch::x86::_mm256_cvtss_f32\">_mm256_cvtss_f32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns the first element of the input vector of <code>[8 x float]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm256_cvttpd_epi32\">_mm256_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed double-precision (64-bit) floating-point elements in <code>a</code>\nto packed 32-bit integers with truncation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm256_cvttps_epi32\">_mm256_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Converts packed single-precision (32-bit) floating-point elements in <code>a</code>\nto packed 32-bit integers with truncation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_div_pd.html\" title=\"fn core::arch::x86::_mm256_div_pd\">_mm256_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the division of each of the 4 packed 64-bit floating-point elements\nin <code>a</code> by the corresponding packed elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_div_ps.html\" title=\"fn core::arch::x86::_mm256_div_ps\">_mm256_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the division of each of the 8 packed 32-bit floating-point elements\nin <code>a</code> by the corresponding packed elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dp_ps.html\" title=\"fn core::arch::x86::_mm256_dp_ps\">_mm256_dp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Conditionally multiplies the packed single-precision (32-bit) floating-point\nelements in <code>a</code> and <code>b</code> using the high 4 bits in <code>imm8</code>,\nsum the four products, and conditionally return the sum\nusing the low 4 bits of <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extract_epi8.html\" title=\"fn core::arch::x86::_mm256_extract_epi8\">_mm256_extract_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Extracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. Returns a 32-bit\ninteger containing the zero-extended integer data.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extract_epi16.html\" title=\"fn core::arch::x86::_mm256_extract_epi16\">_mm256_extract_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Extracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. Returns a 32-bit\ninteger containing the zero-extended integer data.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extract_epi32.html\" title=\"fn core::arch::x86::_mm256_extract_epi32\">_mm256_extract_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Extracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extractf128_pd.html\" title=\"fn core::arch::x86::_mm256_extractf128_pd\">_mm256_extractf128_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Extracts 128 bits (composed of 2 packed double-precision (64-bit)\nfloating-point elements) from <code>a</code>, selected with <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extractf128_ps.html\" title=\"fn core::arch::x86::_mm256_extractf128_ps\">_mm256_extractf128_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Extracts 128 bits (composed of 4 packed single-precision (32-bit)\nfloating-point elements) from <code>a</code>, selected with <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extractf128_si256.html\" title=\"fn core::arch::x86::_mm256_extractf128_si256\">_mm256_extractf128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Extracts 128 bits (composed of integer data) from <code>a</code>, selected with <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extracti128_si256.html\" title=\"fn core::arch::x86::_mm256_extracti128_si256\">_mm256_extracti128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Extracts 128 bits (of integer data) from <code>a</code> selected with <code>IMM1</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_floor_pd.html\" title=\"fn core::arch::x86::_mm256_floor_pd\">_mm256_floor_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Rounds packed double-precision (64-bit) floating point elements in <code>a</code>\ntoward negative infinity.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_floor_ps.html\" title=\"fn core::arch::x86::_mm256_floor_ps\">_mm256_floor_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Rounds packed single-precision (32-bit) floating point elements in <code>a</code>\ntoward negative infinity.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmadd_pd.html\" title=\"fn core::arch::x86::_mm256_fmadd_pd\">_mm256_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmadd_ps.html\" title=\"fn core::arch::x86::_mm256_fmadd_ps\">_mm256_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm256_fmaddsub_pd\">_mm256_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm256_fmaddsub_ps\">_mm256_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmsub_pd.html\" title=\"fn core::arch::x86::_mm256_fmsub_pd\">_mm256_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmsub_ps.html\" title=\"fn core::arch::x86::_mm256_fmsub_ps\">_mm256_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm256_fmsubadd_pd\">_mm256_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm256_fmsubadd_ps\">_mm256_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm256_fnmadd_pd\">_mm256_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm256_fnmadd_ps\">_mm256_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm256_fnmsub_pd\">_mm256_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate\nresult.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm256_fnmsub_ps\">_mm256_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate\nresult.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hadd_epi16.html\" title=\"fn core::arch::x86::_mm256_hadd_epi16\">_mm256_hadd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Horizontally adds adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hadd_epi32.html\" title=\"fn core::arch::x86::_mm256_hadd_epi32\">_mm256_hadd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Horizontally adds adjacent pairs of 32-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hadd_pd.html\" title=\"fn core::arch::x86::_mm256_hadd_pd\">_mm256_hadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Horizontal addition of adjacent pairs in the two packed vectors\nof 4 64-bit floating points <code>a</code> and <code>b</code>.\nIn the result, sums of elements from <code>a</code> are returned in even locations,\nwhile sums of elements from <code>b</code> are returned in odd locations.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hadd_ps.html\" title=\"fn core::arch::x86::_mm256_hadd_ps\">_mm256_hadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Horizontal addition of adjacent pairs in the two packed vectors\nof 8 32-bit floating points <code>a</code> and <code>b</code>.\nIn the result, sums of elements from <code>a</code> are returned in locations of\nindices 0, 1, 4, 5; while sums of elements from <code>b</code> are locations\n2, 3, 6, 7.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hadds_epi16.html\" title=\"fn core::arch::x86::_mm256_hadds_epi16\">_mm256_hadds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Horizontally adds adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>\nusing saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hsub_epi16.html\" title=\"fn core::arch::x86::_mm256_hsub_epi16\">_mm256_hsub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Horizontally subtract adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hsub_epi32.html\" title=\"fn core::arch::x86::_mm256_hsub_epi32\">_mm256_hsub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Horizontally subtract adjacent pairs of 32-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hsub_pd.html\" title=\"fn core::arch::x86::_mm256_hsub_pd\">_mm256_hsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Horizontal subtraction of adjacent pairs in the two packed vectors\nof 4 64-bit floating points <code>a</code> and <code>b</code>.\nIn the result, sums of elements from <code>a</code> are returned in even locations,\nwhile sums of elements from <code>b</code> are returned in odd locations.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hsub_ps.html\" title=\"fn core::arch::x86::_mm256_hsub_ps\">_mm256_hsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Horizontal subtraction of adjacent pairs in the two packed vectors\nof 8 32-bit floating points <code>a</code> and <code>b</code>.\nIn the result, sums of elements from <code>a</code> are returned in locations of\nindices 0, 1, 4, 5; while sums of elements from <code>b</code> are locations\n2, 3, 6, 7.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_hsubs_epi16.html\" title=\"fn core::arch::x86::_mm256_hsubs_epi16\">_mm256_hsubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Horizontally subtract adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>\nusing saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i32gather_epi32.html\" title=\"fn core::arch::x86::_mm256_i32gather_epi32\">_mm256_i32gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i32gather_epi64.html\" title=\"fn core::arch::x86::_mm256_i32gather_epi64\">_mm256_i32gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i32gather_pd.html\" title=\"fn core::arch::x86::_mm256_i32gather_pd\">_mm256_i32gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i32gather_ps.html\" title=\"fn core::arch::x86::_mm256_i32gather_ps\">_mm256_i32gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i64gather_epi32.html\" title=\"fn core::arch::x86::_mm256_i64gather_epi32\">_mm256_i64gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i64gather_epi64.html\" title=\"fn core::arch::x86::_mm256_i64gather_epi64\">_mm256_i64gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i64gather_pd.html\" title=\"fn core::arch::x86::_mm256_i64gather_pd\">_mm256_i64gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i64gather_ps.html\" title=\"fn core::arch::x86::_mm256_i64gather_ps\">_mm256_i64gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insert_epi8.html\" title=\"fn core::arch::x86::_mm256_insert_epi8\">_mm256_insert_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into result\nat the location specified by <code>index</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insert_epi16.html\" title=\"fn core::arch::x86::_mm256_insert_epi16\">_mm256_insert_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into result\nat the location specified by <code>index</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insert_epi32.html\" title=\"fn core::arch::x86::_mm256_insert_epi32\">_mm256_insert_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into result\nat the location specified by <code>index</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insertf128_pd.html\" title=\"fn core::arch::x86::_mm256_insertf128_pd\">_mm256_insertf128_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to result, then inserts 128 bits (composed of 2 packed\ndouble-precision (64-bit) floating-point elements) from <code>b</code> into result\nat the location specified by <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insertf128_ps.html\" title=\"fn core::arch::x86::_mm256_insertf128_ps\">_mm256_insertf128_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to result, then inserts 128 bits (composed of 4 packed\nsingle-precision (32-bit) floating-point elements) from <code>b</code> into result\nat the location specified by <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insertf128_si256.html\" title=\"fn core::arch::x86::_mm256_insertf128_si256\">_mm256_insertf128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to result, then inserts 128 bits from <code>b</code> into result\nat the location specified by <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_inserti128_si256.html\" title=\"fn core::arch::x86::_mm256_inserti128_si256\">_mm256_inserti128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Copies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) from <code>b</code> at the\nlocation specified by <code>IMM1</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_lddqu_si256.html\" title=\"fn core::arch::x86::_mm256_lddqu_si256\">_mm256_lddqu_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits of integer data from unaligned memory into result.\nThis intrinsic may perform better than <code>_mm256_loadu_si256</code> when the\ndata crosses a cache line boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_load_pd.html\" title=\"fn core::arch::x86::_mm256_load_pd\">_mm256_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits (composed of 4 packed double-precision (64-bit)\nfloating-point elements) from memory into result.\n<code>mem_addr</code> must be aligned on a 32-byte boundary or a\ngeneral-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_load_ps.html\" title=\"fn core::arch::x86::_mm256_load_ps\">_mm256_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits (composed of 8 packed single-precision (32-bit)\nfloating-point elements) from memory into result.\n<code>mem_addr</code> must be aligned on a 32-byte boundary or a\ngeneral-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_load_si256.html\" title=\"fn core::arch::x86::_mm256_load_si256\">_mm256_load_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits of integer data from memory into result.\n<code>mem_addr</code> must be aligned on a 32-byte boundary or a\ngeneral-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu2_m128.html\" title=\"fn core::arch::x86::_mm256_loadu2_m128\">_mm256_loadu2_m128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse` only\">(x86 or x86-64) and <code>avx,sse</code></span></div><div class=\"desc docblock-short\">Loads two 128-bit values (composed of 4 packed single-precision (32-bit)\nfloating-point elements) from memory, and combine them into a 256-bit\nvalue.\n<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu2_m128d.html\" title=\"fn core::arch::x86::_mm256_loadu2_m128d\">_mm256_loadu2_m128d</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Loads two 128-bit values (composed of 2 packed double-precision (64-bit)\nfloating-point elements) from memory, and combine them into a 256-bit\nvalue.\n<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu2_m128i.html\" title=\"fn core::arch::x86::_mm256_loadu2_m128i\">_mm256_loadu2_m128i</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Loads two 128-bit values (composed of integer data) from memory, and combine\nthem into a 256-bit value.\n<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_pd.html\" title=\"fn core::arch::x86::_mm256_loadu_pd\">_mm256_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits (composed of 4 packed double-precision (64-bit)\nfloating-point elements) from memory into result.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_ps.html\" title=\"fn core::arch::x86::_mm256_loadu_ps\">_mm256_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits (composed of 8 packed single-precision (32-bit)\nfloating-point elements) from memory into result.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_si256.html\" title=\"fn core::arch::x86::_mm256_loadu_si256\">_mm256_loadu_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads 256-bits of integer data from memory into result.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_madd_epi16.html\" title=\"fn core::arch::x86::_mm256_madd_epi16\">_mm256_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, producing\nintermediate signed 32-bit integers. Horizontally add adjacent pairs\nof intermediate 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm256_maddubs_epi16\">_mm256_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Vertically multiplies each unsigned 8-bit integer from <code>a</code> with the\ncorresponding signed 8-bit integer from <code>b</code>, producing intermediate\nsigned 16-bit integers. Horizontally add adjacent pairs of intermediate\nsigned 16-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i32gather_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_i32gather_epi32\">_mm256_mask_i32gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i32gather_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_i32gather_epi64\">_mm256_mask_i32gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i32gather_pd.html\" title=\"fn core::arch::x86::_mm256_mask_i32gather_pd\">_mm256_mask_i32gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i32gather_ps.html\" title=\"fn core::arch::x86::_mm256_mask_i32gather_ps\">_mm256_mask_i32gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i64gather_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_i64gather_epi32\">_mm256_mask_i64gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i64gather_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_i64gather_epi64\">_mm256_mask_i64gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i64gather_pd.html\" title=\"fn core::arch::x86::_mm256_mask_i64gather_pd\">_mm256_mask_i64gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_i64gather_ps.html\" title=\"fn core::arch::x86::_mm256_mask_i64gather_ps\">_mm256_mask_i64gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskload_epi32.html\" title=\"fn core::arch::x86::_mm256_maskload_epi32\">_mm256_maskload_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Loads packed 32-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>\n(elements are zeroed out when the highest bit is not set in the\ncorresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskload_epi64.html\" title=\"fn core::arch::x86::_mm256_maskload_epi64\">_mm256_maskload_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Loads packed 64-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>\n(elements are zeroed out when the highest bit is not set in the\ncorresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskload_pd.html\" title=\"fn core::arch::x86::_mm256_maskload_pd\">_mm256_maskload_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads packed double-precision (64-bit) floating-point elements from memory\ninto result using <code>mask</code> (elements are zeroed out when the high bit of the\ncorresponding element is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskload_ps.html\" title=\"fn core::arch::x86::_mm256_maskload_ps\">_mm256_maskload_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads packed single-precision (32-bit) floating-point elements from memory\ninto result using <code>mask</code> (elements are zeroed out when the high bit of the\ncorresponding element is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskstore_epi32.html\" title=\"fn core::arch::x86::_mm256_maskstore_epi32\">_mm256_maskstore_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Stores packed 32-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>\nusing <code>mask</code> (elements are not stored when the highest bit is not set\nin the corresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskstore_epi64.html\" title=\"fn core::arch::x86::_mm256_maskstore_epi64\">_mm256_maskstore_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Stores packed 64-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>\nusing <code>mask</code> (elements are not stored when the highest bit is not set\nin the corresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskstore_pd.html\" title=\"fn core::arch::x86::_mm256_maskstore_pd\">_mm256_maskstore_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores packed double-precision (64-bit) floating-point elements from <code>a</code>\ninto memory using <code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskstore_ps.html\" title=\"fn core::arch::x86::_mm256_maskstore_ps\">_mm256_maskstore_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores packed single-precision (32-bit) floating-point elements from <code>a</code>\ninto memory using <code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epi8.html\" title=\"fn core::arch::x86::_mm256_max_epi8\">_mm256_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nmaximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epi16.html\" title=\"fn core::arch::x86::_mm256_max_epi16\">_mm256_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nmaximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epi32.html\" title=\"fn core::arch::x86::_mm256_max_epi32\">_mm256_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nmaximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epu8.html\" title=\"fn core::arch::x86::_mm256_max_epu8\">_mm256_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns\nthe packed maximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epu16.html\" title=\"fn core::arch::x86::_mm256_max_epu16\">_mm256_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns\nthe packed maximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epu32.html\" title=\"fn core::arch::x86::_mm256_max_epu32\">_mm256_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns\nthe packed maximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_pd.html\" title=\"fn core::arch::x86::_mm256_max_pd\">_mm256_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Compares packed double-precision (64-bit) floating-point elements\nin <code>a</code> and <code>b</code>, and returns packed maximum values</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_ps.html\" title=\"fn core::arch::x86::_mm256_max_ps\">_mm256_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Compares packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and returns packed maximum values</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epi8.html\" title=\"fn core::arch::x86::_mm256_min_epi8\">_mm256_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nminimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epi16.html\" title=\"fn core::arch::x86::_mm256_min_epi16\">_mm256_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nminimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epi32.html\" title=\"fn core::arch::x86::_mm256_min_epi32\">_mm256_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nminimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epu8.html\" title=\"fn core::arch::x86::_mm256_min_epu8\">_mm256_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns\nthe packed minimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epu16.html\" title=\"fn core::arch::x86::_mm256_min_epu16\">_mm256_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns\nthe packed minimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epu32.html\" title=\"fn core::arch::x86::_mm256_min_epu32\">_mm256_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns\nthe packed minimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_pd.html\" title=\"fn core::arch::x86::_mm256_min_pd\">_mm256_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Compares packed double-precision (64-bit) floating-point elements\nin <code>a</code> and <code>b</code>, and returns packed minimum values</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_ps.html\" title=\"fn core::arch::x86::_mm256_min_ps\">_mm256_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Compares packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and returns packed minimum values</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movedup_pd.html\" title=\"fn core::arch::x86::_mm256_movedup_pd\">_mm256_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements\nfrom <code>a</code>, and returns the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movehdup_ps.html\" title=\"fn core::arch::x86::_mm256_movehdup_ps\">_mm256_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements\nfrom <code>a</code>, and returns the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_moveldup_ps.html\" title=\"fn core::arch::x86::_mm256_moveldup_ps\">_mm256_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements\nfrom <code>a</code>, and returns the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movemask_epi8.html\" title=\"fn core::arch::x86::_mm256_movemask_epi8\">_mm256_movemask_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Creates mask from the most significant bit of each 8-bit element in <code>a</code>,\nreturn the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movemask_pd.html\" title=\"fn core::arch::x86::_mm256_movemask_pd\">_mm256_movemask_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets each bit of the returned mask based on the most significant bit of the\ncorresponding packed double-precision (64-bit) floating-point element in\n<code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movemask_ps.html\" title=\"fn core::arch::x86::_mm256_movemask_ps\">_mm256_movemask_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets each bit of the returned mask based on the most significant bit of the\ncorresponding packed single-precision (32-bit) floating-point element in\n<code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mpsadbw_epu8.html\" title=\"fn core::arch::x86::_mm256_mpsadbw_epu8\">_mm256_mpsadbw_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the sum of absolute differences (SADs) of quadruplets of unsigned\n8-bit integers in <code>a</code> compared to those in <code>b</code>, and stores the 16-bit\nresults in dst. Eight SADs are performed for each 128-bit lane using one\nquadruplet from <code>b</code> and eight quadruplets from <code>a</code>. One quadruplet is\nselected from <code>b</code> starting at on the offset specified in <code>imm8</code>. Eight\nquadruplets are formed from sequential 8-bit integers selected from <code>a</code>\nstarting at the offset specified in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mul_epi32.html\" title=\"fn core::arch::x86::_mm256_mul_epi32\">_mm256_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies the low 32-bit integers from each packed 64-bit element in\n<code>a</code> and <code>b</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mul_epu32.html\" title=\"fn core::arch::x86::_mm256_mul_epu32\">_mm256_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies the low unsigned 32-bit integers from each packed 64-bit\nelement in <code>a</code> and <code>b</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mul_pd.html\" title=\"fn core::arch::x86::_mm256_mul_pd\">_mm256_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements\nin <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mul_ps.html\" title=\"fn core::arch::x86::_mm256_mul_ps\">_mm256_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code> and\n<code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm256_mulhi_epi16\">_mm256_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nintermediate 32-bit integers and returning the high 16 bits of the\nintermediate integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm256_mulhi_epu16\">_mm256_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, producing\nintermediate 32-bit integers and returning the high 16 bits of the\nintermediate integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm256_mulhrs_epi16\">_mm256_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nintermediate signed 32-bit integers. Truncate each intermediate\ninteger to the 18 most significant bits, round by adding 1, and\nreturn bits <code>[16:1]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mullo_epi16.html\" title=\"fn core::arch::x86::_mm256_mullo_epi16\">_mm256_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nintermediate 32-bit integers, and returns the low 16 bits of the\nintermediate integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mullo_epi32.html\" title=\"fn core::arch::x86::_mm256_mullo_epi32\">_mm256_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing\nintermediate 64-bit integers, and returns the low 32 bits of the\nintermediate integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_or_pd.html\" title=\"fn core::arch::x86::_mm256_or_pd\">_mm256_or_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise OR packed double-precision (64-bit) floating-point\nelements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_or_ps.html\" title=\"fn core::arch::x86::_mm256_or_ps\">_mm256_or_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise OR packed single-precision (32-bit) floating-point\nelements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_or_si256.html\" title=\"fn core::arch::x86::_mm256_or_si256\">_mm256_or_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise OR of 256 bits (representing integer data) in <code>a</code>\nand <code>b</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_packs_epi16.html\" title=\"fn core::arch::x86::_mm256_packs_epi16\">_mm256_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers\nusing signed saturation</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_packs_epi32.html\" title=\"fn core::arch::x86::_mm256_packs_epi32\">_mm256_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers\nusing signed saturation</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_packus_epi16.html\" title=\"fn core::arch::x86::_mm256_packus_epi16\">_mm256_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers\nusing unsigned saturation</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_packus_epi32.html\" title=\"fn core::arch::x86::_mm256_packus_epi32\">_mm256_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers\nusing unsigned saturation</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute2f128_pd.html\" title=\"fn core::arch::x86::_mm256_permute2f128_pd\">_mm256_permute2f128_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles 256 bits (composed of 4 packed double-precision (64-bit)\nfloating-point elements) selected by <code>imm8</code> from <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute2f128_ps.html\" title=\"fn core::arch::x86::_mm256_permute2f128_ps\">_mm256_permute2f128_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles 256 bits (composed of 8 packed single-precision (32-bit)\nfloating-point elements) selected by <code>imm8</code> from <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute2f128_si256.html\" title=\"fn core::arch::x86::_mm256_permute2f128_si256\">_mm256_permute2f128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles 128-bits (composed of integer data) selected by <code>imm8</code>\nfrom <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute2x128_si256.html\" title=\"fn core::arch::x86::_mm256_permute2x128_si256\">_mm256_permute2x128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute4x64_epi64.html\" title=\"fn core::arch::x86::_mm256_permute4x64_epi64\">_mm256_permute4x64_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Permutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute4x64_pd.html\" title=\"fn core::arch::x86::_mm256_permute4x64_pd\">_mm256_permute4x64_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles 64-bit floating-point elements in <code>a</code> across lanes using the\ncontrol in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute_pd.html\" title=\"fn core::arch::x86::_mm256_permute_pd\">_mm256_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles double-precision (64-bit) floating-point elements in <code>a</code>\nwithin 128-bit lanes using the control in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permute_ps.html\" title=\"fn core::arch::x86::_mm256_permute_ps\">_mm256_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles single-precision (32-bit) floating-point elements in <code>a</code>\nwithin 128-bit lanes using the control in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutevar8x32_epi32.html\" title=\"fn core::arch::x86::_mm256_permutevar8x32_epi32\">_mm256_permutevar8x32_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Permutes packed 32-bit integers from <code>a</code> according to the content of <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutevar8x32_ps.html\" title=\"fn core::arch::x86::_mm256_permutevar8x32_ps\">_mm256_permutevar8x32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles eight 32-bit floating-point elements in <code>a</code> across lanes using\nthe corresponding 32-bit integer index in <code>idx</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutevar_pd.html\" title=\"fn core::arch::x86::_mm256_permutevar_pd\">_mm256_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles double-precision (64-bit) floating-point elements in <code>a</code>\nwithin 256-bit lanes using the control in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutevar_ps.html\" title=\"fn core::arch::x86::_mm256_permutevar_ps\">_mm256_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles single-precision (32-bit) floating-point elements in <code>a</code>\nwithin 128-bit lanes using the control in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rcp_ps.html\" title=\"fn core::arch::x86::_mm256_rcp_ps\">_mm256_rcp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the approximate reciprocal of packed single-precision (32-bit)\nfloating-point elements in <code>a</code>, and returns the results. The maximum\nrelative error for this approximation is less than 1.5*2^-12.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_round_pd.html\" title=\"fn core::arch::x86::_mm256_round_pd\">_mm256_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Rounds packed double-precision (64-bit) floating point elements in <code>a</code>\naccording to the flag <code>ROUNDING</code>. The value of <code>ROUNDING</code> may be as follows:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_round_ps.html\" title=\"fn core::arch::x86::_mm256_round_ps\">_mm256_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Rounds packed single-precision (32-bit) floating point elements in <code>a</code>\naccording to the flag <code>ROUNDING</code>. The value of <code>ROUNDING</code> may be as follows:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rsqrt_ps.html\" title=\"fn core::arch::x86::_mm256_rsqrt_ps\">_mm256_rsqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the approximate reciprocal square root of packed single-precision\n(32-bit) floating-point elements in <code>a</code>, and returns the results.\nThe maximum relative error for this approximation is less than 1.5*2^-12.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sad_epu8.html\" title=\"fn core::arch::x86::_mm256_sad_epu8\">_mm256_sad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the absolute differences of packed unsigned 8-bit integers in <code>a</code>\nand <code>b</code>, then horizontally sum each consecutive 8 differences to\nproduce four unsigned 16-bit integers, and pack these unsigned 16-bit\nintegers in the low 16 bits of the 64-bit return value</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set1_epi8.html\" title=\"fn core::arch::x86::_mm256_set1_epi8\">_mm256_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts 8-bit integer <code>a</code> to all elements of returned vector.\nThis intrinsic may generate the <code>vpbroadcastb</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set1_epi16.html\" title=\"fn core::arch::x86::_mm256_set1_epi16\">_mm256_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts 16-bit integer <code>a</code> to all elements of returned vector.\nThis intrinsic may generate the <code>vpbroadcastw</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set1_epi32.html\" title=\"fn core::arch::x86::_mm256_set1_epi32\">_mm256_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts 32-bit integer <code>a</code> to all elements of returned vector.\nThis intrinsic may generate the <code>vpbroadcastd</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set1_epi64x.html\" title=\"fn core::arch::x86::_mm256_set1_epi64x\">_mm256_set1_epi64x</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts 64-bit integer <code>a</code> to all elements of returned vector.\nThis intrinsic may generate the <code>vpbroadcastq</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set1_pd.html\" title=\"fn core::arch::x86::_mm256_set1_pd\">_mm256_set1_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts double-precision (64-bit) floating-point value <code>a</code> to all\nelements of returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set1_ps.html\" title=\"fn core::arch::x86::_mm256_set1_ps\">_mm256_set1_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts single-precision (32-bit) floating-point value <code>a</code> to all\nelements of returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_epi8.html\" title=\"fn core::arch::x86::_mm256_set_epi8\">_mm256_set_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 8-bit integers in returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_epi16.html\" title=\"fn core::arch::x86::_mm256_set_epi16\">_mm256_set_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 16-bit integers in returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_epi32.html\" title=\"fn core::arch::x86::_mm256_set_epi32\">_mm256_set_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers in returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_epi64x.html\" title=\"fn core::arch::x86::_mm256_set_epi64x\">_mm256_set_epi64x</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 64-bit integers in returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_m128.html\" title=\"fn core::arch::x86::_mm256_set_m128\">_mm256_set_m128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed __m256 returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_m128d.html\" title=\"fn core::arch::x86::_mm256_set_m128d\">_mm256_set_m128d</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed __m256d returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_m128i.html\" title=\"fn core::arch::x86::_mm256_set_m128i\">_mm256_set_m128i</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed __m256i returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_pd.html\" title=\"fn core::arch::x86::_mm256_set_pd\">_mm256_set_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed double-precision (64-bit) floating-point elements in returned\nvector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_set_ps.html\" title=\"fn core::arch::x86::_mm256_set_ps\">_mm256_set_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed single-precision (32-bit) floating-point elements in returned\nvector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_epi8.html\" title=\"fn core::arch::x86::_mm256_setr_epi8\">_mm256_setr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 8-bit integers in returned vector with the supplied values in\nreverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_epi16.html\" title=\"fn core::arch::x86::_mm256_setr_epi16\">_mm256_setr_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 16-bit integers in returned vector with the supplied values in\nreverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_epi32.html\" title=\"fn core::arch::x86::_mm256_setr_epi32\">_mm256_setr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers in returned vector with the supplied values in\nreverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_epi64x.html\" title=\"fn core::arch::x86::_mm256_setr_epi64x\">_mm256_setr_epi64x</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed 64-bit integers in returned vector with the supplied values in\nreverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_m128.html\" title=\"fn core::arch::x86::_mm256_setr_m128\">_mm256_setr_m128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed __m256 returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_m128d.html\" title=\"fn core::arch::x86::_mm256_setr_m128d\">_mm256_setr_m128d</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed __m256d returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_m128i.html\" title=\"fn core::arch::x86::_mm256_setr_m128i\">_mm256_setr_m128i</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed __m256i returned vector with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_pd.html\" title=\"fn core::arch::x86::_mm256_setr_pd\">_mm256_setr_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed double-precision (64-bit) floating-point elements in returned\nvector with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setr_ps.html\" title=\"fn core::arch::x86::_mm256_setr_ps\">_mm256_setr_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Sets packed single-precision (32-bit) floating-point elements in returned\nvector with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setzero_pd.html\" title=\"fn core::arch::x86::_mm256_setzero_pd\">_mm256_setzero_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m256d with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setzero_ps.html\" title=\"fn core::arch::x86::_mm256_setzero_ps\">_mm256_setzero_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m256 with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_setzero_si256.html\" title=\"fn core::arch::x86::_mm256_setzero_si256\">_mm256_setzero_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m256i with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm256_shuffle_epi8\">_mm256_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles bytes from <code>a</code> according to the content of <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm256_shuffle_epi32\">_mm256_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles 32-bit integers in 128-bit lanes of <code>a</code> using the control in\n<code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_pd.html\" title=\"fn core::arch::x86::_mm256_shuffle_pd\">_mm256_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles double-precision (64-bit) floating-point elements within 128-bit\nlanes using the control in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_ps.html\" title=\"fn core::arch::x86::_mm256_shuffle_ps\">_mm256_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles single-precision (32-bit) floating-point elements in <code>a</code> within\n128-bit lanes using the control in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm256_shufflehi_epi16\">_mm256_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of <code>a</code> using\nthe control in <code>imm8</code>. The low 64 bits of 128-bit lanes of <code>a</code> are copied\nto the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm256_shufflelo_epi16\">_mm256_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of <code>a</code> using\nthe control in <code>imm8</code>. The high 64 bits of 128-bit lanes of <code>a</code> are copied\nto the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sign_epi8.html\" title=\"fn core::arch::x86::_mm256_sign_epi8\">_mm256_sign_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Negates packed 8-bit integers in <code>a</code> when the corresponding signed\n8-bit integer in <code>b</code> is negative, and returns the results.\nResults are zeroed out when the corresponding element in <code>b</code> is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sign_epi16.html\" title=\"fn core::arch::x86::_mm256_sign_epi16\">_mm256_sign_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Negates packed 16-bit integers in <code>a</code> when the corresponding signed\n16-bit integer in <code>b</code> is negative, and returns the results.\nResults are zeroed out when the corresponding element in <code>b</code> is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sign_epi32.html\" title=\"fn core::arch::x86::_mm256_sign_epi32\">_mm256_sign_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Negates packed 32-bit integers in <code>a</code> when the corresponding signed\n32-bit integer in <code>b</code> is negative, and returns the results.\nResults are zeroed out when the corresponding element in <code>b</code> is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sll_epi16.html\" title=\"fn core::arch::x86::_mm256_sll_epi16\">_mm256_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> left by <code>count</code> while\nshifting in zeros, and returns the result</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sll_epi32.html\" title=\"fn core::arch::x86::_mm256_sll_epi32\">_mm256_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> left by <code>count</code> while\nshifting in zeros, and returns the result</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sll_epi64.html\" title=\"fn core::arch::x86::_mm256_sll_epi64\">_mm256_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> left by <code>count</code> while\nshifting in zeros, and returns the result</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_slli_epi16.html\" title=\"fn core::arch::x86::_mm256_slli_epi16\">_mm256_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while\nshifting in zeros, return the results;</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_slli_epi32.html\" title=\"fn core::arch::x86::_mm256_slli_epi32\">_mm256_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while\nshifting in zeros, return the results;</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_slli_epi64.html\" title=\"fn core::arch::x86::_mm256_slli_epi64\">_mm256_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while\nshifting in zeros, return the results;</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_slli_si256.html\" title=\"fn core::arch::x86::_mm256_slli_si256\">_mm256_slli_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sllv_epi32.html\" title=\"fn core::arch::x86::_mm256_sllv_epi32\">_mm256_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> left by the amount\nspecified by the corresponding element in <code>count</code> while\nshifting in zeros, and returns the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sllv_epi64.html\" title=\"fn core::arch::x86::_mm256_sllv_epi64\">_mm256_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> left by the amount\nspecified by the corresponding element in <code>count</code> while\nshifting in zeros, and returns the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sqrt_pd.html\" title=\"fn core::arch::x86::_mm256_sqrt_pd\">_mm256_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns the square root of packed double-precision (64-bit) floating point\nelements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sqrt_ps.html\" title=\"fn core::arch::x86::_mm256_sqrt_ps\">_mm256_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns the square root of packed single-precision (32-bit) floating point\nelements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sra_epi16.html\" title=\"fn core::arch::x86::_mm256_sra_epi16\">_mm256_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while\nshifting in sign bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sra_epi32.html\" title=\"fn core::arch::x86::_mm256_sra_epi32\">_mm256_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while\nshifting in sign bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srai_epi16.html\" title=\"fn core::arch::x86::_mm256_srai_epi16\">_mm256_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while\nshifting in sign bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srai_epi32.html\" title=\"fn core::arch::x86::_mm256_srai_epi32\">_mm256_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while\nshifting in sign bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srav_epi32.html\" title=\"fn core::arch::x86::_mm256_srav_epi32\">_mm256_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by the amount specified by the\ncorresponding element in <code>count</code> while shifting in sign bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srl_epi16.html\" title=\"fn core::arch::x86::_mm256_srl_epi16\">_mm256_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srl_epi32.html\" title=\"fn core::arch::x86::_mm256_srl_epi32\">_mm256_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srl_epi64.html\" title=\"fn core::arch::x86::_mm256_srl_epi64\">_mm256_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> right by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srli_epi16.html\" title=\"fn core::arch::x86::_mm256_srli_epi16\">_mm256_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in\nzeros</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srli_epi32.html\" title=\"fn core::arch::x86::_mm256_srli_epi32\">_mm256_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in\nzeros</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srli_epi64.html\" title=\"fn core::arch::x86::_mm256_srli_epi64\">_mm256_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in\nzeros</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srli_si256.html\" title=\"fn core::arch::x86::_mm256_srli_si256\">_mm256_srli_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srlv_epi32.html\" title=\"fn core::arch::x86::_mm256_srlv_epi32\">_mm256_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by the amount specified by\nthe corresponding element in <code>count</code> while shifting in zeros,</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srlv_epi64.html\" title=\"fn core::arch::x86::_mm256_srlv_epi64\">_mm256_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> right by the amount specified by\nthe corresponding element in <code>count</code> while shifting in zeros,</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_store_pd.html\" title=\"fn core::arch::x86::_mm256_store_pd\">_mm256_store_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores 256-bits (composed of 4 packed double-precision (64-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> must be aligned on a 32-byte boundary or a\ngeneral-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_store_ps.html\" title=\"fn core::arch::x86::_mm256_store_ps\">_mm256_store_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores 256-bits (composed of 8 packed single-precision (32-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> must be aligned on a 32-byte boundary or a\ngeneral-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_store_si256.html\" title=\"fn core::arch::x86::_mm256_store_si256\">_mm256_store_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores 256-bits of integer data from <code>a</code> into memory.\n<code>mem_addr</code> must be aligned on a 32-byte boundary or a\ngeneral-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu2_m128.html\" title=\"fn core::arch::x86::_mm256_storeu2_m128\">_mm256_storeu2_m128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse` only\">(x86 or x86-64) and <code>avx,sse</code></span></div><div class=\"desc docblock-short\">Stores the high and low 128-bit halves (each composed of 4 packed\nsingle-precision (32-bit) floating-point elements) from <code>a</code> into memory two\ndifferent 128-bit locations.\n<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu2_m128d.html\" title=\"fn core::arch::x86::_mm256_storeu2_m128d\">_mm256_storeu2_m128d</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Stores the high and low 128-bit halves (each composed of 2 packed\ndouble-precision (64-bit) floating-point elements) from <code>a</code> into memory two\ndifferent 128-bit locations.\n<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu2_m128i.html\" title=\"fn core::arch::x86::_mm256_storeu2_m128i\">_mm256_storeu2_m128i</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Stores the high and low 128-bit halves (each composed of integer data) from\n<code>a</code> into memory two different 128-bit locations.\n<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_pd.html\" title=\"fn core::arch::x86::_mm256_storeu_pd\">_mm256_storeu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores 256-bits (composed of 4 packed double-precision (64-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_ps.html\" title=\"fn core::arch::x86::_mm256_storeu_ps\">_mm256_storeu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores 256-bits (composed of 8 packed single-precision (32-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_si256.html\" title=\"fn core::arch::x86::_mm256_storeu_si256\">_mm256_storeu_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores 256-bits of integer data from <code>a</code> into memory.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_stream_pd.html\" title=\"fn core::arch::x86::_mm256_stream_pd\">_mm256_stream_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Moves double-precision values from a 256-bit vector of <code>[4 x double]</code>\nto a 32-byte aligned memory location. To minimize caching, the data is\nflagged as non-temporal (unlikely to be used again soon).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_stream_ps.html\" title=\"fn core::arch::x86::_mm256_stream_ps\">_mm256_stream_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Moves single-precision floating point values from a 256-bit vector\nof <code>[8 x float]</code> to a 32-byte aligned memory location. To minimize\ncaching, the data is flagged as non-temporal (unlikely to be used again\nsoon).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_stream_si256.html\" title=\"fn core::arch::x86::_mm256_stream_si256\">_mm256_stream_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Moves integer data from a 256-bit integer vector to a 32-byte\naligned memory location. To minimize caching, the data is flagged as\nnon-temporal (unlikely to be used again soon)</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sub_epi8.html\" title=\"fn core::arch::x86::_mm256_sub_epi8\">_mm256_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in <code>b</code> from packed 8-bit integers in <code>a</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sub_epi16.html\" title=\"fn core::arch::x86::_mm256_sub_epi16\">_mm256_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in <code>b</code> from packed 16-bit integers in <code>a</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sub_epi32.html\" title=\"fn core::arch::x86::_mm256_sub_epi32\">_mm256_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in <code>b</code> from packed 32-bit integers in <code>a</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sub_epi64.html\" title=\"fn core::arch::x86::_mm256_sub_epi64\">_mm256_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in <code>b</code> from packed 64-bit integers in <code>a</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sub_pd.html\" title=\"fn core::arch::x86::_mm256_sub_pd\">_mm256_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Subtracts packed double-precision (64-bit) floating-point elements in <code>b</code>\nfrom packed elements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sub_ps.html\" title=\"fn core::arch::x86::_mm256_sub_ps\">_mm256_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Subtracts packed single-precision (32-bit) floating-point elements in <code>b</code>\nfrom packed elements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_subs_epi8.html\" title=\"fn core::arch::x86::_mm256_subs_epi8\">_mm256_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in <code>b</code> from packed 8-bit integers in\n<code>a</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_subs_epi16.html\" title=\"fn core::arch::x86::_mm256_subs_epi16\">_mm256_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in <code>b</code> from packed 16-bit integers in\n<code>a</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_subs_epu8.html\" title=\"fn core::arch::x86::_mm256_subs_epu8\">_mm256_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in <code>b</code> from packed 8-bit\nintegers in <code>a</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_subs_epu16.html\" title=\"fn core::arch::x86::_mm256_subs_epu16\">_mm256_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in <code>b</code> from packed 16-bit\nintegers in <code>a</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testc_pd.html\" title=\"fn core::arch::x86::_mm256_testc_pd\">_mm256_testc_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testc_ps.html\" title=\"fn core::arch::x86::_mm256_testc_ps\">_mm256_testc_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testc_si256.html\" title=\"fn core::arch::x86::_mm256_testc_si256\">_mm256_testc_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing integer data) in <code>a</code> and\n<code>b</code>, and set <code>ZF</code> to 1 if the result is zero, otherwise set <code>ZF</code> to 0.\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>, and set <code>CF</code> to 1 if\nthe result is zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testnzc_pd.html\" title=\"fn core::arch::x86::_mm256_testnzc_pd\">_mm256_testnzc_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values\nare zero, otherwise return 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testnzc_ps.html\" title=\"fn core::arch::x86::_mm256_testnzc_ps\">_mm256_testnzc_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values\nare zero, otherwise return 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testnzc_si256.html\" title=\"fn core::arch::x86::_mm256_testnzc_si256\">_mm256_testnzc_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing integer data) in <code>a</code> and\n<code>b</code>, and set <code>ZF</code> to 1 if the result is zero, otherwise set <code>ZF</code> to 0.\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>, and set <code>CF</code> to 1 if\nthe result is zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and\n<code>CF</code> values are zero, otherwise return 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testz_pd.html\" title=\"fn core::arch::x86::_mm256_testz_pd\">_mm256_testz_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testz_ps.html\" title=\"fn core::arch::x86::_mm256_testz_ps\">_mm256_testz_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testz_si256.html\" title=\"fn core::arch::x86::_mm256_testz_si256\">_mm256_testz_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 256 bits (representing integer data) in <code>a</code> and\n<code>b</code>, and set <code>ZF</code> to 1 if the result is zero, otherwise set <code>ZF</code> to 0.\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>, and set <code>CF</code> to 1 if\nthe result is zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_undefined_pd.html\" title=\"fn core::arch::x86::_mm256_undefined_pd\">_mm256_undefined_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m256d</code> with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_undefined_ps.html\" title=\"fn core::arch::x86::_mm256_undefined_ps\">_mm256_undefined_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m256</code> with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_undefined_si256.html\" title=\"fn core::arch::x86::_mm256_undefined_si256\">_mm256_undefined_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m256i with with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm256_unpackhi_epi8\">_mm256_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 8-bit integers from the high half of each\n128-bit lane in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm256_unpackhi_epi16\">_mm256_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 16-bit integers from the high half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm256_unpackhi_epi32\">_mm256_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 32-bit integers from the high half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm256_unpackhi_epi64\">_mm256_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 64-bit integers from the high half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm256_unpackhi_pd\">_mm256_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave double-precision (64-bit) floating-point elements\nfrom the high half of each 128-bit lane in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm256_unpackhi_ps\">_mm256_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave single-precision (32-bit) floating-point elements\nfrom the high half of each 128-bit lane in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm256_unpacklo_epi8\">_mm256_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 8-bit integers from the low half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm256_unpacklo_epi16\">_mm256_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 16-bit integers from the low half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm256_unpacklo_epi32\">_mm256_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 32-bit integers from the low half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm256_unpacklo_epi64\">_mm256_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 64-bit integers from the low half of each\n128-bit lane of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm256_unpacklo_pd\">_mm256_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave double-precision (64-bit) floating-point elements\nfrom the low half of each 128-bit lane in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm256_unpacklo_ps\">_mm256_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave single-precision (32-bit) floating-point elements\nfrom the low half of each 128-bit lane in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_xor_pd.html\" title=\"fn core::arch::x86::_mm256_xor_pd\">_mm256_xor_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise XOR of packed double-precision (64-bit) floating-point\nelements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_xor_ps.html\" title=\"fn core::arch::x86::_mm256_xor_ps\">_mm256_xor_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise XOR of packed single-precision (32-bit) floating-point\nelements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_xor_si256.html\" title=\"fn core::arch::x86::_mm256_xor_si256\">_mm256_xor_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise XOR of 256 bits (representing integer data)\nin <code>a</code> and <code>b</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_zeroall.html\" title=\"fn core::arch::x86::_mm256_zeroall\">_mm256_zeroall</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Zeroes the contents of all XMM or YMM registers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_zeroupper.html\" title=\"fn core::arch::x86::_mm256_zeroupper\">_mm256_zeroupper</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Zeroes the upper 128 bits of all YMM registers;\nthe lower 128-bits of the registers are unmodified.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_zextpd128_pd256.html\" title=\"fn core::arch::x86::_mm256_zextpd128_pd256\">_mm256_zextpd128_pd256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Constructs a 256-bit floating-point vector of <code>[4 x double]</code> from a\n128-bit floating-point vector of <code>[2 x double]</code>. The lower 128 bits\ncontain the value of the source vector. The upper 128 bits are set\nto zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_zextps128_ps256.html\" title=\"fn core::arch::x86::_mm256_zextps128_ps256\">_mm256_zextps128_ps256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse` only\">(x86 or x86-64) and <code>avx,sse</code></span></div><div class=\"desc docblock-short\">Constructs a 256-bit floating-point vector of <code>[8 x float]</code> from a\n128-bit floating-point vector of <code>[4 x float]</code>. The lower 128 bits contain\nthe value of the source vector. The upper 128 bits are set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_zextsi128_si256.html\" title=\"fn core::arch::x86::_mm256_zextsi128_si256\">_mm256_zextsi128_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Constructs a 256-bit integer vector from a 128-bit integer vector.\nThe lower 128 bits contain the value of the source vector. The upper\n128 bits are set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_abs_epi8.html\" title=\"fn core::arch::x86::_mm_abs_epi8\">_mm_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Computes the absolute value of packed 8-bit signed integers in <code>a</code> and\nreturn the unsigned results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_abs_epi16.html\" title=\"fn core::arch::x86::_mm_abs_epi16\">_mm_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Computes the absolute value of each of the packed 16-bit signed integers in\n<code>a</code> and\nreturn the 16-bit unsigned integer</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_abs_epi32.html\" title=\"fn core::arch::x86::_mm_abs_epi32\">_mm_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Computes the absolute value of each of the packed 32-bit signed integers in\n<code>a</code> and\nreturn the 32-bit unsigned integer</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_epi8.html\" title=\"fn core::arch::x86::_mm_add_epi8\">_mm_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed 8-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_epi16.html\" title=\"fn core::arch::x86::_mm_add_epi16\">_mm_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_epi32.html\" title=\"fn core::arch::x86::_mm_add_epi32\">_mm_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed 32-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_epi64.html\" title=\"fn core::arch::x86::_mm_add_epi64\">_mm_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed 64-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_pd.html\" title=\"fn core::arch::x86::_mm_add_pd\">_mm_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed double-precision (64-bit) floating-point elements in <code>a</code> and\n<code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_ps.html\" title=\"fn core::arch::x86::_mm_add_ps\">_mm_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Adds __m128 vectors.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_sd.html\" title=\"fn core::arch::x86::_mm_add_sd\">_mm_add_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the sum of the\nlow elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_ss.html\" title=\"fn core::arch::x86::_mm_add_ss\">_mm_add_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Adds the first component of <code>a</code> and <code>b</code>, the other components are copied\nfrom <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_adds_epi8.html\" title=\"fn core::arch::x86::_mm_adds_epi8\">_mm_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_adds_epi16.html\" title=\"fn core::arch::x86::_mm_adds_epi16\">_mm_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_adds_epu8.html\" title=\"fn core::arch::x86::_mm_adds_epu8\">_mm_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_adds_epu16.html\" title=\"fn core::arch::x86::_mm_adds_epu16\">_mm_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Adds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_addsub_pd.html\" title=\"fn core::arch::x86::_mm_addsub_pd\">_mm_addsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Alternatively add and subtract packed double-precision (64-bit)\nfloating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_addsub_ps.html\" title=\"fn core::arch::x86::_mm_addsub_ps\">_mm_addsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Alternatively add and subtract packed single-precision (32-bit)\nfloating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_aesdec_si128.html\" title=\"fn core::arch::x86::_mm_aesdec_si128\">_mm_aesdec_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `aes` only\">(x86 or x86-64) and <code>aes</code></span></div><div class=\"desc docblock-short\">Performs one round of an AES decryption flow on data (state) in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_aesdeclast_si128.html\" title=\"fn core::arch::x86::_mm_aesdeclast_si128\">_mm_aesdeclast_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `aes` only\">(x86 or x86-64) and <code>aes</code></span></div><div class=\"desc docblock-short\">Performs the last round of an AES decryption flow on data (state) in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_aesenc_si128.html\" title=\"fn core::arch::x86::_mm_aesenc_si128\">_mm_aesenc_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `aes` only\">(x86 or x86-64) and <code>aes</code></span></div><div class=\"desc docblock-short\">Performs one round of an AES encryption flow on data (state) in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_aesenclast_si128.html\" title=\"fn core::arch::x86::_mm_aesenclast_si128\">_mm_aesenclast_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `aes` only\">(x86 or x86-64) and <code>aes</code></span></div><div class=\"desc docblock-short\">Performs the last round of an AES encryption flow on data (state) in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_aesimc_si128.html\" title=\"fn core::arch::x86::_mm_aesimc_si128\">_mm_aesimc_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `aes` only\">(x86 or x86-64) and <code>aes</code></span></div><div class=\"desc docblock-short\">Performs the <code>InvMixColumns</code> transformation on <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_aeskeygenassist_si128.html\" title=\"fn core::arch::x86::_mm_aeskeygenassist_si128\">_mm_aeskeygenassist_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `aes` only\">(x86 or x86-64) and <code>aes</code></span></div><div class=\"desc docblock-short\">Assist in expanding the AES cipher key.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_alignr_epi8.html\" title=\"fn core::arch::x86::_mm_alignr_epi8\">_mm_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Concatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte temporary result,\nshift the result right by <code>n</code> bytes, and returns the low 16 bytes.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_and_pd.html\" title=\"fn core::arch::x86::_mm_and_pd\">_mm_and_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of packed double-precision (64-bit) floating-point\nelements in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_and_ps.html\" title=\"fn core::arch::x86::_mm_and_ps\">_mm_and_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Bitwise AND of packed single-precision (32-bit) floating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_and_si128.html\" title=\"fn core::arch::x86::_mm_and_si128\">_mm_and_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing integer data) in <code>a</code> and\n<code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_andnot_pd.html\" title=\"fn core::arch::x86::_mm_andnot_pd\">_mm_andnot_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_andnot_ps.html\" title=\"fn core::arch::x86::_mm_andnot_ps\">_mm_andnot_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Bitwise AND-NOT of packed single-precision (32-bit) floating-point\nelements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_andnot_si128.html\" title=\"fn core::arch::x86::_mm_andnot_si128\">_mm_andnot_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise NOT of 128 bits (representing integer data) in <code>a</code> and\nthen AND with <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_avg_epu8.html\" title=\"fn core::arch::x86::_mm_avg_epu8\">_mm_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Averages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_avg_epu16.html\" title=\"fn core::arch::x86::_mm_avg_epu16\">_mm_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Averages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blend_epi16.html\" title=\"fn core::arch::x86::_mm_blend_epi16\">_mm_blend_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Blend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blend_epi32.html\" title=\"fn core::arch::x86::_mm_blend_epi32\">_mm_blend_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Blends packed 32-bit integers from <code>a</code> and <code>b</code> using control mask <code>IMM4</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blend_pd.html\" title=\"fn core::arch::x86::_mm_blend_pd\">_mm_blend_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Blend packed double-precision (64-bit) floating-point elements from <code>a</code>\nand <code>b</code> using control mask <code>IMM2</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blend_ps.html\" title=\"fn core::arch::x86::_mm_blend_ps\">_mm_blend_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Blend packed single-precision (32-bit) floating-point elements from <code>a</code>\nand <code>b</code> using mask <code>IMM4</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blendv_epi8.html\" title=\"fn core::arch::x86::_mm_blendv_epi8\">_mm_blendv_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Blend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blendv_pd.html\" title=\"fn core::arch::x86::_mm_blendv_pd\">_mm_blendv_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Blend packed double-precision (64-bit) floating-point elements from <code>a</code>\nand <code>b</code> using <code>mask</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_blendv_ps.html\" title=\"fn core::arch::x86::_mm_blendv_ps\">_mm_blendv_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Blend packed single-precision (32-bit) floating-point elements from <code>a</code>\nand <code>b</code> using <code>mask</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcast_ss.html\" title=\"fn core::arch::x86::_mm_broadcast_ss\">_mm_broadcast_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Broadcasts a single-precision (32-bit) floating-point element from memory\nto all elements of the returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm_broadcastb_epi8\">_mm_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 8-bit integer from <code>a</code> to all elements of\nthe 128-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm_broadcastd_epi32\">_mm_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 32-bit integer from <code>a</code> to all elements of\nthe 128-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm_broadcastq_epi64\">_mm_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 64-bit integer from <code>a</code> to all elements of\nthe 128-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm_broadcastsd_pd\">_mm_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low double-precision (64-bit) floating-point element\nfrom <code>a</code> to all elements of the 128-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm_broadcastss_ps\">_mm_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low single-precision (32-bit) floating-point element\nfrom <code>a</code> to all elements of the 128-bit returned value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm_broadcastw_epi16\">_mm_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Broadcasts the low packed 16-bit integer from a to all elements of\nthe 128-bit returned value</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_bslli_si128.html\" title=\"fn core::arch::x86::_mm_bslli_si128\">_mm_bslli_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_bsrli_si128.html\" title=\"fn core::arch::x86::_mm_bsrli_si128\">_mm_bsrli_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_castpd_ps.html\" title=\"fn core::arch::x86::_mm_castpd_ps\">_mm_castpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Casts a 128-bit floating-point vector of <code>[2 x double]</code> into a 128-bit\nfloating-point vector of <code>[4 x float]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_castpd_si128.html\" title=\"fn core::arch::x86::_mm_castpd_si128\">_mm_castpd_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Casts a 128-bit floating-point vector of <code>[2 x double]</code> into a 128-bit\ninteger vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_castps_pd.html\" title=\"fn core::arch::x86::_mm_castps_pd\">_mm_castps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Casts a 128-bit floating-point vector of <code>[4 x float]</code> into a 128-bit\nfloating-point vector of <code>[2 x double]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_castps_si128.html\" title=\"fn core::arch::x86::_mm_castps_si128\">_mm_castps_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Casts a 128-bit floating-point vector of <code>[4 x float]</code> into a 128-bit\ninteger vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_castsi128_pd.html\" title=\"fn core::arch::x86::_mm_castsi128_pd\">_mm_castsi128_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Casts a 128-bit integer vector into a 128-bit floating-point vector\nof <code>[2 x double]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_castsi128_ps.html\" title=\"fn core::arch::x86::_mm_castsi128_ps\">_mm_castsi128_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Casts a 128-bit integer vector into a 128-bit floating-point vector\nof <code>[4 x float]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ceil_pd.html\" title=\"fn core::arch::x86::_mm_ceil_pd\">_mm_ceil_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the packed double-precision (64-bit) floating-point elements in <code>a</code>\nup to an integer value, and stores the results as packed double-precision\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ceil_ps.html\" title=\"fn core::arch::x86::_mm_ceil_ps\">_mm_ceil_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the packed single-precision (32-bit) floating-point elements in <code>a</code>\nup to an integer value, and stores the results as packed single-precision\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ceil_sd.html\" title=\"fn core::arch::x86::_mm_ceil_sd\">_mm_ceil_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in <code>b</code>\nup to an integer value, store the result as a double-precision\nfloating-point element in the lower element of the intrinsic result,\nand copies the upper element from <code>a</code> to the upper element\nof the intrinsic result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ceil_ss.html\" title=\"fn core::arch::x86::_mm_ceil_ss\">_mm_ceil_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in <code>b</code>\nup to an integer value, store the result as a single-precision\nfloating-point element in the lower element of the intrinsic result,\nand copies the upper 3 packed elements from <code>a</code> to the upper elements\nof the intrinsic result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_clflush.html\" title=\"fn core::arch::x86::_mm_clflush\">_mm_clflush</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Invalidates and flushes the cache line that contains <code>p</code> from all levels of\nthe cache hierarchy.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_clmulepi64_si128.html\" title=\"fn core::arch::x86::_mm_clmulepi64_si128\">_mm_clmulepi64_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `pclmulqdq` only\">(x86 or x86-64) and <code>pclmulqdq</code></span></div><div class=\"desc docblock-short\">Performs a carry-less multiplication of two 64-bit polynomials over the\nfinite field GF(2).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_pd.html\" title=\"fn core::arch::x86::_mm_cmp_pd\">_mm_cmp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Compares packed double-precision (64-bit) floating-point\nelements in <code>a</code> and <code>b</code> based on the comparison operand\nspecified by <code>IMM5</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_ps.html\" title=\"fn core::arch::x86::_mm_cmp_ps\">_mm_cmp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse` only\">(x86 or x86-64) and <code>avx,sse</code></span></div><div class=\"desc docblock-short\">Compares packed single-precision (32-bit) floating-point\nelements in <code>a</code> and <code>b</code> based on the comparison operand\nspecified by <code>IMM5</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_sd.html\" title=\"fn core::arch::x86::_mm_cmp_sd\">_mm_cmp_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower double-precision (64-bit) floating-point element in\n<code>a</code> and <code>b</code> based on the comparison operand specified by <code>IMM5</code>,\nstore the result in the lower element of returned vector,\nand copies the upper element from <code>a</code> to the upper element of returned\nvector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_ss.html\" title=\"fn core::arch::x86::_mm_cmp_ss\">_mm_cmp_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse` only\">(x86 or x86-64) and <code>avx,sse</code></span></div><div class=\"desc docblock-short\">Compares the lower single-precision (32-bit) floating-point element in\n<code>a</code> and <code>b</code> based on the comparison operand specified by <code>IMM5</code>,\nstore the result in the lower element of returned vector,\nand copies the upper 3 packed elements from <code>a</code> to the upper elements of\nreturned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi8.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi8\">_mm_cmpeq_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi16.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi16\">_mm_cmpeq_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi32.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi32\">_mm_cmpeq_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi64.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi64\">_mm_cmpeq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed 64-bit integers in <code>a</code> and <code>b</code> for equality</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_pd.html\" title=\"fn core::arch::x86::_mm_cmpeq_pd\">_mm_cmpeq_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_ps.html\" title=\"fn core::arch::x86::_mm_cmpeq_ps\">_mm_cmpeq_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input elements\nwere equal, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_sd.html\" title=\"fn core::arch::x86::_mm_cmpeq_sd\">_mm_cmpeq_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the equality\ncomparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_ss.html\" title=\"fn core::arch::x86::_mm_cmpeq_ss\">_mm_cmpeq_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for equality. The lowest 32 bits of\nthe result will be <code>0xffffffff</code> if the two inputs are equal, or <code>0</code>\notherwise. The upper 96 bits of the result are the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestra.html\" title=\"fn core::arch::x86::_mm_cmpestra\">_mm_cmpestra</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>\nusing the control in <code>IMM8</code>, and return <code>1</code> if <code>b</code> did not\ncontain a null character and the resulting mask was zero, and <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestrc.html\" title=\"fn core::arch::x86::_mm_cmpestrc\">_mm_cmpestrc</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>\nusing the control in <code>IMM8</code>, and return <code>1</code> if the resulting mask\nwas non-zero, and <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestri.html\" title=\"fn core::arch::x86::_mm_cmpestri\">_mm_cmpestri</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> using the\ncontrol in <code>IMM8</code> and return the generated index. Similar to\n<a href=\"fn._mm_cmpistri.html\"><code>_mm_cmpistri</code></a> with the exception that <a href=\"fn._mm_cmpistri.html\"><code>_mm_cmpistri</code></a> implicitly\ndetermines the length of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestrm.html\" title=\"fn core::arch::x86::_mm_cmpestrm\">_mm_cmpestrm</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>\nusing the control in <code>IMM8</code>, and return the generated mask.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestro.html\" title=\"fn core::arch::x86::_mm_cmpestro\">_mm_cmpestro</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>\nusing the control in <code>IMM8</code>, and return bit <code>0</code> of the resulting\nbit mask.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestrs.html\" title=\"fn core::arch::x86::_mm_cmpestrs\">_mm_cmpestrs</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>\nusing the control in <code>IMM8</code>, and return <code>1</code> if any character in\na was null, and <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpestrz.html\" title=\"fn core::arch::x86::_mm_cmpestrz\">_mm_cmpestrz</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>\nusing the control in <code>IMM8</code>, and return <code>1</code> if any character in\n<code>b</code> was null, and <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_pd.html\" title=\"fn core::arch::x86::_mm_cmpge_pd\">_mm_cmpge_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for greater-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_ps.html\" title=\"fn core::arch::x86::_mm_cmpge_ps\">_mm_cmpge_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is greater than or equal to the corresponding element in <code>b</code>, or <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_sd.html\" title=\"fn core::arch::x86::_mm_cmpge_sd\">_mm_cmpge_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\ngreater-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_ss.html\" title=\"fn core::arch::x86::_mm_cmpge_ss\">_mm_cmpge_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for greater than or equal. The\nlowest 32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is\ngreater than or equal <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits\nof the result are the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi8.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi8\">_mm_cmpgt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi16.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi16\">_mm_cmpgt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi32.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi32\">_mm_cmpgt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi64.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi64\">_mm_cmpgt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed 64-bit integers in <code>a</code> and <code>b</code> for greater-than,\nreturn the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_pd.html\" title=\"fn core::arch::x86::_mm_cmpgt_pd\">_mm_cmpgt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_ps.html\" title=\"fn core::arch::x86::_mm_cmpgt_ps\">_mm_cmpgt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is greater than the corresponding element in <code>b</code>, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_sd.html\" title=\"fn core::arch::x86::_mm_cmpgt_sd\">_mm_cmpgt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\ngreater-than comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_ss.html\" title=\"fn core::arch::x86::_mm_cmpgt_ss\">_mm_cmpgt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for greater than. The lowest 32\nbits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is greater\nthan <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result\nare the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistra.html\" title=\"fn core::arch::x86::_mm_cmpistra\">_mm_cmpistra</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code>, and return <code>1</code> if <code>b</code> did not contain a null\ncharacter and the resulting mask was zero, and <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistrc.html\" title=\"fn core::arch::x86::_mm_cmpistrc\">_mm_cmpistrc</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code>, and return <code>1</code> if the resulting mask was non-zero,\nand <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistri.html\" title=\"fn core::arch::x86::_mm_cmpistri\">_mm_cmpistri</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code> and return the generated index. Similar to\n<a href=\"fn._mm_cmpestri.html\" title=\"fn core::arch::x86::_mm_cmpestri\"><code>_mm_cmpestri</code></a> with the exception that <a href=\"fn._mm_cmpestri.html\" title=\"fn core::arch::x86::_mm_cmpestri\"><code>_mm_cmpestri</code></a> requires the\nlengths of <code>a</code> and <code>b</code> to be explicitly specified.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistrm.html\" title=\"fn core::arch::x86::_mm_cmpistrm\">_mm_cmpistrm</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code>, and return the generated mask.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistro.html\" title=\"fn core::arch::x86::_mm_cmpistro\">_mm_cmpistro</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code>, and return bit <code>0</code> of the resulting bit mask.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistrs.html\" title=\"fn core::arch::x86::_mm_cmpistrs\">_mm_cmpistrs</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code>, and returns <code>1</code> if any character in <code>a</code> was null,\nand <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpistrz.html\" title=\"fn core::arch::x86::_mm_cmpistrz\">_mm_cmpistrz</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the\ncontrol in <code>IMM8</code>, and return <code>1</code> if any character in <code>b</code> was null.\nand <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_pd.html\" title=\"fn core::arch::x86::_mm_cmple_pd\">_mm_cmple_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for less-than-or-equal</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_ps.html\" title=\"fn core::arch::x86::_mm_cmple_ps\">_mm_cmple_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is less than or equal to the corresponding element in <code>b</code>, or <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_sd.html\" title=\"fn core::arch::x86::_mm_cmple_sd\">_mm_cmple_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\nless-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_ss.html\" title=\"fn core::arch::x86::_mm_cmple_ss\">_mm_cmple_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for less than or equal. The lowest\n32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is less than\nor equal <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result\nare the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi8.html\" title=\"fn core::arch::x86::_mm_cmplt_epi8\">_mm_cmplt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi16.html\" title=\"fn core::arch::x86::_mm_cmplt_epi16\">_mm_cmplt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi32.html\" title=\"fn core::arch::x86::_mm_cmplt_epi32\">_mm_cmplt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_pd.html\" title=\"fn core::arch::x86::_mm_cmplt_pd\">_mm_cmplt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_ps.html\" title=\"fn core::arch::x86::_mm_cmplt_ps\">_mm_cmplt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is less than the corresponding element in <code>b</code>, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_sd.html\" title=\"fn core::arch::x86::_mm_cmplt_sd\">_mm_cmplt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the less-than\ncomparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_ss.html\" title=\"fn core::arch::x86::_mm_cmplt_ss\">_mm_cmplt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for less than. The lowest 32 bits\nof the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is less than\n<code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are the\nupper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_pd.html\" title=\"fn core::arch::x86::_mm_cmpneq_pd\">_mm_cmpneq_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for not-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_ps.html\" title=\"fn core::arch::x86::_mm_cmpneq_ps\">_mm_cmpneq_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input elements\nare <strong>not</strong> equal, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_sd.html\" title=\"fn core::arch::x86::_mm_cmpneq_sd\">_mm_cmpneq_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the not-equal\ncomparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_ss.html\" title=\"fn core::arch::x86::_mm_cmpneq_ss\">_mm_cmpneq_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for inequality. The lowest 32 bits\nof the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not equal to\n<code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are the\nupper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnge_pd.html\" title=\"fn core::arch::x86::_mm_cmpnge_pd\">_mm_cmpnge_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for\nnot-greater-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnge_ps.html\" title=\"fn core::arch::x86::_mm_cmpnge_ps\">_mm_cmpnge_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is <strong>not</strong> greater than or equal to the corresponding element in <code>b</code>,\nor <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnge_sd.html\" title=\"fn core::arch::x86::_mm_cmpnge_sd\">_mm_cmpnge_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\nnot-greater-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnge_ss.html\" title=\"fn core::arch::x86::_mm_cmpnge_ss\">_mm_cmpnge_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for not-greater-than-or-equal. The\nlowest 32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not\ngreater than or equal to <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96\nbits of the result are the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpngt_pd.html\" title=\"fn core::arch::x86::_mm_cmpngt_pd\">_mm_cmpngt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for not-greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpngt_ps.html\" title=\"fn core::arch::x86::_mm_cmpngt_ps\">_mm_cmpngt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is <strong>not</strong> greater than the corresponding element in <code>b</code>, or <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpngt_sd.html\" title=\"fn core::arch::x86::_mm_cmpngt_sd\">_mm_cmpngt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\nnot-greater-than comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpngt_ss.html\" title=\"fn core::arch::x86::_mm_cmpngt_ss\">_mm_cmpngt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for not-greater-than. The lowest 32\nbits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not greater\nthan <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are\nthe upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnle_pd.html\" title=\"fn core::arch::x86::_mm_cmpnle_pd\">_mm_cmpnle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for not-less-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnle_ps.html\" title=\"fn core::arch::x86::_mm_cmpnle_ps\">_mm_cmpnle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is <strong>not</strong> less than or equal to the corresponding element in <code>b</code>, or\n<code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnle_sd.html\" title=\"fn core::arch::x86::_mm_cmpnle_sd\">_mm_cmpnle_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\nnot-less-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnle_ss.html\" title=\"fn core::arch::x86::_mm_cmpnle_ss\">_mm_cmpnle_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for not-less-than-or-equal. The\nlowest 32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not\nless than or equal to <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits\nof the result are the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnlt_pd.html\" title=\"fn core::arch::x86::_mm_cmpnlt_pd\">_mm_cmpnlt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> for not-less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnlt_ps.html\" title=\"fn core::arch::x86::_mm_cmpnlt_ps\">_mm_cmpnlt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nThe result in the output vector will be <code>0xffffffff</code> if the input element\nin <code>a</code> is <strong>not</strong> less than the corresponding element in <code>b</code>, or <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnlt_sd.html\" title=\"fn core::arch::x86::_mm_cmpnlt_sd\">_mm_cmpnlt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the\nnot-less-than comparison of the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpnlt_ss.html\" title=\"fn core::arch::x86::_mm_cmpnlt_ss\">_mm_cmpnlt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the lowest <code>f32</code> of both inputs for not-less-than. The lowest 32\nbits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not less than\n<code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are the\nupper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpord_pd.html\" title=\"fn core::arch::x86::_mm_cmpord_pd\">_mm_cmpord_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> to see if neither is <code>NaN</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpord_ps.html\" title=\"fn core::arch::x86::_mm_cmpord_ps\">_mm_cmpord_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nReturns four floats that have one of two possible bit patterns. The element\nin the output vector will be <code>0xffffffff</code> if the input elements in <code>a</code> and\n<code>b</code> are ordered (i.e., neither of them is a NaN), or 0 otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpord_sd.html\" title=\"fn core::arch::x86::_mm_cmpord_sd\">_mm_cmpord_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the result\nof comparing both of the lower elements of <code>a</code> and <code>b</code> to <code>NaN</code>. If\nneither are equal to <code>NaN</code> then <code>0xFFFFFFFFFFFFFFFF</code> is used and <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpord_ss.html\" title=\"fn core::arch::x86::_mm_cmpord_ss\">_mm_cmpord_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Checks if the lowest <code>f32</code> of both inputs are ordered. The lowest 32 bits of\nthe result will be <code>0xffffffff</code> if neither of <code>a.extract(0)</code> or\n<code>b.extract(0)</code> is a NaN, or <code>0</code> otherwise. The upper 96 bits of the result\nare the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpunord_pd.html\" title=\"fn core::arch::x86::_mm_cmpunord_pd\">_mm_cmpunord_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares corresponding elements in <code>a</code> and <code>b</code> to see if either is <code>NaN</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpunord_ps.html\" title=\"fn core::arch::x86::_mm_cmpunord_ps\">_mm_cmpunord_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.\nReturns four floats that have one of two possible bit patterns. The element\nin the output vector will be <code>0xffffffff</code> if the input elements in <code>a</code> and\n<code>b</code> are unordered (i.e., at least on of them is a NaN), or 0 otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpunord_sd.html\" title=\"fn core::arch::x86::_mm_cmpunord_sd\">_mm_cmpunord_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the result of\ncomparing both of the lower elements of <code>a</code> and <code>b</code> to <code>NaN</code>. If either is\nequal to <code>NaN</code> then <code>0xFFFFFFFFFFFFFFFF</code> is used and <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpunord_ss.html\" title=\"fn core::arch::x86::_mm_cmpunord_ss\">_mm_cmpunord_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Checks if the lowest <code>f32</code> of both inputs are unordered. The lowest 32 bits\nof the result will be <code>0xffffffff</code> if any of <code>a.extract(0)</code> or\n<code>b.extract(0)</code> is a NaN, or <code>0</code> otherwise. The upper 96 bits of the result\nare the upper 96 bits of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comieq_sd.html\" title=\"fn core::arch::x86::_mm_comieq_sd\">_mm_comieq_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comieq_ss.html\" title=\"fn core::arch::x86::_mm_comieq_ss\">_mm_comieq_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if they are equal, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comige_sd.html\" title=\"fn core::arch::x86::_mm_comige_sd\">_mm_comige_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for greater-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comige_ss.html\" title=\"fn core::arch::x86::_mm_comige_ss\">_mm_comige_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is greater than or equal to the one from <code>b</code>, or\n<code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comigt_sd.html\" title=\"fn core::arch::x86::_mm_comigt_sd\">_mm_comigt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comigt_ss.html\" title=\"fn core::arch::x86::_mm_comigt_ss\">_mm_comigt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is greater than the one from <code>b</code>, or <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comile_sd.html\" title=\"fn core::arch::x86::_mm_comile_sd\">_mm_comile_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for less-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comile_ss.html\" title=\"fn core::arch::x86::_mm_comile_ss\">_mm_comile_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is less than or equal to the one from <code>b</code>, or <code>0</code>\notherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comilt_sd.html\" title=\"fn core::arch::x86::_mm_comilt_sd\">_mm_comilt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comilt_ss.html\" title=\"fn core::arch::x86::_mm_comilt_ss\">_mm_comilt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is less than the one from <code>b</code>, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comineq_sd.html\" title=\"fn core::arch::x86::_mm_comineq_sd\">_mm_comineq_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for not-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comineq_ss.html\" title=\"fn core::arch::x86::_mm_comineq_ss\">_mm_comineq_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if they are <strong>not</strong> equal, or <code>0</code> otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_crc32_u8.html\" title=\"fn core::arch::x86::_mm_crc32_u8\">_mm_crc32_u8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Starting with the initial value in <code>crc</code>, return the accumulated\nCRC32-C value for unsigned 8-bit integer <code>v</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_crc32_u16.html\" title=\"fn core::arch::x86::_mm_crc32_u16\">_mm_crc32_u16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Starting with the initial value in <code>crc</code>, return the accumulated\nCRC32-C value for unsigned 16-bit integer <code>v</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_crc32_u32.html\" title=\"fn core::arch::x86::_mm_crc32_u32\">_mm_crc32_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.2` only\">(x86 or x86-64) and <code>sse4.2</code></span></div><div class=\"desc docblock-short\">Starting with the initial value in <code>crc</code>, return the accumulated\nCRC32-C value for unsigned 32-bit integer <code>v</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_si2ss.html\" title=\"fn core::arch::x86::_mm_cvt_si2ss\">_mm_cvt_si2ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Alias for <a href=\"fn._mm_cvtsi32_ss.html\"><code>_mm_cvtsi32_ss</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_ss2si.html\" title=\"fn core::arch::x86::_mm_cvt_ss2si\">_mm_cvt_ss2si</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Alias for <a href=\"fn._mm_cvtss_si32.html\"><code>_mm_cvtss_si32</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm_cvtepi8_epi16\">_mm_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in <code>a</code> to packed 16-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm_cvtepi8_epi32\">_mm_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in <code>a</code> to packed 32-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm_cvtepi8_epi64\">_mm_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 8 bytes of <code>a</code> to packed\n64-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm_cvtepi16_epi32\">_mm_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in <code>a</code> to packed 32-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm_cvtepi16_epi64\">_mm_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in <code>a</code> to packed 64-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm_cvtepi32_epi64\">_mm_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in <code>a</code> to packed 64-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm_cvtepi32_pd\">_mm_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts the lower two packed 32-bit integers in <code>a</code> to packed\ndouble-precision (64-bit) floating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm_cvtepi32_ps\">_mm_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers in <code>a</code> to packed single-precision (32-bit)\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm_cvtepu8_epi16\">_mm_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 8-bit integers in <code>a</code> to packed 16-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm_cvtepu8_epi32\">_mm_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 8-bit integers in <code>a</code> to packed 32-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm_cvtepu8_epi64\">_mm_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 8-bit integers in <code>a</code> to packed 64-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm_cvtepu16_epi32\">_mm_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 16-bit integers in <code>a</code>\nto packed 32-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm_cvtepu16_epi64\">_mm_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 16-bit integers in <code>a</code>\nto packed 64-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm_cvtepu32_epi64\">_mm_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Zeroes extend packed unsigned 32-bit integers in <code>a</code>\nto packed 64-bit integers</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm_cvtpd_epi32\">_mm_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed double-precision (64-bit) floating-point elements in <code>a</code> to\npacked 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm_cvtpd_ps\">_mm_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed double-precision (64-bit) floating-point elements in <code>a</code> to\npacked single-precision (32-bit) floating-point elements</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtph_ps.html\" title=\"fn core::arch::x86::_mm_cvtph_ps\">_mm_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `f16c` only\">(x86 or x86-64) and <code>f16c</code></span></div><div class=\"desc docblock-short\">Converts the 4 x 16-bit half-precision float values in the lowest 64-bit of\nthe 128-bit vector <code>a</code> into 4 x 32-bit float values stored in a 128-bit wide\nvector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm_cvtps_epi32\">_mm_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed single-precision (32-bit) floating-point elements in <code>a</code>\nto packed 32-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtps_pd.html\" title=\"fn core::arch::x86::_mm_cvtps_pd\">_mm_cvtps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed single-precision (32-bit) floating-point elements in <code>a</code> to\npacked\ndouble-precision (64-bit) floating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtps_ph.html\" title=\"fn core::arch::x86::_mm_cvtps_ph\">_mm_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `f16c` only\">(x86 or x86-64) and <code>f16c</code></span></div><div class=\"desc docblock-short\">Converts the 4 x 32-bit float values in the 128-bit vector <code>a</code> into 4 x\n16-bit half-precision float values stored in the lowest 64-bit of a 128-bit\nvector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsd_f64.html\" title=\"fn core::arch::x86::_mm_cvtsd_f64\">_mm_cvtsd_f64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns the lower double-precision (64-bit) floating-point element of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsd_si32.html\" title=\"fn core::arch::x86::_mm_cvtsd_si32\">_mm_cvtsd_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts the lower double-precision (64-bit) floating-point element in a to\na 32-bit integer.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsd_ss.html\" title=\"fn core::arch::x86::_mm_cvtsd_ss\">_mm_cvtsd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts the lower double-precision (64-bit) floating-point element in <code>b</code>\nto a single-precision (32-bit) floating-point element, store the result in\nthe lower element of the return value, and copies the upper element from <code>a</code>\nto the upper element the return value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsi32_sd.html\" title=\"fn core::arch::x86::_mm_cvtsi32_sd\">_mm_cvtsi32_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns <code>a</code> with its lower element replaced by <code>b</code> after converting it to\nan <code>f64</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsi32_si128.html\" title=\"fn core::arch::x86::_mm_cvtsi32_si128\">_mm_cvtsi32_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a vector whose lowest element is <code>a</code> and all higher elements are\n<code>0</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsi32_ss.html\" title=\"fn core::arch::x86::_mm_cvtsi32_ss\">_mm_cvtsi32_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Converts a 32 bit integer to a 32 bit float. The result vector is the input\nvector <code>a</code> with the lowest 32 bit float replaced by the converted integer.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsi128_si32.html\" title=\"fn core::arch::x86::_mm_cvtsi128_si32\">_mm_cvtsi128_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns the lowest element of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtss_f32.html\" title=\"fn core::arch::x86::_mm_cvtss_f32\">_mm_cvtss_f32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Extracts the lowest 32 bit float from the input vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtss_sd.html\" title=\"fn core::arch::x86::_mm_cvtss_sd\">_mm_cvtss_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts the lower single-precision (32-bit) floating-point element in <code>b</code>\nto a double-precision (64-bit) floating-point element, store the result in\nthe lower element of the return value, and copies the upper element from <code>a</code>\nto the upper element the return value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtss_si32.html\" title=\"fn core::arch::x86::_mm_cvtss_si32\">_mm_cvtss_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Converts the lowest 32 bit float in the input vector to a 32 bit integer.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_ss2si.html\" title=\"fn core::arch::x86::_mm_cvtt_ss2si\">_mm_cvtt_ss2si</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Alias for <a href=\"fn._mm_cvttss_si32.html\"><code>_mm_cvttss_si32</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm_cvttpd_epi32\">_mm_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed double-precision (64-bit) floating-point elements in <code>a</code> to\npacked 32-bit integers with truncation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm_cvttps_epi32\">_mm_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed single-precision (32-bit) floating-point elements in <code>a</code> to\npacked 32-bit integers with truncation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttsd_si32.html\" title=\"fn core::arch::x86::_mm_cvttsd_si32\">_mm_cvttsd_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts the lower double-precision (64-bit) floating-point element in <code>a</code>\nto a 32-bit integer with truncation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttss_si32.html\" title=\"fn core::arch::x86::_mm_cvttss_si32\">_mm_cvttss_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Converts the lowest 32 bit float in the input vector to a 32 bit integer\nwith\ntruncation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_div_pd.html\" title=\"fn core::arch::x86::_mm_div_pd\">_mm_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in <code>a</code> by\npacked elements in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_div_ps.html\" title=\"fn core::arch::x86::_mm_div_ps\">_mm_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Divides __m128 vectors.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_div_sd.html\" title=\"fn core::arch::x86::_mm_div_sd\">_mm_div_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the result of\ndiving the lower element of <code>a</code> by the lower element of <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_div_ss.html\" title=\"fn core::arch::x86::_mm_div_ss\">_mm_div_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Divides the first component of <code>b</code> by <code>a</code>, the other components are\ncopied from <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dp_pd.html\" title=\"fn core::arch::x86::_mm_dp_pd\">_mm_dp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Returns the dot product of two __m128d vectors.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dp_ps.html\" title=\"fn core::arch::x86::_mm_dp_ps\">_mm_dp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Returns the dot product of two __m128 vectors.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_extract_epi8.html\" title=\"fn core::arch::x86::_mm_extract_epi8\">_mm_extract_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Extracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. Returns a 32-bit\ninteger containing the zero-extended integer data.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_extract_epi16.html\" title=\"fn core::arch::x86::_mm_extract_epi16\">_mm_extract_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns the <code>imm8</code> element of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_extract_epi32.html\" title=\"fn core::arch::x86::_mm_extract_epi32\">_mm_extract_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Extracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_extract_ps.html\" title=\"fn core::arch::x86::_mm_extract_ps\">_mm_extract_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Extracts a single-precision (32-bit) floating-point element from <code>a</code>,\nselected with <code>IMM8</code>. The returned <code>i32</code> stores the float’s bit-pattern,\nand may be converted back to a floating point number via casting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_extract_si64.html\" title=\"fn core::arch::x86::_mm_extract_si64\">_mm_extract_si64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4a` only\">(x86 or x86-64) and <code>sse4a</code></span></div><div class=\"desc docblock-short\">Extracts the bit range specified by <code>y</code> from the lower 64 bits of <code>x</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_floor_pd.html\" title=\"fn core::arch::x86::_mm_floor_pd\">_mm_floor_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the packed double-precision (64-bit) floating-point elements in <code>a</code>\ndown to an integer value, and stores the results as packed double-precision\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_floor_ps.html\" title=\"fn core::arch::x86::_mm_floor_ps\">_mm_floor_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the packed single-precision (32-bit) floating-point elements in <code>a</code>\ndown to an integer value, and stores the results as packed single-precision\nfloating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_floor_sd.html\" title=\"fn core::arch::x86::_mm_floor_sd\">_mm_floor_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in <code>b</code>\ndown to an integer value, store the result as a double-precision\nfloating-point element in the lower element of the intrinsic result,\nand copies the upper element from <code>a</code> to the upper element of the intrinsic\nresult.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_floor_ss.html\" title=\"fn core::arch::x86::_mm_floor_ss\">_mm_floor_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in <code>b</code>\ndown to an integer value, store the result as a single-precision\nfloating-point element in the lower element of the intrinsic result,\nand copies the upper 3 packed elements from <code>a</code> to the upper elements\nof the intrinsic result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmadd_pd.html\" title=\"fn core::arch::x86::_mm_fmadd_pd\">_mm_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmadd_ps.html\" title=\"fn core::arch::x86::_mm_fmadd_ps\">_mm_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmadd_sd.html\" title=\"fn core::arch::x86::_mm_fmadd_sd\">_mm_fmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower double-precision (64-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and add the intermediate result to the lower element in <code>c</code>.\nStores the result in the lower element of the returned value, and copy the\nupper element from <code>a</code> to the upper elements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmadd_ss.html\" title=\"fn core::arch::x86::_mm_fmadd_ss\">_mm_fmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower single-precision (32-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and add the intermediate result to the lower element in <code>c</code>.\nStores the result in the lower element of the returned value, and copy the\n3 upper elements from <code>a</code> to the upper elements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm_fmaddsub_pd\">_mm_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm_fmaddsub_ps\">_mm_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsub_pd.html\" title=\"fn core::arch::x86::_mm_fmsub_pd\">_mm_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsub_ps.html\" title=\"fn core::arch::x86::_mm_fmsub_ps\">_mm_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsub_sd.html\" title=\"fn core::arch::x86::_mm_fmsub_sd\">_mm_fmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower double-precision (64-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and subtract the lower element in <code>c</code> from the intermediate\nresult. Store the result in the lower element of the returned value, and\ncopy the upper element from <code>a</code> to the upper elements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsub_ss.html\" title=\"fn core::arch::x86::_mm_fmsub_ss\">_mm_fmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower single-precision (32-bit) floating-point elements in\n<code>a</code> and <code>b</code>,  and subtract the lower element in <code>c</code> from the intermediate\nresult. Store the result in the lower element of the returned value, and\ncopy the 3 upper elements from <code>a</code> to the upper elements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm_fmsubadd_pd\">_mm_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm_fmsubadd_ps\">_mm_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to\nthe intermediate result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm_fnmadd_pd\">_mm_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm_fnmadd_ps\">_mm_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmadd_sd.html\" title=\"fn core::arch::x86::_mm_fnmadd_sd\">_mm_fnmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower double-precision (64-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and add the negated intermediate result to the lower element\nin <code>c</code>. Store the result in the lower element of the returned value, and\ncopy the upper element from <code>a</code> to the upper elements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmadd_ss.html\" title=\"fn core::arch::x86::_mm_fnmadd_ss\">_mm_fnmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower single-precision (32-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and add the negated intermediate result to the lower element\nin <code>c</code>. Store the result in the lower element of the returned value, and\ncopy the 3 upper elements from <code>a</code> to the upper elements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm_fnmsub_pd\">_mm_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate\nresult.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm_fnmsub_ps\">_mm_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>\nand <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate\nresult.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmsub_sd.html\" title=\"fn core::arch::x86::_mm_fnmsub_sd\">_mm_fnmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower double-precision (64-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and subtract packed elements in <code>c</code> from the negated\nintermediate result. Store the result in the lower element of the returned\nvalue, and copy the upper element from <code>a</code> to the upper elements of the\nresult.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmsub_ss.html\" title=\"fn core::arch::x86::_mm_fnmsub_ss\">_mm_fnmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `fma` only\">(x86 or x86-64) and <code>fma</code></span></div><div class=\"desc docblock-short\">Multiplies the lower single-precision (32-bit) floating-point elements in\n<code>a</code> and <code>b</code>, and subtract packed elements in <code>c</code> from the negated\nintermediate result. Store the result in the lower element of the\nreturned value, and copy the 3 upper elements from <code>a</code> to the upper\nelements of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getcsr.html\" title=\"fn core::arch::x86::_mm_getcsr\">_mm_getcsr</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Gets the unsigned 32-bit value of the MXCSR control and status register.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hadd_epi16.html\" title=\"fn core::arch::x86::_mm_hadd_epi16\">_mm_hadd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Horizontally adds the adjacent pairs of values contained in 2 packed\n128-bit vectors of <code>[8 x i16]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hadd_epi32.html\" title=\"fn core::arch::x86::_mm_hadd_epi32\">_mm_hadd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Horizontally adds the adjacent pairs of values contained in 2 packed\n128-bit vectors of <code>[4 x i32]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hadd_pd.html\" title=\"fn core::arch::x86::_mm_hadd_pd\">_mm_hadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Horizontally adds adjacent pairs of double-precision (64-bit)\nfloating-point elements in <code>a</code> and <code>b</code>, and pack the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hadd_ps.html\" title=\"fn core::arch::x86::_mm_hadd_ps\">_mm_hadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Horizontally adds adjacent pairs of single-precision (32-bit)\nfloating-point elements in <code>a</code> and <code>b</code>, and pack the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hadds_epi16.html\" title=\"fn core::arch::x86::_mm_hadds_epi16\">_mm_hadds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Horizontally adds the adjacent pairs of values contained in 2 packed\n128-bit vectors of <code>[8 x i16]</code>. Positive sums greater than 7FFFh are\nsaturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hsub_epi16.html\" title=\"fn core::arch::x86::_mm_hsub_epi16\">_mm_hsub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Horizontally subtract the adjacent pairs of values contained in 2\npacked 128-bit vectors of <code>[8 x i16]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hsub_epi32.html\" title=\"fn core::arch::x86::_mm_hsub_epi32\">_mm_hsub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Horizontally subtract the adjacent pairs of values contained in 2\npacked 128-bit vectors of <code>[4 x i32]</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hsub_pd.html\" title=\"fn core::arch::x86::_mm_hsub_pd\">_mm_hsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Horizontally subtract adjacent pairs of double-precision (64-bit)\nfloating-point elements in <code>a</code> and <code>b</code>, and pack the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hsub_ps.html\" title=\"fn core::arch::x86::_mm_hsub_ps\">_mm_hsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Horizontally adds adjacent pairs of single-precision (32-bit)\nfloating-point elements in <code>a</code> and <code>b</code>, and pack the results.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_hsubs_epi16.html\" title=\"fn core::arch::x86::_mm_hsubs_epi16\">_mm_hsubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Horizontally subtract the adjacent pairs of values contained in 2\npacked 128-bit vectors of <code>[8 x i16]</code>. Positive differences greater than\n7FFFh are saturated to 7FFFh. Negative differences less than 8000h are\nsaturated to 8000h.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i32gather_epi32.html\" title=\"fn core::arch::x86::_mm_i32gather_epi32\">_mm_i32gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i32gather_epi64.html\" title=\"fn core::arch::x86::_mm_i32gather_epi64\">_mm_i32gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i32gather_pd.html\" title=\"fn core::arch::x86::_mm_i32gather_pd\">_mm_i32gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i32gather_ps.html\" title=\"fn core::arch::x86::_mm_i32gather_ps\">_mm_i32gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i64gather_epi32.html\" title=\"fn core::arch::x86::_mm_i64gather_epi32\">_mm_i64gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i64gather_epi64.html\" title=\"fn core::arch::x86::_mm_i64gather_epi64\">_mm_i64gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i64gather_pd.html\" title=\"fn core::arch::x86::_mm_i64gather_pd\">_mm_i64gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_i64gather_ps.html\" title=\"fn core::arch::x86::_mm_i64gather_ps\">_mm_i64gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_insert_epi8.html\" title=\"fn core::arch::x86::_mm_insert_epi8\">_mm_insert_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Returns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted at a\nlocation specified by <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_insert_epi16.html\" title=\"fn core::arch::x86::_mm_insert_epi16\">_mm_insert_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector where the <code>imm8</code> element of <code>a</code> is replaced with <code>i</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_insert_epi32.html\" title=\"fn core::arch::x86::_mm_insert_epi32\">_mm_insert_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Returns a copy of <code>a</code> with the 32-bit integer from <code>i</code> inserted at a\nlocation specified by <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_insert_ps.html\" title=\"fn core::arch::x86::_mm_insert_ps\">_mm_insert_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Select a single value in <code>b</code> to store at some position in <code>a</code>,\nThen zero elements according to <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_insert_si64.html\" title=\"fn core::arch::x86::_mm_insert_si64\">_mm_insert_si64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4a` only\">(x86 or x86-64) and <code>sse4a</code></span></div><div class=\"desc docblock-short\">Inserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_lddqu_si128.html\" title=\"fn core::arch::x86::_mm_lddqu_si128\">_mm_lddqu_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Loads 128-bits of integer data from unaligned memory.\nThis intrinsic may perform better than <code>_mm_loadu_si128</code>\nwhen the data crosses a cache line boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_lfence.html\" title=\"fn core::arch::x86::_mm_lfence\">_mm_lfence</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Performs a serializing operation on all load-from-memory instructions\nthat were issued prior to this instruction.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load1_pd.html\" title=\"fn core::arch::x86::_mm_load1_pd\">_mm_load1_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads a double-precision (64-bit) floating-point element from memory\ninto both elements of returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load1_ps.html\" title=\"fn core::arch::x86::_mm_load1_ps\">_mm_load1_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> by duplicating the value read from <code>p</code> into all\nelements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_pd.html\" title=\"fn core::arch::x86::_mm_load_pd\">_mm_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads 128-bits (composed of 2 packed double-precision (64-bit)\nfloating-point elements) from memory into the returned vector.\n<code>mem_addr</code> must be aligned on a 16-byte boundary or a general-protection\nexception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_pd1.html\" title=\"fn core::arch::x86::_mm_load_pd1\">_mm_load_pd1</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads a double-precision (64-bit) floating-point element from memory\ninto both elements of returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_ps.html\" title=\"fn core::arch::x86::_mm_load_ps\">_mm_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Loads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. If the\npointer is not aligned to a 128-bit boundary (16 bytes) a general\nprotection fault will be triggered (fatal program crash).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_ps1.html\" title=\"fn core::arch::x86::_mm_load_ps1\">_mm_load_ps1</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Alias for <a href=\"fn._mm_load1_ps.html\"><code>_mm_load1_ps</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_sd.html\" title=\"fn core::arch::x86::_mm_load_sd\">_mm_load_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads a 64-bit double-precision value to the low element of a\n128-bit integer vector and clears the upper element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_si128.html\" title=\"fn core::arch::x86::_mm_load_si128\">_mm_load_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads 128-bits of integer data from memory into a new vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_ss.html\" title=\"fn core::arch::x86::_mm_load_ss\">_mm_load_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> with the lowest element read from <code>p</code> and the other\nelements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loaddup_pd.html\" title=\"fn core::arch::x86::_mm_loaddup_pd\">_mm_loaddup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Loads a double-precision (64-bit) floating-point element from memory\ninto both elements of return vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadh_pd.html\" title=\"fn core::arch::x86::_mm_loadh_pd\">_mm_loadh_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads a double-precision value into the high-order bits of a 128-bit\nvector of <code>[2 x double]</code>. The low-order bits are copied from the low-order\nbits of the first operand.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadl_epi64.html\" title=\"fn core::arch::x86::_mm_loadl_epi64\">_mm_loadl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads 64-bit integer from memory into first element of returned vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadl_pd.html\" title=\"fn core::arch::x86::_mm_loadl_pd\">_mm_loadl_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads a double-precision value into the low-order bits of a 128-bit\nvector of <code>[2 x double]</code>. The high-order bits are copied from the\nhigh-order bits of the first operand.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadr_pd.html\" title=\"fn core::arch::x86::_mm_loadr_pd\">_mm_loadr_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads 2 double-precision (64-bit) floating-point elements from memory into\nthe returned vector in reverse order. <code>mem_addr</code> must be aligned on a\n16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadr_ps.html\" title=\"fn core::arch::x86::_mm_loadr_ps\">_mm_loadr_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Loads four <code>f32</code> values from aligned memory into a <code>__m128</code> in reverse\norder.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_pd.html\" title=\"fn core::arch::x86::_mm_loadu_pd\">_mm_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads 128-bits (composed of 2 packed double-precision (64-bit)\nfloating-point elements) from memory into the returned vector.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_ps.html\" title=\"fn core::arch::x86::_mm_loadu_ps\">_mm_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Loads four <code>f32</code> values from memory into a <code>__m128</code>. There are no\nrestrictions\non memory alignment. For aligned memory\n<a href=\"fn._mm_load_ps.html\"><code>_mm_load_ps</code></a>\nmay be faster.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_si64.html\" title=\"fn core::arch::x86::_mm_loadu_si64\">_mm_loadu_si64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Loads unaligned 64-bits of integer data from memory into new vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_si128.html\" title=\"fn core::arch::x86::_mm_loadu_si128\">_mm_loadu_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Loads 128-bits of integer data from memory into a new vector.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_madd_epi16.html\" title=\"fn core::arch::x86::_mm_madd_epi16\">_mm_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Multiplies and then horizontally add signed 16 bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm_maddubs_epi16\">_mm_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Multiplies corresponding pairs of packed 8-bit unsigned integer\nvalues contained in the first source operand and packed 8-bit signed\ninteger values contained in the second source operand, add pairs of\ncontiguous products with signed saturation, and writes the 16-bit sums to\nthe corresponding bits in the destination.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i32gather_epi32.html\" title=\"fn core::arch::x86::_mm_mask_i32gather_epi32\">_mm_mask_i32gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i32gather_epi64.html\" title=\"fn core::arch::x86::_mm_mask_i32gather_epi64\">_mm_mask_i32gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i32gather_pd.html\" title=\"fn core::arch::x86::_mm_mask_i32gather_pd\">_mm_mask_i32gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i32gather_ps.html\" title=\"fn core::arch::x86::_mm_mask_i32gather_ps\">_mm_mask_i32gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i64gather_epi32.html\" title=\"fn core::arch::x86::_mm_mask_i64gather_epi32\">_mm_mask_i64gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i64gather_epi64.html\" title=\"fn core::arch::x86::_mm_mask_i64gather_epi64\">_mm_mask_i64gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i64gather_pd.html\" title=\"fn core::arch::x86::_mm_mask_i64gather_pd\">_mm_mask_i64gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_i64gather_ps.html\" title=\"fn core::arch::x86::_mm_mask_i64gather_ps\">_mm_mask_i64gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,\nwhere\n<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in\nthat position instead.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskload_epi32.html\" title=\"fn core::arch::x86::_mm_maskload_epi32\">_mm_maskload_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Loads packed 32-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>\n(elements are zeroed out when the highest bit is not set in the\ncorresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskload_epi64.html\" title=\"fn core::arch::x86::_mm_maskload_epi64\">_mm_maskload_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Loads packed 64-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>\n(elements are zeroed out when the highest bit is not set in the\ncorresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskload_pd.html\" title=\"fn core::arch::x86::_mm_maskload_pd\">_mm_maskload_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads packed double-precision (64-bit) floating-point elements from memory\ninto result using <code>mask</code> (elements are zeroed out when the high bit of the\ncorresponding element is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskload_ps.html\" title=\"fn core::arch::x86::_mm_maskload_ps\">_mm_maskload_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Loads packed single-precision (32-bit) floating-point elements from memory\ninto result using <code>mask</code> (elements are zeroed out when the high bit of the\ncorresponding element is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskmoveu_si128.html\" title=\"fn core::arch::x86::_mm_maskmoveu_si128\">_mm_maskmoveu_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Conditionally store 8-bit integer elements from <code>a</code> into memory using\n<code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskstore_epi32.html\" title=\"fn core::arch::x86::_mm_maskstore_epi32\">_mm_maskstore_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Stores packed 32-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>\nusing <code>mask</code> (elements are not stored when the highest bit is not set\nin the corresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskstore_epi64.html\" title=\"fn core::arch::x86::_mm_maskstore_epi64\">_mm_maskstore_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Stores packed 64-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>\nusing <code>mask</code> (elements are not stored when the highest bit is not set\nin the corresponding element).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskstore_pd.html\" title=\"fn core::arch::x86::_mm_maskstore_pd\">_mm_maskstore_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores packed double-precision (64-bit) floating-point elements from <code>a</code>\ninto memory using <code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskstore_ps.html\" title=\"fn core::arch::x86::_mm_maskstore_ps\">_mm_maskstore_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Stores packed single-precision (32-bit) floating-point elements from <code>a</code>\ninto memory using <code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epi8.html\" title=\"fn core::arch::x86::_mm_max_epi8\">_mm_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> and returns packed maximum\nvalues in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epi16.html\" title=\"fn core::arch::x86::_mm_max_epi16\">_mm_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nmaximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epi32.html\" title=\"fn core::arch::x86::_mm_max_epi32\">_mm_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns packed maximum\nvalues.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epu8.html\" title=\"fn core::arch::x86::_mm_max_epu8\">_mm_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns the\npacked maximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epu16.html\" title=\"fn core::arch::x86::_mm_max_epu16\">_mm_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns packed\nmaximum.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epu32.html\" title=\"fn core::arch::x86::_mm_max_epu32\">_mm_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns packed\nmaximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_pd.html\" title=\"fn core::arch::x86::_mm_max_pd\">_mm_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the maximum values from corresponding elements in\n<code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_ps.html\" title=\"fn core::arch::x86::_mm_max_ps\">_mm_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares packed single-precision (32-bit) floating-point elements in <code>a</code> and\n<code>b</code>, and return the corresponding maximum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_sd.html\" title=\"fn core::arch::x86::_mm_max_sd\">_mm_max_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the maximum\nof the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_ss.html\" title=\"fn core::arch::x86::_mm_max_ss\">_mm_max_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the first single-precision (32-bit) floating-point element of <code>a</code>\nand <code>b</code>, and return the maximum value in the first element of the return\nvalue, the other elements are copied from <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mfence.html\" title=\"fn core::arch::x86::_mm_mfence\">_mm_mfence</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Performs a serializing operation on all load-from-memory and store-to-memory\ninstructions that were issued prior to this instruction.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epi8.html\" title=\"fn core::arch::x86::_mm_min_epi8\">_mm_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed 8-bit integers in <code>a</code> and <code>b</code> and returns packed minimum\nvalues in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epi16.html\" title=\"fn core::arch::x86::_mm_min_epi16\">_mm_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed\nminimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epi32.html\" title=\"fn core::arch::x86::_mm_min_epi32\">_mm_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns packed minimum\nvalues.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epu8.html\" title=\"fn core::arch::x86::_mm_min_epu8\">_mm_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns the\npacked minimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epu16.html\" title=\"fn core::arch::x86::_mm_min_epu16\">_mm_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns packed\nminimum.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epu32.html\" title=\"fn core::arch::x86::_mm_min_epu32\">_mm_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns packed\nminimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_pd.html\" title=\"fn core::arch::x86::_mm_min_pd\">_mm_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the minimum values from corresponding elements in\n<code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_ps.html\" title=\"fn core::arch::x86::_mm_min_ps\">_mm_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares packed single-precision (32-bit) floating-point elements in <code>a</code> and\n<code>b</code>, and return the corresponding minimum values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_sd.html\" title=\"fn core::arch::x86::_mm_min_sd\">_mm_min_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the minimum\nof the lower elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_ss.html\" title=\"fn core::arch::x86::_mm_min_ss\">_mm_min_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares the first single-precision (32-bit) floating-point element of <code>a</code>\nand <code>b</code>, and return the minimum value in the first element of the return\nvalue, the other elements are copied from <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_minpos_epu16.html\" title=\"fn core::arch::x86::_mm_minpos_epu16\">_mm_minpos_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Finds the minimum unsigned 16-bit element in the 128-bit __m128i vector,\nreturning a vector containing its value in its first position, and its\nindex\nin its second position; all other elements are set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_move_epi64.html\" title=\"fn core::arch::x86::_mm_move_epi64\">_mm_move_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a vector where the low element is extracted from <code>a</code> and its upper\nelement is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_move_sd.html\" title=\"fn core::arch::x86::_mm_move_sd\">_mm_move_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Constructs a 128-bit floating-point vector of <code>[2 x double]</code>. The lower\n64 bits are set to the lower 64 bits of the second parameter. The upper\n64 bits are set to the upper 64 bits of the first parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_move_ss.html\" title=\"fn core::arch::x86::_mm_move_ss\">_mm_move_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns a <code>__m128</code> with the first component from <code>b</code> and the remaining\ncomponents from <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movedup_pd.html\" title=\"fn core::arch::x86::_mm_movedup_pd\">_mm_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Duplicate the low double-precision (64-bit) floating-point element\nfrom <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movehdup_ps.html\" title=\"fn core::arch::x86::_mm_movehdup_ps\">_mm_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements\nfrom <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movehl_ps.html\" title=\"fn core::arch::x86::_mm_movehl_ps\">_mm_movehl_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Combine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> occupies the\nlower half of result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_moveldup_ps.html\" title=\"fn core::arch::x86::_mm_moveldup_ps\">_mm_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse3` only\">(x86 or x86-64) and <code>sse3</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements\nfrom <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movelh_ps.html\" title=\"fn core::arch::x86::_mm_movelh_ps\">_mm_movelh_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Combine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> occupies the\nhigher half of result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movemask_epi8.html\" title=\"fn core::arch::x86::_mm_movemask_epi8\">_mm_movemask_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a mask of the most significant bit of each element in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movemask_pd.html\" title=\"fn core::arch::x86::_mm_movemask_pd\">_mm_movemask_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a mask of the most significant bit of each element in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movemask_ps.html\" title=\"fn core::arch::x86::_mm_movemask_ps\">_mm_movemask_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns a mask of the most significant bit of each element in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mpsadbw_epu8.html\" title=\"fn core::arch::x86::_mm_mpsadbw_epu8\">_mm_mpsadbw_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Subtracts 8-bit unsigned integer values and computes the absolute\nvalues of the differences to the corresponding bits in the destination.\nThen sums of the absolute differences are returned according to the bit\nfields in the immediate operand.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_epi32.html\" title=\"fn core::arch::x86::_mm_mul_epi32\">_mm_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Multiplies the low 32-bit integers from each packed 64-bit\nelement in <code>a</code> and <code>b</code>, and returns the signed 64-bit result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_epu32.html\" title=\"fn core::arch::x86::_mm_mul_epu32\">_mm_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Multiplies the low unsigned 32-bit integers from each packed 64-bit element\nin <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_pd.html\" title=\"fn core::arch::x86::_mm_mul_pd\">_mm_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>\nand <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_ps.html\" title=\"fn core::arch::x86::_mm_mul_ps\">_mm_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Multiplies __m128 vectors.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_sd.html\" title=\"fn core::arch::x86::_mm_mul_sd\">_mm_mul_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by multiplying the\nlow elements of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_ss.html\" title=\"fn core::arch::x86::_mm_mul_ss\">_mm_mul_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Multiplies the first component of <code>a</code> and <code>b</code>, the other components are\ncopied from <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm_mulhi_epi16\">_mm_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm_mulhi_epu16\">_mm_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm_mulhrs_epi16\">_mm_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Multiplies packed 16-bit signed integer values, truncate the 32-bit\nproduct to the 18 most significant bits by right-shifting, round the\ntruncated value by adding 1, and write bits <code>[16:1]</code> to the destination.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mullo_epi16.html\" title=\"fn core::arch::x86::_mm_mullo_epi16\">_mm_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mullo_epi32.html\" title=\"fn core::arch::x86::_mm_mullo_epi32\">_mm_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Multiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing intermediate\n64-bit integers, and returns the lowest 32-bit, whatever they might be,\nreinterpreted as a signed integer. While <code>pmulld __m128i::splat(2), __m128i::splat(2)</code> returns the obvious <code>__m128i::splat(4)</code>, due to wrapping\narithmetic <code>pmulld __m128i::splat(i32::MAX), __m128i::splat(2)</code> would\nreturn a negative number.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_or_pd.html\" title=\"fn core::arch::x86::_mm_or_pd\">_mm_or_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise OR of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_or_ps.html\" title=\"fn core::arch::x86::_mm_or_ps\">_mm_or_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Bitwise OR of packed single-precision (32-bit) floating-point elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_or_si128.html\" title=\"fn core::arch::x86::_mm_or_si128\">_mm_or_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise OR of 128 bits (representing integer data) in <code>a</code> and\n<code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_packs_epi16.html\" title=\"fn core::arch::x86::_mm_packs_epi16\">_mm_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers\nusing signed saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_packs_epi32.html\" title=\"fn core::arch::x86::_mm_packs_epi32\">_mm_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers\nusing signed saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_packus_epi16.html\" title=\"fn core::arch::x86::_mm_packus_epi16\">_mm_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers\nusing unsigned saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_packus_epi32.html\" title=\"fn core::arch::x86::_mm_packus_epi32\">_mm_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers\nusing unsigned saturation</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_pause.html\" title=\"fn core::arch::x86::_mm_pause\">_mm_pause</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Provides a hint to the processor that the code sequence is a spin-wait loop.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permute_pd.html\" title=\"fn core::arch::x86::_mm_permute_pd\">_mm_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse2` only\">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class=\"desc docblock-short\">Shuffles double-precision (64-bit) floating-point elements in <code>a</code>\nusing the control in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permute_ps.html\" title=\"fn core::arch::x86::_mm_permute_ps\">_mm_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx,sse` only\">(x86 or x86-64) and <code>avx,sse</code></span></div><div class=\"desc docblock-short\">Shuffles single-precision (32-bit) floating-point elements in <code>a</code>\nusing the control in <code>imm8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutevar_pd.html\" title=\"fn core::arch::x86::_mm_permutevar_pd\">_mm_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles double-precision (64-bit) floating-point elements in <code>a</code>\nusing the control in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutevar_ps.html\" title=\"fn core::arch::x86::_mm_permutevar_ps\">_mm_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Shuffles single-precision (32-bit) floating-point elements in <code>a</code>\nusing the control in <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_prefetch.html\" title=\"fn core::arch::x86::_mm_prefetch\">_mm_prefetch</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Fetch the cache line that contains address <code>p</code> using the given <code>STRATEGY</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rcp_ps.html\" title=\"fn core::arch::x86::_mm_rcp_ps\">_mm_rcp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns the approximate reciprocal of packed single-precision (32-bit)\nfloating-point elements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rcp_ss.html\" title=\"fn core::arch::x86::_mm_rcp_ss\">_mm_rcp_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns the approximate reciprocal of the first single-precision\n(32-bit) floating-point element in <code>a</code>, the other elements are unchanged.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_round_pd.html\" title=\"fn core::arch::x86::_mm_round_pd\">_mm_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the packed double-precision (64-bit) floating-point elements in <code>a</code>\nusing the <code>ROUNDING</code> parameter, and stores the results as packed\ndouble-precision floating-point elements.\nRounding is done according to the rounding parameter, which can be one of:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_round_ps.html\" title=\"fn core::arch::x86::_mm_round_ps\">_mm_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the packed single-precision (32-bit) floating-point elements in <code>a</code>\nusing the <code>ROUNDING</code> parameter, and stores the results as packed\nsingle-precision floating-point elements.\nRounding is done according to the rounding parameter, which can be one of:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_round_sd.html\" title=\"fn core::arch::x86::_mm_round_sd\">_mm_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in <code>b</code>\nusing the <code>ROUNDING</code> parameter, store the result as a double-precision\nfloating-point element in the lower element of the intrinsic result,\nand copies the upper element from <code>a</code> to the upper element of the intrinsic\nresult.\nRounding is done according to the rounding parameter, which can be one of:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_round_ss.html\" title=\"fn core::arch::x86::_mm_round_ss\">_mm_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in <code>b</code>\nusing the <code>ROUNDING</code> parameter, store the result as a single-precision\nfloating-point element in the lower element of the intrinsic result,\nand copies the upper 3 packed elements from <code>a</code> to the upper elements\nof the intrinsic result.\nRounding is done according to the rounding parameter, which can be one of:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rsqrt_ps.html\" title=\"fn core::arch::x86::_mm_rsqrt_ps\">_mm_rsqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns the approximate reciprocal square root of packed single-precision\n(32-bit) floating-point elements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rsqrt_ss.html\" title=\"fn core::arch::x86::_mm_rsqrt_ss\">_mm_rsqrt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns the approximate reciprocal square root of the first single-precision\n(32-bit) floating-point element in <code>a</code>, the other elements are unchanged.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sad_epu8.html\" title=\"fn core::arch::x86::_mm_sad_epu8\">_mm_sad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sum the absolute differences of packed unsigned 8-bit integers.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set1_epi8.html\" title=\"fn core::arch::x86::_mm_set1_epi8\">_mm_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Broadcasts 8-bit integer <code>a</code> to all elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set1_epi16.html\" title=\"fn core::arch::x86::_mm_set1_epi16\">_mm_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Broadcasts 16-bit integer <code>a</code> to all elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set1_epi32.html\" title=\"fn core::arch::x86::_mm_set1_epi32\">_mm_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Broadcasts 32-bit integer <code>a</code> to all elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set1_epi64x.html\" title=\"fn core::arch::x86::_mm_set1_epi64x\">_mm_set1_epi64x</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Broadcasts 64-bit integer <code>a</code> to all elements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set1_pd.html\" title=\"fn core::arch::x86::_mm_set1_pd\">_mm_set1_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Broadcasts double-precision (64-bit) floating-point value a to all elements\nof the return value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set1_ps.html\" title=\"fn core::arch::x86::_mm_set1_ps\">_mm_set1_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> with all element set to <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_epi8.html\" title=\"fn core::arch::x86::_mm_set_epi8\">_mm_set_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 8-bit integers with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_epi16.html\" title=\"fn core::arch::x86::_mm_set_epi16\">_mm_set_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 16-bit integers with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_epi32.html\" title=\"fn core::arch::x86::_mm_set_epi32\">_mm_set_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_epi64x.html\" title=\"fn core::arch::x86::_mm_set_epi64x\">_mm_set_epi64x</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 64-bit integers with the supplied values, from highest to\nlowest.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_pd.html\" title=\"fn core::arch::x86::_mm_set_pd\">_mm_set_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed double-precision (64-bit) floating-point elements in the return\nvalue with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_pd1.html\" title=\"fn core::arch::x86::_mm_set_pd1\">_mm_set_pd1</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Broadcasts double-precision (64-bit) floating-point value a to all elements\nof the return value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_ps.html\" title=\"fn core::arch::x86::_mm_set_ps\">_mm_set_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> from four floating point values highest to lowest.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_ps1.html\" title=\"fn core::arch::x86::_mm_set_ps1\">_mm_set_ps1</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Alias for <a href=\"fn._mm_set1_ps.html\"><code>_mm_set1_ps</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_sd.html\" title=\"fn core::arch::x86::_mm_set_sd\">_mm_set_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Copies double-precision (64-bit) floating-point element <code>a</code> to the lower\nelement of the packed 64-bit return value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_set_ss.html\" title=\"fn core::arch::x86::_mm_set_ss\">_mm_set_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> with the lowest element set to <code>a</code> and the rest set to\nzero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setcsr.html\" title=\"fn core::arch::x86::_mm_setcsr\">_mm_setcsr</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab deprecated\" title=\"\">Deprecated</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Sets the MXCSR register with the 32-bit unsigned integer value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setr_epi8.html\" title=\"fn core::arch::x86::_mm_setr_epi8\">_mm_setr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 8-bit integers with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setr_epi16.html\" title=\"fn core::arch::x86::_mm_setr_epi16\">_mm_setr_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 16-bit integers with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setr_epi32.html\" title=\"fn core::arch::x86::_mm_setr_epi32\">_mm_setr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setr_pd.html\" title=\"fn core::arch::x86::_mm_setr_pd\">_mm_setr_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Sets packed double-precision (64-bit) floating-point elements in the return\nvalue with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setr_ps.html\" title=\"fn core::arch::x86::_mm_setr_ps\">_mm_setr_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> from four floating point values lowest to highest.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setzero_pd.html\" title=\"fn core::arch::x86::_mm_setzero_pd\">_mm_setzero_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns packed double-precision (64-bit) floating-point elements with all\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setzero_ps.html\" title=\"fn core::arch::x86::_mm_setzero_ps\">_mm_setzero_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Construct a <code>__m128</code> with all elements initialized to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_setzero_si128.html\" title=\"fn core::arch::x86::_mm_setzero_si128\">_mm_setzero_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a vector with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sfence.html\" title=\"fn core::arch::x86::_mm_sfence\">_mm_sfence</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Performs a serializing operation on all non-temporal (“streaming”) store instructions that\nwere issued by the current thread prior to this instruction.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha1msg1_epu32.html\" title=\"fn core::arch::x86::_mm_sha1msg1_epu32\">_mm_sha1msg1_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Performs an intermediate calculation for the next four SHA1 message values\n(unsigned 32-bit integers) using previous message values from <code>a</code> and <code>b</code>,\nand returning the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha1msg2_epu32.html\" title=\"fn core::arch::x86::_mm_sha1msg2_epu32\">_mm_sha1msg2_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Performs the final calculation for the next four SHA1 message values\n(unsigned 32-bit integers) using the intermediate result in <code>a</code> and the\nprevious message values in <code>b</code>, and returns the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha1nexte_epu32.html\" title=\"fn core::arch::x86::_mm_sha1nexte_epu32\">_mm_sha1nexte_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Calculate SHA1 state variable E after four rounds of operation from the\ncurrent SHA1 state variable <code>a</code>, add that value to the scheduled values\n(unsigned 32-bit integers) in <code>b</code>, and returns the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha1rnds4_epu32.html\" title=\"fn core::arch::x86::_mm_sha1rnds4_epu32\">_mm_sha1rnds4_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D)\nfrom <code>a</code> and some pre-computed sum of the next 4 round message values\n(unsigned 32-bit integers), and state variable E from <code>b</code>, and return the\nupdated SHA1 state (A,B,C,D). <code>FUNC</code> contains the logic functions and round\nconstants.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha256msg1_epu32.html\" title=\"fn core::arch::x86::_mm_sha256msg1_epu32\">_mm_sha256msg1_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Performs an intermediate calculation for the next four SHA256 message values\n(unsigned 32-bit integers) using previous message values from <code>a</code> and <code>b</code>,\nand return the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha256msg2_epu32.html\" title=\"fn core::arch::x86::_mm_sha256msg2_epu32\">_mm_sha256msg2_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Performs the final calculation for the next four SHA256 message values\n(unsigned 32-bit integers) using previous message values from <code>a</code> and <code>b</code>,\nand return the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sha256rnds2_epu32.html\" title=\"fn core::arch::x86::_mm_sha256rnds2_epu32\">_mm_sha256rnds2_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sha` only\">(x86 or x86-64) and <code>sha</code></span></div><div class=\"desc docblock-short\">Performs 2 rounds of SHA256 operation using an initial SHA256 state\n(C,D,G,H) from <code>a</code>, an initial SHA256 state (A,B,E,F) from <code>b</code>, and a\npre-computed sum of the next 2 round message values (unsigned 32-bit\nintegers) and the corresponding round constants from <code>k</code>, and store the\nupdated SHA256 state (A,B,E,F) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm_shuffle_epi8\">_mm_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Shuffles bytes from <code>a</code> according to the content of <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm_shuffle_epi32\">_mm_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shuffle_pd.html\" title=\"fn core::arch::x86::_mm_shuffle_pd\">_mm_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Constructs a 128-bit floating-point vector of <code>[2 x double]</code> from two\n128-bit vector parameters of <code>[2 x double]</code>, using the immediate-value\nparameter as a specifier.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shuffle_ps.html\" title=\"fn core::arch::x86::_mm_shuffle_ps\">_mm_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Shuffles packed single-precision (32-bit) floating-point elements in <code>a</code> and\n<code>b</code> using <code>MASK</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm_shufflehi_epi16\">_mm_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shuffles 16-bit integers in the high 64 bits of <code>a</code> using the control in\n<code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm_shufflelo_epi16\">_mm_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shuffles 16-bit integers in the low 64 bits of <code>a</code> using the control in\n<code>IMM8</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sign_epi8.html\" title=\"fn core::arch::x86::_mm_sign_epi8\">_mm_sign_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Negates packed 8-bit integers in <code>a</code> when the corresponding signed 8-bit\ninteger in <code>b</code> is negative, and returns the result.\nElements in result are zeroed out when the corresponding element in <code>b</code>\nis zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sign_epi16.html\" title=\"fn core::arch::x86::_mm_sign_epi16\">_mm_sign_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Negates packed 16-bit integers in <code>a</code> when the corresponding signed 16-bit\ninteger in <code>b</code> is negative, and returns the results.\nElements in result are zeroed out when the corresponding element in <code>b</code>\nis zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sign_epi32.html\" title=\"fn core::arch::x86::_mm_sign_epi32\">_mm_sign_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `ssse3` only\">(x86 or x86-64) and <code>ssse3</code></span></div><div class=\"desc docblock-short\">Negates packed 32-bit integers in <code>a</code> when the corresponding signed 32-bit\ninteger in <code>b</code> is negative, and returns the results.\nElement in result are zeroed out when the corresponding element in <code>b</code>\nis zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sll_epi16.html\" title=\"fn core::arch::x86::_mm_sll_epi16\">_mm_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> left by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sll_epi32.html\" title=\"fn core::arch::x86::_mm_sll_epi32\">_mm_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> left by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sll_epi64.html\" title=\"fn core::arch::x86::_mm_sll_epi64\">_mm_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> left by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_slli_epi16.html\" title=\"fn core::arch::x86::_mm_slli_epi16\">_mm_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_slli_epi32.html\" title=\"fn core::arch::x86::_mm_slli_epi32\">_mm_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_slli_epi64.html\" title=\"fn core::arch::x86::_mm_slli_epi64\">_mm_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_slli_si128.html\" title=\"fn core::arch::x86::_mm_slli_si128\">_mm_slli_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sllv_epi32.html\" title=\"fn core::arch::x86::_mm_sllv_epi32\">_mm_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> left by the amount\nspecified by the corresponding element in <code>count</code> while\nshifting in zeros, and returns the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sllv_epi64.html\" title=\"fn core::arch::x86::_mm_sllv_epi64\">_mm_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> left by the amount\nspecified by the corresponding element in <code>count</code> while\nshifting in zeros, and returns the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sqrt_pd.html\" title=\"fn core::arch::x86::_mm_sqrt_pd\">_mm_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the square root of each of the values in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sqrt_ps.html\" title=\"fn core::arch::x86::_mm_sqrt_ps\">_mm_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns the square root of packed single-precision (32-bit) floating-point\nelements in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sqrt_sd.html\" title=\"fn core::arch::x86::_mm_sqrt_sd\">_mm_sqrt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by the square\nroot of the lower element <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sqrt_ss.html\" title=\"fn core::arch::x86::_mm_sqrt_ss\">_mm_sqrt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns the square root of the first single-precision (32-bit)\nfloating-point element in <code>a</code>, the other elements are unchanged.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sra_epi16.html\" title=\"fn core::arch::x86::_mm_sra_epi16\">_mm_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while shifting in sign\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sra_epi32.html\" title=\"fn core::arch::x86::_mm_sra_epi32\">_mm_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while shifting in sign\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srai_epi16.html\" title=\"fn core::arch::x86::_mm_srai_epi16\">_mm_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in sign\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srai_epi32.html\" title=\"fn core::arch::x86::_mm_srai_epi32\">_mm_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in sign\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srav_epi32.html\" title=\"fn core::arch::x86::_mm_srav_epi32\">_mm_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by the amount specified by the\ncorresponding element in <code>count</code> while shifting in sign bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srl_epi16.html\" title=\"fn core::arch::x86::_mm_srl_epi16\">_mm_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srl_epi32.html\" title=\"fn core::arch::x86::_mm_srl_epi32\">_mm_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srl_epi64.html\" title=\"fn core::arch::x86::_mm_srl_epi64\">_mm_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> right by <code>count</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srli_epi16.html\" title=\"fn core::arch::x86::_mm_srli_epi16\">_mm_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srli_epi32.html\" title=\"fn core::arch::x86::_mm_srli_epi32\">_mm_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srli_epi64.html\" title=\"fn core::arch::x86::_mm_srli_epi64\">_mm_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srli_si128.html\" title=\"fn core::arch::x86::_mm_srli_si128\">_mm_srli_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Shifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srlv_epi32.html\" title=\"fn core::arch::x86::_mm_srlv_epi32\">_mm_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 32-bit integers in <code>a</code> right by the amount specified by\nthe corresponding element in <code>count</code> while shifting in zeros,</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srlv_epi64.html\" title=\"fn core::arch::x86::_mm_srlv_epi64\">_mm_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx2` only\">(x86 or x86-64) and <code>avx2</code></span></div><div class=\"desc docblock-short\">Shifts packed 64-bit integers in <code>a</code> right by the amount specified by\nthe corresponding element in <code>count</code> while shifting in zeros,</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store1_pd.html\" title=\"fn core::arch::x86::_mm_store1_pd\">_mm_store1_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores the lower double-precision (64-bit) floating-point element from <code>a</code>\ninto 2 contiguous elements in memory. <code>mem_addr</code> must be aligned on a\n16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store1_ps.html\" title=\"fn core::arch::x86::_mm_store1_ps\">_mm_store1_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Stores the lowest 32 bit float of <code>a</code> repeated four times into <em>aligned</em>\nmemory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_pd.html\" title=\"fn core::arch::x86::_mm_store_pd\">_mm_store_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores 128-bits (composed of 2 packed double-precision (64-bit)\nfloating-point elements) from <code>a</code> into memory. <code>mem_addr</code> must be aligned\non a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_pd1.html\" title=\"fn core::arch::x86::_mm_store_pd1\">_mm_store_pd1</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores the lower double-precision (64-bit) floating-point element from <code>a</code>\ninto 2 contiguous elements in memory. <code>mem_addr</code> must be aligned on a\n16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_ps.html\" title=\"fn core::arch::x86::_mm_store_ps\">_mm_store_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Stores four 32-bit floats into <em>aligned</em> memory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_ps1.html\" title=\"fn core::arch::x86::_mm_store_ps1\">_mm_store_ps1</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Alias for <a href=\"fn._mm_store1_ps.html\"><code>_mm_store1_ps</code></a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_sd.html\" title=\"fn core::arch::x86::_mm_store_sd\">_mm_store_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores the lower 64 bits of a 128-bit vector of <code>[2 x double]</code> to a\nmemory location.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_si128.html\" title=\"fn core::arch::x86::_mm_store_si128\">_mm_store_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores 128-bits of integer data from <code>a</code> into memory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_ss.html\" title=\"fn core::arch::x86::_mm_store_ss\">_mm_store_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Stores the lowest 32 bit float of <code>a</code> into memory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeh_pd.html\" title=\"fn core::arch::x86::_mm_storeh_pd\">_mm_storeh_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores the upper 64 bits of a 128-bit vector of <code>[2 x double]</code> to a\nmemory location.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storel_epi64.html\" title=\"fn core::arch::x86::_mm_storel_epi64\">_mm_storel_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores the lower 64-bit integer <code>a</code> to a memory location.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storel_pd.html\" title=\"fn core::arch::x86::_mm_storel_pd\">_mm_storel_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores the lower 64 bits of a 128-bit vector of <code>[2 x double]</code> to a\nmemory location.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storer_pd.html\" title=\"fn core::arch::x86::_mm_storer_pd\">_mm_storer_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores 2 double-precision (64-bit) floating-point elements from <code>a</code> into\nmemory in reverse order.\n<code>mem_addr</code> must be aligned on a 16-byte boundary or a general-protection\nexception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storer_ps.html\" title=\"fn core::arch::x86::_mm_storer_ps\">_mm_storer_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Stores four 32-bit floats into <em>aligned</em> memory in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_pd.html\" title=\"fn core::arch::x86::_mm_storeu_pd\">_mm_storeu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores 128-bits (composed of 2 packed double-precision (64-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_ps.html\" title=\"fn core::arch::x86::_mm_storeu_ps\">_mm_storeu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Stores four 32-bit floats into memory. There are no restrictions on memory\nalignment. For aligned memory <a href=\"fn._mm_store_ps.html\"><code>_mm_store_ps</code></a> may be\nfaster.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_si128.html\" title=\"fn core::arch::x86::_mm_storeu_si128\">_mm_storeu_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores 128-bits of integer data from <code>a</code> into memory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_stream_pd.html\" title=\"fn core::arch::x86::_mm_stream_pd\">_mm_stream_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores a 128-bit floating point vector of <code>[2 x double]</code> to a 128-bit\naligned memory location.\nTo minimize caching, the data is flagged as non-temporal (unlikely to be\nused again soon).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_stream_ps.html\" title=\"fn core::arch::x86::_mm_stream_ps\">_mm_stream_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Stores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal memory hint.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_stream_sd.html\" title=\"fn core::arch::x86::_mm_stream_sd\">_mm_stream_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4a` only\">(x86 or x86-64) and <code>sse4a</code></span></div><div class=\"desc docblock-short\">Non-temporal store of <code>a.0</code> into <code>p</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_stream_si32.html\" title=\"fn core::arch::x86::_mm_stream_si32\">_mm_stream_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores a 32-bit integer value in the specified memory location.\nTo minimize caching, the data is flagged as non-temporal (unlikely to be\nused again soon).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_stream_si128.html\" title=\"fn core::arch::x86::_mm_stream_si128\">_mm_stream_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Stores a 128-bit integer vector to a 128-bit aligned memory location.\nTo minimize caching, the data is flagged as non-temporal (unlikely to be\nused again soon).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_stream_ss.html\" title=\"fn core::arch::x86::_mm_stream_ss\">_mm_stream_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4a` only\">(x86 or x86-64) and <code>sse4a</code></span></div><div class=\"desc docblock-short\">Non-temporal store of <code>a.0</code> into <code>p</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_epi8.html\" title=\"fn core::arch::x86::_mm_sub_epi8\">_mm_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtracts packed 8-bit integers in <code>b</code> from packed 8-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_epi16.html\" title=\"fn core::arch::x86::_mm_sub_epi16\">_mm_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtracts packed 16-bit integers in <code>b</code> from packed 16-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_epi32.html\" title=\"fn core::arch::x86::_mm_sub_epi32\">_mm_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in <code>b</code> from packed 32-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_epi64.html\" title=\"fn core::arch::x86::_mm_sub_epi64\">_mm_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in <code>b</code> from packed 64-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_pd.html\" title=\"fn core::arch::x86::_mm_sub_pd\">_mm_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in <code>b</code>\nfrom <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_ps.html\" title=\"fn core::arch::x86::_mm_sub_ps\">_mm_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Subtracts __m128 vectors.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_sd.html\" title=\"fn core::arch::x86::_mm_sub_sd\">_mm_sub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns a new vector with the low element of <code>a</code> replaced by subtracting the\nlow element by <code>b</code> from the low element of <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_ss.html\" title=\"fn core::arch::x86::_mm_sub_ss\">_mm_sub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Subtracts the first component of <code>b</code> from <code>a</code>, the other components are\ncopied from <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_subs_epi8.html\" title=\"fn core::arch::x86::_mm_subs_epi8\">_mm_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in <code>b</code> from packed 8-bit integers in <code>a</code>\nusing saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_subs_epi16.html\" title=\"fn core::arch::x86::_mm_subs_epi16\">_mm_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in <code>b</code> from packed 16-bit integers in <code>a</code>\nusing saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_subs_epu8.html\" title=\"fn core::arch::x86::_mm_subs_epu8\">_mm_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in <code>b</code> from packed unsigned 8-bit\nintegers in <code>a</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_subs_epu16.html\" title=\"fn core::arch::x86::_mm_subs_epu16\">_mm_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in <code>b</code> from packed unsigned 16-bit\nintegers in <code>a</code> using saturation.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_all_ones.html\" title=\"fn core::arch::x86::_mm_test_all_ones\">_mm_test_all_ones</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Tests whether the specified bits in <code>a</code> 128-bit integer vector are all\nones.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_all_zeros.html\" title=\"fn core::arch::x86::_mm_test_all_zeros\">_mm_test_all_zeros</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Tests whether the specified bits in a 128-bit integer vector are all\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_mix_ones_zeros.html\" title=\"fn core::arch::x86::_mm_test_mix_ones_zeros\">_mm_test_mix_ones_zeros</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Tests whether the specified bits in a 128-bit integer vector are\nneither all zeros nor all ones.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testc_pd.html\" title=\"fn core::arch::x86::_mm_testc_pd\">_mm_testc_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testc_ps.html\" title=\"fn core::arch::x86::_mm_testc_ps\">_mm_testc_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testc_si128.html\" title=\"fn core::arch::x86::_mm_testc_si128\">_mm_testc_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Tests whether the specified bits in a 128-bit integer vector are all\nones.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testnzc_pd.html\" title=\"fn core::arch::x86::_mm_testnzc_pd\">_mm_testnzc_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values\nare zero, otherwise return 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testnzc_ps.html\" title=\"fn core::arch::x86::_mm_testnzc_ps\">_mm_testnzc_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values\nare zero, otherwise return 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testnzc_si128.html\" title=\"fn core::arch::x86::_mm_testnzc_si128\">_mm_testnzc_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Tests whether the specified bits in a 128-bit integer vector are\nneither all zeros nor all ones.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testz_pd.html\" title=\"fn core::arch::x86::_mm_testz_pd\">_mm_testz_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testz_ps.html\" title=\"fn core::arch::x86::_mm_testz_ps\">_mm_testz_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx` only\">(x86 or x86-64) and <code>avx</code></span></div><div class=\"desc docblock-short\">Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\nfloating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit\nvalue, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the\nintermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise\nNOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set\n<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value\nis zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testz_si128.html\" title=\"fn core::arch::x86::_mm_testz_si128\">_mm_testz_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse4.1` only\">(x86 or x86-64) and <code>sse4.1</code></span></div><div class=\"desc docblock-short\">Tests whether the specified bits in a 128-bit integer vector are all\nzeros.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_tzcnt_32.html\" title=\"fn core::arch::x86::_mm_tzcnt_32\">_mm_tzcnt_32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Counts the number of trailing least significant zero bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomieq_sd.html\" title=\"fn core::arch::x86::_mm_ucomieq_sd\">_mm_ucomieq_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for equality.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomieq_ss.html\" title=\"fn core::arch::x86::_mm_ucomieq_ss\">_mm_ucomieq_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if they are equal, or <code>0</code> otherwise. This instruction will not signal\nan exception if either argument is a quiet NaN.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomige_sd.html\" title=\"fn core::arch::x86::_mm_ucomige_sd\">_mm_ucomige_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for greater-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomige_ss.html\" title=\"fn core::arch::x86::_mm_ucomige_ss\">_mm_ucomige_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is greater than or equal to the one from <code>b</code>, or\n<code>0</code> otherwise. This instruction will not signal an exception if either\nargument is a quiet NaN.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomigt_sd.html\" title=\"fn core::arch::x86::_mm_ucomigt_sd\">_mm_ucomigt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for greater-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomigt_ss.html\" title=\"fn core::arch::x86::_mm_ucomigt_ss\">_mm_ucomigt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is greater than the one from <code>b</code>, or <code>0</code>\notherwise. This instruction will not signal an exception if either argument\nis a quiet NaN.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomile_sd.html\" title=\"fn core::arch::x86::_mm_ucomile_sd\">_mm_ucomile_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for less-than-or-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomile_ss.html\" title=\"fn core::arch::x86::_mm_ucomile_ss\">_mm_ucomile_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is less than or equal to the one from <code>b</code>, or <code>0</code>\notherwise. This instruction will not signal an exception if either argument\nis a quiet NaN.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomilt_sd.html\" title=\"fn core::arch::x86::_mm_ucomilt_sd\">_mm_ucomilt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for less-than.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomilt_ss.html\" title=\"fn core::arch::x86::_mm_ucomilt_ss\">_mm_ucomilt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if the value from <code>a</code> is less than the one from <code>b</code>, or <code>0</code> otherwise.\nThis instruction will not signal an exception if either argument is a quiet\nNaN.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomineq_sd.html\" title=\"fn core::arch::x86::_mm_ucomineq_sd\">_mm_ucomineq_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Compares the lower element of <code>a</code> and <code>b</code> for not-equal.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ucomineq_ss.html\" title=\"fn core::arch::x86::_mm_ucomineq_ss\">_mm_ucomineq_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns\n<code>1</code> if they are <strong>not</strong> equal, or <code>0</code> otherwise. This instruction will not\nsignal an exception if either argument is a quiet NaN.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_undefined_pd.html\" title=\"fn core::arch::x86::_mm_undefined_pd\">_mm_undefined_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m128d with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_undefined_ps.html\" title=\"fn core::arch::x86::_mm_undefined_ps\">_mm_undefined_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m128 with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_undefined_si128.html\" title=\"fn core::arch::x86::_mm_undefined_si128\">_mm_undefined_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Returns vector of type __m128i with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm_unpackhi_epi8\">_mm_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 8-bit integers from the high half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm_unpackhi_epi16\">_mm_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 16-bit integers from the high half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm_unpackhi_epi32\">_mm_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 32-bit integers from the high half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm_unpackhi_epi64\">_mm_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 64-bit integers from the high half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm_unpackhi_pd\">_mm_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">The resulting <code>__m128d</code> element is composed by the low-order values of\nthe two <code>__m128d</code> interleaved input elements, i.e.:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm_unpackhi_ps\">_mm_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave single-precision (32-bit) floating-point elements\nfrom the higher half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm_unpacklo_epi8\">_mm_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 8-bit integers from the low half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm_unpacklo_epi16\">_mm_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 16-bit integers from the low half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm_unpacklo_epi32\">_mm_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 32-bit integers from the low half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm_unpacklo_epi64\">_mm_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave 64-bit integers from the low half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm_unpacklo_pd\">_mm_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">The resulting <code>__m128d</code> element is composed by the high-order values of\nthe two <code>__m128d</code> interleaved input elements, i.e.:</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm_unpacklo_ps\">_mm_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Unpacks and interleave single-precision (32-bit) floating-point elements\nfrom the lower half of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_xor_pd.html\" title=\"fn core::arch::x86::_mm_xor_pd\">_mm_xor_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise XOR of <code>a</code> and <code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_xor_ps.html\" title=\"fn core::arch::x86::_mm_xor_ps\">_mm_xor_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse` only\">(x86 or x86-64) and <code>sse</code></span></div><div class=\"desc docblock-short\">Bitwise exclusive OR of packed single-precision (32-bit) floating-point\nelements.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_xor_si128.html\" title=\"fn core::arch::x86::_mm_xor_si128\">_mm_xor_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `sse2` only\">(x86 or x86-64) and <code>sse2</code></span></div><div class=\"desc docblock-short\">Computes the bitwise XOR of 128 bits (representing integer data) in <code>a</code> and\n<code>b</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mulx_u32.html\" title=\"fn core::arch::x86::_mulx_u32\">_mulx_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi2` only\">(x86 or x86-64) and <code>bmi2</code></span></div><div class=\"desc docblock-short\">Unsigned multiply without affecting flags.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._pdep_u32.html\" title=\"fn core::arch::x86::_pdep_u32\">_pdep_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi2` only\">(x86 or x86-64) and <code>bmi2</code></span></div><div class=\"desc docblock-short\">Scatter contiguous low order bits of <code>a</code> to the result at the positions\nspecified by the <code>mask</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._pext_u32.html\" title=\"fn core::arch::x86::_pext_u32\">_pext_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi2` only\">(x86 or x86-64) and <code>bmi2</code></span></div><div class=\"desc docblock-short\">Gathers the bits of <code>x</code> specified by the <code>mask</code> into the contiguous low\norder bit positions of the result.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._popcnt32.html\" title=\"fn core::arch::x86::_popcnt32\">_popcnt32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `popcnt` only\">(x86 or x86-64) and <code>popcnt</code></span></div><div class=\"desc docblock-short\">Counts the bits that are set.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._rdrand16_step.html\" title=\"fn core::arch::x86::_rdrand16_step\">_rdrand16_step</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rdrand` only\">(x86 or x86-64) and <code>rdrand</code></span></div><div class=\"desc docblock-short\">Read a hardware generated 16-bit random value and store the result in val.\nReturns 1 if a random value was generated, and 0 otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._rdrand32_step.html\" title=\"fn core::arch::x86::_rdrand32_step\">_rdrand32_step</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rdrand` only\">(x86 or x86-64) and <code>rdrand</code></span></div><div class=\"desc docblock-short\">Read a hardware generated 32-bit random value and store the result in val.\nReturns 1 if a random value was generated, and 0 otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._rdseed16_step.html\" title=\"fn core::arch::x86::_rdseed16_step\">_rdseed16_step</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rdseed` only\">(x86 or x86-64) and <code>rdseed</code></span></div><div class=\"desc docblock-short\">Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store\nin val. Return 1 if a random value was generated, and 0 otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._rdseed32_step.html\" title=\"fn core::arch::x86::_rdseed32_step\">_rdseed32_step</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rdseed` only\">(x86 or x86-64) and <code>rdseed</code></span></div><div class=\"desc docblock-short\">Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store\nin val. Return 1 if a random value was generated, and 0 otherwise.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._rdtsc.html\" title=\"fn core::arch::x86::_rdtsc\">_rdtsc</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Reads the current value of the processor’s time-stamp counter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._subborrow_u32.html\" title=\"fn core::arch::x86::_subborrow_u32\">_subborrow_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Adds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>\n(carry or overflow flag), and store the unsigned 32-bit result in <code>out</code>, and\nthe carry-out is returned (carry or overflow flag).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._t1mskc_u32.html\" title=\"fn core::arch::x86::_t1mskc_u32\">_t1mskc_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Clears all bits below the least significant zero of <code>x</code> and sets all other\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._t1mskc_u64.html\" title=\"fn core::arch::x86::_t1mskc_u64\">_t1mskc_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Clears all bits below the least significant zero of <code>x</code> and sets all other\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._tzcnt_u32.html\" title=\"fn core::arch::x86::_tzcnt_u32\">_tzcnt_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `bmi1` only\">(x86 or x86-64) and <code>bmi1</code></span></div><div class=\"desc docblock-short\">Counts the number of trailing least significant zero bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._tzmsk_u32.html\" title=\"fn core::arch::x86::_tzmsk_u32\">_tzmsk_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets all bits below the least significant one of <code>x</code> and clears all other\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._tzmsk_u64.html\" title=\"fn core::arch::x86::_tzmsk_u64\">_tzmsk_u64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `tbm` only\">(x86 or x86-64) and <code>tbm</code></span></div><div class=\"desc docblock-short\">Sets all bits below the least significant one of <code>x</code> and clears all other\nbits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xgetbv.html\" title=\"fn core::arch::x86::_xgetbv\">_xgetbv</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave` only\">(x86 or x86-64) and <code>xsave</code></span></div><div class=\"desc docblock-short\">Reads the contents of the extended control register <code>XCR</code>\nspecified in <code>xcr_no</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xrstor.html\" title=\"fn core::arch::x86::_xrstor\">_xrstor</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave` only\">(x86 or x86-64) and <code>xsave</code></span></div><div class=\"desc docblock-short\">Performs a full or partial restore of the enabled processor states using\nthe state information stored in memory at <code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xrstors.html\" title=\"fn core::arch::x86::_xrstors\">_xrstors</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave,xsaves` only\">(x86 or x86-64) and <code>xsave,xsaves</code></span></div><div class=\"desc docblock-short\">Performs a full or partial restore of the enabled processor states using the\nstate information stored in memory at <code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xsave.html\" title=\"fn core::arch::x86::_xsave\">_xsave</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave` only\">(x86 or x86-64) and <code>xsave</code></span></div><div class=\"desc docblock-short\">Performs a full or partial save of the enabled processor states to memory at\n<code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xsavec.html\" title=\"fn core::arch::x86::_xsavec\">_xsavec</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave,xsavec` only\">(x86 or x86-64) and <code>xsave,xsavec</code></span></div><div class=\"desc docblock-short\">Performs a full or partial save of the enabled processor states to memory\nat <code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xsaveopt.html\" title=\"fn core::arch::x86::_xsaveopt\">_xsaveopt</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave,xsaveopt` only\">(x86 or x86-64) and <code>xsave,xsaveopt</code></span></div><div class=\"desc docblock-short\">Performs a full or partial save of the enabled processor states to memory at\n<code>mem_addr</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xsaves.html\" title=\"fn core::arch::x86::_xsaves\">_xsaves</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave,xsaves` only\">(x86 or x86-64) and <code>xsave,xsaves</code></span></div><div class=\"desc docblock-short\">Performs a full or partial save of the enabled processor states to memory at\n<code>mem_addr</code></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xsetbv.html\" title=\"fn core::arch::x86::_xsetbv\">_xsetbv</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `xsave` only\">(x86 or x86-64) and <code>xsave</code></span></div><div class=\"desc docblock-short\">Copies 64-bits from <code>val</code> to the extended control register (<code>XCR</code>) specified\nby <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._MM_SHUFFLE.html\" title=\"fn core::arch::x86::_MM_SHUFFLE\">_MM_SHUFFLE</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">A utility function for creating masks to use with Intel shuffle and\npermute intrinsics.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kadd_mask32.html\" title=\"fn core::arch::x86::_kadd_mask32\">_kadd_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add 32-bit masks in a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kadd_mask64.html\" title=\"fn core::arch::x86::_kadd_mask64\">_kadd_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add 64-bit masks in a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kand_mask16.html\" title=\"fn core::arch::x86::_kand_mask16\">_kand_mask16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kand_mask32.html\" title=\"fn core::arch::x86::_kand_mask32\">_kand_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of 32-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kand_mask64.html\" title=\"fn core::arch::x86::_kand_mask64\">_kand_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of 64-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kandn_mask16.html\" title=\"fn core::arch::x86::_kandn_mask16\">_kandn_mask16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kandn_mask32.html\" title=\"fn core::arch::x86::_kandn_mask32\">_kandn_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 32-bit masks a and then AND with b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kandn_mask64.html\" title=\"fn core::arch::x86::_kandn_mask64\">_kandn_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 64-bit masks a and then AND with b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._knot_mask16.html\" title=\"fn core::arch::x86::_knot_mask16\">_knot_mask16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 16-bit mask a, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._knot_mask32.html\" title=\"fn core::arch::x86::_knot_mask32\">_knot_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 32-bit mask a, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._knot_mask64.html\" title=\"fn core::arch::x86::_knot_mask64\">_knot_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 64-bit mask a, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kor_mask16.html\" title=\"fn core::arch::x86::_kor_mask16\">_kor_mask16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kor_mask32.html\" title=\"fn core::arch::x86::_kor_mask32\">_kor_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of 32-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kor_mask64.html\" title=\"fn core::arch::x86::_kor_mask64\">_kor_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of 64-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kxnor_mask16.html\" title=\"fn core::arch::x86::_kxnor_mask16\">_kxnor_mask16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kxnor_mask32.html\" title=\"fn core::arch::x86::_kxnor_mask32\">_kxnor_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XNOR of 32-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kxnor_mask64.html\" title=\"fn core::arch::x86::_kxnor_mask64\">_kxnor_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XNOR of 64-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kxor_mask16.html\" title=\"fn core::arch::x86::_kxor_mask16\">_kxor_mask16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kxor_mask32.html\" title=\"fn core::arch::x86::_kxor_mask32\">_kxor_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of 32-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._kxor_mask64.html\" title=\"fn core::arch::x86::_kxor_mask64\">_kxor_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of 64-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._load_mask32.html\" title=\"fn core::arch::x86::_load_mask32\">_load_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Load 32-bit mask from memory into k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._load_mask64.html\" title=\"fn core::arch::x86::_load_mask64\">_load_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Load 64-bit mask from memory into k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_abs_epi64.html\" title=\"fn core::arch::x86::_mm256_abs_epi64\">_mm256_abs_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_aesdec_epi128.html\" title=\"fn core::arch::x86::_mm256_aesdec_epi128\">_mm256_aesdec_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes` only\">(x86 or x86-64) and <code>vaes</code></span></div><div class=\"desc docblock-short\">Performs one round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_aesdeclast_epi128.html\" title=\"fn core::arch::x86::_mm256_aesdeclast_epi128\">_mm256_aesdeclast_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes` only\">(x86 or x86-64) and <code>vaes</code></span></div><div class=\"desc docblock-short\">Performs the last round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_aesenc_epi128.html\" title=\"fn core::arch::x86::_mm256_aesenc_epi128\">_mm256_aesenc_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes` only\">(x86 or x86-64) and <code>vaes</code></span></div><div class=\"desc docblock-short\">Performs one round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_aesenclast_epi128.html\" title=\"fn core::arch::x86::_mm256_aesenclast_epi128\">_mm256_aesenclast_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes` only\">(x86 or x86-64) and <code>vaes</code></span></div><div class=\"desc docblock-short\">Performs the last round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_alignr_epi32.html\" title=\"fn core::arch::x86::_mm256_alignr_epi32\">_mm256_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_alignr_epi64.html\" title=\"fn core::arch::x86::_mm256_alignr_epi64\">_mm256_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_bitshuffle_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_bitshuffle_epi64_mask\">_mm256_bitshuffle_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.\nThen groups 8 8-bit values from <code>c</code>as indices into the bits of the corresponding 64-bit integer.\nIt then selects these bits and packs them into the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcast_f32x4.html\" title=\"fn core::arch::x86::_mm256_broadcast_f32x4\">_mm256_broadcast_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcast_i32x4.html\" title=\"fn core::arch::x86::_mm256_broadcast_i32x4\">_mm256_broadcast_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 32-bit integers from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastmb_epi64.html\" title=\"fn core::arch::x86::_mm256_broadcastmb_epi64\">_mm256_broadcastmb_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_broadcastmw_epi32.html\" title=\"fn core::arch::x86::_mm256_broadcastmw_epi32\">_mm256_broadcastmw_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_clmulepi64_epi128.html\" title=\"fn core::arch::x86::_mm256_clmulepi64_epi128\">_mm256_clmulepi64_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vpclmulqdq` only\">(x86 or x86-64) and <code>vpclmulqdq</code></span></div><div class=\"desc docblock-short\">Performs a carry-less multiplication of two 64-bit polynomials over the\nfinite field GF(2) - in each of the 2 128-bit lanes.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epi8_mask\">_mm256_cmp_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epi16_mask\">_mm256_cmp_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epi32_mask\">_mm256_cmp_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epi64_mask\">_mm256_cmp_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epu8_mask\">_mm256_cmp_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epu16_mask\">_mm256_cmp_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epu32_mask\">_mm256_cmp_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_epu64_mask\">_mm256_cmp_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_pd_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_pd_mask\">_mm256_cmp_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmp_ps_mask.html\" title=\"fn core::arch::x86::_mm256_cmp_ps_mask\">_mm256_cmp_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi8_mask\">_mm256_cmpeq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi16_mask\">_mm256_cmpeq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi32_mask\">_mm256_cmpeq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epi64_mask\">_mm256_cmpeq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epu8_mask\">_mm256_cmpeq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epu16_mask\">_mm256_cmpeq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epu32_mask\">_mm256_cmpeq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpeq_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpeq_epu64_mask\">_mm256_cmpeq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epi8_mask\">_mm256_cmpge_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epi16_mask\">_mm256_cmpge_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epi32_mask\">_mm256_cmpge_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epi64_mask\">_mm256_cmpge_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epu8_mask\">_mm256_cmpge_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epu16_mask\">_mm256_cmpge_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epu32_mask\">_mm256_cmpge_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpge_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpge_epu64_mask\">_mm256_cmpge_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi8_mask\">_mm256_cmpgt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi16_mask\">_mm256_cmpgt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi32_mask\">_mm256_cmpgt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epi64_mask\">_mm256_cmpgt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epu8_mask\">_mm256_cmpgt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epu16_mask\">_mm256_cmpgt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epu32_mask\">_mm256_cmpgt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpgt_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpgt_epu64_mask\">_mm256_cmpgt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epi8_mask\">_mm256_cmple_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epi16_mask\">_mm256_cmple_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epi32_mask\">_mm256_cmple_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epi64_mask\">_mm256_cmple_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epu8_mask\">_mm256_cmple_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epu16_mask\">_mm256_cmple_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epu32_mask\">_mm256_cmple_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmple_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmple_epu64_mask\">_mm256_cmple_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epi8_mask\">_mm256_cmplt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epi16_mask\">_mm256_cmplt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epi32_mask\">_mm256_cmplt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epi64_mask\">_mm256_cmplt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epu8_mask\">_mm256_cmplt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epu16_mask\">_mm256_cmplt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epu32_mask\">_mm256_cmplt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmplt_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmplt_epu64_mask\">_mm256_cmplt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epi8_mask\">_mm256_cmpneq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epi16_mask\">_mm256_cmpneq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epi32_mask\">_mm256_cmpneq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epi64_mask\">_mm256_cmpneq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epu8_mask\">_mm256_cmpneq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epu16_mask\">_mm256_cmpneq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epu32_mask\">_mm256_cmpneq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cmpneq_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_cmpneq_epu64_mask\">_mm256_cmpneq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_conflict_epi32.html\" title=\"fn core::arch::x86::_mm256_conflict_epi32\">_mm256_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_conflict_epi64.html\" title=\"fn core::arch::x86::_mm256_conflict_epi64\">_mm256_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtepi16_epi8\">_mm256_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtepi32_epi8\">_mm256_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtepi32_epi16\">_mm256_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtepi64_epi8\">_mm256_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtepi64_epi16\">_mm256_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtepi64_epi32\">_mm256_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm256_cvtepu32_pd\">_mm256_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm256_cvtne2ps_pbh\">_mm256_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two 256-bit vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results in a\n256-bit wide vector.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&amp;avx512techs=AVX512_BF16&amp;text=_mm256_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtneps_pbh.html\" title=\"fn core::arch::x86::_mm256_cvtneps_pbh\">_mm256_cvtneps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)\nfloating-point elements, and store the results in dst.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_cvtneps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm256_cvtpd_epu32\">_mm256_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm256_cvtps_epu32\">_mm256_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtsepi16_epi8\">_mm256_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtsepi32_epi8\">_mm256_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtsepi32_epi16\">_mm256_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtsepi64_epi8\">_mm256_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtsepi64_epi16\">_mm256_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtsepi64_epi32\">_mm256_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm256_cvttpd_epu32\">_mm256_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm256_cvttps_epu32\">_mm256_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtusepi16_epi8\">_mm256_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtusepi32_epi8\">_mm256_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtusepi32_epi16\">_mm256_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_cvtusepi64_epi8\">_mm256_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_cvtusepi64_epi16\">_mm256_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_cvtusepi64_epi32\">_mm256_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm256_dbsad_epu8\">_mm256_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm256_dpbf16_ps\">_mm256_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm256_dpbusd_epi32\">_mm256_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm256_dpbusds_epi32\">_mm256_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm256_dpwssd_epi32\">_mm256_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm256_dpwssds_epi32\">_mm256_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extractf32x4_ps.html\" title=\"fn core::arch::x86::_mm256_extractf32x4_ps\">_mm256_extractf32x4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_extracti32x4_epi32.html\" title=\"fn core::arch::x86::_mm256_extracti32x4_epi32\">_mm256_extracti32x4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm256_fixupimm_pd\">_mm256_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm256_fixupimm_ps\">_mm256_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_getexp_pd.html\" title=\"fn core::arch::x86::_mm256_getexp_pd\">_mm256_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_getexp_ps.html\" title=\"fn core::arch::x86::_mm256_getexp_ps\">_mm256_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_getmant_pd.html\" title=\"fn core::arch::x86::_mm256_getmant_pd\">_mm256_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_getmant_ps.html\" title=\"fn core::arch::x86::_mm256_getmant_ps\">_mm256_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.\nThe mantissa is normalized to the interval specified by interv, which can take the following values:\n_MM_MANT_NORM_1_2     // interval [1, 2)\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)\nThe sign is determined by sc which can take the following values:\n_MM_MANT_SIGN_src     // sign = sign(src)\n_MM_MANT_SIGN_zero    // sign = 0\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_gf2p8affine_epi64_epi8\">_mm256_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx` only\">(x86 or x86-64) and <code>gfni,avx</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_gf2p8affineinv_epi64_epi8\">_mm256_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx` only\">(x86 or x86-64) and <code>gfni,avx</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm256_gf2p8mul_epi8\">_mm256_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx` only\">(x86 or x86-64) and <code>gfni,avx</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_i32scatter_epi64.html\" title=\"fn core::arch::x86::_mm256_i32scatter_epi64\">_mm256_i32scatter_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_insertf32x4.html\" title=\"fn core::arch::x86::_mm256_insertf32x4\">_mm256_insertf32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_inserti32x4.html\" title=\"fn core::arch::x86::_mm256_inserti32x4\">_mm256_inserti32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_load_epi32.html\" title=\"fn core::arch::x86::_mm256_load_epi32\">_mm256_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_load_epi64.html\" title=\"fn core::arch::x86::_mm256_load_epi64\">_mm256_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_epi8.html\" title=\"fn core::arch::x86::_mm256_loadu_epi8\">_mm256_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 256-bits (composed of 32 packed 8-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_epi16.html\" title=\"fn core::arch::x86::_mm256_loadu_epi16\">_mm256_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 256-bits (composed of 16 packed 16-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_epi32.html\" title=\"fn core::arch::x86::_mm256_loadu_epi32\">_mm256_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_loadu_epi64.html\" title=\"fn core::arch::x86::_mm256_loadu_epi64\">_mm256_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm256_lzcnt_epi32\">_mm256_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm256_lzcnt_epi64\">_mm256_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_madd52hi_epu64.html\" title=\"fn core::arch::x86::_mm256_madd52hi_epu64\">_mm256_madd52hi_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only\">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 52-bit integers in each 64-bit element of\n<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the high 52-bit\nunsigned integer from the intermediate result with the\ncorresponding unsigned 64-bit integer in <code>a</code>, and store the\nresults in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_madd52lo_epu64.html\" title=\"fn core::arch::x86::_mm256_madd52lo_epu64\">_mm256_madd52lo_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only\">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 52-bit integers in each 64-bit element of\n<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the low 52-bit\nunsigned integer from the intermediate result with the\ncorresponding unsigned 64-bit integer in <code>a</code>, and store the\nresults in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask2_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm256_mask2_permutex2var_epi8\">_mm256_mask2_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask2_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm256_mask2_permutex2var_epi16\">_mm256_mask2_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask2_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm256_mask2_permutex2var_epi32\">_mm256_mask2_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask2_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm256_mask2_permutex2var_epi64\">_mm256_mask2_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask2_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm256_mask2_permutex2var_pd\">_mm256_mask2_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask2_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm256_mask2_permutex2var_ps\">_mm256_mask2_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmadd_pd.html\" title=\"fn core::arch::x86::_mm256_mask3_fmadd_pd\">_mm256_mask3_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmadd_ps.html\" title=\"fn core::arch::x86::_mm256_mask3_fmadd_ps\">_mm256_mask3_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm256_mask3_fmaddsub_pd\">_mm256_mask3_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm256_mask3_fmaddsub_ps\">_mm256_mask3_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmsub_pd.html\" title=\"fn core::arch::x86::_mm256_mask3_fmsub_pd\">_mm256_mask3_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmsub_ps.html\" title=\"fn core::arch::x86::_mm256_mask3_fmsub_ps\">_mm256_mask3_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm256_mask3_fmsubadd_pd\">_mm256_mask3_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm256_mask3_fmsubadd_ps\">_mm256_mask3_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm256_mask3_fnmadd_pd\">_mm256_mask3_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm256_mask3_fnmadd_ps\">_mm256_mask3_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm256_mask3_fnmsub_pd\">_mm256_mask3_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask3_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm256_mask3_fnmsub_ps\">_mm256_mask3_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_abs_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_abs_epi8\">_mm256_mask_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_abs_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_abs_epi16\">_mm256_mask_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_abs_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_abs_epi32\">_mm256_mask_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_abs_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_abs_epi64\">_mm256_mask_abs_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_add_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_add_epi8\">_mm256_mask_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_add_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_add_epi16\">_mm256_mask_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_add_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_add_epi32\">_mm256_mask_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_add_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_add_epi64\">_mm256_mask_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_add_pd.html\" title=\"fn core::arch::x86::_mm256_mask_add_pd\">_mm256_mask_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_add_ps.html\" title=\"fn core::arch::x86::_mm256_mask_add_ps\">_mm256_mask_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_adds_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_adds_epi8\">_mm256_mask_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_adds_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_adds_epi16\">_mm256_mask_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_adds_epu8.html\" title=\"fn core::arch::x86::_mm256_mask_adds_epu8\">_mm256_mask_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_adds_epu16.html\" title=\"fn core::arch::x86::_mm256_mask_adds_epu16\">_mm256_mask_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_alignr_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_alignr_epi8\">_mm256_mask_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_alignr_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_alignr_epi32\">_mm256_mask_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_alignr_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_alignr_epi64\">_mm256_mask_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_and_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_and_epi32\">_mm256_mask_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_and_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_and_epi64\">_mm256_mask_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_andnot_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_andnot_epi32\">_mm256_mask_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_andnot_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_andnot_epi64\">_mm256_mask_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_avg_epu8.html\" title=\"fn core::arch::x86::_mm256_mask_avg_epu8\">_mm256_mask_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_avg_epu16.html\" title=\"fn core::arch::x86::_mm256_mask_avg_epu16\">_mm256_mask_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_bitshuffle_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_bitshuffle_epi64_mask\">_mm256_mask_bitshuffle_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.\nThen groups 8 8-bit values from <code>c</code>as indices into the bits of the corresponding 64-bit integer.\nIt then selects these bits and packs them into the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_blend_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_blend_epi8\">_mm256_mask_blend_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_blend_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_blend_epi16\">_mm256_mask_blend_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_blend_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_blend_epi32\">_mm256_mask_blend_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_blend_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_blend_epi64\">_mm256_mask_blend_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_blend_pd.html\" title=\"fn core::arch::x86::_mm256_mask_blend_pd\">_mm256_mask_blend_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_blend_ps.html\" title=\"fn core::arch::x86::_mm256_mask_blend_ps\">_mm256_mask_blend_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcast_f32x4.html\" title=\"fn core::arch::x86::_mm256_mask_broadcast_f32x4\">_mm256_mask_broadcast_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcast_i32x4.html\" title=\"fn core::arch::x86::_mm256_mask_broadcast_i32x4\">_mm256_mask_broadcast_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_broadcastb_epi8\">_mm256_mask_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_broadcastd_epi32\">_mm256_mask_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_broadcastq_epi64\">_mm256_mask_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm256_mask_broadcastsd_pd\">_mm256_mask_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm256_mask_broadcastss_ps\">_mm256_mask_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_broadcastw_epi16\">_mm256_mask_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epi8_mask\">_mm256_mask_cmp_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epi16_mask\">_mm256_mask_cmp_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epi32_mask\">_mm256_mask_cmp_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epi64_mask\">_mm256_mask_cmp_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epu8_mask\">_mm256_mask_cmp_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epu16_mask\">_mm256_mask_cmp_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epu32_mask\">_mm256_mask_cmp_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_epu64_mask\">_mm256_mask_cmp_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_pd_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_pd_mask\">_mm256_mask_cmp_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmp_ps_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmp_ps_mask\">_mm256_mask_cmp_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epi8_mask\">_mm256_mask_cmpeq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epi16_mask\">_mm256_mask_cmpeq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epi32_mask\">_mm256_mask_cmpeq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epi64_mask\">_mm256_mask_cmpeq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epu8_mask\">_mm256_mask_cmpeq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epu16_mask\">_mm256_mask_cmpeq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epu32_mask\">_mm256_mask_cmpeq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpeq_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpeq_epu64_mask\">_mm256_mask_cmpeq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epi8_mask\">_mm256_mask_cmpge_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epi16_mask\">_mm256_mask_cmpge_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epi32_mask\">_mm256_mask_cmpge_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epi64_mask\">_mm256_mask_cmpge_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epu8_mask\">_mm256_mask_cmpge_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epu16_mask\">_mm256_mask_cmpge_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epu32_mask\">_mm256_mask_cmpge_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpge_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpge_epu64_mask\">_mm256_mask_cmpge_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epi8_mask\">_mm256_mask_cmpgt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epi16_mask\">_mm256_mask_cmpgt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epi32_mask\">_mm256_mask_cmpgt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epi64_mask\">_mm256_mask_cmpgt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epu8_mask\">_mm256_mask_cmpgt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epu16_mask\">_mm256_mask_cmpgt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epu32_mask\">_mm256_mask_cmpgt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpgt_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpgt_epu64_mask\">_mm256_mask_cmpgt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epi8_mask\">_mm256_mask_cmple_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epi16_mask\">_mm256_mask_cmple_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epi32_mask\">_mm256_mask_cmple_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epi64_mask\">_mm256_mask_cmple_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epu8_mask\">_mm256_mask_cmple_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epu16_mask\">_mm256_mask_cmple_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epu32_mask\">_mm256_mask_cmple_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmple_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmple_epu64_mask\">_mm256_mask_cmple_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epi8_mask\">_mm256_mask_cmplt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epi16_mask\">_mm256_mask_cmplt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epi32_mask\">_mm256_mask_cmplt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epi64_mask\">_mm256_mask_cmplt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epu8_mask\">_mm256_mask_cmplt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epu16_mask\">_mm256_mask_cmplt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epu32_mask\">_mm256_mask_cmplt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmplt_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmplt_epu64_mask\">_mm256_mask_cmplt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epi8_mask\">_mm256_mask_cmpneq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epi16_mask\">_mm256_mask_cmpneq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epi32_mask\">_mm256_mask_cmpneq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epi64_mask\">_mm256_mask_cmpneq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epu8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epu8_mask\">_mm256_mask_cmpneq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epu16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epu16_mask\">_mm256_mask_cmpneq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epu32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epu32_mask\">_mm256_mask_cmpneq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cmpneq_epu64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_cmpneq_epu64_mask\">_mm256_mask_cmpneq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compress_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_compress_epi8\">_mm256_mask_compress_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compress_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_compress_epi16\">_mm256_mask_compress_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compress_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_compress_epi32\">_mm256_mask_compress_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compress_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_compress_epi64\">_mm256_mask_compress_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compress_pd.html\" title=\"fn core::arch::x86::_mm256_mask_compress_pd\">_mm256_mask_compress_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compress_ps.html\" title=\"fn core::arch::x86::_mm256_mask_compress_ps\">_mm256_mask_compress_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compressstoreu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_compressstoreu_epi8\">_mm256_mask_compressstoreu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compressstoreu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_compressstoreu_epi16\">_mm256_mask_compressstoreu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compressstoreu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_compressstoreu_epi32\">_mm256_mask_compressstoreu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compressstoreu_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_compressstoreu_epi64\">_mm256_mask_compressstoreu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compressstoreu_pd.html\" title=\"fn core::arch::x86::_mm256_mask_compressstoreu_pd\">_mm256_mask_compressstoreu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_compressstoreu_ps.html\" title=\"fn core::arch::x86::_mm256_mask_compressstoreu_ps\">_mm256_mask_compressstoreu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_conflict_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_conflict_epi32\">_mm256_mask_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_conflict_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_conflict_epi64\">_mm256_mask_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm256_mask_cvt_roundps_ph\">_mm256_mask_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi8_epi16\">_mm256_mask_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi8_epi32\">_mm256_mask_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi8_epi64\">_mm256_mask_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi16_epi8\">_mm256_mask_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi16_epi32\">_mm256_mask_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi16_epi64\">_mm256_mask_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi16_storeu_epi8\">_mm256_mask_cvtepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_epi8\">_mm256_mask_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_epi16\">_mm256_mask_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_epi64\">_mm256_mask_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_pd\">_mm256_mask_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_ps\">_mm256_mask_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_storeu_epi8\">_mm256_mask_cvtepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi32_storeu_epi16\">_mm256_mask_cvtepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi64_epi8\">_mm256_mask_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi64_epi16\">_mm256_mask_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi64_epi32\">_mm256_mask_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi64_storeu_epi8\">_mm256_mask_cvtepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi64_storeu_epi16\">_mm256_mask_cvtepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepi64_storeu_epi32\">_mm256_mask_cvtepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu8_epi16\">_mm256_mask_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu8_epi32\">_mm256_mask_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu8_epi64\">_mm256_mask_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu16_epi32\">_mm256_mask_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu16_epi64\">_mm256_mask_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu32_epi64\">_mm256_mask_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm256_mask_cvtepu32_pd\">_mm256_mask_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm256_mask_cvtne2ps_pbh\">_mm256_mask_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two vectors a and b\nto packed BF16 (16-bit) floating-point elements and store the results in single vector\ndst using writemask k (elements are copied from src when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&amp;avx512techs=AVX512_BF16&amp;text=_mm256_mask_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtneps_pbh.html\" title=\"fn core::arch::x86::_mm256_mask_cvtneps_pbh\">_mm256_mask_cvtneps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)\nfloating-point elements, and store the results in dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_mask_cvtneps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtpd_epi32\">_mm256_mask_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtpd_epu32\">_mm256_mask_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm256_mask_cvtpd_ps\">_mm256_mask_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtph_ps.html\" title=\"fn core::arch::x86::_mm256_mask_cvtph_ps\">_mm256_mask_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtps_epi32\">_mm256_mask_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtps_epu32\">_mm256_mask_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtps_ph.html\" title=\"fn core::arch::x86::_mm256_mask_cvtps_ph\">_mm256_mask_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi16_epi8\">_mm256_mask_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi16_storeu_epi8\">_mm256_mask_cvtsepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi32_epi8\">_mm256_mask_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi32_epi16\">_mm256_mask_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi32_storeu_epi8\">_mm256_mask_cvtsepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi32_storeu_epi16\">_mm256_mask_cvtsepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi64_epi8\">_mm256_mask_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi64_epi16\">_mm256_mask_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi64_epi32\">_mm256_mask_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi64_storeu_epi8\">_mm256_mask_cvtsepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi64_storeu_epi16\">_mm256_mask_cvtsepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtsepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtsepi64_storeu_epi32\">_mm256_mask_cvtsepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvttpd_epi32\">_mm256_mask_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_cvttpd_epu32\">_mm256_mask_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvttps_epi32\">_mm256_mask_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_cvttps_epu32\">_mm256_mask_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi16_epi8\">_mm256_mask_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi16_storeu_epi8\">_mm256_mask_cvtusepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi32_epi8\">_mm256_mask_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi32_epi16\">_mm256_mask_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi32_storeu_epi8\">_mm256_mask_cvtusepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi32_storeu_epi16\">_mm256_mask_cvtusepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi64_epi8\">_mm256_mask_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi64_epi16\">_mm256_mask_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi64_epi32\">_mm256_mask_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi64_storeu_epi8\">_mm256_mask_cvtusepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi64_storeu_epi16\">_mm256_mask_cvtusepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_cvtusepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_cvtusepi64_storeu_epi32\">_mm256_mask_cvtusepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm256_mask_dbsad_epu8\">_mm256_mask_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_div_pd.html\" title=\"fn core::arch::x86::_mm256_mask_div_pd\">_mm256_mask_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_div_ps.html\" title=\"fn core::arch::x86::_mm256_mask_div_ps\">_mm256_mask_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm256_mask_dpbf16_ps\">_mm256_mask_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_mask_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_dpbusd_epi32\">_mm256_mask_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_dpbusds_epi32\">_mm256_mask_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_dpwssd_epi32\">_mm256_mask_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_dpwssds_epi32\">_mm256_mask_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expand_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_expand_epi8\">_mm256_mask_expand_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expand_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_expand_epi16\">_mm256_mask_expand_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expand_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_expand_epi32\">_mm256_mask_expand_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expand_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_expand_epi64\">_mm256_mask_expand_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expand_pd.html\" title=\"fn core::arch::x86::_mm256_mask_expand_pd\">_mm256_mask_expand_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expand_ps.html\" title=\"fn core::arch::x86::_mm256_mask_expand_ps\">_mm256_mask_expand_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expandloadu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_expandloadu_epi8\">_mm256_mask_expandloadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expandloadu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_expandloadu_epi16\">_mm256_mask_expandloadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expandloadu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_expandloadu_epi32\">_mm256_mask_expandloadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expandloadu_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_expandloadu_epi64\">_mm256_mask_expandloadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expandloadu_pd.html\" title=\"fn core::arch::x86::_mm256_mask_expandloadu_pd\">_mm256_mask_expandloadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_expandloadu_ps.html\" title=\"fn core::arch::x86::_mm256_mask_expandloadu_ps\">_mm256_mask_expandloadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_extractf32x4_ps.html\" title=\"fn core::arch::x86::_mm256_mask_extractf32x4_ps\">_mm256_mask_extractf32x4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_extracti32x4_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_extracti32x4_epi32\">_mm256_mask_extracti32x4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fixupimm_pd\">_mm256_mask_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fixupimm_ps\">_mm256_mask_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmadd_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fmadd_pd\">_mm256_mask_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmadd_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fmadd_ps\">_mm256_mask_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fmaddsub_pd\">_mm256_mask_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fmaddsub_ps\">_mm256_mask_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmsub_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fmsub_pd\">_mm256_mask_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmsub_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fmsub_ps\">_mm256_mask_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fmsubadd_pd\">_mm256_mask_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fmsubadd_ps\">_mm256_mask_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fnmadd_pd\">_mm256_mask_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fnmadd_ps\">_mm256_mask_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm256_mask_fnmsub_pd\">_mm256_mask_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm256_mask_fnmsub_ps\">_mm256_mask_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_getexp_pd.html\" title=\"fn core::arch::x86::_mm256_mask_getexp_pd\">_mm256_mask_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_getexp_ps.html\" title=\"fn core::arch::x86::_mm256_mask_getexp_ps\">_mm256_mask_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_getmant_pd.html\" title=\"fn core::arch::x86::_mm256_mask_getmant_pd\">_mm256_mask_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_getmant_ps.html\" title=\"fn core::arch::x86::_mm256_mask_getmant_ps\">_mm256_mask_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_gf2p8affine_epi64_epi8\">_mm256_mask_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_gf2p8affineinv_epi64_epi8\">_mm256_mask_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_gf2p8mul_epi8\">_mm256_mask_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_insertf32x4.html\" title=\"fn core::arch::x86::_mm256_mask_insertf32x4\">_mm256_mask_insertf32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_inserti32x4.html\" title=\"fn core::arch::x86::_mm256_mask_inserti32x4\">_mm256_mask_inserti32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_load_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_load_epi32\">_mm256_mask_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_load_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_load_epi64\">_mm256_mask_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_load_pd.html\" title=\"fn core::arch::x86::_mm256_mask_load_pd\">_mm256_mask_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_load_ps.html\" title=\"fn core::arch::x86::_mm256_mask_load_ps\">_mm256_mask_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_loadu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_loadu_epi8\">_mm256_mask_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 8-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_loadu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_loadu_epi16\">_mm256_mask_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 16-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_loadu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_loadu_epi32\">_mm256_mask_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_loadu_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_loadu_epi64\">_mm256_mask_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_loadu_pd.html\" title=\"fn core::arch::x86::_mm256_mask_loadu_pd\">_mm256_mask_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_loadu_ps.html\" title=\"fn core::arch::x86::_mm256_mask_loadu_ps\">_mm256_mask_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_lzcnt_epi32\">_mm256_mask_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_lzcnt_epi64\">_mm256_mask_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_madd_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_madd_epi16\">_mm256_mask_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_maddubs_epi16\">_mm256_mask_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_max_epi8\">_mm256_mask_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_max_epi16\">_mm256_mask_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_max_epi32\">_mm256_mask_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_max_epi64\">_mm256_mask_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epu8.html\" title=\"fn core::arch::x86::_mm256_mask_max_epu8\">_mm256_mask_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epu16.html\" title=\"fn core::arch::x86::_mm256_mask_max_epu16\">_mm256_mask_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_max_epu32\">_mm256_mask_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_epu64.html\" title=\"fn core::arch::x86::_mm256_mask_max_epu64\">_mm256_mask_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_pd.html\" title=\"fn core::arch::x86::_mm256_mask_max_pd\">_mm256_mask_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_max_ps.html\" title=\"fn core::arch::x86::_mm256_mask_max_ps\">_mm256_mask_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_min_epi8\">_mm256_mask_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_min_epi16\">_mm256_mask_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_min_epi32\">_mm256_mask_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_min_epi64\">_mm256_mask_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epu8.html\" title=\"fn core::arch::x86::_mm256_mask_min_epu8\">_mm256_mask_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epu16.html\" title=\"fn core::arch::x86::_mm256_mask_min_epu16\">_mm256_mask_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_min_epu32\">_mm256_mask_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_epu64.html\" title=\"fn core::arch::x86::_mm256_mask_min_epu64\">_mm256_mask_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_pd.html\" title=\"fn core::arch::x86::_mm256_mask_min_pd\">_mm256_mask_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_min_ps.html\" title=\"fn core::arch::x86::_mm256_mask_min_ps\">_mm256_mask_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mov_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_mov_epi8\">_mm256_mask_mov_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mov_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_mov_epi16\">_mm256_mask_mov_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mov_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_mov_epi32\">_mm256_mask_mov_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mov_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_mov_epi64\">_mm256_mask_mov_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mov_pd.html\" title=\"fn core::arch::x86::_mm256_mask_mov_pd\">_mm256_mask_mov_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mov_ps.html\" title=\"fn core::arch::x86::_mm256_mask_mov_ps\">_mm256_mask_mov_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_movedup_pd.html\" title=\"fn core::arch::x86::_mm256_mask_movedup_pd\">_mm256_mask_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_movehdup_ps.html\" title=\"fn core::arch::x86::_mm256_mask_movehdup_ps\">_mm256_mask_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_moveldup_ps.html\" title=\"fn core::arch::x86::_mm256_mask_moveldup_ps\">_mm256_mask_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mul_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_mul_epi32\">_mm256_mask_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mul_epu32.html\" title=\"fn core::arch::x86::_mm256_mask_mul_epu32\">_mm256_mask_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mul_pd.html\" title=\"fn core::arch::x86::_mm256_mask_mul_pd\">_mm256_mask_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mul_ps.html\" title=\"fn core::arch::x86::_mm256_mask_mul_ps\">_mm256_mask_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_mulhi_epi16\">_mm256_mask_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm256_mask_mulhi_epu16\">_mm256_mask_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_mulhrs_epi16\">_mm256_mask_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mullo_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_mullo_epi16\">_mm256_mask_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_mullo_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_mullo_epi32\">_mm256_mask_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_multishift_epi64_epi8\">_mm256_mask_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_or_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_or_epi32\">_mm256_mask_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_or_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_or_epi64\">_mm256_mask_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_packs_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_packs_epi16\">_mm256_mask_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_packs_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_packs_epi32\">_mm256_mask_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_packus_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_packus_epi16\">_mm256_mask_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_packus_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_packus_epi32\">_mm256_mask_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permute_pd.html\" title=\"fn core::arch::x86::_mm256_mask_permute_pd\">_mm256_mask_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permute_ps.html\" title=\"fn core::arch::x86::_mm256_mask_permute_ps\">_mm256_mask_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutevar_pd.html\" title=\"fn core::arch::x86::_mm256_mask_permutevar_pd\">_mm256_mask_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutevar_ps.html\" title=\"fn core::arch::x86::_mm256_mask_permutevar_ps\">_mm256_mask_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_permutex2var_epi8\">_mm256_mask_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_permutex2var_epi16\">_mm256_mask_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_permutex2var_epi32\">_mm256_mask_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_permutex2var_epi64\">_mm256_mask_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm256_mask_permutex2var_pd\">_mm256_mask_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm256_mask_permutex2var_ps\">_mm256_mask_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_permutex_epi64\">_mm256_mask_permutex_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutex_pd.html\" title=\"fn core::arch::x86::_mm256_mask_permutex_pd\">_mm256_mask_permutex_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_permutexvar_epi8\">_mm256_mask_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_permutexvar_epi16\">_mm256_mask_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutexvar_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_permutexvar_epi32\">_mm256_mask_permutexvar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutexvar_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_permutexvar_epi64\">_mm256_mask_permutexvar_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutexvar_pd.html\" title=\"fn core::arch::x86::_mm256_mask_permutexvar_pd\">_mm256_mask_permutexvar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_permutexvar_ps.html\" title=\"fn core::arch::x86::_mm256_mask_permutexvar_ps\">_mm256_mask_permutexvar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_popcnt_epi8\">_mm256_mask_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_popcnt_epi16\">_mm256_mask_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_popcnt_epi32\">_mm256_mask_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_popcnt_epi64\">_mm256_mask_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rcp14_pd.html\" title=\"fn core::arch::x86::_mm256_mask_rcp14_pd\">_mm256_mask_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rcp14_ps.html\" title=\"fn core::arch::x86::_mm256_mask_rcp14_ps\">_mm256_mask_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rol_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_rol_epi32\">_mm256_mask_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rol_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_rol_epi64\">_mm256_mask_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rolv_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_rolv_epi32\">_mm256_mask_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rolv_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_rolv_epi64\">_mm256_mask_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_ror_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_ror_epi32\">_mm256_mask_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_ror_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_ror_epi64\">_mm256_mask_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rorv_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_rorv_epi32\">_mm256_mask_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rorv_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_rorv_epi64\">_mm256_mask_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_roundscale_pd.html\" title=\"fn core::arch::x86::_mm256_mask_roundscale_pd\">_mm256_mask_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_roundscale_ps.html\" title=\"fn core::arch::x86::_mm256_mask_roundscale_ps\">_mm256_mask_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm256_mask_rsqrt14_pd\">_mm256_mask_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm256_mask_rsqrt14_ps\">_mm256_mask_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_scalef_pd.html\" title=\"fn core::arch::x86::_mm256_mask_scalef_pd\">_mm256_mask_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_scalef_ps.html\" title=\"fn core::arch::x86::_mm256_mask_scalef_ps\">_mm256_mask_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_set1_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_set1_epi8\">_mm256_mask_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_set1_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_set1_epi16\">_mm256_mask_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_set1_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_set1_epi32\">_mm256_mask_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_set1_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_set1_epi64\">_mm256_mask_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shldi_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_shldi_epi16\">_mm256_mask_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shldi_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_shldi_epi32\">_mm256_mask_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shldi_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_shldi_epi64\">_mm256_mask_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shldv_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_shldv_epi16\">_mm256_mask_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shldv_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_shldv_epi32\">_mm256_mask_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shldv_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_shldv_epi64\">_mm256_mask_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_shrdi_epi16\">_mm256_mask_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_shrdi_epi32\">_mm256_mask_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_shrdi_epi64\">_mm256_mask_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_shrdv_epi16\">_mm256_mask_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_shrdv_epi32\">_mm256_mask_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_shrdv_epi64\">_mm256_mask_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_epi8\">_mm256_mask_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_epi32\">_mm256_mask_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_f32x4.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_f32x4\">_mm256_mask_shuffle_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_f64x2.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_f64x2\">_mm256_mask_shuffle_f64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_i32x4.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_i32x4\">_mm256_mask_shuffle_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_i64x2.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_i64x2\">_mm256_mask_shuffle_i64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_pd.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_pd\">_mm256_mask_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shuffle_ps.html\" title=\"fn core::arch::x86::_mm256_mask_shuffle_ps\">_mm256_mask_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_shufflehi_epi16\">_mm256_mask_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_shufflelo_epi16\">_mm256_mask_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sll_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_sll_epi16\">_mm256_mask_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sll_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_sll_epi32\">_mm256_mask_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sll_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_sll_epi64\">_mm256_mask_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_slli_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_slli_epi16\">_mm256_mask_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_slli_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_slli_epi32\">_mm256_mask_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_slli_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_slli_epi64\">_mm256_mask_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sllv_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_sllv_epi16\">_mm256_mask_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sllv_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_sllv_epi32\">_mm256_mask_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sllv_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_sllv_epi64\">_mm256_mask_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sqrt_pd.html\" title=\"fn core::arch::x86::_mm256_mask_sqrt_pd\">_mm256_mask_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sqrt_ps.html\" title=\"fn core::arch::x86::_mm256_mask_sqrt_ps\">_mm256_mask_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sra_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_sra_epi16\">_mm256_mask_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sra_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_sra_epi32\">_mm256_mask_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sra_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_sra_epi64\">_mm256_mask_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srai_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_srai_epi16\">_mm256_mask_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srai_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_srai_epi32\">_mm256_mask_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srai_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_srai_epi64\">_mm256_mask_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srav_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_srav_epi16\">_mm256_mask_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srav_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_srav_epi32\">_mm256_mask_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srav_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_srav_epi64\">_mm256_mask_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srl_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_srl_epi16\">_mm256_mask_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srl_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_srl_epi32\">_mm256_mask_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srl_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_srl_epi64\">_mm256_mask_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srli_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_srli_epi16\">_mm256_mask_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srli_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_srli_epi32\">_mm256_mask_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srli_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_srli_epi64\">_mm256_mask_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srlv_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_srlv_epi16\">_mm256_mask_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srlv_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_srlv_epi32\">_mm256_mask_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_srlv_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_srlv_epi64\">_mm256_mask_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_store_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_store_epi32\">_mm256_mask_store_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed 32-bit integers from a into memory using writemask k.\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_store_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_store_epi64\">_mm256_mask_store_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed 64-bit integers from a into memory using writemask k.\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_store_pd.html\" title=\"fn core::arch::x86::_mm256_mask_store_pd\">_mm256_mask_store_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_store_ps.html\" title=\"fn core::arch::x86::_mm256_mask_store_ps\">_mm256_mask_store_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_storeu_epi8\">_mm256_mask_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed 8-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_storeu_epi16\">_mm256_mask_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed 16-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_storeu_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_storeu_epi32\">_mm256_mask_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed 32-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_storeu_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_storeu_epi64\">_mm256_mask_storeu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed 64-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_storeu_pd.html\" title=\"fn core::arch::x86::_mm256_mask_storeu_pd\">_mm256_mask_storeu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_storeu_ps.html\" title=\"fn core::arch::x86::_mm256_mask_storeu_ps\">_mm256_mask_storeu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sub_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_sub_epi8\">_mm256_mask_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sub_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_sub_epi16\">_mm256_mask_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sub_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_sub_epi32\">_mm256_mask_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sub_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_sub_epi64\">_mm256_mask_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sub_pd.html\" title=\"fn core::arch::x86::_mm256_mask_sub_pd\">_mm256_mask_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_sub_ps.html\" title=\"fn core::arch::x86::_mm256_mask_sub_ps\">_mm256_mask_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_subs_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_subs_epi8\">_mm256_mask_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_subs_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_subs_epi16\">_mm256_mask_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_subs_epu8.html\" title=\"fn core::arch::x86::_mm256_mask_subs_epu8\">_mm256_mask_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_subs_epu16.html\" title=\"fn core::arch::x86::_mm256_mask_subs_epu16\">_mm256_mask_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_ternarylogic_epi32\">_mm256_mask_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_ternarylogic_epi64\">_mm256_mask_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_test_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_test_epi8_mask\">_mm256_mask_test_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_test_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_test_epi16_mask\">_mm256_mask_test_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_test_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_test_epi32_mask\">_mm256_mask_test_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_test_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_test_epi64_mask\">_mm256_mask_test_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_testn_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_mask_testn_epi8_mask\">_mm256_mask_testn_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_testn_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_mask_testn_epi16_mask\">_mm256_mask_testn_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_testn_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_mask_testn_epi32_mask\">_mm256_mask_testn_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_testn_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_mask_testn_epi64_mask\">_mm256_mask_testn_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_unpackhi_epi8\">_mm256_mask_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_unpackhi_epi16\">_mm256_mask_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_unpackhi_epi32\">_mm256_mask_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_unpackhi_epi64\">_mm256_mask_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm256_mask_unpackhi_pd\">_mm256_mask_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm256_mask_unpackhi_ps\">_mm256_mask_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm256_mask_unpacklo_epi8\">_mm256_mask_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm256_mask_unpacklo_epi16\">_mm256_mask_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_unpacklo_epi32\">_mm256_mask_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_unpacklo_epi64\">_mm256_mask_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm256_mask_unpacklo_pd\">_mm256_mask_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm256_mask_unpacklo_ps\">_mm256_mask_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_xor_epi32.html\" title=\"fn core::arch::x86::_mm256_mask_xor_epi32\">_mm256_mask_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_mask_xor_epi64.html\" title=\"fn core::arch::x86::_mm256_mask_xor_epi64\">_mm256_mask_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_abs_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_abs_epi8\">_mm256_maskz_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_abs_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_abs_epi16\">_mm256_maskz_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_abs_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_abs_epi32\">_mm256_maskz_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_abs_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_abs_epi64\">_mm256_maskz_abs_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_add_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_add_epi8\">_mm256_maskz_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_add_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_add_epi16\">_mm256_maskz_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_add_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_add_epi32\">_mm256_maskz_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_add_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_add_epi64\">_mm256_maskz_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_add_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_add_pd\">_mm256_maskz_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_add_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_add_ps\">_mm256_maskz_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_adds_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_adds_epi8\">_mm256_maskz_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_adds_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_adds_epi16\">_mm256_maskz_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_adds_epu8.html\" title=\"fn core::arch::x86::_mm256_maskz_adds_epu8\">_mm256_maskz_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_adds_epu16.html\" title=\"fn core::arch::x86::_mm256_maskz_adds_epu16\">_mm256_maskz_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_alignr_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_alignr_epi8\">_mm256_maskz_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_alignr_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_alignr_epi32\">_mm256_maskz_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_alignr_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_alignr_epi64\">_mm256_maskz_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_and_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_and_epi32\">_mm256_maskz_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_and_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_and_epi64\">_mm256_maskz_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_andnot_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_andnot_epi32\">_mm256_maskz_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_andnot_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_andnot_epi64\">_mm256_maskz_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_avg_epu8.html\" title=\"fn core::arch::x86::_mm256_maskz_avg_epu8\">_mm256_maskz_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_avg_epu16.html\" title=\"fn core::arch::x86::_mm256_maskz_avg_epu16\">_mm256_maskz_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcast_f32x4.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcast_f32x4\">_mm256_maskz_broadcast_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcast_i32x4.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcast_i32x4\">_mm256_maskz_broadcast_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcastb_epi8\">_mm256_maskz_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcastd_epi32\">_mm256_maskz_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcastq_epi64\">_mm256_maskz_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcastsd_pd\">_mm256_maskz_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcastss_ps\">_mm256_maskz_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_broadcastw_epi16\">_mm256_maskz_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_compress_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_compress_epi8\">_mm256_maskz_compress_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_compress_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_compress_epi16\">_mm256_maskz_compress_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_compress_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_compress_epi32\">_mm256_maskz_compress_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_compress_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_compress_epi64\">_mm256_maskz_compress_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_compress_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_compress_pd\">_mm256_maskz_compress_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_compress_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_compress_ps\">_mm256_maskz_compress_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_conflict_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_conflict_epi32\">_mm256_maskz_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_conflict_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_conflict_epi64\">_mm256_maskz_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm256_maskz_cvt_roundps_ph\">_mm256_maskz_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi8_epi16\">_mm256_maskz_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi8_epi32\">_mm256_maskz_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi8_epi64\">_mm256_maskz_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi16_epi8\">_mm256_maskz_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi16_epi32\">_mm256_maskz_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi16_epi64\">_mm256_maskz_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi32_epi8\">_mm256_maskz_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi32_epi16\">_mm256_maskz_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi32_epi64\">_mm256_maskz_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi32_pd\">_mm256_maskz_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi32_ps\">_mm256_maskz_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi64_epi8\">_mm256_maskz_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi64_epi16\">_mm256_maskz_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepi64_epi32\">_mm256_maskz_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu8_epi16\">_mm256_maskz_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu8_epi32\">_mm256_maskz_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu8_epi64\">_mm256_maskz_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu16_epi32\">_mm256_maskz_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu16_epi64\">_mm256_maskz_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu32_epi64\">_mm256_maskz_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtepu32_pd\">_mm256_maskz_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtne2ps_pbh\">_mm256_maskz_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two vectors a and b\nto packed BF16 (16-bit) floating-point elements, and store the results in single vector\ndst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&amp;avx512techs=AVX512_BF16&amp;text=_mm256_maskz_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtneps_pbh.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtneps_pbh\">_mm256_maskz_cvtneps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)\nfloating-point elements, and store the results in dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_maskz_cvtneps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtpd_epi32\">_mm256_maskz_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtpd_epu32\">_mm256_maskz_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtpd_ps\">_mm256_maskz_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtph_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtph_ps\">_mm256_maskz_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtps_epi32\">_mm256_maskz_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtps_epu32\">_mm256_maskz_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtps_ph.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtps_ph\">_mm256_maskz_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtsepi16_epi8\">_mm256_maskz_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtsepi32_epi8\">_mm256_maskz_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtsepi32_epi16\">_mm256_maskz_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtsepi64_epi8\">_mm256_maskz_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtsepi64_epi16\">_mm256_maskz_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtsepi64_epi32\">_mm256_maskz_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvttpd_epi32\">_mm256_maskz_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvttpd_epu32\">_mm256_maskz_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvttps_epi32\">_mm256_maskz_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvttps_epu32\">_mm256_maskz_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtusepi16_epi8\">_mm256_maskz_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtusepi32_epi8\">_mm256_maskz_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtusepi32_epi16\">_mm256_maskz_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtusepi64_epi8\">_mm256_maskz_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtusepi64_epi16\">_mm256_maskz_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_cvtusepi64_epi32\">_mm256_maskz_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm256_maskz_dbsad_epu8\">_mm256_maskz_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_div_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_div_pd\">_mm256_maskz_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_div_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_div_ps\">_mm256_maskz_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_dpbf16_ps\">_mm256_maskz_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_maskz_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_dpbusd_epi32\">_mm256_maskz_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_dpbusds_epi32\">_mm256_maskz_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_dpwssd_epi32\">_mm256_maskz_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_dpwssds_epi32\">_mm256_maskz_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expand_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_expand_epi8\">_mm256_maskz_expand_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expand_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_expand_epi16\">_mm256_maskz_expand_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expand_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_expand_epi32\">_mm256_maskz_expand_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expand_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_expand_epi64\">_mm256_maskz_expand_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expand_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_expand_pd\">_mm256_maskz_expand_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expand_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_expand_ps\">_mm256_maskz_expand_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expandloadu_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_expandloadu_epi8\">_mm256_maskz_expandloadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expandloadu_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_expandloadu_epi16\">_mm256_maskz_expandloadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expandloadu_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_expandloadu_epi32\">_mm256_maskz_expandloadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expandloadu_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_expandloadu_epi64\">_mm256_maskz_expandloadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expandloadu_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_expandloadu_pd\">_mm256_maskz_expandloadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_expandloadu_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_expandloadu_ps\">_mm256_maskz_expandloadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_extractf32x4_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_extractf32x4_ps\">_mm256_maskz_extractf32x4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_extracti32x4_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_extracti32x4_epi32\">_mm256_maskz_extracti32x4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fixupimm_pd\">_mm256_maskz_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fixupimm_ps\">_mm256_maskz_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmadd_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fmadd_pd\">_mm256_maskz_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmadd_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fmadd_ps\">_mm256_maskz_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fmaddsub_pd\">_mm256_maskz_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fmaddsub_ps\">_mm256_maskz_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmsub_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fmsub_pd\">_mm256_maskz_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmsub_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fmsub_ps\">_mm256_maskz_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fmsubadd_pd\">_mm256_maskz_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fmsubadd_ps\">_mm256_maskz_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fnmadd_pd\">_mm256_maskz_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fnmadd_ps\">_mm256_maskz_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_fnmsub_pd\">_mm256_maskz_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_fnmsub_ps\">_mm256_maskz_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_getexp_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_getexp_pd\">_mm256_maskz_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_getexp_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_getexp_ps\">_mm256_maskz_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_getmant_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_getmant_pd\">_mm256_maskz_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_getmant_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_getmant_ps\">_mm256_maskz_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_gf2p8affine_epi64_epi8\">_mm256_maskz_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_gf2p8affineinv_epi64_epi8\">_mm256_maskz_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_gf2p8mul_epi8\">_mm256_maskz_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_insertf32x4.html\" title=\"fn core::arch::x86::_mm256_maskz_insertf32x4\">_mm256_maskz_insertf32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_inserti32x4.html\" title=\"fn core::arch::x86::_mm256_maskz_inserti32x4\">_mm256_maskz_inserti32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_load_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_load_epi32\">_mm256_maskz_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_load_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_load_epi64\">_mm256_maskz_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_load_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_load_pd\">_mm256_maskz_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_load_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_load_ps\">_mm256_maskz_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_loadu_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_loadu_epi8\">_mm256_maskz_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 8-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_loadu_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_loadu_epi16\">_mm256_maskz_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 16-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_loadu_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_loadu_epi32\">_mm256_maskz_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_loadu_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_loadu_epi64\">_mm256_maskz_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_loadu_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_loadu_pd\">_mm256_maskz_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_loadu_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_loadu_ps\">_mm256_maskz_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_lzcnt_epi32\">_mm256_maskz_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_lzcnt_epi64\">_mm256_maskz_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_madd_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_madd_epi16\">_mm256_maskz_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_maddubs_epi16\">_mm256_maskz_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epi8\">_mm256_maskz_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epi16\">_mm256_maskz_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epi32\">_mm256_maskz_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epi64\">_mm256_maskz_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epu8.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epu8\">_mm256_maskz_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epu16.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epu16\">_mm256_maskz_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epu32\">_mm256_maskz_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_epu64.html\" title=\"fn core::arch::x86::_mm256_maskz_max_epu64\">_mm256_maskz_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_max_pd\">_mm256_maskz_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_max_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_max_ps\">_mm256_maskz_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epi8\">_mm256_maskz_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epi16\">_mm256_maskz_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epi32\">_mm256_maskz_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epi64\">_mm256_maskz_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epu8.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epu8\">_mm256_maskz_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epu16.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epu16\">_mm256_maskz_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epu32\">_mm256_maskz_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_epu64.html\" title=\"fn core::arch::x86::_mm256_maskz_min_epu64\">_mm256_maskz_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_min_pd\">_mm256_maskz_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_min_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_min_ps\">_mm256_maskz_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mov_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_mov_epi8\">_mm256_maskz_mov_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mov_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_mov_epi16\">_mm256_maskz_mov_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mov_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_mov_epi32\">_mm256_maskz_mov_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mov_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_mov_epi64\">_mm256_maskz_mov_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mov_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_mov_pd\">_mm256_maskz_mov_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mov_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_mov_ps\">_mm256_maskz_mov_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_movedup_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_movedup_pd\">_mm256_maskz_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_movehdup_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_movehdup_ps\">_mm256_maskz_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_moveldup_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_moveldup_ps\">_mm256_maskz_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mul_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_mul_epi32\">_mm256_maskz_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mul_epu32.html\" title=\"fn core::arch::x86::_mm256_maskz_mul_epu32\">_mm256_maskz_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mul_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_mul_pd\">_mm256_maskz_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mul_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_mul_ps\">_mm256_maskz_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_mulhi_epi16\">_mm256_maskz_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm256_maskz_mulhi_epu16\">_mm256_maskz_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_mulhrs_epi16\">_mm256_maskz_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mullo_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_mullo_epi16\">_mm256_maskz_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_mullo_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_mullo_epi32\">_mm256_maskz_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_multishift_epi64_epi8\">_mm256_maskz_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_or_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_or_epi32\">_mm256_maskz_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_or_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_or_epi64\">_mm256_maskz_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_packs_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_packs_epi16\">_mm256_maskz_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_packs_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_packs_epi32\">_mm256_maskz_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_packus_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_packus_epi16\">_mm256_maskz_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_packus_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_packus_epi32\">_mm256_maskz_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permute_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_permute_pd\">_mm256_maskz_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permute_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_permute_ps\">_mm256_maskz_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutevar_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_permutevar_pd\">_mm256_maskz_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutevar_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_permutevar_ps\">_mm256_maskz_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex2var_epi8\">_mm256_maskz_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex2var_epi16\">_mm256_maskz_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex2var_epi32\">_mm256_maskz_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex2var_epi64\">_mm256_maskz_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex2var_pd\">_mm256_maskz_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex2var_ps\">_mm256_maskz_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex_epi64\">_mm256_maskz_permutex_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutex_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_permutex_pd\">_mm256_maskz_permutex_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_permutexvar_epi8\">_mm256_maskz_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_permutexvar_epi16\">_mm256_maskz_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutexvar_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_permutexvar_epi32\">_mm256_maskz_permutexvar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutexvar_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_permutexvar_epi64\">_mm256_maskz_permutexvar_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutexvar_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_permutexvar_pd\">_mm256_maskz_permutexvar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_permutexvar_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_permutexvar_ps\">_mm256_maskz_permutexvar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_popcnt_epi8\">_mm256_maskz_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_popcnt_epi16\">_mm256_maskz_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_popcnt_epi32\">_mm256_maskz_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_popcnt_epi64\">_mm256_maskz_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rcp14_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_rcp14_pd\">_mm256_maskz_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rcp14_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_rcp14_ps\">_mm256_maskz_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rol_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_rol_epi32\">_mm256_maskz_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rol_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_rol_epi64\">_mm256_maskz_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rolv_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_rolv_epi32\">_mm256_maskz_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rolv_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_rolv_epi64\">_mm256_maskz_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_ror_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_ror_epi32\">_mm256_maskz_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_ror_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_ror_epi64\">_mm256_maskz_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rorv_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_rorv_epi32\">_mm256_maskz_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rorv_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_rorv_epi64\">_mm256_maskz_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_roundscale_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_roundscale_pd\">_mm256_maskz_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_roundscale_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_roundscale_ps\">_mm256_maskz_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_rsqrt14_pd\">_mm256_maskz_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_rsqrt14_ps\">_mm256_maskz_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_scalef_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_scalef_pd\">_mm256_maskz_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_scalef_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_scalef_ps\">_mm256_maskz_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_set1_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_set1_epi8\">_mm256_maskz_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_set1_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_set1_epi16\">_mm256_maskz_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_set1_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_set1_epi32\">_mm256_maskz_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_set1_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_set1_epi64\">_mm256_maskz_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shldi_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_shldi_epi16\">_mm256_maskz_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shldi_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_shldi_epi32\">_mm256_maskz_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shldi_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_shldi_epi64\">_mm256_maskz_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shldv_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_shldv_epi16\">_mm256_maskz_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shldv_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_shldv_epi32\">_mm256_maskz_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shldv_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_shldv_epi64\">_mm256_maskz_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_shrdi_epi16\">_mm256_maskz_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_shrdi_epi32\">_mm256_maskz_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_shrdi_epi64\">_mm256_maskz_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_shrdv_epi16\">_mm256_maskz_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_shrdv_epi32\">_mm256_maskz_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_shrdv_epi64\">_mm256_maskz_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_epi8\">_mm256_maskz_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_epi32\">_mm256_maskz_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_f32x4.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_f32x4\">_mm256_maskz_shuffle_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_f64x2.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_f64x2\">_mm256_maskz_shuffle_f64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_i32x4.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_i32x4\">_mm256_maskz_shuffle_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_i64x2.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_i64x2\">_mm256_maskz_shuffle_i64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_pd\">_mm256_maskz_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shuffle_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_shuffle_ps\">_mm256_maskz_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_shufflehi_epi16\">_mm256_maskz_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_shufflelo_epi16\">_mm256_maskz_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sll_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_sll_epi16\">_mm256_maskz_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sll_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_sll_epi32\">_mm256_maskz_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sll_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_sll_epi64\">_mm256_maskz_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_slli_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_slli_epi16\">_mm256_maskz_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_slli_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_slli_epi32\">_mm256_maskz_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_slli_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_slli_epi64\">_mm256_maskz_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sllv_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_sllv_epi16\">_mm256_maskz_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sllv_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_sllv_epi32\">_mm256_maskz_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sllv_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_sllv_epi64\">_mm256_maskz_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sqrt_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_sqrt_pd\">_mm256_maskz_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sqrt_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_sqrt_ps\">_mm256_maskz_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sra_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_sra_epi16\">_mm256_maskz_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sra_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_sra_epi32\">_mm256_maskz_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sra_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_sra_epi64\">_mm256_maskz_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srai_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_srai_epi16\">_mm256_maskz_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srai_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_srai_epi32\">_mm256_maskz_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srai_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_srai_epi64\">_mm256_maskz_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srav_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_srav_epi16\">_mm256_maskz_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srav_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_srav_epi32\">_mm256_maskz_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srav_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_srav_epi64\">_mm256_maskz_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srl_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_srl_epi16\">_mm256_maskz_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srl_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_srl_epi32\">_mm256_maskz_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srl_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_srl_epi64\">_mm256_maskz_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srli_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_srli_epi16\">_mm256_maskz_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srli_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_srli_epi32\">_mm256_maskz_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srli_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_srli_epi64\">_mm256_maskz_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srlv_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_srlv_epi16\">_mm256_maskz_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srlv_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_srlv_epi32\">_mm256_maskz_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_srlv_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_srlv_epi64\">_mm256_maskz_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sub_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_sub_epi8\">_mm256_maskz_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sub_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_sub_epi16\">_mm256_maskz_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sub_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_sub_epi32\">_mm256_maskz_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sub_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_sub_epi64\">_mm256_maskz_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sub_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_sub_pd\">_mm256_maskz_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_sub_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_sub_ps\">_mm256_maskz_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_subs_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_subs_epi8\">_mm256_maskz_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_subs_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_subs_epi16\">_mm256_maskz_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_subs_epu8.html\" title=\"fn core::arch::x86::_mm256_maskz_subs_epu8\">_mm256_maskz_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_subs_epu16.html\" title=\"fn core::arch::x86::_mm256_maskz_subs_epu16\">_mm256_maskz_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_ternarylogic_epi32\">_mm256_maskz_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_ternarylogic_epi64\">_mm256_maskz_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_unpackhi_epi8\">_mm256_maskz_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_unpackhi_epi16\">_mm256_maskz_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_unpackhi_epi32\">_mm256_maskz_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_unpackhi_epi64\">_mm256_maskz_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_unpackhi_pd\">_mm256_maskz_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_unpackhi_ps\">_mm256_maskz_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm256_maskz_unpacklo_epi8\">_mm256_maskz_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm256_maskz_unpacklo_epi16\">_mm256_maskz_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_unpacklo_epi32\">_mm256_maskz_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_unpacklo_epi64\">_mm256_maskz_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm256_maskz_unpacklo_pd\">_mm256_maskz_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm256_maskz_unpacklo_ps\">_mm256_maskz_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_xor_epi32.html\" title=\"fn core::arch::x86::_mm256_maskz_xor_epi32\">_mm256_maskz_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_maskz_xor_epi64.html\" title=\"fn core::arch::x86::_mm256_maskz_xor_epi64\">_mm256_maskz_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epi64.html\" title=\"fn core::arch::x86::_mm256_max_epi64\">_mm256_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_max_epu64.html\" title=\"fn core::arch::x86::_mm256_max_epu64\">_mm256_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epi64.html\" title=\"fn core::arch::x86::_mm256_min_epi64\">_mm256_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_min_epu64.html\" title=\"fn core::arch::x86::_mm256_min_epu64\">_mm256_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movepi8_mask.html\" title=\"fn core::arch::x86::_mm256_movepi8_mask\">_mm256_movepi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movepi16_mask.html\" title=\"fn core::arch::x86::_mm256_movepi16_mask\">_mm256_movepi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movm_epi8.html\" title=\"fn core::arch::x86::_mm256_movm_epi8\">_mm256_movm_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_movm_epi16.html\" title=\"fn core::arch::x86::_mm256_movm_epi16\">_mm256_movm_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm256_multishift_epi64_epi8\">_mm256_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_or_epi32.html\" title=\"fn core::arch::x86::_mm256_or_epi32\">_mm256_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_or_epi64.html\" title=\"fn core::arch::x86::_mm256_or_epi64\">_mm256_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm256_permutex2var_epi8\">_mm256_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm256_permutex2var_epi16\">_mm256_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm256_permutex2var_epi32\">_mm256_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm256_permutex2var_epi64\">_mm256_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm256_permutex2var_pd\">_mm256_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm256_permutex2var_ps\">_mm256_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex_epi64.html\" title=\"fn core::arch::x86::_mm256_permutex_epi64\">_mm256_permutex_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutex_pd.html\" title=\"fn core::arch::x86::_mm256_permutex_pd\">_mm256_permutex_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm256_permutexvar_epi8\">_mm256_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm256_permutexvar_epi16\">_mm256_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutexvar_epi32.html\" title=\"fn core::arch::x86::_mm256_permutexvar_epi32\">_mm256_permutexvar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutexvar_epi64.html\" title=\"fn core::arch::x86::_mm256_permutexvar_epi64\">_mm256_permutexvar_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutexvar_pd.html\" title=\"fn core::arch::x86::_mm256_permutexvar_pd\">_mm256_permutexvar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_permutexvar_ps.html\" title=\"fn core::arch::x86::_mm256_permutexvar_ps\">_mm256_permutexvar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm256_popcnt_epi8\">_mm256_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm256_popcnt_epi16\">_mm256_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm256_popcnt_epi32\">_mm256_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm256_popcnt_epi64\">_mm256_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rcp14_pd.html\" title=\"fn core::arch::x86::_mm256_rcp14_pd\">_mm256_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rcp14_ps.html\" title=\"fn core::arch::x86::_mm256_rcp14_ps\">_mm256_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rol_epi32.html\" title=\"fn core::arch::x86::_mm256_rol_epi32\">_mm256_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rol_epi64.html\" title=\"fn core::arch::x86::_mm256_rol_epi64\">_mm256_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rolv_epi32.html\" title=\"fn core::arch::x86::_mm256_rolv_epi32\">_mm256_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rolv_epi64.html\" title=\"fn core::arch::x86::_mm256_rolv_epi64\">_mm256_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_ror_epi32.html\" title=\"fn core::arch::x86::_mm256_ror_epi32\">_mm256_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_ror_epi64.html\" title=\"fn core::arch::x86::_mm256_ror_epi64\">_mm256_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rorv_epi32.html\" title=\"fn core::arch::x86::_mm256_rorv_epi32\">_mm256_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_rorv_epi64.html\" title=\"fn core::arch::x86::_mm256_rorv_epi64\">_mm256_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_roundscale_pd.html\" title=\"fn core::arch::x86::_mm256_roundscale_pd\">_mm256_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_roundscale_ps.html\" title=\"fn core::arch::x86::_mm256_roundscale_ps\">_mm256_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_scalef_pd.html\" title=\"fn core::arch::x86::_mm256_scalef_pd\">_mm256_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_scalef_ps.html\" title=\"fn core::arch::x86::_mm256_scalef_ps\">_mm256_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shldi_epi16.html\" title=\"fn core::arch::x86::_mm256_shldi_epi16\">_mm256_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shldi_epi32.html\" title=\"fn core::arch::x86::_mm256_shldi_epi32\">_mm256_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shldi_epi64.html\" title=\"fn core::arch::x86::_mm256_shldi_epi64\">_mm256_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shldv_epi16.html\" title=\"fn core::arch::x86::_mm256_shldv_epi16\">_mm256_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shldv_epi32.html\" title=\"fn core::arch::x86::_mm256_shldv_epi32\">_mm256_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shldv_epi64.html\" title=\"fn core::arch::x86::_mm256_shldv_epi64\">_mm256_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm256_shrdi_epi16\">_mm256_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm256_shrdi_epi32\">_mm256_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm256_shrdi_epi64\">_mm256_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm256_shrdv_epi16\">_mm256_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm256_shrdv_epi32\">_mm256_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm256_shrdv_epi64\">_mm256_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_f32x4.html\" title=\"fn core::arch::x86::_mm256_shuffle_f32x4\">_mm256_shuffle_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_f64x2.html\" title=\"fn core::arch::x86::_mm256_shuffle_f64x2\">_mm256_shuffle_f64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_i32x4.html\" title=\"fn core::arch::x86::_mm256_shuffle_i32x4\">_mm256_shuffle_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_shuffle_i64x2.html\" title=\"fn core::arch::x86::_mm256_shuffle_i64x2\">_mm256_shuffle_i64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sllv_epi16.html\" title=\"fn core::arch::x86::_mm256_sllv_epi16\">_mm256_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_sra_epi64.html\" title=\"fn core::arch::x86::_mm256_sra_epi64\">_mm256_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srai_epi64.html\" title=\"fn core::arch::x86::_mm256_srai_epi64\">_mm256_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srav_epi16.html\" title=\"fn core::arch::x86::_mm256_srav_epi16\">_mm256_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srav_epi64.html\" title=\"fn core::arch::x86::_mm256_srav_epi64\">_mm256_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_srlv_epi16.html\" title=\"fn core::arch::x86::_mm256_srlv_epi16\">_mm256_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_store_epi32.html\" title=\"fn core::arch::x86::_mm256_store_epi32\">_mm256_store_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_store_epi64.html\" title=\"fn core::arch::x86::_mm256_store_epi64\">_mm256_store_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_epi8.html\" title=\"fn core::arch::x86::_mm256_storeu_epi8\">_mm256_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 256-bits (composed of 32 packed 8-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_epi16.html\" title=\"fn core::arch::x86::_mm256_storeu_epi16\">_mm256_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 256-bits (composed of 16 packed 16-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_epi32.html\" title=\"fn core::arch::x86::_mm256_storeu_epi32\">_mm256_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_storeu_epi64.html\" title=\"fn core::arch::x86::_mm256_storeu_epi64\">_mm256_storeu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm256_ternarylogic_epi32\">_mm256_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm256_ternarylogic_epi64\">_mm256_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_test_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_test_epi8_mask\">_mm256_test_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_test_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_test_epi16_mask\">_mm256_test_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_test_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_test_epi32_mask\">_mm256_test_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_test_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_test_epi64_mask\">_mm256_test_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testn_epi8_mask.html\" title=\"fn core::arch::x86::_mm256_testn_epi8_mask\">_mm256_testn_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testn_epi16_mask.html\" title=\"fn core::arch::x86::_mm256_testn_epi16_mask\">_mm256_testn_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testn_epi32_mask.html\" title=\"fn core::arch::x86::_mm256_testn_epi32_mask\">_mm256_testn_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_testn_epi64_mask.html\" title=\"fn core::arch::x86::_mm256_testn_epi64_mask\">_mm256_testn_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_xor_epi32.html\" title=\"fn core::arch::x86::_mm256_xor_epi32\">_mm256_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm256_xor_epi64.html\" title=\"fn core::arch::x86::_mm256_xor_epi64\">_mm256_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_abs_epi8.html\" title=\"fn core::arch::x86::_mm512_abs_epi8\">_mm512_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_abs_epi16.html\" title=\"fn core::arch::x86::_mm512_abs_epi16\">_mm512_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_abs_epi32.html\" title=\"fn core::arch::x86::_mm512_abs_epi32\">_mm512_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Computes the absolute values of packed 32-bit integers in <code>a</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_abs_epi64.html\" title=\"fn core::arch::x86::_mm512_abs_epi64\">_mm512_abs_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_abs_pd.html\" title=\"fn core::arch::x86::_mm512_abs_pd\">_mm512_abs_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_abs_ps.html\" title=\"fn core::arch::x86::_mm512_abs_ps\">_mm512_abs_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_epi8.html\" title=\"fn core::arch::x86::_mm512_add_epi8\">_mm512_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_epi16.html\" title=\"fn core::arch::x86::_mm512_add_epi16\">_mm512_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_epi32.html\" title=\"fn core::arch::x86::_mm512_add_epi32\">_mm512_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_epi64.html\" title=\"fn core::arch::x86::_mm512_add_epi64\">_mm512_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_pd.html\" title=\"fn core::arch::x86::_mm512_add_pd\">_mm512_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_ps.html\" title=\"fn core::arch::x86::_mm512_add_ps\">_mm512_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_round_pd.html\" title=\"fn core::arch::x86::_mm512_add_round_pd\">_mm512_add_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_add_round_ps.html\" title=\"fn core::arch::x86::_mm512_add_round_ps\">_mm512_add_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_adds_epi8.html\" title=\"fn core::arch::x86::_mm512_adds_epi8\">_mm512_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_adds_epi16.html\" title=\"fn core::arch::x86::_mm512_adds_epi16\">_mm512_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_adds_epu8.html\" title=\"fn core::arch::x86::_mm512_adds_epu8\">_mm512_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_adds_epu16.html\" title=\"fn core::arch::x86::_mm512_adds_epu16\">_mm512_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_aesdec_epi128.html\" title=\"fn core::arch::x86::_mm512_aesdec_epi128\">_mm512_aesdec_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes,avx512f` only\">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class=\"desc docblock-short\">Performs one round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_aesdeclast_epi128.html\" title=\"fn core::arch::x86::_mm512_aesdeclast_epi128\">_mm512_aesdeclast_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes,avx512f` only\">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class=\"desc docblock-short\">Performs the last round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_aesenc_epi128.html\" title=\"fn core::arch::x86::_mm512_aesenc_epi128\">_mm512_aesenc_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes,avx512f` only\">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class=\"desc docblock-short\">Performs one round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_aesenclast_epi128.html\" title=\"fn core::arch::x86::_mm512_aesenclast_epi128\">_mm512_aesenclast_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vaes,avx512f` only\">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class=\"desc docblock-short\">Performs the last round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using\nthe corresponding 128-bit word (key) in <code>round_key</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_alignr_epi8.html\" title=\"fn core::arch::x86::_mm512_alignr_epi8\">_mm512_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_alignr_epi32.html\" title=\"fn core::arch::x86::_mm512_alignr_epi32\">_mm512_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_alignr_epi64.html\" title=\"fn core::arch::x86::_mm512_alignr_epi64\">_mm512_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_and_epi32.html\" title=\"fn core::arch::x86::_mm512_and_epi32\">_mm512_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_and_epi64.html\" title=\"fn core::arch::x86::_mm512_and_epi64\">_mm512_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of 512 bits (composed of packed 64-bit integers) in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_and_si512.html\" title=\"fn core::arch::x86::_mm512_and_si512\">_mm512_and_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of 512 bits (representing integer data) in a and b, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_andnot_epi32.html\" title=\"fn core::arch::x86::_mm512_andnot_epi32\">_mm512_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_andnot_epi64.html\" title=\"fn core::arch::x86::_mm512_andnot_epi64\">_mm512_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 512 bits (composed of packed 64-bit integers) in a and then AND with b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_andnot_si512.html\" title=\"fn core::arch::x86::_mm512_andnot_si512\">_mm512_andnot_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 512 bits (representing integer data) in a and then AND with b, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_avg_epu8.html\" title=\"fn core::arch::x86::_mm512_avg_epu8\">_mm512_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_avg_epu16.html\" title=\"fn core::arch::x86::_mm512_avg_epu16\">_mm512_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_bitshuffle_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_bitshuffle_epi64_mask\">_mm512_bitshuffle_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.\nThen groups 8 8-bit values from <code>c</code>as indices into the bits of the corresponding 64-bit integer.\nIt then selects these bits and packs them into the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcast_f32x4.html\" title=\"fn core::arch::x86::_mm512_broadcast_f32x4\">_mm512_broadcast_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcast_f64x4.html\" title=\"fn core::arch::x86::_mm512_broadcast_f64x4\">_mm512_broadcast_f64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcast_i32x4.html\" title=\"fn core::arch::x86::_mm512_broadcast_i32x4\">_mm512_broadcast_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 32-bit integers from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcast_i64x4.html\" title=\"fn core::arch::x86::_mm512_broadcast_i64x4\">_mm512_broadcast_i64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 64-bit integers from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm512_broadcastb_epi8\">_mm512_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm512_broadcastd_epi32\">_mm512_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastmb_epi64.html\" title=\"fn core::arch::x86::_mm512_broadcastmb_epi64\">_mm512_broadcastmb_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastmw_epi32.html\" title=\"fn core::arch::x86::_mm512_broadcastmw_epi32\">_mm512_broadcastmw_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm512_broadcastq_epi64\">_mm512_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm512_broadcastsd_pd\">_mm512_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm512_broadcastss_ps\">_mm512_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm512_broadcastw_epi16\">_mm512_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_bslli_epi128.html\" title=\"fn core::arch::x86::_mm512_bslli_epi128\">_mm512_bslli_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift 128-bit lanes in a left by imm8 bytes while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_bsrli_epi128.html\" title=\"fn core::arch::x86::_mm512_bsrli_epi128\">_mm512_bsrli_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift 128-bit lanes in a right by imm8 bytes while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castpd128_pd512.html\" title=\"fn core::arch::x86::_mm512_castpd128_pd512\">_mm512_castpd128_pd512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castpd256_pd512.html\" title=\"fn core::arch::x86::_mm512_castpd256_pd512\">_mm512_castpd256_pd512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castpd512_pd128.html\" title=\"fn core::arch::x86::_mm512_castpd512_pd128\">_mm512_castpd512_pd128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512d to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castpd512_pd256.html\" title=\"fn core::arch::x86::_mm512_castpd512_pd256\">_mm512_castpd512_pd256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512d to type __m256d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castpd_ps.html\" title=\"fn core::arch::x86::_mm512_castpd_ps\">_mm512_castpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512d to type __m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castpd_si512.html\" title=\"fn core::arch::x86::_mm512_castpd_si512\">_mm512_castpd_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512d to type __m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castps128_ps512.html\" title=\"fn core::arch::x86::_mm512_castps128_ps512\">_mm512_castps128_ps512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m128 to type __m512; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castps256_ps512.html\" title=\"fn core::arch::x86::_mm512_castps256_ps512\">_mm512_castps256_ps512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256 to type __m512; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castps512_ps128.html\" title=\"fn core::arch::x86::_mm512_castps512_ps128\">_mm512_castps512_ps128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512 to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castps512_ps256.html\" title=\"fn core::arch::x86::_mm512_castps512_ps256\">_mm512_castps512_ps256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512 to type __m256. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castps_pd.html\" title=\"fn core::arch::x86::_mm512_castps_pd\">_mm512_castps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512 to type __m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castps_si512.html\" title=\"fn core::arch::x86::_mm512_castps_si512\">_mm512_castps_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512 to type __m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castsi128_si512.html\" title=\"fn core::arch::x86::_mm512_castsi128_si512\">_mm512_castsi128_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castsi256_si512.html\" title=\"fn core::arch::x86::_mm512_castsi256_si512\">_mm512_castsi256_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castsi512_pd.html\" title=\"fn core::arch::x86::_mm512_castsi512_pd\">_mm512_castsi512_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512i to type __m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castsi512_ps.html\" title=\"fn core::arch::x86::_mm512_castsi512_ps\">_mm512_castsi512_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512i to type __m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castsi512_si128.html\" title=\"fn core::arch::x86::_mm512_castsi512_si128\">_mm512_castsi512_si128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512i to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_castsi512_si256.html\" title=\"fn core::arch::x86::_mm512_castsi512_si256\">_mm512_castsi512_si256</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m512i to type __m256i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_clmulepi64_epi128.html\" title=\"fn core::arch::x86::_mm512_clmulepi64_epi128\">_mm512_clmulepi64_epi128</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `vpclmulqdq,avx512f` only\">(x86 or x86-64) and <code>vpclmulqdq,avx512f</code></span></div><div class=\"desc docblock-short\">Performs a carry-less multiplication of two 64-bit polynomials over the\nfinite field GF(2) - in each of the 4 128-bit lanes.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epi8_mask\">_mm512_cmp_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epi16_mask\">_mm512_cmp_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epi32_mask\">_mm512_cmp_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epi64_mask\">_mm512_cmp_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epu8_mask\">_mm512_cmp_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epu16_mask\">_mm512_cmp_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by <code>IMM8</code>, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epu32_mask\">_mm512_cmp_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_epu64_mask\">_mm512_cmp_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_pd_mask\">_mm512_cmp_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_ps_mask\">_mm512_cmp_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_round_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_round_pd_mask\">_mm512_cmp_round_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmp_round_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmp_round_ps_mask\">_mm512_cmp_round_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epi8_mask\">_mm512_cmpeq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epi16_mask\">_mm512_cmpeq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epi32_mask\">_mm512_cmpeq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epi64_mask\">_mm512_cmpeq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epu8_mask\">_mm512_cmpeq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epu16_mask\">_mm512_cmpeq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epu32_mask\">_mm512_cmpeq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_epu64_mask\">_mm512_cmpeq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_pd_mask\">_mm512_cmpeq_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpeq_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmpeq_ps_mask\">_mm512_cmpeq_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epi8_mask\">_mm512_cmpge_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epi16_mask\">_mm512_cmpge_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epi32_mask\">_mm512_cmpge_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epi64_mask\">_mm512_cmpge_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epu8_mask\">_mm512_cmpge_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epu16_mask\">_mm512_cmpge_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epu32_mask\">_mm512_cmpge_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpge_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpge_epu64_mask\">_mm512_cmpge_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epi8_mask\">_mm512_cmpgt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epi16_mask\">_mm512_cmpgt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epi32_mask\">_mm512_cmpgt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epi64_mask\">_mm512_cmpgt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epu8_mask\">_mm512_cmpgt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epu16_mask\">_mm512_cmpgt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epu32_mask\">_mm512_cmpgt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpgt_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpgt_epu64_mask\">_mm512_cmpgt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epi8_mask\">_mm512_cmple_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epi16_mask\">_mm512_cmple_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epi32_mask\">_mm512_cmple_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epi64_mask\">_mm512_cmple_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epu8_mask\">_mm512_cmple_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epu16_mask\">_mm512_cmple_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epu32_mask\">_mm512_cmple_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_epu64_mask\">_mm512_cmple_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_pd_mask\">_mm512_cmple_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmple_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmple_ps_mask\">_mm512_cmple_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epi8_mask\">_mm512_cmplt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epi16_mask\">_mm512_cmplt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epi32_mask\">_mm512_cmplt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epi64_mask\">_mm512_cmplt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epu8_mask\">_mm512_cmplt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epu16_mask\">_mm512_cmplt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epu32_mask\">_mm512_cmplt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_epu64_mask\">_mm512_cmplt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_pd_mask\">_mm512_cmplt_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmplt_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmplt_ps_mask\">_mm512_cmplt_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epi8_mask\">_mm512_cmpneq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epi16_mask\">_mm512_cmpneq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epi32_mask\">_mm512_cmpneq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epi64_mask\">_mm512_cmpneq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epu8_mask\">_mm512_cmpneq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epu16_mask\">_mm512_cmpneq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epu32_mask\">_mm512_cmpneq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_epu64_mask\">_mm512_cmpneq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_pd_mask\">_mm512_cmpneq_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpneq_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmpneq_ps_mask\">_mm512_cmpneq_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpnle_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmpnle_pd_mask\">_mm512_cmpnle_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpnle_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmpnle_ps_mask\">_mm512_cmpnle_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpnlt_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmpnlt_pd_mask\">_mm512_cmpnlt_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpnlt_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmpnlt_ps_mask\">_mm512_cmpnlt_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpord_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmpord_pd_mask\">_mm512_cmpord_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpord_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmpord_ps_mask\">_mm512_cmpord_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpunord_pd_mask.html\" title=\"fn core::arch::x86::_mm512_cmpunord_pd_mask\">_mm512_cmpunord_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cmpunord_ps_mask.html\" title=\"fn core::arch::x86::_mm512_cmpunord_ps_mask\">_mm512_cmpunord_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_conflict_epi32.html\" title=\"fn core::arch::x86::_mm512_conflict_epi32\">_mm512_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_conflict_epi64.html\" title=\"fn core::arch::x86::_mm512_conflict_epi64\">_mm512_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundepi32_ps.html\" title=\"fn core::arch::x86::_mm512_cvt_roundepi32_ps\">_mm512_cvt_roundepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundepu32_ps.html\" title=\"fn core::arch::x86::_mm512_cvt_roundepu32_ps\">_mm512_cvt_roundepu32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundpd_epi32.html\" title=\"fn core::arch::x86::_mm512_cvt_roundpd_epi32\">_mm512_cvt_roundpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundpd_epu32.html\" title=\"fn core::arch::x86::_mm512_cvt_roundpd_epu32\">_mm512_cvt_roundpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundpd_ps.html\" title=\"fn core::arch::x86::_mm512_cvt_roundpd_ps\">_mm512_cvt_roundpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundph_ps.html\" title=\"fn core::arch::x86::_mm512_cvt_roundph_ps\">_mm512_cvt_roundph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundps_epi32.html\" title=\"fn core::arch::x86::_mm512_cvt_roundps_epi32\">_mm512_cvt_roundps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundps_epu32.html\" title=\"fn core::arch::x86::_mm512_cvt_roundps_epu32\">_mm512_cvt_roundps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundps_pd.html\" title=\"fn core::arch::x86::_mm512_cvt_roundps_pd\">_mm512_cvt_roundps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm512_cvt_roundps_ph\">_mm512_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtepi8_epi16\">_mm512_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtepi8_epi32\">_mm512_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm512_cvtepi8_epi64\">_mm512_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtepi16_epi8\">_mm512_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtepi16_epi32\">_mm512_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm512_cvtepi16_epi64\">_mm512_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtepi32_epi8\">_mm512_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtepi32_epi16\">_mm512_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm512_cvtepi32_epi64\">_mm512_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm512_cvtepi32_pd\">_mm512_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm512_cvtepi32_ps\">_mm512_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi32lo_pd.html\" title=\"fn core::arch::x86::_mm512_cvtepi32lo_pd\">_mm512_cvtepi32lo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtepi64_epi8\">_mm512_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtepi64_epi16\">_mm512_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtepi64_epi32\">_mm512_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtepu8_epi16\">_mm512_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtepu8_epi32\">_mm512_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm512_cvtepu8_epi64\">_mm512_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 8 byte sof a to packed 64-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtepu16_epi32\">_mm512_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm512_cvtepu16_epi64\">_mm512_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm512_cvtepu32_epi64\">_mm512_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm512_cvtepu32_pd\">_mm512_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu32_ps.html\" title=\"fn core::arch::x86::_mm512_cvtepu32_ps\">_mm512_cvtepu32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtepu32lo_pd.html\" title=\"fn core::arch::x86::_mm512_cvtepu32lo_pd\">_mm512_cvtepu32lo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element conversion of the lower half of packed 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm512_cvtne2ps_pbh\">_mm512_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two 512-bit vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results in a<br>\n512-bit wide vector.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&amp;avx512techs=AVX512_BF16&amp;text=_mm512_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtneps_pbh.html\" title=\"fn core::arch::x86::_mm512_cvtneps_pbh\">_mm512_cvtneps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)\nfloating-point elements, and store the results in dst.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_cvtneps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtpd_epi32\">_mm512_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm512_cvtpd_epu32\">_mm512_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm512_cvtpd_ps\">_mm512_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtpd_pslo.html\" title=\"fn core::arch::x86::_mm512_cvtpd_pslo\">_mm512_cvtpd_pslo</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst. The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtph_ps.html\" title=\"fn core::arch::x86::_mm512_cvtph_ps\">_mm512_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtps_epi32\">_mm512_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm512_cvtps_epu32\">_mm512_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtps_pd.html\" title=\"fn core::arch::x86::_mm512_cvtps_pd\">_mm512_cvtps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtps_ph.html\" title=\"fn core::arch::x86::_mm512_cvtps_ph\">_mm512_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtpslo_pd.html\" title=\"fn core::arch::x86::_mm512_cvtpslo_pd\">_mm512_cvtpslo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtsepi16_epi8\">_mm512_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtsepi32_epi8\">_mm512_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtsepi32_epi16\">_mm512_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtsepi64_epi8\">_mm512_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtsepi64_epi16\">_mm512_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtsepi64_epi32\">_mm512_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtsi512_si32.html\" title=\"fn core::arch::x86::_mm512_cvtsi512_si32\">_mm512_cvtsi512_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy the lower 32-bit integer in a to dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtt_roundpd_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtt_roundpd_epi32\">_mm512_cvtt_roundpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtt_roundpd_epu32.html\" title=\"fn core::arch::x86::_mm512_cvtt_roundpd_epu32\">_mm512_cvtt_roundpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtt_roundps_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtt_roundps_epi32\">_mm512_cvtt_roundps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtt_roundps_epu32.html\" title=\"fn core::arch::x86::_mm512_cvtt_roundps_epu32\">_mm512_cvtt_roundps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm512_cvttpd_epi32\">_mm512_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm512_cvttpd_epu32\">_mm512_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm512_cvttps_epi32\">_mm512_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm512_cvttps_epu32\">_mm512_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtusepi16_epi8\">_mm512_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtusepi32_epi8\">_mm512_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtusepi32_epi16\">_mm512_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_cvtusepi64_epi8\">_mm512_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_cvtusepi64_epi16\">_mm512_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_cvtusepi64_epi32\">_mm512_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm512_dbsad_epu8\">_mm512_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_div_pd.html\" title=\"fn core::arch::x86::_mm512_div_pd\">_mm512_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_div_ps.html\" title=\"fn core::arch::x86::_mm512_div_ps\">_mm512_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_div_round_pd.html\" title=\"fn core::arch::x86::_mm512_div_round_pd\">_mm512_div_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, =and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_div_round_ps.html\" title=\"fn core::arch::x86::_mm512_div_round_ps\">_mm512_div_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm512_dpbf16_ps\">_mm512_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst.Compute dot-product of BF16 (16-bit)\nfloating-point pairs in a and b, accumulating the intermediate single-precision (32-bit)\nfloating-point elements with elements in src, and store the results in dst.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm512_dpbusd_epi32\">_mm512_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm512_dpbusds_epi32\">_mm512_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm512_dpwssd_epi32\">_mm512_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm512_dpwssds_epi32\">_mm512_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_extractf32x4_ps.html\" title=\"fn core::arch::x86::_mm512_extractf32x4_ps\">_mm512_extractf32x4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_extractf64x4_pd.html\" title=\"fn core::arch::x86::_mm512_extractf64x4_pd\">_mm512_extractf64x4_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_extracti32x4_epi32.html\" title=\"fn core::arch::x86::_mm512_extracti32x4_epi32\">_mm512_extracti32x4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_extracti64x4_epi64.html\" title=\"fn core::arch::x86::_mm512_extracti64x4_epi64\">_mm512_extracti64x4_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm512_fixupimm_pd\">_mm512_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm512_fixupimm_ps\">_mm512_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fixupimm_round_pd.html\" title=\"fn core::arch::x86::_mm512_fixupimm_round_pd\">_mm512_fixupimm_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fixupimm_round_ps.html\" title=\"fn core::arch::x86::_mm512_fixupimm_round_ps\">_mm512_fixupimm_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmadd_pd.html\" title=\"fn core::arch::x86::_mm512_fmadd_pd\">_mm512_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmadd_ps.html\" title=\"fn core::arch::x86::_mm512_fmadd_ps\">_mm512_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_fmadd_round_pd\">_mm512_fmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_fmadd_round_ps\">_mm512_fmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm512_fmaddsub_pd\">_mm512_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm512_fmaddsub_ps\">_mm512_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmaddsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_fmaddsub_round_pd\">_mm512_fmaddsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmaddsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_fmaddsub_round_ps\">_mm512_fmaddsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsub_pd.html\" title=\"fn core::arch::x86::_mm512_fmsub_pd\">_mm512_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsub_ps.html\" title=\"fn core::arch::x86::_mm512_fmsub_ps\">_mm512_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_fmsub_round_pd\">_mm512_fmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_fmsub_round_ps\">_mm512_fmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm512_fmsubadd_pd\">_mm512_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm512_fmsubadd_ps\">_mm512_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsubadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_fmsubadd_round_pd\">_mm512_fmsubadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fmsubadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_fmsubadd_round_ps\">_mm512_fmsubadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm512_fnmadd_pd\">_mm512_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm512_fnmadd_ps\">_mm512_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_fnmadd_round_pd\">_mm512_fnmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_fnmadd_round_ps\">_mm512_fnmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm512_fnmsub_pd\">_mm512_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm512_fnmsub_ps\">_mm512_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_fnmsub_round_pd\">_mm512_fnmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_fnmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_fnmsub_round_ps\">_mm512_fnmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getexp_pd.html\" title=\"fn core::arch::x86::_mm512_getexp_pd\">_mm512_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getexp_ps.html\" title=\"fn core::arch::x86::_mm512_getexp_ps\">_mm512_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getexp_round_pd.html\" title=\"fn core::arch::x86::_mm512_getexp_round_pd\">_mm512_getexp_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getexp_round_ps.html\" title=\"fn core::arch::x86::_mm512_getexp_round_ps\">_mm512_getexp_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getmant_pd.html\" title=\"fn core::arch::x86::_mm512_getmant_pd\">_mm512_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getmant_ps.html\" title=\"fn core::arch::x86::_mm512_getmant_ps\">_mm512_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.\nThe mantissa is normalized to the interval specified by interv, which can take the following values:\n_MM_MANT_NORM_1_2     // interval [1, 2)\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)\nThe sign is determined by sc which can take the following values:\n_MM_MANT_SIGN_src     // sign = sign(src)\n_MM_MANT_SIGN_zero    // sign = 0\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getmant_round_pd.html\" title=\"fn core::arch::x86::_mm512_getmant_round_pd\">_mm512_getmant_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_getmant_round_ps.html\" title=\"fn core::arch::x86::_mm512_getmant_round_ps\">_mm512_getmant_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_gf2p8affine_epi64_epi8\">_mm512_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_gf2p8affineinv_epi64_epi8\">_mm512_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm512_gf2p8mul_epi8\">_mm512_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32gather_epi32.html\" title=\"fn core::arch::x86::_mm512_i32gather_epi32\">_mm512_i32gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32gather_epi64.html\" title=\"fn core::arch::x86::_mm512_i32gather_epi64\">_mm512_i32gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32gather_pd.html\" title=\"fn core::arch::x86::_mm512_i32gather_pd\">_mm512_i32gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32gather_ps.html\" title=\"fn core::arch::x86::_mm512_i32gather_ps\">_mm512_i32gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32scatter_epi32.html\" title=\"fn core::arch::x86::_mm512_i32scatter_epi32\">_mm512_i32scatter_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32scatter_epi64.html\" title=\"fn core::arch::x86::_mm512_i32scatter_epi64\">_mm512_i32scatter_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32scatter_pd.html\" title=\"fn core::arch::x86::_mm512_i32scatter_pd\">_mm512_i32scatter_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i32scatter_ps.html\" title=\"fn core::arch::x86::_mm512_i32scatter_ps\">_mm512_i32scatter_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64gather_epi32.html\" title=\"fn core::arch::x86::_mm512_i64gather_epi32\">_mm512_i64gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64gather_epi64.html\" title=\"fn core::arch::x86::_mm512_i64gather_epi64\">_mm512_i64gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64gather_pd.html\" title=\"fn core::arch::x86::_mm512_i64gather_pd\">_mm512_i64gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64gather_ps.html\" title=\"fn core::arch::x86::_mm512_i64gather_ps\">_mm512_i64gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64scatter_epi32.html\" title=\"fn core::arch::x86::_mm512_i64scatter_epi32\">_mm512_i64scatter_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64scatter_epi64.html\" title=\"fn core::arch::x86::_mm512_i64scatter_epi64\">_mm512_i64scatter_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64scatter_pd.html\" title=\"fn core::arch::x86::_mm512_i64scatter_pd\">_mm512_i64scatter_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_i64scatter_ps.html\" title=\"fn core::arch::x86::_mm512_i64scatter_ps\">_mm512_i64scatter_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_insertf32x4.html\" title=\"fn core::arch::x86::_mm512_insertf32x4\">_mm512_insertf32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_insertf64x4.html\" title=\"fn core::arch::x86::_mm512_insertf64x4\">_mm512_insertf64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to dst, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into dst at the location specified by imm8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_inserti32x4.html\" title=\"fn core::arch::x86::_mm512_inserti32x4\">_mm512_inserti32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_inserti64x4.html\" title=\"fn core::arch::x86::_mm512_inserti64x4\">_mm512_inserti64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to dst, then insert 256 bits (composed of 4 packed 64-bit integers) from b into dst at the location specified by imm8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_int2mask.html\" title=\"fn core::arch::x86::_mm512_int2mask\">_mm512_int2mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Converts integer mask into bitmask, storing the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kand.html\" title=\"fn core::arch::x86::_mm512_kand\">_mm512_kand</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kandn.html\" title=\"fn core::arch::x86::_mm512_kandn\">_mm512_kandn</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kmov.html\" title=\"fn core::arch::x86::_mm512_kmov\">_mm512_kmov</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy 16-bit mask a to k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_knot.html\" title=\"fn core::arch::x86::_mm512_knot\">_mm512_knot</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of 16-bit mask a, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kor.html\" title=\"fn core::arch::x86::_mm512_kor\">_mm512_kor</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kortestc.html\" title=\"fn core::arch::x86::_mm512_kortestc\">_mm512_kortestc</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs bitwise OR between k1 and k2, storing the result in dst. CF flag is set if dst consists of all 1’s.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kunpackb.html\" title=\"fn core::arch::x86::_mm512_kunpackb\">_mm512_kunpackb</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8 bits from masks a and b, and store the 16-bit result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kxnor.html\" title=\"fn core::arch::x86::_mm512_kxnor\">_mm512_kxnor</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_kxor.html\" title=\"fn core::arch::x86::_mm512_kxor\">_mm512_kxor</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_load_epi32.html\" title=\"fn core::arch::x86::_mm512_load_epi32\">_mm512_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_load_epi64.html\" title=\"fn core::arch::x86::_mm512_load_epi64\">_mm512_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_load_pd.html\" title=\"fn core::arch::x86::_mm512_load_pd\">_mm512_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_load_ps.html\" title=\"fn core::arch::x86::_mm512_load_ps\">_mm512_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_load_si512.html\" title=\"fn core::arch::x86::_mm512_load_si512\">_mm512_load_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits of integer data from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_epi8.html\" title=\"fn core::arch::x86::_mm512_loadu_epi8\">_mm512_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 64 packed 8-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_epi16.html\" title=\"fn core::arch::x86::_mm512_loadu_epi16\">_mm512_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 32 packed 16-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_epi32.html\" title=\"fn core::arch::x86::_mm512_loadu_epi32\">_mm512_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_epi64.html\" title=\"fn core::arch::x86::_mm512_loadu_epi64\">_mm512_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_pd.html\" title=\"fn core::arch::x86::_mm512_loadu_pd\">_mm512_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Loads 512-bits (composed of 8 packed double-precision (64-bit)\nfloating-point elements) from memory into result.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_ps.html\" title=\"fn core::arch::x86::_mm512_loadu_ps\">_mm512_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Loads 512-bits (composed of 16 packed single-precision (32-bit)\nfloating-point elements) from memory into result.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_loadu_si512.html\" title=\"fn core::arch::x86::_mm512_loadu_si512\">_mm512_loadu_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load 512-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm512_lzcnt_epi32\">_mm512_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm512_lzcnt_epi64\">_mm512_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_madd52hi_epu64.html\" title=\"fn core::arch::x86::_mm512_madd52hi_epu64\">_mm512_madd52hi_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512ifma` only\">(x86 or x86-64) and <code>avx512ifma</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 52-bit integers in each 64-bit element of\n<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the high 52-bit\nunsigned integer from the intermediate result with the\ncorresponding unsigned 64-bit integer in <code>a</code>, and store the\nresults in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_madd52lo_epu64.html\" title=\"fn core::arch::x86::_mm512_madd52lo_epu64\">_mm512_madd52lo_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512ifma` only\">(x86 or x86-64) and <code>avx512ifma</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 52-bit integers in each 64-bit element of\n<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the low 52-bit\nunsigned integer from the intermediate result with the\ncorresponding unsigned 64-bit integer in <code>a</code>, and store the\nresults in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_madd_epi16.html\" title=\"fn core::arch::x86::_mm512_madd_epi16\">_mm512_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm512_maddubs_epi16\">_mm512_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Vertically multiply each unsigned 8-bit integer from a with the corresponding signed 8-bit integer from b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm512_mask2_permutex2var_epi8\">_mm512_mask2_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm512_mask2_permutex2var_epi16\">_mm512_mask2_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm512_mask2_permutex2var_epi32\">_mm512_mask2_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm512_mask2_permutex2var_epi64\">_mm512_mask2_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm512_mask2_permutex2var_pd\">_mm512_mask2_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm512_mask2_permutex2var_ps\">_mm512_mask2_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask2int.html\" title=\"fn core::arch::x86::_mm512_mask2int\">_mm512_mask2int</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Converts bit mask k1 into an integer value, storing the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmadd_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmadd_pd\">_mm512_mask3_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmadd_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmadd_ps\">_mm512_mask3_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmadd_round_pd\">_mm512_mask3_fmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmadd_round_ps\">_mm512_mask3_fmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmaddsub_pd\">_mm512_mask3_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmaddsub_ps\">_mm512_mask3_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmaddsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmaddsub_round_pd\">_mm512_mask3_fmaddsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmaddsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmaddsub_round_ps\">_mm512_mask3_fmaddsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsub_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsub_pd\">_mm512_mask3_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsub_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsub_ps\">_mm512_mask3_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsub_round_pd\">_mm512_mask3_fmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsub_round_ps\">_mm512_mask3_fmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsubadd_pd\">_mm512_mask3_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsubadd_ps\">_mm512_mask3_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsubadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsubadd_round_pd\">_mm512_mask3_fmsubadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fmsubadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fmsubadd_round_ps\">_mm512_mask3_fmsubadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmadd_pd\">_mm512_mask3_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmadd_ps\">_mm512_mask3_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmadd_round_pd\">_mm512_mask3_fnmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmadd_round_ps\">_mm512_mask3_fnmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmsub_pd\">_mm512_mask3_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmsub_ps\">_mm512_mask3_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmsub_round_pd\">_mm512_mask3_fnmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask3_fnmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask3_fnmsub_round_ps\">_mm512_mask3_fnmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_abs_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_abs_epi8\">_mm512_mask_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_abs_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_abs_epi16\">_mm512_mask_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_abs_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_abs_epi32\">_mm512_mask_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Computes the absolute value of packed 32-bit integers in <code>a</code>, and store the\nunsigned results in <code>dst</code> using writemask <code>k</code> (elements are copied from\n<code>src</code> when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_abs_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_abs_epi64\">_mm512_mask_abs_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_abs_pd.html\" title=\"fn core::arch::x86::_mm512_mask_abs_pd\">_mm512_mask_abs_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_abs_ps.html\" title=\"fn core::arch::x86::_mm512_mask_abs_ps\">_mm512_mask_abs_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_add_epi8\">_mm512_mask_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_add_epi16\">_mm512_mask_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_add_epi32\">_mm512_mask_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_add_epi64\">_mm512_mask_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_pd.html\" title=\"fn core::arch::x86::_mm512_mask_add_pd\">_mm512_mask_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_ps.html\" title=\"fn core::arch::x86::_mm512_mask_add_ps\">_mm512_mask_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_add_round_pd\">_mm512_mask_add_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_add_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_add_round_ps\">_mm512_mask_add_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_adds_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_adds_epi8\">_mm512_mask_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_adds_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_adds_epi16\">_mm512_mask_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_adds_epu8.html\" title=\"fn core::arch::x86::_mm512_mask_adds_epu8\">_mm512_mask_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_adds_epu16.html\" title=\"fn core::arch::x86::_mm512_mask_adds_epu16\">_mm512_mask_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_alignr_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_alignr_epi8\">_mm512_mask_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_alignr_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_alignr_epi32\">_mm512_mask_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_alignr_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_alignr_epi64\">_mm512_mask_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_and_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_and_epi32\">_mm512_mask_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_and_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_and_epi64\">_mm512_mask_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_andnot_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_andnot_epi32\">_mm512_mask_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_andnot_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_andnot_epi64\">_mm512_mask_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_avg_epu8.html\" title=\"fn core::arch::x86::_mm512_mask_avg_epu8\">_mm512_mask_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_avg_epu16.html\" title=\"fn core::arch::x86::_mm512_mask_avg_epu16\">_mm512_mask_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_bitshuffle_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_bitshuffle_epi64_mask\">_mm512_mask_bitshuffle_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.\nThen groups 8 8-bit values from <code>c</code>as indices into the bits of the corresponding 64-bit integer.\nIt then selects these bits and packs them into the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_blend_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_blend_epi8\">_mm512_mask_blend_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_blend_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_blend_epi16\">_mm512_mask_blend_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_blend_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_blend_epi32\">_mm512_mask_blend_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_blend_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_blend_epi64\">_mm512_mask_blend_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_blend_pd.html\" title=\"fn core::arch::x86::_mm512_mask_blend_pd\">_mm512_mask_blend_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_blend_ps.html\" title=\"fn core::arch::x86::_mm512_mask_blend_ps\">_mm512_mask_blend_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcast_f32x4.html\" title=\"fn core::arch::x86::_mm512_mask_broadcast_f32x4\">_mm512_mask_broadcast_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcast_f64x4.html\" title=\"fn core::arch::x86::_mm512_mask_broadcast_f64x4\">_mm512_mask_broadcast_f64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcast_i32x4.html\" title=\"fn core::arch::x86::_mm512_mask_broadcast_i32x4\">_mm512_mask_broadcast_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcast_i64x4.html\" title=\"fn core::arch::x86::_mm512_mask_broadcast_i64x4\">_mm512_mask_broadcast_i64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 64-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_broadcastb_epi8\">_mm512_mask_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_broadcastd_epi32\">_mm512_mask_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_broadcastq_epi64\">_mm512_mask_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm512_mask_broadcastsd_pd\">_mm512_mask_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm512_mask_broadcastss_ps\">_mm512_mask_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_broadcastw_epi16\">_mm512_mask_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epi8_mask\">_mm512_mask_cmp_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epi16_mask\">_mm512_mask_cmp_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epi32_mask\">_mm512_mask_cmp_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epi64_mask\">_mm512_mask_cmp_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epu8_mask\">_mm512_mask_cmp_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epu16_mask\">_mm512_mask_cmp_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epu32_mask\">_mm512_mask_cmp_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_epu64_mask\">_mm512_mask_cmp_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_pd_mask\">_mm512_mask_cmp_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_ps_mask\">_mm512_mask_cmp_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_round_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_round_pd_mask\">_mm512_mask_cmp_round_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmp_round_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmp_round_ps_mask\">_mm512_mask_cmp_round_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epi8_mask\">_mm512_mask_cmpeq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epi16_mask\">_mm512_mask_cmpeq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epi32_mask\">_mm512_mask_cmpeq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epi64_mask\">_mm512_mask_cmpeq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epu8_mask\">_mm512_mask_cmpeq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epu16_mask\">_mm512_mask_cmpeq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epu32_mask\">_mm512_mask_cmpeq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_epu64_mask\">_mm512_mask_cmpeq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_pd_mask\">_mm512_mask_cmpeq_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpeq_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpeq_ps_mask\">_mm512_mask_cmpeq_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epi8_mask\">_mm512_mask_cmpge_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epi16_mask\">_mm512_mask_cmpge_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epi32_mask\">_mm512_mask_cmpge_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epi64_mask\">_mm512_mask_cmpge_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epu8_mask\">_mm512_mask_cmpge_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epu16_mask\">_mm512_mask_cmpge_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epu32_mask\">_mm512_mask_cmpge_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpge_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpge_epu64_mask\">_mm512_mask_cmpge_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epi8_mask\">_mm512_mask_cmpgt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epi16_mask\">_mm512_mask_cmpgt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epi32_mask\">_mm512_mask_cmpgt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epi64_mask\">_mm512_mask_cmpgt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epu8_mask\">_mm512_mask_cmpgt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epu16_mask\">_mm512_mask_cmpgt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epu32_mask\">_mm512_mask_cmpgt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpgt_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpgt_epu64_mask\">_mm512_mask_cmpgt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epi8_mask\">_mm512_mask_cmple_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epi16_mask\">_mm512_mask_cmple_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epi32_mask\">_mm512_mask_cmple_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epi64_mask\">_mm512_mask_cmple_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epu8_mask\">_mm512_mask_cmple_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epu16_mask\">_mm512_mask_cmple_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epu32_mask\">_mm512_mask_cmple_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_epu64_mask\">_mm512_mask_cmple_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_pd_mask\">_mm512_mask_cmple_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmple_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmple_ps_mask\">_mm512_mask_cmple_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epi8_mask\">_mm512_mask_cmplt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epi16_mask\">_mm512_mask_cmplt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epi32_mask\">_mm512_mask_cmplt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epi64_mask\">_mm512_mask_cmplt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epu8_mask\">_mm512_mask_cmplt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epu16_mask\">_mm512_mask_cmplt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epu32_mask\">_mm512_mask_cmplt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_epu64_mask\">_mm512_mask_cmplt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_pd_mask\">_mm512_mask_cmplt_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmplt_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmplt_ps_mask\">_mm512_mask_cmplt_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epi8_mask\">_mm512_mask_cmpneq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epi16_mask\">_mm512_mask_cmpneq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epi32_mask\">_mm512_mask_cmpneq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epi64_mask\">_mm512_mask_cmpneq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epu8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epu8_mask\">_mm512_mask_cmpneq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epu16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epu16_mask\">_mm512_mask_cmpneq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epu32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epu32_mask\">_mm512_mask_cmpneq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_epu64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_epu64_mask\">_mm512_mask_cmpneq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_pd_mask\">_mm512_mask_cmpneq_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpneq_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpneq_ps_mask\">_mm512_mask_cmpneq_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpnle_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpnle_pd_mask\">_mm512_mask_cmpnle_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpnle_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpnle_ps_mask\">_mm512_mask_cmpnle_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpnlt_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpnlt_pd_mask\">_mm512_mask_cmpnlt_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpnlt_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpnlt_ps_mask\">_mm512_mask_cmpnlt_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpord_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpord_pd_mask\">_mm512_mask_cmpord_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpord_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpord_ps_mask\">_mm512_mask_cmpord_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpunord_pd_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpunord_pd_mask\">_mm512_mask_cmpunord_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cmpunord_ps_mask.html\" title=\"fn core::arch::x86::_mm512_mask_cmpunord_ps_mask\">_mm512_mask_cmpunord_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compress_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_compress_epi8\">_mm512_mask_compress_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compress_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_compress_epi16\">_mm512_mask_compress_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compress_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_compress_epi32\">_mm512_mask_compress_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compress_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_compress_epi64\">_mm512_mask_compress_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compress_pd.html\" title=\"fn core::arch::x86::_mm512_mask_compress_pd\">_mm512_mask_compress_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compress_ps.html\" title=\"fn core::arch::x86::_mm512_mask_compress_ps\">_mm512_mask_compress_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compressstoreu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_compressstoreu_epi8\">_mm512_mask_compressstoreu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compressstoreu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_compressstoreu_epi16\">_mm512_mask_compressstoreu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compressstoreu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_compressstoreu_epi32\">_mm512_mask_compressstoreu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compressstoreu_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_compressstoreu_epi64\">_mm512_mask_compressstoreu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compressstoreu_pd.html\" title=\"fn core::arch::x86::_mm512_mask_compressstoreu_pd\">_mm512_mask_compressstoreu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_compressstoreu_ps.html\" title=\"fn core::arch::x86::_mm512_mask_compressstoreu_ps\">_mm512_mask_compressstoreu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_conflict_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_conflict_epi32\">_mm512_mask_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_conflict_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_conflict_epi64\">_mm512_mask_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundepi32_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundepi32_ps\">_mm512_mask_cvt_roundepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundepu32_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundepu32_ps\">_mm512_mask_cvt_roundepu32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundpd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundpd_epi32\">_mm512_mask_cvt_roundpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundpd_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundpd_epu32\">_mm512_mask_cvt_roundpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundpd_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundpd_ps\">_mm512_mask_cvt_roundpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundph_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundph_ps\">_mm512_mask_cvt_roundph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundps_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundps_epi32\">_mm512_mask_cvt_roundps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundps_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundps_epu32\">_mm512_mask_cvt_roundps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundps_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundps_pd\">_mm512_mask_cvt_roundps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm512_mask_cvt_roundps_ph\">_mm512_mask_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi8_epi16\">_mm512_mask_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi8_epi32\">_mm512_mask_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi8_epi64\">_mm512_mask_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi16_epi8\">_mm512_mask_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi16_epi32\">_mm512_mask_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi16_epi64\">_mm512_mask_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi16_storeu_epi8\">_mm512_mask_cvtepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_epi8\">_mm512_mask_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_epi16\">_mm512_mask_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_epi64\">_mm512_mask_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_pd\">_mm512_mask_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_ps\">_mm512_mask_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_storeu_epi8\">_mm512_mask_cvtepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32_storeu_epi16\">_mm512_mask_cvtepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi32lo_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi32lo_pd\">_mm512_mask_cvtepi32lo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi64_epi8\">_mm512_mask_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi64_epi16\">_mm512_mask_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi64_epi32\">_mm512_mask_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi64_storeu_epi8\">_mm512_mask_cvtepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi64_storeu_epi16\">_mm512_mask_cvtepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepi64_storeu_epi32\">_mm512_mask_cvtepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu8_epi16\">_mm512_mask_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu8_epi32\">_mm512_mask_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu8_epi64\">_mm512_mask_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu16_epi32\">_mm512_mask_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu16_epi64\">_mm512_mask_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu32_epi64\">_mm512_mask_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu32_pd\">_mm512_mask_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu32_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu32_ps\">_mm512_mask_cvtepu32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtepu32lo_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvtepu32lo_pd\">_mm512_mask_cvtepu32lo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element conversion of the lower half of 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm512_mask_cvtne2ps_pbh\">_mm512_mask_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results\nin single vector dst using writemask k (elements are copied from src when the\ncorresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&amp;avx512techs=AVX512_BF16&amp;text=_mm512_mask_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtneps_pbh.html\" title=\"fn core::arch::x86::_mm512_mask_cvtneps_pbh\">_mm512_mask_cvtneps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)\nfloating-point elements, and store the results in dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_mask_cvtneps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtpd_epi32\">_mm512_mask_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtpd_epu32\">_mm512_mask_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvtpd_ps\">_mm512_mask_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtpd_pslo.html\" title=\"fn core::arch::x86::_mm512_mask_cvtpd_pslo\">_mm512_mask_cvtpd_pslo</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtph_ps.html\" title=\"fn core::arch::x86::_mm512_mask_cvtph_ps\">_mm512_mask_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtps_epi32\">_mm512_mask_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtps_epu32\">_mm512_mask_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtps_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvtps_pd\">_mm512_mask_cvtps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtps_ph.html\" title=\"fn core::arch::x86::_mm512_mask_cvtps_ph\">_mm512_mask_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtpslo_pd.html\" title=\"fn core::arch::x86::_mm512_mask_cvtpslo_pd\">_mm512_mask_cvtpslo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi16_epi8\">_mm512_mask_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi16_storeu_epi8\">_mm512_mask_cvtsepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi32_epi8\">_mm512_mask_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi32_epi16\">_mm512_mask_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi32_storeu_epi8\">_mm512_mask_cvtsepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi32_storeu_epi16\">_mm512_mask_cvtsepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi64_epi8\">_mm512_mask_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi64_epi16\">_mm512_mask_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi64_epi32\">_mm512_mask_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi64_storeu_epi8\">_mm512_mask_cvtsepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi64_storeu_epi16\">_mm512_mask_cvtsepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtsepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtsepi64_storeu_epi32\">_mm512_mask_cvtsepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtt_roundpd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtt_roundpd_epi32\">_mm512_mask_cvtt_roundpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtt_roundpd_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtt_roundpd_epu32\">_mm512_mask_cvtt_roundpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtt_roundps_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtt_roundps_epi32\">_mm512_mask_cvtt_roundps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtt_roundps_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtt_roundps_epu32\">_mm512_mask_cvtt_roundps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvttpd_epi32\">_mm512_mask_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvttpd_epu32\">_mm512_mask_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvttps_epi32\">_mm512_mask_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_cvttps_epu32\">_mm512_mask_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi16_epi8\">_mm512_mask_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi16_storeu_epi8\">_mm512_mask_cvtusepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi32_epi8\">_mm512_mask_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi32_epi16\">_mm512_mask_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi32_storeu_epi8\">_mm512_mask_cvtusepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi32_storeu_epi16\">_mm512_mask_cvtusepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi64_epi8\">_mm512_mask_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi64_epi16\">_mm512_mask_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi64_epi32\">_mm512_mask_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi64_storeu_epi8\">_mm512_mask_cvtusepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi64_storeu_epi16\">_mm512_mask_cvtusepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_cvtusepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_cvtusepi64_storeu_epi32\">_mm512_mask_cvtusepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm512_mask_dbsad_epu8\">_mm512_mask_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_div_pd.html\" title=\"fn core::arch::x86::_mm512_mask_div_pd\">_mm512_mask_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_div_ps.html\" title=\"fn core::arch::x86::_mm512_mask_div_ps\">_mm512_mask_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_div_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_div_round_pd\">_mm512_mask_div_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_div_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_div_round_ps\">_mm512_mask_div_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm512_mask_dpbf16_ps\">_mm512_mask_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_mask_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_dpbusd_epi32\">_mm512_mask_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_dpbusds_epi32\">_mm512_mask_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_dpwssd_epi32\">_mm512_mask_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_dpwssds_epi32\">_mm512_mask_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expand_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_expand_epi8\">_mm512_mask_expand_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expand_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_expand_epi16\">_mm512_mask_expand_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expand_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_expand_epi32\">_mm512_mask_expand_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expand_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_expand_epi64\">_mm512_mask_expand_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expand_pd.html\" title=\"fn core::arch::x86::_mm512_mask_expand_pd\">_mm512_mask_expand_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expand_ps.html\" title=\"fn core::arch::x86::_mm512_mask_expand_ps\">_mm512_mask_expand_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expandloadu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_expandloadu_epi8\">_mm512_mask_expandloadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expandloadu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_expandloadu_epi16\">_mm512_mask_expandloadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expandloadu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_expandloadu_epi32\">_mm512_mask_expandloadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expandloadu_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_expandloadu_epi64\">_mm512_mask_expandloadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expandloadu_pd.html\" title=\"fn core::arch::x86::_mm512_mask_expandloadu_pd\">_mm512_mask_expandloadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_expandloadu_ps.html\" title=\"fn core::arch::x86::_mm512_mask_expandloadu_ps\">_mm512_mask_expandloadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_extractf32x4_ps.html\" title=\"fn core::arch::x86::_mm512_mask_extractf32x4_ps\">_mm512_mask_extractf32x4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_extractf64x4_pd.html\" title=\"fn core::arch::x86::_mm512_mask_extractf64x4_pd\">_mm512_mask_extractf64x4_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_extracti32x4_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_extracti32x4_epi32\">_mm512_mask_extracti32x4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_extracti64x4_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_extracti64x4_epi64\">_mm512_mask_extracti64x4_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fixupimm_pd\">_mm512_mask_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fixupimm_ps\">_mm512_mask_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fixupimm_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fixupimm_round_pd\">_mm512_mask_fixupimm_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fixupimm_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fixupimm_round_ps\">_mm512_mask_fixupimm_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmadd_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmadd_pd\">_mm512_mask_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmadd_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmadd_ps\">_mm512_mask_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmadd_round_pd\">_mm512_mask_fmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmadd_round_ps\">_mm512_mask_fmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmaddsub_pd\">_mm512_mask_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmaddsub_ps\">_mm512_mask_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmaddsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmaddsub_round_pd\">_mm512_mask_fmaddsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmaddsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmaddsub_round_ps\">_mm512_mask_fmaddsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsub_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmsub_pd\">_mm512_mask_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsub_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmsub_ps\">_mm512_mask_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmsub_round_pd\">_mm512_mask_fmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmsub_round_ps\">_mm512_mask_fmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmsubadd_pd\">_mm512_mask_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmsubadd_ps\">_mm512_mask_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsubadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fmsubadd_round_pd\">_mm512_mask_fmsubadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fmsubadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fmsubadd_round_ps\">_mm512_mask_fmsubadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fnmadd_pd\">_mm512_mask_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fnmadd_ps\">_mm512_mask_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fnmadd_round_pd\">_mm512_mask_fnmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fnmadd_round_ps\">_mm512_mask_fnmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fnmsub_pd\">_mm512_mask_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fnmsub_ps\">_mm512_mask_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_fnmsub_round_pd\">_mm512_mask_fnmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_fnmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_fnmsub_round_ps\">_mm512_mask_fnmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getexp_pd.html\" title=\"fn core::arch::x86::_mm512_mask_getexp_pd\">_mm512_mask_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getexp_ps.html\" title=\"fn core::arch::x86::_mm512_mask_getexp_ps\">_mm512_mask_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getexp_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_getexp_round_pd\">_mm512_mask_getexp_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getexp_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_getexp_round_ps\">_mm512_mask_getexp_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getmant_pd.html\" title=\"fn core::arch::x86::_mm512_mask_getmant_pd\">_mm512_mask_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getmant_ps.html\" title=\"fn core::arch::x86::_mm512_mask_getmant_ps\">_mm512_mask_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getmant_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_getmant_round_pd\">_mm512_mask_getmant_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_getmant_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_getmant_round_ps\">_mm512_mask_getmant_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_gf2p8affine_epi64_epi8\">_mm512_mask_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_gf2p8affineinv_epi64_epi8\">_mm512_mask_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_gf2p8mul_epi8\">_mm512_mask_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32gather_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_i32gather_epi32\">_mm512_mask_i32gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32gather_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_i32gather_epi64\">_mm512_mask_i32gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32gather_pd.html\" title=\"fn core::arch::x86::_mm512_mask_i32gather_pd\">_mm512_mask_i32gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32gather_ps.html\" title=\"fn core::arch::x86::_mm512_mask_i32gather_ps\">_mm512_mask_i32gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32scatter_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_i32scatter_epi32\">_mm512_mask_i32scatter_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32scatter_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_i32scatter_epi64\">_mm512_mask_i32scatter_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32scatter_pd.html\" title=\"fn core::arch::x86::_mm512_mask_i32scatter_pd\">_mm512_mask_i32scatter_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i32scatter_ps.html\" title=\"fn core::arch::x86::_mm512_mask_i32scatter_ps\">_mm512_mask_i32scatter_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64gather_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_i64gather_epi32\">_mm512_mask_i64gather_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64gather_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_i64gather_epi64\">_mm512_mask_i64gather_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64gather_pd.html\" title=\"fn core::arch::x86::_mm512_mask_i64gather_pd\">_mm512_mask_i64gather_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64gather_ps.html\" title=\"fn core::arch::x86::_mm512_mask_i64gather_ps\">_mm512_mask_i64gather_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64scatter_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_i64scatter_epi32\">_mm512_mask_i64scatter_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64scatter_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_i64scatter_epi64\">_mm512_mask_i64scatter_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64scatter_pd.html\" title=\"fn core::arch::x86::_mm512_mask_i64scatter_pd\">_mm512_mask_i64scatter_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_i64scatter_ps.html\" title=\"fn core::arch::x86::_mm512_mask_i64scatter_ps\">_mm512_mask_i64scatter_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_insertf32x4.html\" title=\"fn core::arch::x86::_mm512_mask_insertf32x4\">_mm512_mask_insertf32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_insertf64x4.html\" title=\"fn core::arch::x86::_mm512_mask_insertf64x4\">_mm512_mask_insertf64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_inserti32x4.html\" title=\"fn core::arch::x86::_mm512_mask_inserti32x4\">_mm512_mask_inserti32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_inserti64x4.html\" title=\"fn core::arch::x86::_mm512_mask_inserti64x4\">_mm512_mask_inserti64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_load_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_load_epi32\">_mm512_mask_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_load_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_load_epi64\">_mm512_mask_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_load_pd.html\" title=\"fn core::arch::x86::_mm512_mask_load_pd\">_mm512_mask_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_load_ps.html\" title=\"fn core::arch::x86::_mm512_mask_load_ps\">_mm512_mask_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_loadu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_loadu_epi8\">_mm512_mask_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only\">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class=\"desc docblock-short\">Load packed 8-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_loadu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_loadu_epi16\">_mm512_mask_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only\">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class=\"desc docblock-short\">Load packed 16-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_loadu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_loadu_epi32\">_mm512_mask_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_loadu_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_loadu_epi64\">_mm512_mask_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_loadu_pd.html\" title=\"fn core::arch::x86::_mm512_mask_loadu_pd\">_mm512_mask_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_loadu_ps.html\" title=\"fn core::arch::x86::_mm512_mask_loadu_ps\">_mm512_mask_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_lzcnt_epi32\">_mm512_mask_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_lzcnt_epi64\">_mm512_mask_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_madd_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_madd_epi16\">_mm512_mask_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_maddubs_epi16\">_mm512_mask_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_max_epi8\">_mm512_mask_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_max_epi16\">_mm512_mask_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_max_epi32\">_mm512_mask_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_max_epi64\">_mm512_mask_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epu8.html\" title=\"fn core::arch::x86::_mm512_mask_max_epu8\">_mm512_mask_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epu16.html\" title=\"fn core::arch::x86::_mm512_mask_max_epu16\">_mm512_mask_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_max_epu32\">_mm512_mask_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_epu64.html\" title=\"fn core::arch::x86::_mm512_mask_max_epu64\">_mm512_mask_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_pd.html\" title=\"fn core::arch::x86::_mm512_mask_max_pd\">_mm512_mask_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_ps.html\" title=\"fn core::arch::x86::_mm512_mask_max_ps\">_mm512_mask_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_max_round_pd\">_mm512_mask_max_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_max_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_max_round_ps\">_mm512_mask_max_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_min_epi8\">_mm512_mask_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_min_epi16\">_mm512_mask_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_min_epi32\">_mm512_mask_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_min_epi64\">_mm512_mask_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epu8.html\" title=\"fn core::arch::x86::_mm512_mask_min_epu8\">_mm512_mask_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epu16.html\" title=\"fn core::arch::x86::_mm512_mask_min_epu16\">_mm512_mask_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_min_epu32\">_mm512_mask_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_epu64.html\" title=\"fn core::arch::x86::_mm512_mask_min_epu64\">_mm512_mask_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_pd.html\" title=\"fn core::arch::x86::_mm512_mask_min_pd\">_mm512_mask_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_ps.html\" title=\"fn core::arch::x86::_mm512_mask_min_ps\">_mm512_mask_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_min_round_pd\">_mm512_mask_min_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_min_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_min_round_ps\">_mm512_mask_min_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mov_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_mov_epi8\">_mm512_mask_mov_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mov_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_mov_epi16\">_mm512_mask_mov_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mov_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_mov_epi32\">_mm512_mask_mov_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mov_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_mov_epi64\">_mm512_mask_mov_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mov_pd.html\" title=\"fn core::arch::x86::_mm512_mask_mov_pd\">_mm512_mask_mov_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mov_ps.html\" title=\"fn core::arch::x86::_mm512_mask_mov_ps\">_mm512_mask_mov_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_movedup_pd.html\" title=\"fn core::arch::x86::_mm512_mask_movedup_pd\">_mm512_mask_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_movehdup_ps.html\" title=\"fn core::arch::x86::_mm512_mask_movehdup_ps\">_mm512_mask_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_moveldup_ps.html\" title=\"fn core::arch::x86::_mm512_mask_moveldup_ps\">_mm512_mask_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mul_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_mul_epi32\">_mm512_mask_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mul_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_mul_epu32\">_mm512_mask_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mul_pd.html\" title=\"fn core::arch::x86::_mm512_mask_mul_pd\">_mm512_mask_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mul_ps.html\" title=\"fn core::arch::x86::_mm512_mask_mul_ps\">_mm512_mask_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mul_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_mul_round_pd\">_mm512_mask_mul_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mul_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_mul_round_ps\">_mm512_mask_mul_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_mulhi_epi16\">_mm512_mask_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm512_mask_mulhi_epu16\">_mm512_mask_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_mulhrs_epi16\">_mm512_mask_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mullo_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_mullo_epi16\">_mm512_mask_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mullo_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_mullo_epi32\">_mm512_mask_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_mullox_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_mullox_epi64\">_mm512_mask_mullox_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_multishift_epi64_epi8\">_mm512_mask_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_or_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_or_epi32\">_mm512_mask_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_or_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_or_epi64\">_mm512_mask_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_packs_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_packs_epi16\">_mm512_mask_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_packs_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_packs_epi32\">_mm512_mask_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_packus_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_packus_epi16\">_mm512_mask_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_packus_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_packus_epi32\">_mm512_mask_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permute_pd.html\" title=\"fn core::arch::x86::_mm512_mask_permute_pd\">_mm512_mask_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permute_ps.html\" title=\"fn core::arch::x86::_mm512_mask_permute_ps\">_mm512_mask_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutevar_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_permutevar_epi32\">_mm512_mask_permutevar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to _mm512_mask_permutexvar_epi32, and it is recommended that you use that intrinsic name.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutevar_pd.html\" title=\"fn core::arch::x86::_mm512_mask_permutevar_pd\">_mm512_mask_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutevar_ps.html\" title=\"fn core::arch::x86::_mm512_mask_permutevar_ps\">_mm512_mask_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_permutex2var_epi8\">_mm512_mask_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_permutex2var_epi16\">_mm512_mask_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_permutex2var_epi32\">_mm512_mask_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_permutex2var_epi64\">_mm512_mask_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm512_mask_permutex2var_pd\">_mm512_mask_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm512_mask_permutex2var_ps\">_mm512_mask_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_permutex_epi64\">_mm512_mask_permutex_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutex_pd.html\" title=\"fn core::arch::x86::_mm512_mask_permutex_pd\">_mm512_mask_permutex_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_permutexvar_epi8\">_mm512_mask_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_permutexvar_epi16\">_mm512_mask_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutexvar_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_permutexvar_epi32\">_mm512_mask_permutexvar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutexvar_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_permutexvar_epi64\">_mm512_mask_permutexvar_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutexvar_pd.html\" title=\"fn core::arch::x86::_mm512_mask_permutexvar_pd\">_mm512_mask_permutexvar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_permutexvar_ps.html\" title=\"fn core::arch::x86::_mm512_mask_permutexvar_ps\">_mm512_mask_permutexvar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_popcnt_epi8\">_mm512_mask_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_popcnt_epi16\">_mm512_mask_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_popcnt_epi32\">_mm512_mask_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only\">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_popcnt_epi64\">_mm512_mask_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only\">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rcp14_pd.html\" title=\"fn core::arch::x86::_mm512_mask_rcp14_pd\">_mm512_mask_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rcp14_ps.html\" title=\"fn core::arch::x86::_mm512_mask_rcp14_ps\">_mm512_mask_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_add_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_add_epi32\">_mm512_mask_reduce_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_add_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_add_epi64\">_mm512_mask_reduce_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_add_pd.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_add_pd\">_mm512_mask_reduce_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_add_ps.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_add_ps\">_mm512_mask_reduce_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_and_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_and_epi32\">_mm512_mask_reduce_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by bitwise AND using mask k. Returns the bitwise AND of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_and_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_and_epi64\">_mm512_mask_reduce_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_max_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_max_epi32\">_mm512_mask_reduce_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_max_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_max_epi64\">_mm512_mask_reduce_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_max_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_max_epu32\">_mm512_mask_reduce_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_max_epu64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_max_epu64\">_mm512_mask_reduce_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_max_pd.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_max_pd\">_mm512_mask_reduce_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_max_ps.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_max_ps\">_mm512_mask_reduce_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_min_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_min_epi32\">_mm512_mask_reduce_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_min_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_min_epi64\">_mm512_mask_reduce_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_min_epu32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_min_epu32\">_mm512_mask_reduce_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_min_epu64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_min_epu64\">_mm512_mask_reduce_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_min_pd.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_min_pd\">_mm512_mask_reduce_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_min_ps.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_min_ps\">_mm512_mask_reduce_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_mul_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_mul_epi32\">_mm512_mask_reduce_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_mul_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_mul_epi64\">_mm512_mask_reduce_mul_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_mul_pd.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_mul_pd\">_mm512_mask_reduce_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_mul_ps.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_mul_ps\">_mm512_mask_reduce_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_or_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_or_epi32\">_mm512_mask_reduce_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_reduce_or_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_reduce_or_epi64\">_mm512_mask_reduce_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rol_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_rol_epi32\">_mm512_mask_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rol_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_rol_epi64\">_mm512_mask_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rolv_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_rolv_epi32\">_mm512_mask_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rolv_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_rolv_epi64\">_mm512_mask_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_ror_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_ror_epi32\">_mm512_mask_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_ror_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_ror_epi64\">_mm512_mask_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rorv_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_rorv_epi32\">_mm512_mask_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rorv_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_rorv_epi64\">_mm512_mask_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_roundscale_pd.html\" title=\"fn core::arch::x86::_mm512_mask_roundscale_pd\">_mm512_mask_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_roundscale_ps.html\" title=\"fn core::arch::x86::_mm512_mask_roundscale_ps\">_mm512_mask_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_roundscale_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_roundscale_round_pd\">_mm512_mask_roundscale_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_roundscale_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_roundscale_round_ps\">_mm512_mask_roundscale_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm512_mask_rsqrt14_pd\">_mm512_mask_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm512_mask_rsqrt14_ps\">_mm512_mask_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_scalef_pd.html\" title=\"fn core::arch::x86::_mm512_mask_scalef_pd\">_mm512_mask_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_scalef_ps.html\" title=\"fn core::arch::x86::_mm512_mask_scalef_ps\">_mm512_mask_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_scalef_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_scalef_round_pd\">_mm512_mask_scalef_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_scalef_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_scalef_round_ps\">_mm512_mask_scalef_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_set1_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_set1_epi8\">_mm512_mask_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_set1_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_set1_epi16\">_mm512_mask_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_set1_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_set1_epi32\">_mm512_mask_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_set1_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_set1_epi64\">_mm512_mask_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shldi_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_shldi_epi16\">_mm512_mask_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shldi_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_shldi_epi32\">_mm512_mask_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shldi_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_shldi_epi64\">_mm512_mask_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shldv_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_shldv_epi16\">_mm512_mask_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shldv_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_shldv_epi32\">_mm512_mask_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shldv_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_shldv_epi64\">_mm512_mask_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_shrdi_epi16\">_mm512_mask_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_shrdi_epi32\">_mm512_mask_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_shrdi_epi64\">_mm512_mask_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_shrdv_epi16\">_mm512_mask_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_shrdv_epi32\">_mm512_mask_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_shrdv_epi64\">_mm512_mask_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_epi8\">_mm512_mask_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_epi32\">_mm512_mask_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_f32x4.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_f32x4\">_mm512_mask_shuffle_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_f64x2.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_f64x2\">_mm512_mask_shuffle_f64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_i32x4.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_i32x4\">_mm512_mask_shuffle_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_i64x2.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_i64x2\">_mm512_mask_shuffle_i64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_pd.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_pd\">_mm512_mask_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shuffle_ps.html\" title=\"fn core::arch::x86::_mm512_mask_shuffle_ps\">_mm512_mask_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_shufflehi_epi16\">_mm512_mask_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_shufflelo_epi16\">_mm512_mask_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sll_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_sll_epi16\">_mm512_mask_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sll_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_sll_epi32\">_mm512_mask_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sll_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_sll_epi64\">_mm512_mask_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_slli_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_slli_epi16\">_mm512_mask_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_slli_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_slli_epi32\">_mm512_mask_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_slli_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_slli_epi64\">_mm512_mask_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sllv_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_sllv_epi16\">_mm512_mask_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sllv_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_sllv_epi32\">_mm512_mask_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sllv_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_sllv_epi64\">_mm512_mask_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sqrt_pd.html\" title=\"fn core::arch::x86::_mm512_mask_sqrt_pd\">_mm512_mask_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sqrt_ps.html\" title=\"fn core::arch::x86::_mm512_mask_sqrt_ps\">_mm512_mask_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sqrt_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_sqrt_round_pd\">_mm512_mask_sqrt_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sqrt_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_sqrt_round_ps\">_mm512_mask_sqrt_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sra_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_sra_epi16\">_mm512_mask_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sra_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_sra_epi32\">_mm512_mask_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sra_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_sra_epi64\">_mm512_mask_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srai_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_srai_epi16\">_mm512_mask_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srai_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_srai_epi32\">_mm512_mask_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srai_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_srai_epi64\">_mm512_mask_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srav_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_srav_epi16\">_mm512_mask_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srav_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_srav_epi32\">_mm512_mask_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srav_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_srav_epi64\">_mm512_mask_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srl_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_srl_epi16\">_mm512_mask_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srl_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_srl_epi32\">_mm512_mask_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srl_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_srl_epi64\">_mm512_mask_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srli_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_srli_epi16\">_mm512_mask_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srli_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_srli_epi32\">_mm512_mask_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srli_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_srli_epi64\">_mm512_mask_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srlv_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_srlv_epi16\">_mm512_mask_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srlv_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_srlv_epi32\">_mm512_mask_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_srlv_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_srlv_epi64\">_mm512_mask_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_store_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_store_epi32\">_mm512_mask_store_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed 32-bit integers from a into memory using writemask k.\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_store_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_store_epi64\">_mm512_mask_store_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed 64-bit integers from a into memory using writemask k.\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_store_pd.html\" title=\"fn core::arch::x86::_mm512_mask_store_pd\">_mm512_mask_store_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_store_ps.html\" title=\"fn core::arch::x86::_mm512_mask_store_ps\">_mm512_mask_store_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_storeu_epi8\">_mm512_mask_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only\">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class=\"desc docblock-short\">Store packed 8-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_storeu_epi16\">_mm512_mask_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only\">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class=\"desc docblock-short\">Store packed 16-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_storeu_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_storeu_epi32\">_mm512_mask_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed 32-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_storeu_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_storeu_epi64\">_mm512_mask_storeu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed 64-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_storeu_pd.html\" title=\"fn core::arch::x86::_mm512_mask_storeu_pd\">_mm512_mask_storeu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_storeu_ps.html\" title=\"fn core::arch::x86::_mm512_mask_storeu_ps\">_mm512_mask_storeu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_sub_epi8\">_mm512_mask_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_sub_epi16\">_mm512_mask_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_sub_epi32\">_mm512_mask_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_sub_epi64\">_mm512_mask_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_pd.html\" title=\"fn core::arch::x86::_mm512_mask_sub_pd\">_mm512_mask_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_ps.html\" title=\"fn core::arch::x86::_mm512_mask_sub_ps\">_mm512_mask_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_round_pd.html\" title=\"fn core::arch::x86::_mm512_mask_sub_round_pd\">_mm512_mask_sub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_sub_round_ps.html\" title=\"fn core::arch::x86::_mm512_mask_sub_round_ps\">_mm512_mask_sub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_subs_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_subs_epi8\">_mm512_mask_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_subs_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_subs_epi16\">_mm512_mask_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_subs_epu8.html\" title=\"fn core::arch::x86::_mm512_mask_subs_epu8\">_mm512_mask_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_subs_epu16.html\" title=\"fn core::arch::x86::_mm512_mask_subs_epu16\">_mm512_mask_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_ternarylogic_epi32\">_mm512_mask_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_ternarylogic_epi64\">_mm512_mask_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_test_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_test_epi8_mask\">_mm512_mask_test_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_test_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_test_epi16_mask\">_mm512_mask_test_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_test_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_test_epi32_mask\">_mm512_mask_test_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_test_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_test_epi64_mask\">_mm512_mask_test_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_testn_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_mask_testn_epi8_mask\">_mm512_mask_testn_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_testn_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_mask_testn_epi16_mask\">_mm512_mask_testn_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_testn_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_mask_testn_epi32_mask\">_mm512_mask_testn_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_testn_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_mask_testn_epi64_mask\">_mm512_mask_testn_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_unpackhi_epi8\">_mm512_mask_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_unpackhi_epi16\">_mm512_mask_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_unpackhi_epi32\">_mm512_mask_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_unpackhi_epi64\">_mm512_mask_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm512_mask_unpackhi_pd\">_mm512_mask_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm512_mask_unpackhi_ps\">_mm512_mask_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm512_mask_unpacklo_epi8\">_mm512_mask_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm512_mask_unpacklo_epi16\">_mm512_mask_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_unpacklo_epi32\">_mm512_mask_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_unpacklo_epi64\">_mm512_mask_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm512_mask_unpacklo_pd\">_mm512_mask_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm512_mask_unpacklo_ps\">_mm512_mask_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_xor_epi32.html\" title=\"fn core::arch::x86::_mm512_mask_xor_epi32\">_mm512_mask_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mask_xor_epi64.html\" title=\"fn core::arch::x86::_mm512_mask_xor_epi64\">_mm512_mask_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_abs_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_abs_epi8\">_mm512_maskz_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_abs_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_abs_epi16\">_mm512_maskz_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_abs_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_abs_epi32\">_mm512_maskz_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Computes the absolute value of packed 32-bit integers in <code>a</code>, and store the\nunsigned results in <code>dst</code> using zeromask <code>k</code> (elements are zeroed out when\nthe corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_abs_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_abs_epi64\">_mm512_maskz_abs_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_add_epi8\">_mm512_maskz_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_add_epi16\">_mm512_maskz_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_add_epi32\">_mm512_maskz_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_add_epi64\">_mm512_maskz_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_add_pd\">_mm512_maskz_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_add_ps\">_mm512_maskz_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_add_round_pd\">_mm512_maskz_add_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_add_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_add_round_ps\">_mm512_maskz_add_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_adds_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_adds_epi8\">_mm512_maskz_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_adds_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_adds_epi16\">_mm512_maskz_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_adds_epu8.html\" title=\"fn core::arch::x86::_mm512_maskz_adds_epu8\">_mm512_maskz_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_adds_epu16.html\" title=\"fn core::arch::x86::_mm512_maskz_adds_epu16\">_mm512_maskz_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_alignr_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_alignr_epi8\">_mm512_maskz_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_alignr_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_alignr_epi32\">_mm512_maskz_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and stores the low 64 bytes (16 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_alignr_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_alignr_epi64\">_mm512_maskz_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and stores the low 64 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_and_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_and_epi32\">_mm512_maskz_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_and_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_and_epi64\">_mm512_maskz_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_andnot_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_andnot_epi32\">_mm512_maskz_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_andnot_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_andnot_epi64\">_mm512_maskz_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_avg_epu8.html\" title=\"fn core::arch::x86::_mm512_maskz_avg_epu8\">_mm512_maskz_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_avg_epu16.html\" title=\"fn core::arch::x86::_mm512_maskz_avg_epu16\">_mm512_maskz_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcast_f32x4.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcast_f32x4\">_mm512_maskz_broadcast_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcast_f64x4.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcast_f64x4\">_mm512_maskz_broadcast_f64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcast_i32x4.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcast_i32x4\">_mm512_maskz_broadcast_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcast_i64x4.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcast_i64x4\">_mm512_maskz_broadcast_i64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the 4 packed 64-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcastb_epi8\">_mm512_maskz_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcastd_epi32\">_mm512_maskz_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcastq_epi64\">_mm512_maskz_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcastsd_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcastsd_pd\">_mm512_maskz_broadcastsd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcastss_ps\">_mm512_maskz_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_broadcastw_epi16\">_mm512_maskz_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_compress_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_compress_epi8\">_mm512_maskz_compress_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_compress_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_compress_epi16\">_mm512_maskz_compress_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_compress_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_compress_epi32\">_mm512_maskz_compress_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_compress_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_compress_epi64\">_mm512_maskz_compress_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_compress_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_compress_pd\">_mm512_maskz_compress_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_compress_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_compress_ps\">_mm512_maskz_compress_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_conflict_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_conflict_epi32\">_mm512_maskz_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_conflict_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_conflict_epi64\">_mm512_maskz_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundepi32_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundepi32_ps\">_mm512_maskz_cvt_roundepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundepu32_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundepu32_ps\">_mm512_maskz_cvt_roundepu32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundpd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundpd_epi32\">_mm512_maskz_cvt_roundpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundpd_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundpd_epu32\">_mm512_maskz_cvt_roundpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundpd_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundpd_ps\">_mm512_maskz_cvt_roundpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundph_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundph_ps\">_mm512_maskz_cvt_roundph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundps_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundps_epi32\">_mm512_maskz_cvt_roundps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundps_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundps_epu32\">_mm512_maskz_cvt_roundps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundps_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundps_pd\">_mm512_maskz_cvt_roundps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm512_maskz_cvt_roundps_ph\">_mm512_maskz_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi8_epi16\">_mm512_maskz_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi8_epi32\">_mm512_maskz_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi8_epi64\">_mm512_maskz_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi16_epi8\">_mm512_maskz_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi16_epi32\">_mm512_maskz_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi16_epi64\">_mm512_maskz_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi32_epi8\">_mm512_maskz_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi32_epi16\">_mm512_maskz_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi32_epi64\">_mm512_maskz_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi32_pd\">_mm512_maskz_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi32_ps\">_mm512_maskz_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi64_epi8\">_mm512_maskz_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi64_epi16\">_mm512_maskz_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepi64_epi32\">_mm512_maskz_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu8_epi16\">_mm512_maskz_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu8_epi32\">_mm512_maskz_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu8_epi64\">_mm512_maskz_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu16_epi32\">_mm512_maskz_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu16_epi64\">_mm512_maskz_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu32_epi64\">_mm512_maskz_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu32_pd\">_mm512_maskz_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtepu32_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtepu32_ps\">_mm512_maskz_cvtepu32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtne2ps_pbh\">_mm512_maskz_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results\nin single vector dst using zeromask k (elements are zeroed out when the corresponding\nmask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&amp;avx512techs=AVX512_BF16&amp;text=_mm512_maskz_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtneps_pbh.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtneps_pbh\">_mm512_maskz_cvtneps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)\nfloating-point elements, and store the results in dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_maskz_cvtneps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtpd_epi32\">_mm512_maskz_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtpd_epu32\">_mm512_maskz_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtpd_ps\">_mm512_maskz_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtph_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtph_ps\">_mm512_maskz_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtps_epi32\">_mm512_maskz_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtps_epu32\">_mm512_maskz_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtps_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtps_pd\">_mm512_maskz_cvtps_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtps_ph.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtps_ph\">_mm512_maskz_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtsepi16_epi8\">_mm512_maskz_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtsepi32_epi8\">_mm512_maskz_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtsepi32_epi16\">_mm512_maskz_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtsepi64_epi8\">_mm512_maskz_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtsepi64_epi16\">_mm512_maskz_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtsepi64_epi32\">_mm512_maskz_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtt_roundpd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtt_roundpd_epi32\">_mm512_maskz_cvtt_roundpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtt_roundpd_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtt_roundpd_epu32\">_mm512_maskz_cvtt_roundpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtt_roundps_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtt_roundps_epi32\">_mm512_maskz_cvtt_roundps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtt_roundps_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtt_roundps_epu32\">_mm512_maskz_cvtt_roundps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvttpd_epi32\">_mm512_maskz_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvttpd_epu32\">_mm512_maskz_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvttps_epi32\">_mm512_maskz_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvttps_epu32\">_mm512_maskz_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtusepi16_epi8\">_mm512_maskz_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtusepi32_epi8\">_mm512_maskz_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtusepi32_epi16\">_mm512_maskz_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtusepi64_epi8\">_mm512_maskz_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtusepi64_epi16\">_mm512_maskz_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_cvtusepi64_epi32\">_mm512_maskz_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm512_maskz_dbsad_epu8\">_mm512_maskz_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_div_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_div_pd\">_mm512_maskz_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_div_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_div_ps\">_mm512_maskz_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_div_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_div_round_pd\">_mm512_maskz_div_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_div_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_div_round_ps\">_mm512_maskz_div_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_dpbf16_ps\">_mm512_maskz_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only\">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_maskz_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_dpbusd_epi32\">_mm512_maskz_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_dpbusds_epi32\">_mm512_maskz_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_dpwssd_epi32\">_mm512_maskz_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_dpwssds_epi32\">_mm512_maskz_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni` only\">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expand_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_expand_epi8\">_mm512_maskz_expand_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expand_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_expand_epi16\">_mm512_maskz_expand_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expand_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_expand_epi32\">_mm512_maskz_expand_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expand_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_expand_epi64\">_mm512_maskz_expand_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expand_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_expand_pd\">_mm512_maskz_expand_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expand_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_expand_ps\">_mm512_maskz_expand_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expandloadu_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_expandloadu_epi8\">_mm512_maskz_expandloadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expandloadu_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_expandloadu_epi16\">_mm512_maskz_expandloadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expandloadu_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_expandloadu_epi32\">_mm512_maskz_expandloadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expandloadu_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_expandloadu_epi64\">_mm512_maskz_expandloadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expandloadu_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_expandloadu_pd\">_mm512_maskz_expandloadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_expandloadu_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_expandloadu_ps\">_mm512_maskz_expandloadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_extractf32x4_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_extractf32x4_ps\">_mm512_maskz_extractf32x4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_extractf64x4_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_extractf64x4_pd\">_mm512_maskz_extractf64x4_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_extracti32x4_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_extracti32x4_epi32\">_mm512_maskz_extracti32x4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_extracti64x4_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_extracti64x4_epi64\">_mm512_maskz_extracti64x4_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fixupimm_pd\">_mm512_maskz_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fixupimm_ps\">_mm512_maskz_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fixupimm_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fixupimm_round_pd\">_mm512_maskz_fixupimm_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fixupimm_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fixupimm_round_ps\">_mm512_maskz_fixupimm_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmadd_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmadd_pd\">_mm512_maskz_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmadd_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmadd_ps\">_mm512_maskz_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmadd_round_pd\">_mm512_maskz_fmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmadd_round_ps\">_mm512_maskz_fmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in a using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmaddsub_pd\">_mm512_maskz_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmaddsub_ps\">_mm512_maskz_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmaddsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmaddsub_round_pd\">_mm512_maskz_fmaddsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmaddsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmaddsub_round_ps\">_mm512_maskz_fmaddsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsub_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsub_pd\">_mm512_maskz_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsub_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsub_ps\">_mm512_maskz_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsub_round_pd\">_mm512_maskz_fmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsub_round_ps\">_mm512_maskz_fmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsubadd_pd\">_mm512_maskz_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsubadd_ps\">_mm512_maskz_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsubadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsubadd_round_pd\">_mm512_maskz_fmsubadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fmsubadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fmsubadd_round_ps\">_mm512_maskz_fmsubadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmadd_pd\">_mm512_maskz_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmadd_ps\">_mm512_maskz_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmadd_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmadd_round_pd\">_mm512_maskz_fnmadd_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmadd_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmadd_round_ps\">_mm512_maskz_fnmadd_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmsub_pd\">_mm512_maskz_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmsub_ps\">_mm512_maskz_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmsub_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmsub_round_pd\">_mm512_maskz_fnmsub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_fnmsub_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_fnmsub_round_ps\">_mm512_maskz_fnmsub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getexp_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_getexp_pd\">_mm512_maskz_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getexp_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_getexp_ps\">_mm512_maskz_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getexp_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_getexp_round_pd\">_mm512_maskz_getexp_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getexp_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_getexp_round_ps\">_mm512_maskz_getexp_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getmant_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_getmant_pd\">_mm512_maskz_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getmant_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_getmant_ps\">_mm512_maskz_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getmant_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_getmant_round_pd\">_mm512_maskz_getmant_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_getmant_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_getmant_round_ps\">_mm512_maskz_getmant_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_gf2p8affine_epi64_epi8\">_mm512_maskz_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_gf2p8affineinv_epi64_epi8\">_mm512_maskz_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_gf2p8mul_epi8\">_mm512_maskz_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_insertf32x4.html\" title=\"fn core::arch::x86::_mm512_maskz_insertf32x4\">_mm512_maskz_insertf32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_insertf64x4.html\" title=\"fn core::arch::x86::_mm512_maskz_insertf64x4\">_mm512_maskz_insertf64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_inserti32x4.html\" title=\"fn core::arch::x86::_mm512_maskz_inserti32x4\">_mm512_maskz_inserti32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_inserti64x4.html\" title=\"fn core::arch::x86::_mm512_maskz_inserti64x4\">_mm512_maskz_inserti64x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_load_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_load_epi32\">_mm512_maskz_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_load_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_load_epi64\">_mm512_maskz_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_load_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_load_pd\">_mm512_maskz_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_load_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_load_ps\">_mm512_maskz_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_loadu_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_loadu_epi8\">_mm512_maskz_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only\">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class=\"desc docblock-short\">Load packed 8-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_loadu_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_loadu_epi16\">_mm512_maskz_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only\">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class=\"desc docblock-short\">Load packed 16-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_loadu_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_loadu_epi32\">_mm512_maskz_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_loadu_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_loadu_epi64\">_mm512_maskz_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_loadu_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_loadu_pd\">_mm512_maskz_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_loadu_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_loadu_ps\">_mm512_maskz_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_lzcnt_epi32\">_mm512_maskz_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_lzcnt_epi64\">_mm512_maskz_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd` only\">(x86 or x86-64) and <code>avx512cd</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_madd_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_madd_epi16\">_mm512_maskz_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_maddubs_epi16\">_mm512_maskz_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epi8\">_mm512_maskz_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epi16\">_mm512_maskz_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epi32\">_mm512_maskz_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epi64\">_mm512_maskz_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epu8.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epu8\">_mm512_maskz_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epu16.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epu16\">_mm512_maskz_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epu32\">_mm512_maskz_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_epu64.html\" title=\"fn core::arch::x86::_mm512_maskz_max_epu64\">_mm512_maskz_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_max_pd\">_mm512_maskz_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_max_ps\">_mm512_maskz_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_max_round_pd\">_mm512_maskz_max_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_max_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_max_round_ps\">_mm512_maskz_max_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epi8\">_mm512_maskz_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epi16\">_mm512_maskz_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epi32\">_mm512_maskz_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epi64\">_mm512_maskz_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epu8.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epu8\">_mm512_maskz_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epu16.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epu16\">_mm512_maskz_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epu32\">_mm512_maskz_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_epu64.html\" title=\"fn core::arch::x86::_mm512_maskz_min_epu64\">_mm512_maskz_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_min_pd\">_mm512_maskz_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_min_ps\">_mm512_maskz_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_min_round_pd\">_mm512_maskz_min_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_min_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_min_round_ps\">_mm512_maskz_min_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mov_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_mov_epi8\">_mm512_maskz_mov_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mov_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_mov_epi16\">_mm512_maskz_mov_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mov_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_mov_epi32\">_mm512_maskz_mov_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mov_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_mov_epi64\">_mm512_maskz_mov_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mov_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_mov_pd\">_mm512_maskz_mov_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mov_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_mov_ps\">_mm512_maskz_mov_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_movedup_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_movedup_pd\">_mm512_maskz_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_movehdup_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_movehdup_ps\">_mm512_maskz_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_moveldup_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_moveldup_ps\">_mm512_maskz_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mul_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_mul_epi32\">_mm512_maskz_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mul_epu32.html\" title=\"fn core::arch::x86::_mm512_maskz_mul_epu32\">_mm512_maskz_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mul_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_mul_pd\">_mm512_maskz_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mul_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_mul_ps\">_mm512_maskz_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mul_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_mul_round_pd\">_mm512_maskz_mul_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mul_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_mul_round_ps\">_mm512_maskz_mul_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_mulhi_epi16\">_mm512_maskz_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm512_maskz_mulhi_epu16\">_mm512_maskz_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_mulhrs_epi16\">_mm512_maskz_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mullo_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_mullo_epi16\">_mm512_maskz_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_mullo_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_mullo_epi32\">_mm512_maskz_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_multishift_epi64_epi8\">_mm512_maskz_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_or_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_or_epi32\">_mm512_maskz_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_or_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_or_epi64\">_mm512_maskz_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_packs_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_packs_epi16\">_mm512_maskz_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_packs_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_packs_epi32\">_mm512_maskz_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_packus_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_packus_epi16\">_mm512_maskz_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_packus_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_packus_epi32\">_mm512_maskz_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permute_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_permute_pd\">_mm512_maskz_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permute_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_permute_ps\">_mm512_maskz_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutevar_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_permutevar_pd\">_mm512_maskz_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutevar_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_permutevar_ps\">_mm512_maskz_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex2var_epi8\">_mm512_maskz_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex2var_epi16\">_mm512_maskz_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex2var_epi32\">_mm512_maskz_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex2var_epi64\">_mm512_maskz_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex2var_pd\">_mm512_maskz_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex2var_ps\">_mm512_maskz_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex_epi64\">_mm512_maskz_permutex_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutex_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_permutex_pd\">_mm512_maskz_permutex_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_permutexvar_epi8\">_mm512_maskz_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_permutexvar_epi16\">_mm512_maskz_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutexvar_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_permutexvar_epi32\">_mm512_maskz_permutexvar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutexvar_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_permutexvar_epi64\">_mm512_maskz_permutexvar_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutexvar_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_permutexvar_pd\">_mm512_maskz_permutexvar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_permutexvar_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_permutexvar_ps\">_mm512_maskz_permutexvar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_popcnt_epi8\">_mm512_maskz_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_popcnt_epi16\">_mm512_maskz_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_popcnt_epi32\">_mm512_maskz_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only\">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_popcnt_epi64\">_mm512_maskz_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only\">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rcp14_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_rcp14_pd\">_mm512_maskz_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rcp14_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_rcp14_ps\">_mm512_maskz_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rol_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_rol_epi32\">_mm512_maskz_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rol_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_rol_epi64\">_mm512_maskz_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rolv_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_rolv_epi32\">_mm512_maskz_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rolv_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_rolv_epi64\">_mm512_maskz_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_ror_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_ror_epi32\">_mm512_maskz_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_ror_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_ror_epi64\">_mm512_maskz_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rorv_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_rorv_epi32\">_mm512_maskz_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rorv_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_rorv_epi64\">_mm512_maskz_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_roundscale_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_roundscale_pd\">_mm512_maskz_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_roundscale_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_roundscale_ps\">_mm512_maskz_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_roundscale_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_roundscale_round_pd\">_mm512_maskz_roundscale_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_roundscale_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_roundscale_round_ps\">_mm512_maskz_roundscale_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_rsqrt14_pd\">_mm512_maskz_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_rsqrt14_ps\">_mm512_maskz_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_scalef_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_scalef_pd\">_mm512_maskz_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_scalef_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_scalef_ps\">_mm512_maskz_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_scalef_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_scalef_round_pd\">_mm512_maskz_scalef_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_scalef_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_scalef_round_ps\">_mm512_maskz_scalef_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_set1_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_set1_epi8\">_mm512_maskz_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_set1_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_set1_epi16\">_mm512_maskz_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_set1_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_set1_epi32\">_mm512_maskz_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_set1_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_set1_epi64\">_mm512_maskz_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shldi_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_shldi_epi16\">_mm512_maskz_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shldi_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_shldi_epi32\">_mm512_maskz_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shldi_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_shldi_epi64\">_mm512_maskz_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shldv_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_shldv_epi16\">_mm512_maskz_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shldv_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_shldv_epi32\">_mm512_maskz_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shldv_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_shldv_epi64\">_mm512_maskz_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_shrdi_epi16\">_mm512_maskz_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_shrdi_epi32\">_mm512_maskz_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_shrdi_epi64\">_mm512_maskz_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_shrdv_epi16\">_mm512_maskz_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_shrdv_epi32\">_mm512_maskz_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_shrdv_epi64\">_mm512_maskz_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_epi8\">_mm512_maskz_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_epi32\">_mm512_maskz_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_f32x4.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_f32x4\">_mm512_maskz_shuffle_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_f64x2.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_f64x2\">_mm512_maskz_shuffle_f64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_i32x4.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_i32x4\">_mm512_maskz_shuffle_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_i64x2.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_i64x2\">_mm512_maskz_shuffle_i64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_pd\">_mm512_maskz_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shuffle_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_shuffle_ps\">_mm512_maskz_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_shufflehi_epi16\">_mm512_maskz_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_shufflelo_epi16\">_mm512_maskz_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sll_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_sll_epi16\">_mm512_maskz_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sll_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_sll_epi32\">_mm512_maskz_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sll_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_sll_epi64\">_mm512_maskz_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_slli_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_slli_epi16\">_mm512_maskz_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_slli_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_slli_epi32\">_mm512_maskz_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_slli_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_slli_epi64\">_mm512_maskz_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sllv_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_sllv_epi16\">_mm512_maskz_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sllv_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_sllv_epi32\">_mm512_maskz_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sllv_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_sllv_epi64\">_mm512_maskz_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sqrt_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_sqrt_pd\">_mm512_maskz_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sqrt_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_sqrt_ps\">_mm512_maskz_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sqrt_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_sqrt_round_pd\">_mm512_maskz_sqrt_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sqrt_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_sqrt_round_ps\">_mm512_maskz_sqrt_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sra_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_sra_epi16\">_mm512_maskz_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sra_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_sra_epi32\">_mm512_maskz_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sra_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_sra_epi64\">_mm512_maskz_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srai_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_srai_epi16\">_mm512_maskz_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srai_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_srai_epi32\">_mm512_maskz_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srai_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_srai_epi64\">_mm512_maskz_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srav_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_srav_epi16\">_mm512_maskz_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srav_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_srav_epi32\">_mm512_maskz_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srav_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_srav_epi64\">_mm512_maskz_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srl_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_srl_epi16\">_mm512_maskz_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srl_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_srl_epi32\">_mm512_maskz_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srl_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_srl_epi64\">_mm512_maskz_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srli_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_srli_epi16\">_mm512_maskz_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srli_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_srli_epi32\">_mm512_maskz_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srli_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_srli_epi64\">_mm512_maskz_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srlv_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_srlv_epi16\">_mm512_maskz_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srlv_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_srlv_epi32\">_mm512_maskz_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_srlv_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_srlv_epi64\">_mm512_maskz_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_epi8\">_mm512_maskz_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_epi16\">_mm512_maskz_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_epi32\">_mm512_maskz_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_epi64\">_mm512_maskz_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_pd\">_mm512_maskz_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_ps\">_mm512_maskz_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_round_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_round_pd\">_mm512_maskz_sub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_sub_round_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_sub_round_ps\">_mm512_maskz_sub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_subs_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_subs_epi8\">_mm512_maskz_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_subs_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_subs_epi16\">_mm512_maskz_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_subs_epu8.html\" title=\"fn core::arch::x86::_mm512_maskz_subs_epu8\">_mm512_maskz_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_subs_epu16.html\" title=\"fn core::arch::x86::_mm512_maskz_subs_epu16\">_mm512_maskz_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_ternarylogic_epi32\">_mm512_maskz_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_ternarylogic_epi64\">_mm512_maskz_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_unpackhi_epi8\">_mm512_maskz_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_unpackhi_epi16\">_mm512_maskz_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_unpackhi_epi32\">_mm512_maskz_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_unpackhi_epi64\">_mm512_maskz_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_unpackhi_pd\">_mm512_maskz_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_unpackhi_ps\">_mm512_maskz_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm512_maskz_unpacklo_epi8\">_mm512_maskz_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm512_maskz_unpacklo_epi16\">_mm512_maskz_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_unpacklo_epi32\">_mm512_maskz_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_unpacklo_epi64\">_mm512_maskz_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm512_maskz_unpacklo_pd\">_mm512_maskz_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm512_maskz_unpacklo_ps\">_mm512_maskz_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_xor_epi32.html\" title=\"fn core::arch::x86::_mm512_maskz_xor_epi32\">_mm512_maskz_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_maskz_xor_epi64.html\" title=\"fn core::arch::x86::_mm512_maskz_xor_epi64\">_mm512_maskz_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epi8.html\" title=\"fn core::arch::x86::_mm512_max_epi8\">_mm512_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epi16.html\" title=\"fn core::arch::x86::_mm512_max_epi16\">_mm512_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epi32.html\" title=\"fn core::arch::x86::_mm512_max_epi32\">_mm512_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epi64.html\" title=\"fn core::arch::x86::_mm512_max_epi64\">_mm512_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epu8.html\" title=\"fn core::arch::x86::_mm512_max_epu8\">_mm512_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epu16.html\" title=\"fn core::arch::x86::_mm512_max_epu16\">_mm512_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epu32.html\" title=\"fn core::arch::x86::_mm512_max_epu32\">_mm512_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_epu64.html\" title=\"fn core::arch::x86::_mm512_max_epu64\">_mm512_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_pd.html\" title=\"fn core::arch::x86::_mm512_max_pd\">_mm512_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_ps.html\" title=\"fn core::arch::x86::_mm512_max_ps\">_mm512_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_round_pd.html\" title=\"fn core::arch::x86::_mm512_max_round_pd\">_mm512_max_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_max_round_ps.html\" title=\"fn core::arch::x86::_mm512_max_round_ps\">_mm512_max_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epi8.html\" title=\"fn core::arch::x86::_mm512_min_epi8\">_mm512_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epi16.html\" title=\"fn core::arch::x86::_mm512_min_epi16\">_mm512_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epi32.html\" title=\"fn core::arch::x86::_mm512_min_epi32\">_mm512_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epi64.html\" title=\"fn core::arch::x86::_mm512_min_epi64\">_mm512_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epu8.html\" title=\"fn core::arch::x86::_mm512_min_epu8\">_mm512_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epu16.html\" title=\"fn core::arch::x86::_mm512_min_epu16\">_mm512_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epu32.html\" title=\"fn core::arch::x86::_mm512_min_epu32\">_mm512_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_epu64.html\" title=\"fn core::arch::x86::_mm512_min_epu64\">_mm512_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_pd.html\" title=\"fn core::arch::x86::_mm512_min_pd\">_mm512_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.\nCompare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_ps.html\" title=\"fn core::arch::x86::_mm512_min_ps\">_mm512_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_round_pd.html\" title=\"fn core::arch::x86::_mm512_min_round_pd\">_mm512_min_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_min_round_ps.html\" title=\"fn core::arch::x86::_mm512_min_round_ps\">_mm512_min_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_movedup_pd.html\" title=\"fn core::arch::x86::_mm512_movedup_pd\">_mm512_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_movehdup_ps.html\" title=\"fn core::arch::x86::_mm512_movehdup_ps\">_mm512_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_moveldup_ps.html\" title=\"fn core::arch::x86::_mm512_moveldup_ps\">_mm512_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_movepi8_mask.html\" title=\"fn core::arch::x86::_mm512_movepi8_mask\">_mm512_movepi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_movepi16_mask.html\" title=\"fn core::arch::x86::_mm512_movepi16_mask\">_mm512_movepi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_movm_epi8.html\" title=\"fn core::arch::x86::_mm512_movm_epi8\">_mm512_movm_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_movm_epi16.html\" title=\"fn core::arch::x86::_mm512_movm_epi16\">_mm512_movm_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mul_epi32.html\" title=\"fn core::arch::x86::_mm512_mul_epi32\">_mm512_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mul_epu32.html\" title=\"fn core::arch::x86::_mm512_mul_epu32\">_mm512_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mul_pd.html\" title=\"fn core::arch::x86::_mm512_mul_pd\">_mm512_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mul_ps.html\" title=\"fn core::arch::x86::_mm512_mul_ps\">_mm512_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mul_round_pd.html\" title=\"fn core::arch::x86::_mm512_mul_round_pd\">_mm512_mul_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mul_round_ps.html\" title=\"fn core::arch::x86::_mm512_mul_round_ps\">_mm512_mul_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm512_mulhi_epi16\">_mm512_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm512_mulhi_epu16\">_mm512_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm512_mulhrs_epi16\">_mm512_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mullo_epi16.html\" title=\"fn core::arch::x86::_mm512_mullo_epi16\">_mm512_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mullo_epi32.html\" title=\"fn core::arch::x86::_mm512_mullo_epi32\">_mm512_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_mullox_epi64.html\" title=\"fn core::arch::x86::_mm512_mullox_epi64\">_mm512_mullox_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm512_multishift_epi64_epi8\">_mm512_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_or_epi32.html\" title=\"fn core::arch::x86::_mm512_or_epi32\">_mm512_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_or_epi64.html\" title=\"fn core::arch::x86::_mm512_or_epi64\">_mm512_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_or_si512.html\" title=\"fn core::arch::x86::_mm512_or_si512\">_mm512_or_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of 512 bits (representing integer data) in a and b, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_packs_epi16.html\" title=\"fn core::arch::x86::_mm512_packs_epi16\">_mm512_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_packs_epi32.html\" title=\"fn core::arch::x86::_mm512_packs_epi32\">_mm512_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_packus_epi16.html\" title=\"fn core::arch::x86::_mm512_packus_epi16\">_mm512_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_packus_epi32.html\" title=\"fn core::arch::x86::_mm512_packus_epi32\">_mm512_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permute_pd.html\" title=\"fn core::arch::x86::_mm512_permute_pd\">_mm512_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permute_ps.html\" title=\"fn core::arch::x86::_mm512_permute_ps\">_mm512_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutevar_epi32.html\" title=\"fn core::arch::x86::_mm512_permutevar_epi32\">_mm512_permutevar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst. Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to _mm512_permutexvar_epi32, and it is recommended that you use that intrinsic name.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutevar_pd.html\" title=\"fn core::arch::x86::_mm512_permutevar_pd\">_mm512_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutevar_ps.html\" title=\"fn core::arch::x86::_mm512_permutevar_ps\">_mm512_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm512_permutex2var_epi8\">_mm512_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm512_permutex2var_epi16\">_mm512_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm512_permutex2var_epi32\">_mm512_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm512_permutex2var_epi64\">_mm512_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm512_permutex2var_pd\">_mm512_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm512_permutex2var_ps\">_mm512_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex_epi64.html\" title=\"fn core::arch::x86::_mm512_permutex_epi64\">_mm512_permutex_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutex_pd.html\" title=\"fn core::arch::x86::_mm512_permutex_pd\">_mm512_permutex_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm512_permutexvar_epi8\">_mm512_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi` only\">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm512_permutexvar_epi16\">_mm512_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutexvar_epi32.html\" title=\"fn core::arch::x86::_mm512_permutexvar_epi32\">_mm512_permutexvar_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutexvar_epi64.html\" title=\"fn core::arch::x86::_mm512_permutexvar_epi64\">_mm512_permutexvar_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutexvar_pd.html\" title=\"fn core::arch::x86::_mm512_permutexvar_pd\">_mm512_permutexvar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_permutexvar_ps.html\" title=\"fn core::arch::x86::_mm512_permutexvar_ps\">_mm512_permutexvar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm512_popcnt_epi8\">_mm512_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm512_popcnt_epi16\">_mm512_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg` only\">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm512_popcnt_epi32\">_mm512_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only\">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm512_popcnt_epi64\">_mm512_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only\">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rcp14_pd.html\" title=\"fn core::arch::x86::_mm512_rcp14_pd\">_mm512_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rcp14_ps.html\" title=\"fn core::arch::x86::_mm512_rcp14_ps\">_mm512_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_add_epi32.html\" title=\"fn core::arch::x86::_mm512_reduce_add_epi32\">_mm512_reduce_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by addition. Returns the sum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_add_epi64.html\" title=\"fn core::arch::x86::_mm512_reduce_add_epi64\">_mm512_reduce_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by addition. Returns the sum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_add_pd.html\" title=\"fn core::arch::x86::_mm512_reduce_add_pd\">_mm512_reduce_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by addition. Returns the sum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_add_ps.html\" title=\"fn core::arch::x86::_mm512_reduce_add_ps\">_mm512_reduce_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by addition. Returns the sum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_and_epi32.html\" title=\"fn core::arch::x86::_mm512_reduce_and_epi32\">_mm512_reduce_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_and_epi64.html\" title=\"fn core::arch::x86::_mm512_reduce_and_epi64\">_mm512_reduce_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_max_epi32.html\" title=\"fn core::arch::x86::_mm512_reduce_max_epi32\">_mm512_reduce_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 32-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_max_epi64.html\" title=\"fn core::arch::x86::_mm512_reduce_max_epi64\">_mm512_reduce_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 64-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_max_epu32.html\" title=\"fn core::arch::x86::_mm512_reduce_max_epu32\">_mm512_reduce_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 32-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_max_epu64.html\" title=\"fn core::arch::x86::_mm512_reduce_max_epu64\">_mm512_reduce_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 64-bit integers in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_max_pd.html\" title=\"fn core::arch::x86::_mm512_reduce_max_pd\">_mm512_reduce_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_max_ps.html\" title=\"fn core::arch::x86::_mm512_reduce_max_ps\">_mm512_reduce_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_min_epi32.html\" title=\"fn core::arch::x86::_mm512_reduce_min_epi32\">_mm512_reduce_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 32-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_min_epi64.html\" title=\"fn core::arch::x86::_mm512_reduce_min_epi64\">_mm512_reduce_min_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed signed 64-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_min_epu32.html\" title=\"fn core::arch::x86::_mm512_reduce_min_epu32\">_mm512_reduce_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 32-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_min_epu64.html\" title=\"fn core::arch::x86::_mm512_reduce_min_epu64\">_mm512_reduce_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed unsigned 64-bit integers in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_min_pd.html\" title=\"fn core::arch::x86::_mm512_reduce_min_pd\">_mm512_reduce_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_min_ps.html\" title=\"fn core::arch::x86::_mm512_reduce_min_ps\">_mm512_reduce_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_mul_epi32.html\" title=\"fn core::arch::x86::_mm512_reduce_mul_epi32\">_mm512_reduce_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by multiplication. Returns the product of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_mul_epi64.html\" title=\"fn core::arch::x86::_mm512_reduce_mul_epi64\">_mm512_reduce_mul_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by multiplication. Returns the product of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_mul_pd.html\" title=\"fn core::arch::x86::_mm512_reduce_mul_pd\">_mm512_reduce_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_mul_ps.html\" title=\"fn core::arch::x86::_mm512_reduce_mul_ps\">_mm512_reduce_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_or_epi32.html\" title=\"fn core::arch::x86::_mm512_reduce_or_epi32\">_mm512_reduce_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 32-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_reduce_or_epi64.html\" title=\"fn core::arch::x86::_mm512_reduce_or_epi64\">_mm512_reduce_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Reduce the packed 64-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rol_epi32.html\" title=\"fn core::arch::x86::_mm512_rol_epi32\">_mm512_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rol_epi64.html\" title=\"fn core::arch::x86::_mm512_rol_epi64\">_mm512_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rolv_epi32.html\" title=\"fn core::arch::x86::_mm512_rolv_epi32\">_mm512_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rolv_epi64.html\" title=\"fn core::arch::x86::_mm512_rolv_epi64\">_mm512_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_ror_epi32.html\" title=\"fn core::arch::x86::_mm512_ror_epi32\">_mm512_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_ror_epi64.html\" title=\"fn core::arch::x86::_mm512_ror_epi64\">_mm512_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rorv_epi32.html\" title=\"fn core::arch::x86::_mm512_rorv_epi32\">_mm512_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rorv_epi64.html\" title=\"fn core::arch::x86::_mm512_rorv_epi64\">_mm512_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_roundscale_pd.html\" title=\"fn core::arch::x86::_mm512_roundscale_pd\">_mm512_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_roundscale_ps.html\" title=\"fn core::arch::x86::_mm512_roundscale_ps\">_mm512_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_roundscale_round_pd.html\" title=\"fn core::arch::x86::_mm512_roundscale_round_pd\">_mm512_roundscale_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_roundscale_round_ps.html\" title=\"fn core::arch::x86::_mm512_roundscale_round_ps\">_mm512_roundscale_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm512_rsqrt14_pd\">_mm512_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm512_rsqrt14_ps\">_mm512_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sad_epu8.html\" title=\"fn core::arch::x86::_mm512_sad_epu8\">_mm512_sad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the absolute differences of packed unsigned 8-bit integers in a and b, then horizontally sum each consecutive 8 differences to produce eight unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_scalef_pd.html\" title=\"fn core::arch::x86::_mm512_scalef_pd\">_mm512_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_scalef_ps.html\" title=\"fn core::arch::x86::_mm512_scalef_ps\">_mm512_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_scalef_round_pd.html\" title=\"fn core::arch::x86::_mm512_scalef_round_pd\">_mm512_scalef_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_scalef_round_ps.html\" title=\"fn core::arch::x86::_mm512_scalef_round_ps\">_mm512_scalef_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set1_epi8.html\" title=\"fn core::arch::x86::_mm512_set1_epi8\">_mm512_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set1_epi16.html\" title=\"fn core::arch::x86::_mm512_set1_epi16\">_mm512_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set1_epi32.html\" title=\"fn core::arch::x86::_mm512_set1_epi32\">_mm512_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set1_epi64.html\" title=\"fn core::arch::x86::_mm512_set1_epi64\">_mm512_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set1_pd.html\" title=\"fn core::arch::x86::_mm512_set1_pd\">_mm512_set1_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set1_ps.html\" title=\"fn core::arch::x86::_mm512_set1_ps\">_mm512_set1_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set4_epi32.html\" title=\"fn core::arch::x86::_mm512_set4_epi32\">_mm512_set4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 32-bit integers in dst with the repeated 4 element sequence.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set4_epi64.html\" title=\"fn core::arch::x86::_mm512_set4_epi64\">_mm512_set4_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 64-bit integers in dst with the repeated 4 element sequence.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set4_pd.html\" title=\"fn core::arch::x86::_mm512_set4_pd\">_mm512_set4_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set4_ps.html\" title=\"fn core::arch::x86::_mm512_set4_ps\">_mm512_set4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set_epi8.html\" title=\"fn core::arch::x86::_mm512_set_epi8\">_mm512_set_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 8-bit integers in dst with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set_epi16.html\" title=\"fn core::arch::x86::_mm512_set_epi16\">_mm512_set_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 16-bit integers in dst with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set_epi32.html\" title=\"fn core::arch::x86::_mm512_set_epi32\">_mm512_set_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers in <code>dst</code> with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set_epi64.html\" title=\"fn core::arch::x86::_mm512_set_epi64\">_mm512_set_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 64-bit integers in dst with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set_pd.html\" title=\"fn core::arch::x86::_mm512_set_pd\">_mm512_set_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed double-precision (64-bit) floating-point elements in dst with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_set_ps.html\" title=\"fn core::arch::x86::_mm512_set_ps\">_mm512_set_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers in <code>dst</code> with the supplied values.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr4_epi32.html\" title=\"fn core::arch::x86::_mm512_setr4_epi32\">_mm512_setr4_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 32-bit integers in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr4_epi64.html\" title=\"fn core::arch::x86::_mm512_setr4_epi64\">_mm512_setr4_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 64-bit integers in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr4_pd.html\" title=\"fn core::arch::x86::_mm512_setr4_pd\">_mm512_setr4_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr4_ps.html\" title=\"fn core::arch::x86::_mm512_setr4_ps\">_mm512_setr4_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr_epi32.html\" title=\"fn core::arch::x86::_mm512_setr_epi32\">_mm512_setr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers in <code>dst</code> with the supplied values in reverse\norder.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr_epi64.html\" title=\"fn core::arch::x86::_mm512_setr_epi64\">_mm512_setr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed 64-bit integers in dst with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr_pd.html\" title=\"fn core::arch::x86::_mm512_setr_pd\">_mm512_setr_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Set packed double-precision (64-bit) floating-point elements in dst with the supplied values in reverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setr_ps.html\" title=\"fn core::arch::x86::_mm512_setr_ps\">_mm512_setr_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Sets packed 32-bit integers in <code>dst</code> with the supplied values in\nreverse order.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setzero.html\" title=\"fn core::arch::x86::_mm512_setzero\">_mm512_setzero</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Return vector of type <code>__m512</code> with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setzero_epi32.html\" title=\"fn core::arch::x86::_mm512_setzero_epi32\">_mm512_setzero_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Return vector of type <code>__m512i</code> with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setzero_pd.html\" title=\"fn core::arch::x86::_mm512_setzero_pd\">_mm512_setzero_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m512d</code> with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setzero_ps.html\" title=\"fn core::arch::x86::_mm512_setzero_ps\">_mm512_setzero_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m512</code> with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_setzero_si512.html\" title=\"fn core::arch::x86::_mm512_setzero_si512\">_mm512_setzero_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m512i</code> with all elements set to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shldi_epi16.html\" title=\"fn core::arch::x86::_mm512_shldi_epi16\">_mm512_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shldi_epi32.html\" title=\"fn core::arch::x86::_mm512_shldi_epi32\">_mm512_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shldi_epi64.html\" title=\"fn core::arch::x86::_mm512_shldi_epi64\">_mm512_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shldv_epi16.html\" title=\"fn core::arch::x86::_mm512_shldv_epi16\">_mm512_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shldv_epi32.html\" title=\"fn core::arch::x86::_mm512_shldv_epi32\">_mm512_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shldv_epi64.html\" title=\"fn core::arch::x86::_mm512_shldv_epi64\">_mm512_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm512_shrdi_epi16\">_mm512_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm512_shrdi_epi32\">_mm512_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm512_shrdi_epi64\">_mm512_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm512_shrdv_epi16\">_mm512_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm512_shrdv_epi32\">_mm512_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm512_shrdv_epi64\">_mm512_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2` only\">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm512_shuffle_epi8\">_mm512_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm512_shuffle_epi32\">_mm512_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_f32x4.html\" title=\"fn core::arch::x86::_mm512_shuffle_f32x4\">_mm512_shuffle_f32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_f64x2.html\" title=\"fn core::arch::x86::_mm512_shuffle_f64x2\">_mm512_shuffle_f64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_i32x4.html\" title=\"fn core::arch::x86::_mm512_shuffle_i32x4\">_mm512_shuffle_i32x4</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_i64x2.html\" title=\"fn core::arch::x86::_mm512_shuffle_i64x2\">_mm512_shuffle_i64x2</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_pd.html\" title=\"fn core::arch::x86::_mm512_shuffle_pd\">_mm512_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shuffle_ps.html\" title=\"fn core::arch::x86::_mm512_shuffle_ps\">_mm512_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm512_shufflehi_epi16\">_mm512_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm512_shufflelo_epi16\">_mm512_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sll_epi16.html\" title=\"fn core::arch::x86::_mm512_sll_epi16\">_mm512_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sll_epi32.html\" title=\"fn core::arch::x86::_mm512_sll_epi32\">_mm512_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sll_epi64.html\" title=\"fn core::arch::x86::_mm512_sll_epi64\">_mm512_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_slli_epi16.html\" title=\"fn core::arch::x86::_mm512_slli_epi16\">_mm512_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_slli_epi32.html\" title=\"fn core::arch::x86::_mm512_slli_epi32\">_mm512_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_slli_epi64.html\" title=\"fn core::arch::x86::_mm512_slli_epi64\">_mm512_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sllv_epi16.html\" title=\"fn core::arch::x86::_mm512_sllv_epi16\">_mm512_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sllv_epi32.html\" title=\"fn core::arch::x86::_mm512_sllv_epi32\">_mm512_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sllv_epi64.html\" title=\"fn core::arch::x86::_mm512_sllv_epi64\">_mm512_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sqrt_pd.html\" title=\"fn core::arch::x86::_mm512_sqrt_pd\">_mm512_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sqrt_ps.html\" title=\"fn core::arch::x86::_mm512_sqrt_ps\">_mm512_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sqrt_round_pd.html\" title=\"fn core::arch::x86::_mm512_sqrt_round_pd\">_mm512_sqrt_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sqrt_round_ps.html\" title=\"fn core::arch::x86::_mm512_sqrt_round_ps\">_mm512_sqrt_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sra_epi16.html\" title=\"fn core::arch::x86::_mm512_sra_epi16\">_mm512_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sra_epi32.html\" title=\"fn core::arch::x86::_mm512_sra_epi32\">_mm512_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sra_epi64.html\" title=\"fn core::arch::x86::_mm512_sra_epi64\">_mm512_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srai_epi16.html\" title=\"fn core::arch::x86::_mm512_srai_epi16\">_mm512_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srai_epi32.html\" title=\"fn core::arch::x86::_mm512_srai_epi32\">_mm512_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srai_epi64.html\" title=\"fn core::arch::x86::_mm512_srai_epi64\">_mm512_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srav_epi16.html\" title=\"fn core::arch::x86::_mm512_srav_epi16\">_mm512_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srav_epi32.html\" title=\"fn core::arch::x86::_mm512_srav_epi32\">_mm512_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srav_epi64.html\" title=\"fn core::arch::x86::_mm512_srav_epi64\">_mm512_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srl_epi16.html\" title=\"fn core::arch::x86::_mm512_srl_epi16\">_mm512_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srl_epi32.html\" title=\"fn core::arch::x86::_mm512_srl_epi32\">_mm512_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srl_epi64.html\" title=\"fn core::arch::x86::_mm512_srl_epi64\">_mm512_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srli_epi16.html\" title=\"fn core::arch::x86::_mm512_srli_epi16\">_mm512_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srli_epi32.html\" title=\"fn core::arch::x86::_mm512_srli_epi32\">_mm512_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srli_epi64.html\" title=\"fn core::arch::x86::_mm512_srli_epi64\">_mm512_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srlv_epi16.html\" title=\"fn core::arch::x86::_mm512_srlv_epi16\">_mm512_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srlv_epi32.html\" title=\"fn core::arch::x86::_mm512_srlv_epi32\">_mm512_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_srlv_epi64.html\" title=\"fn core::arch::x86::_mm512_srlv_epi64\">_mm512_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_store_epi32.html\" title=\"fn core::arch::x86::_mm512_store_epi32\">_mm512_store_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_store_epi64.html\" title=\"fn core::arch::x86::_mm512_store_epi64\">_mm512_store_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_store_pd.html\" title=\"fn core::arch::x86::_mm512_store_pd\">_mm512_store_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_store_ps.html\" title=\"fn core::arch::x86::_mm512_store_ps\">_mm512_store_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits of integer data from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_store_si512.html\" title=\"fn core::arch::x86::_mm512_store_si512\">_mm512_store_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits of integer data from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_epi8.html\" title=\"fn core::arch::x86::_mm512_storeu_epi8\">_mm512_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 64 packed 8-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_epi16.html\" title=\"fn core::arch::x86::_mm512_storeu_epi16\">_mm512_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 32 packed 16-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_epi32.html\" title=\"fn core::arch::x86::_mm512_storeu_epi32\">_mm512_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_epi64.html\" title=\"fn core::arch::x86::_mm512_storeu_epi64\">_mm512_storeu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_pd.html\" title=\"fn core::arch::x86::_mm512_storeu_pd\">_mm512_storeu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Stores 512-bits (composed of 8 packed double-precision (64-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_ps.html\" title=\"fn core::arch::x86::_mm512_storeu_ps\">_mm512_storeu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Stores 512-bits (composed of 16 packed single-precision (32-bit)\nfloating-point elements) from <code>a</code> into memory.\n<code>mem_addr</code> does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_storeu_si512.html\" title=\"fn core::arch::x86::_mm512_storeu_si512\">_mm512_storeu_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits of integer data from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_stream_pd.html\" title=\"fn core::arch::x86::_mm512_stream_pd\">_mm512_stream_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_stream_ps.html\" title=\"fn core::arch::x86::_mm512_stream_ps\">_mm512_stream_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_stream_si512.html\" title=\"fn core::arch::x86::_mm512_stream_si512\">_mm512_stream_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Store 512-bits of integer data from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_epi8.html\" title=\"fn core::arch::x86::_mm512_sub_epi8\">_mm512_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_epi16.html\" title=\"fn core::arch::x86::_mm512_sub_epi16\">_mm512_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_epi32.html\" title=\"fn core::arch::x86::_mm512_sub_epi32\">_mm512_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_epi64.html\" title=\"fn core::arch::x86::_mm512_sub_epi64\">_mm512_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_pd.html\" title=\"fn core::arch::x86::_mm512_sub_pd\">_mm512_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_ps.html\" title=\"fn core::arch::x86::_mm512_sub_ps\">_mm512_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_round_pd.html\" title=\"fn core::arch::x86::_mm512_sub_round_pd\">_mm512_sub_round_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_sub_round_ps.html\" title=\"fn core::arch::x86::_mm512_sub_round_ps\">_mm512_sub_round_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_subs_epi8.html\" title=\"fn core::arch::x86::_mm512_subs_epi8\">_mm512_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_subs_epi16.html\" title=\"fn core::arch::x86::_mm512_subs_epi16\">_mm512_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_subs_epu8.html\" title=\"fn core::arch::x86::_mm512_subs_epu8\">_mm512_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_subs_epu16.html\" title=\"fn core::arch::x86::_mm512_subs_epu16\">_mm512_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm512_ternarylogic_epi32\">_mm512_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm512_ternarylogic_epi64\">_mm512_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_test_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_test_epi8_mask\">_mm512_test_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_test_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_test_epi16_mask\">_mm512_test_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_test_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_test_epi32_mask\">_mm512_test_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_test_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_test_epi64_mask\">_mm512_test_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_testn_epi8_mask.html\" title=\"fn core::arch::x86::_mm512_testn_epi8_mask\">_mm512_testn_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_testn_epi16_mask.html\" title=\"fn core::arch::x86::_mm512_testn_epi16_mask\">_mm512_testn_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_testn_epi32_mask.html\" title=\"fn core::arch::x86::_mm512_testn_epi32_mask\">_mm512_testn_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_testn_epi64_mask.html\" title=\"fn core::arch::x86::_mm512_testn_epi64_mask\">_mm512_testn_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_undefined.html\" title=\"fn core::arch::x86::_mm512_undefined\">_mm512_undefined</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Return vector of type __m512 with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_undefined_epi32.html\" title=\"fn core::arch::x86::_mm512_undefined_epi32\">_mm512_undefined_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Return vector of type __m512i with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_undefined_pd.html\" title=\"fn core::arch::x86::_mm512_undefined_pd\">_mm512_undefined_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m512d</code> with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_undefined_ps.html\" title=\"fn core::arch::x86::_mm512_undefined_ps\">_mm512_undefined_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Returns vector of type <code>__m512</code> with indeterminate elements.\nDespite being “undefined”, this is some valid value and not equivalent to <a href=\"../../mem/union.MaybeUninit.html\" title=\"union core::mem::MaybeUninit\"><code>mem::MaybeUninit</code></a>.\nIn practice, this is equivalent to <a href=\"../../mem/fn.zeroed.html\" title=\"fn core::mem::zeroed\"><code>mem::zeroed</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm512_unpackhi_epi8\">_mm512_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm512_unpackhi_epi16\">_mm512_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm512_unpackhi_epi32\">_mm512_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm512_unpackhi_epi64\">_mm512_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm512_unpackhi_pd\">_mm512_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm512_unpackhi_ps\">_mm512_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm512_unpacklo_epi8\">_mm512_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm512_unpacklo_epi16\">_mm512_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm512_unpacklo_epi32\">_mm512_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm512_unpacklo_epi64\">_mm512_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm512_unpacklo_pd\">_mm512_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm512_unpacklo_ps\">_mm512_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_xor_epi32.html\" title=\"fn core::arch::x86::_mm512_xor_epi32\">_mm512_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_xor_epi64.html\" title=\"fn core::arch::x86::_mm512_xor_epi64\">_mm512_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_xor_si512.html\" title=\"fn core::arch::x86::_mm512_xor_si512\">_mm512_xor_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of 512 bits (representing integer data) in a and b, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_zextpd128_pd512.html\" title=\"fn core::arch::x86::_mm512_zextpd128_pd512\">_mm512_zextpd128_pd512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_zextpd256_pd512.html\" title=\"fn core::arch::x86::_mm512_zextpd256_pd512\">_mm512_zextpd256_pd512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_zextps128_ps512.html\" title=\"fn core::arch::x86::_mm512_zextps128_ps512\">_mm512_zextps128_ps512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m128 to type __m512; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_zextps256_ps512.html\" title=\"fn core::arch::x86::_mm512_zextps256_ps512\">_mm512_zextps256_ps512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256 to type __m512; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_zextsi128_si512.html\" title=\"fn core::arch::x86::_mm512_zextsi128_si512\">_mm512_zextsi128_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm512_zextsi256_si512.html\" title=\"fn core::arch::x86::_mm512_zextsi256_si512\">_mm512_zextsi256_si512</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_round_sd.html\" title=\"fn core::arch::x86::_mm_add_round_sd\">_mm_add_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_add_round_ss.html\" title=\"fn core::arch::x86::_mm_add_round_ss\">_mm_add_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_alignr_epi32.html\" title=\"fn core::arch::x86::_mm_alignr_epi32\">_mm_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_alignr_epi64.html\" title=\"fn core::arch::x86::_mm_alignr_epi64\">_mm_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_bitshuffle_epi64_mask.html\" title=\"fn core::arch::x86::_mm_bitshuffle_epi64_mask\">_mm_bitshuffle_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.\nThen groups 8 8-bit values from <code>c</code>as indices into the bits of the corresponding 64-bit integer.\nIt then selects these bits and packs them into the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastmb_epi64.html\" title=\"fn core::arch::x86::_mm_broadcastmb_epi64\">_mm_broadcastmb_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_broadcastmw_epi32.html\" title=\"fn core::arch::x86::_mm_broadcastmw_epi32\">_mm_broadcastmw_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epi8_mask\">_mm_cmp_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epi16_mask\">_mm_cmp_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epi32_mask\">_mm_cmp_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epi64_mask\">_mm_cmp_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epu8_mask\">_mm_cmp_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epu16_mask\">_mm_cmp_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epu32_mask\">_mm_cmp_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmp_epu64_mask\">_mm_cmp_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_pd_mask.html\" title=\"fn core::arch::x86::_mm_cmp_pd_mask\">_mm_cmp_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_ps_mask.html\" title=\"fn core::arch::x86::_mm_cmp_ps_mask\">_mm_cmp_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_round_sd_mask.html\" title=\"fn core::arch::x86::_mm_cmp_round_sd_mask\">_mm_cmp_round_sd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_round_ss_mask.html\" title=\"fn core::arch::x86::_mm_cmp_round_ss_mask\">_mm_cmp_round_ss_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_sd_mask.html\" title=\"fn core::arch::x86::_mm_cmp_sd_mask\">_mm_cmp_sd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmp_ss_mask.html\" title=\"fn core::arch::x86::_mm_cmp_ss_mask\">_mm_cmp_ss_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi8_mask\">_mm_cmpeq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi16_mask\">_mm_cmpeq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi32_mask\">_mm_cmpeq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epi64_mask\">_mm_cmpeq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epu8_mask\">_mm_cmpeq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epu16_mask\">_mm_cmpeq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epu32_mask\">_mm_cmpeq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpeq_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmpeq_epu64_mask\">_mm_cmpeq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epi8_mask\">_mm_cmpge_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epi16_mask\">_mm_cmpge_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epi32_mask\">_mm_cmpge_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epi64_mask\">_mm_cmpge_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epu8_mask\">_mm_cmpge_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epu16_mask\">_mm_cmpge_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epu32_mask\">_mm_cmpge_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpge_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmpge_epu64_mask\">_mm_cmpge_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi8_mask\">_mm_cmpgt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi16_mask\">_mm_cmpgt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi32_mask\">_mm_cmpgt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epi64_mask\">_mm_cmpgt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epu8_mask\">_mm_cmpgt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epu16_mask\">_mm_cmpgt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epu32_mask\">_mm_cmpgt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpgt_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmpgt_epu64_mask\">_mm_cmpgt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epi8_mask\">_mm_cmple_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epi16_mask\">_mm_cmple_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epi32_mask\">_mm_cmple_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epi64_mask\">_mm_cmple_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epu8_mask\">_mm_cmple_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epu16_mask\">_mm_cmple_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epu32_mask\">_mm_cmple_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmple_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmple_epu64_mask\">_mm_cmple_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epi8_mask\">_mm_cmplt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epi16_mask\">_mm_cmplt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epi32_mask\">_mm_cmplt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epi64_mask\">_mm_cmplt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epu8_mask\">_mm_cmplt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epu16_mask\">_mm_cmplt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epu32_mask\">_mm_cmplt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmplt_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmplt_epu64_mask\">_mm_cmplt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epi8_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epi8_mask\">_mm_cmpneq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epi16_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epi16_mask\">_mm_cmpneq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epi32_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epi32_mask\">_mm_cmpneq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epi64_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epi64_mask\">_mm_cmpneq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epu8_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epu8_mask\">_mm_cmpneq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epu16_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epu16_mask\">_mm_cmpneq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epu32_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epu32_mask\">_mm_cmpneq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cmpneq_epu64_mask.html\" title=\"fn core::arch::x86::_mm_cmpneq_epu64_mask\">_mm_cmpneq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comi_round_sd.html\" title=\"fn core::arch::x86::_mm_comi_round_sd\">_mm_comi_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_comi_round_ss.html\" title=\"fn core::arch::x86::_mm_comi_round_ss\">_mm_comi_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_conflict_epi32.html\" title=\"fn core::arch::x86::_mm_conflict_epi32\">_mm_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_conflict_epi64.html\" title=\"fn core::arch::x86::_mm_conflict_epi64\">_mm_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundi32_ss.html\" title=\"fn core::arch::x86::_mm_cvt_roundi32_ss\">_mm_cvt_roundi32_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundsd_i32.html\" title=\"fn core::arch::x86::_mm_cvt_roundsd_i32\">_mm_cvt_roundsd_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundsd_si32.html\" title=\"fn core::arch::x86::_mm_cvt_roundsd_si32\">_mm_cvt_roundsd_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundsd_ss.html\" title=\"fn core::arch::x86::_mm_cvt_roundsd_ss\">_mm_cvt_roundsd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundsd_u32.html\" title=\"fn core::arch::x86::_mm_cvt_roundsd_u32\">_mm_cvt_roundsd_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundsi32_ss.html\" title=\"fn core::arch::x86::_mm_cvt_roundsi32_ss\">_mm_cvt_roundsi32_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundss_i32.html\" title=\"fn core::arch::x86::_mm_cvt_roundss_i32\">_mm_cvt_roundss_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundss_sd.html\" title=\"fn core::arch::x86::_mm_cvt_roundss_sd\">_mm_cvt_roundss_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundss_si32.html\" title=\"fn core::arch::x86::_mm_cvt_roundss_si32\">_mm_cvt_roundss_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundss_u32.html\" title=\"fn core::arch::x86::_mm_cvt_roundss_u32\">_mm_cvt_roundss_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvt_roundu32_ss.html\" title=\"fn core::arch::x86::_mm_cvt_roundu32_ss\">_mm_cvt_roundu32_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm_cvtepi16_epi8\">_mm_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm_cvtepi32_epi8\">_mm_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm_cvtepi32_epi16\">_mm_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm_cvtepi64_epi8\">_mm_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm_cvtepi64_epi16\">_mm_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm_cvtepi64_epi32\">_mm_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm_cvtepu32_pd\">_mm_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvti32_sd.html\" title=\"fn core::arch::x86::_mm_cvti32_sd\">_mm_cvti32_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the signed 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvti32_ss.html\" title=\"fn core::arch::x86::_mm_cvti32_ss\">_mm_cvti32_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm_cvtne2ps_pbh\">_mm_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two 128-bit vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results in a\n128-bit wide vector.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&amp;avx512techs=AVX512_BF16&amp;text=_mm_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm_cvtpd_epu32\">_mm_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm_cvtps_epu32\">_mm_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsd_i32.html\" title=\"fn core::arch::x86::_mm_cvtsd_i32\">_mm_cvtsd_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsd_u32.html\" title=\"fn core::arch::x86::_mm_cvtsd_u32\">_mm_cvtsd_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm_cvtsepi16_epi8\">_mm_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm_cvtsepi32_epi8\">_mm_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm_cvtsepi32_epi16\">_mm_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm_cvtsepi64_epi8\">_mm_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm_cvtsepi64_epi16\">_mm_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm_cvtsepi64_epi32\">_mm_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtss_i32.html\" title=\"fn core::arch::x86::_mm_cvtss_i32\">_mm_cvtss_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtss_u32.html\" title=\"fn core::arch::x86::_mm_cvtss_u32\">_mm_cvtss_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_roundsd_i32.html\" title=\"fn core::arch::x86::_mm_cvtt_roundsd_i32\">_mm_cvtt_roundsd_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_roundsd_si32.html\" title=\"fn core::arch::x86::_mm_cvtt_roundsd_si32\">_mm_cvtt_roundsd_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_roundsd_u32.html\" title=\"fn core::arch::x86::_mm_cvtt_roundsd_u32\">_mm_cvtt_roundsd_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_roundss_i32.html\" title=\"fn core::arch::x86::_mm_cvtt_roundss_i32\">_mm_cvtt_roundss_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_roundss_si32.html\" title=\"fn core::arch::x86::_mm_cvtt_roundss_si32\">_mm_cvtt_roundss_si32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtt_roundss_u32.html\" title=\"fn core::arch::x86::_mm_cvtt_roundss_u32\">_mm_cvtt_roundss_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm_cvttpd_epu32\">_mm_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm_cvttps_epu32\">_mm_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttsd_i32.html\" title=\"fn core::arch::x86::_mm_cvttsd_i32\">_mm_cvttsd_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttsd_u32.html\" title=\"fn core::arch::x86::_mm_cvttsd_u32\">_mm_cvttsd_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttss_i32.html\" title=\"fn core::arch::x86::_mm_cvttss_i32\">_mm_cvttss_i32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvttss_u32.html\" title=\"fn core::arch::x86::_mm_cvttss_u32\">_mm_cvttss_u32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtu32_sd.html\" title=\"fn core::arch::x86::_mm_cvtu32_sd\">_mm_cvtu32_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the unsigned 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtu32_ss.html\" title=\"fn core::arch::x86::_mm_cvtu32_ss\">_mm_cvtu32_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm_cvtusepi16_epi8\">_mm_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm_cvtusepi32_epi8\">_mm_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm_cvtusepi32_epi16\">_mm_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm_cvtusepi64_epi8\">_mm_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm_cvtusepi64_epi16\">_mm_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm_cvtusepi64_epi32\">_mm_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm_dbsad_epu8\">_mm_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_div_round_sd.html\" title=\"fn core::arch::x86::_mm_div_round_sd\">_mm_div_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_div_round_ss.html\" title=\"fn core::arch::x86::_mm_div_round_ss\">_mm_div_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm_dpbf16_ps\">_mm_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst.\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm_dpbusd_epi32\">_mm_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm_dpbusds_epi32\">_mm_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm_dpwssd_epi32\">_mm_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm_dpwssds_epi32\">_mm_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm_fixupimm_pd\">_mm_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm_fixupimm_ps\">_mm_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fixupimm_round_sd.html\" title=\"fn core::arch::x86::_mm_fixupimm_round_sd\">_mm_fixupimm_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fixupimm_round_ss.html\" title=\"fn core::arch::x86::_mm_fixupimm_round_ss\">_mm_fixupimm_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fixupimm_sd.html\" title=\"fn core::arch::x86::_mm_fixupimm_sd\">_mm_fixupimm_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fixupimm_ss.html\" title=\"fn core::arch::x86::_mm_fixupimm_ss\">_mm_fixupimm_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_fmadd_round_sd\">_mm_fmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_fmadd_round_ss\">_mm_fmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_fmsub_round_sd\">_mm_fmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_fmsub_round_ss\">_mm_fmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_fnmadd_round_sd\">_mm_fnmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_fnmadd_round_ss\">_mm_fnmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_fnmsub_round_sd\">_mm_fnmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_fnmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_fnmsub_round_ss\">_mm_fnmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getexp_pd.html\" title=\"fn core::arch::x86::_mm_getexp_pd\">_mm_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getexp_ps.html\" title=\"fn core::arch::x86::_mm_getexp_ps\">_mm_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getexp_round_sd.html\" title=\"fn core::arch::x86::_mm_getexp_round_sd\">_mm_getexp_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getexp_round_ss.html\" title=\"fn core::arch::x86::_mm_getexp_round_ss\">_mm_getexp_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getexp_sd.html\" title=\"fn core::arch::x86::_mm_getexp_sd\">_mm_getexp_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getexp_ss.html\" title=\"fn core::arch::x86::_mm_getexp_ss\">_mm_getexp_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getmant_pd.html\" title=\"fn core::arch::x86::_mm_getmant_pd\">_mm_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getmant_ps.html\" title=\"fn core::arch::x86::_mm_getmant_ps\">_mm_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.\nThe mantissa is normalized to the interval specified by interv, which can take the following values:\n_MM_MANT_NORM_1_2     // interval [1, 2)\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)\nThe sign is determined by sc which can take the following values:\n_MM_MANT_SIGN_src     // sign = sign(src)\n_MM_MANT_SIGN_zero    // sign = 0\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getmant_round_sd.html\" title=\"fn core::arch::x86::_mm_getmant_round_sd\">_mm_getmant_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getmant_round_ss.html\" title=\"fn core::arch::x86::_mm_getmant_round_ss\">_mm_getmant_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getmant_sd.html\" title=\"fn core::arch::x86::_mm_getmant_sd\">_mm_getmant_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_getmant_ss.html\" title=\"fn core::arch::x86::_mm_getmant_ss\">_mm_getmant_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_gf2p8affine_epi64_epi8\">_mm_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni` only\">(x86 or x86-64) and <code>gfni</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_gf2p8affineinv_epi64_epi8\">_mm_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni` only\">(x86 or x86-64) and <code>gfni</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm_gf2p8mul_epi8\">_mm_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni` only\">(x86 or x86-64) and <code>gfni</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_epi32.html\" title=\"fn core::arch::x86::_mm_load_epi32\">_mm_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_load_epi64.html\" title=\"fn core::arch::x86::_mm_load_epi64\">_mm_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_epi8.html\" title=\"fn core::arch::x86::_mm_loadu_epi8\">_mm_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 128-bits (composed of 16 packed 8-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_epi16.html\" title=\"fn core::arch::x86::_mm_loadu_epi16\">_mm_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 128-bits (composed of 8 packed 16-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_epi32.html\" title=\"fn core::arch::x86::_mm_loadu_epi32\">_mm_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_loadu_epi64.html\" title=\"fn core::arch::x86::_mm_loadu_epi64\">_mm_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm_lzcnt_epi32\">_mm_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm_lzcnt_epi64\">_mm_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_madd52hi_epu64.html\" title=\"fn core::arch::x86::_mm_madd52hi_epu64\">_mm_madd52hi_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only\">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 52-bit integers in each 64-bit element of\n<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the high 52-bit\nunsigned integer from the intermediate result with the\ncorresponding unsigned 64-bit integer in <code>a</code>, and store the\nresults in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_madd52lo_epu64.html\" title=\"fn core::arch::x86::_mm_madd52lo_epu64\">_mm_madd52lo_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only\">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 52-bit integers in each 64-bit element of\n<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the low 52-bit\nunsigned integer from the intermediate result with the\ncorresponding unsigned 64-bit integer in <code>a</code>, and store the\nresults in <code>dst</code>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask2_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm_mask2_permutex2var_epi8\">_mm_mask2_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask2_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm_mask2_permutex2var_epi16\">_mm_mask2_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask2_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm_mask2_permutex2var_epi32\">_mm_mask2_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask2_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm_mask2_permutex2var_epi64\">_mm_mask2_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask2_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm_mask2_permutex2var_pd\">_mm_mask2_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask2_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm_mask2_permutex2var_ps\">_mm_mask2_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmadd_pd.html\" title=\"fn core::arch::x86::_mm_mask3_fmadd_pd\">_mm_mask3_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmadd_ps.html\" title=\"fn core::arch::x86::_mm_mask3_fmadd_ps\">_mm_mask3_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fmadd_round_sd\">_mm_mask3_fmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fmadd_round_ss\">_mm_mask3_fmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmadd_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fmadd_sd\">_mm_mask3_fmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmadd_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fmadd_ss\">_mm_mask3_fmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm_mask3_fmaddsub_pd\">_mm_mask3_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm_mask3_fmaddsub_ps\">_mm_mask3_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsub_pd.html\" title=\"fn core::arch::x86::_mm_mask3_fmsub_pd\">_mm_mask3_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsub_ps.html\" title=\"fn core::arch::x86::_mm_mask3_fmsub_ps\">_mm_mask3_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fmsub_round_sd\">_mm_mask3_fmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fmsub_round_ss\">_mm_mask3_fmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsub_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fmsub_sd\">_mm_mask3_fmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsub_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fmsub_ss\">_mm_mask3_fmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm_mask3_fmsubadd_pd\">_mm_mask3_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm_mask3_fmsubadd_ps\">_mm_mask3_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm_mask3_fnmadd_pd\">_mm_mask3_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm_mask3_fnmadd_ps\">_mm_mask3_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fnmadd_round_sd\">_mm_mask3_fnmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fnmadd_round_ss\">_mm_mask3_fnmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmadd_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fnmadd_sd\">_mm_mask3_fnmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmadd_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fnmadd_ss\">_mm_mask3_fnmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm_mask3_fnmsub_pd\">_mm_mask3_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm_mask3_fnmsub_ps\">_mm_mask3_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fnmsub_round_sd\">_mm_mask3_fnmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fnmsub_round_ss\">_mm_mask3_fnmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmsub_sd.html\" title=\"fn core::arch::x86::_mm_mask3_fnmsub_sd\">_mm_mask3_fnmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask3_fnmsub_ss.html\" title=\"fn core::arch::x86::_mm_mask3_fnmsub_ss\">_mm_mask3_fnmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_abs_epi8.html\" title=\"fn core::arch::x86::_mm_mask_abs_epi8\">_mm_mask_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set)</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_abs_epi16.html\" title=\"fn core::arch::x86::_mm_mask_abs_epi16\">_mm_mask_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_abs_epi32.html\" title=\"fn core::arch::x86::_mm_mask_abs_epi32\">_mm_mask_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_epi8.html\" title=\"fn core::arch::x86::_mm_mask_add_epi8\">_mm_mask_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_epi16.html\" title=\"fn core::arch::x86::_mm_mask_add_epi16\">_mm_mask_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_epi32.html\" title=\"fn core::arch::x86::_mm_mask_add_epi32\">_mm_mask_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_epi64.html\" title=\"fn core::arch::x86::_mm_mask_add_epi64\">_mm_mask_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_pd.html\" title=\"fn core::arch::x86::_mm_mask_add_pd\">_mm_mask_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_ps.html\" title=\"fn core::arch::x86::_mm_mask_add_ps\">_mm_mask_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_add_round_sd\">_mm_mask_add_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_add_round_ss\">_mm_mask_add_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_sd.html\" title=\"fn core::arch::x86::_mm_mask_add_sd\">_mm_mask_add_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_add_ss.html\" title=\"fn core::arch::x86::_mm_mask_add_ss\">_mm_mask_add_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_adds_epi8.html\" title=\"fn core::arch::x86::_mm_mask_adds_epi8\">_mm_mask_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_adds_epi16.html\" title=\"fn core::arch::x86::_mm_mask_adds_epi16\">_mm_mask_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_adds_epu8.html\" title=\"fn core::arch::x86::_mm_mask_adds_epu8\">_mm_mask_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_adds_epu16.html\" title=\"fn core::arch::x86::_mm_mask_adds_epu16\">_mm_mask_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_alignr_epi8.html\" title=\"fn core::arch::x86::_mm_mask_alignr_epi8\">_mm_mask_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_alignr_epi32.html\" title=\"fn core::arch::x86::_mm_mask_alignr_epi32\">_mm_mask_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_alignr_epi64.html\" title=\"fn core::arch::x86::_mm_mask_alignr_epi64\">_mm_mask_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_and_epi32.html\" title=\"fn core::arch::x86::_mm_mask_and_epi32\">_mm_mask_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_and_epi64.html\" title=\"fn core::arch::x86::_mm_mask_and_epi64\">_mm_mask_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_andnot_epi32.html\" title=\"fn core::arch::x86::_mm_mask_andnot_epi32\">_mm_mask_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_andnot_epi64.html\" title=\"fn core::arch::x86::_mm_mask_andnot_epi64\">_mm_mask_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_avg_epu8.html\" title=\"fn core::arch::x86::_mm_mask_avg_epu8\">_mm_mask_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_avg_epu16.html\" title=\"fn core::arch::x86::_mm_mask_avg_epu16\">_mm_mask_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_bitshuffle_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_bitshuffle_epi64_mask\">_mm_mask_bitshuffle_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.\nThen groups 8 8-bit values from <code>c</code>as indices into the bits of the corresponding 64-bit integer.\nIt then selects these bits and packs them into the output.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_blend_epi8.html\" title=\"fn core::arch::x86::_mm_mask_blend_epi8\">_mm_mask_blend_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_blend_epi16.html\" title=\"fn core::arch::x86::_mm_mask_blend_epi16\">_mm_mask_blend_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_blend_epi32.html\" title=\"fn core::arch::x86::_mm_mask_blend_epi32\">_mm_mask_blend_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_blend_epi64.html\" title=\"fn core::arch::x86::_mm_mask_blend_epi64\">_mm_mask_blend_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_blend_pd.html\" title=\"fn core::arch::x86::_mm_mask_blend_pd\">_mm_mask_blend_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_blend_ps.html\" title=\"fn core::arch::x86::_mm_mask_blend_ps\">_mm_mask_blend_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm_mask_broadcastb_epi8\">_mm_mask_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm_mask_broadcastd_epi32\">_mm_mask_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm_mask_broadcastq_epi64\">_mm_mask_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm_mask_broadcastss_ps\">_mm_mask_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm_mask_broadcastw_epi16\">_mm_mask_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epi8_mask\">_mm_mask_cmp_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epi16_mask\">_mm_mask_cmp_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epi32_mask\">_mm_mask_cmp_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epi64_mask\">_mm_mask_cmp_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epu8_mask\">_mm_mask_cmp_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epu16_mask\">_mm_mask_cmp_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epu32_mask\">_mm_mask_cmp_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_epu64_mask\">_mm_mask_cmp_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_pd_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_pd_mask\">_mm_mask_cmp_pd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_ps_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_ps_mask\">_mm_mask_cmp_ps_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_round_sd_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_round_sd_mask\">_mm_mask_cmp_round_sd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_round_ss_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_round_ss_mask\">_mm_mask_cmp_round_ss_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not seti).<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_sd_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_sd_mask\">_mm_mask_cmp_sd_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmp_ss_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmp_ss_mask\">_mm_mask_cmp_ss_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epi8_mask\">_mm_mask_cmpeq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epi16_mask\">_mm_mask_cmpeq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epi32_mask\">_mm_mask_cmpeq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epi64_mask\">_mm_mask_cmpeq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epu8_mask\">_mm_mask_cmpeq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epu16_mask\">_mm_mask_cmpeq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epu32_mask\">_mm_mask_cmpeq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpeq_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpeq_epu64_mask\">_mm_mask_cmpeq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epi8_mask\">_mm_mask_cmpge_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epi16_mask\">_mm_mask_cmpge_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epi32_mask\">_mm_mask_cmpge_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epi64_mask\">_mm_mask_cmpge_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epu8_mask\">_mm_mask_cmpge_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epu16_mask\">_mm_mask_cmpge_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epu32_mask\">_mm_mask_cmpge_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpge_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpge_epu64_mask\">_mm_mask_cmpge_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epi8_mask\">_mm_mask_cmpgt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epi16_mask\">_mm_mask_cmpgt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epi32_mask\">_mm_mask_cmpgt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epi64_mask\">_mm_mask_cmpgt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epu8_mask\">_mm_mask_cmpgt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epu16_mask\">_mm_mask_cmpgt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epu32_mask\">_mm_mask_cmpgt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpgt_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpgt_epu64_mask\">_mm_mask_cmpgt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epi8_mask\">_mm_mask_cmple_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epi16_mask\">_mm_mask_cmple_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epi32_mask\">_mm_mask_cmple_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epi64_mask\">_mm_mask_cmple_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epu8_mask\">_mm_mask_cmple_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epu16_mask\">_mm_mask_cmple_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epu32_mask\">_mm_mask_cmple_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmple_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmple_epu64_mask\">_mm_mask_cmple_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epi8_mask\">_mm_mask_cmplt_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epi16_mask\">_mm_mask_cmplt_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epi32_mask\">_mm_mask_cmplt_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epi64_mask\">_mm_mask_cmplt_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epu8_mask\">_mm_mask_cmplt_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epu16_mask\">_mm_mask_cmplt_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epu32_mask\">_mm_mask_cmplt_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmplt_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmplt_epu64_mask\">_mm_mask_cmplt_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epi8_mask\">_mm_mask_cmpneq_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epi16_mask\">_mm_mask_cmpneq_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epi32_mask\">_mm_mask_cmpneq_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epi64_mask\">_mm_mask_cmpneq_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epu8_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epu8_mask\">_mm_mask_cmpneq_epu8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epu16_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epu16_mask\">_mm_mask_cmpneq_epu16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epu32_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epu32_mask\">_mm_mask_cmpneq_epu32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cmpneq_epu64_mask.html\" title=\"fn core::arch::x86::_mm_mask_cmpneq_epu64_mask\">_mm_mask_cmpneq_epu64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compress_epi8.html\" title=\"fn core::arch::x86::_mm_mask_compress_epi8\">_mm_mask_compress_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compress_epi16.html\" title=\"fn core::arch::x86::_mm_mask_compress_epi16\">_mm_mask_compress_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compress_epi32.html\" title=\"fn core::arch::x86::_mm_mask_compress_epi32\">_mm_mask_compress_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compress_epi64.html\" title=\"fn core::arch::x86::_mm_mask_compress_epi64\">_mm_mask_compress_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compress_pd.html\" title=\"fn core::arch::x86::_mm_mask_compress_pd\">_mm_mask_compress_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compress_ps.html\" title=\"fn core::arch::x86::_mm_mask_compress_ps\">_mm_mask_compress_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compressstoreu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_compressstoreu_epi8\">_mm_mask_compressstoreu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compressstoreu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_compressstoreu_epi16\">_mm_mask_compressstoreu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compressstoreu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_compressstoreu_epi32\">_mm_mask_compressstoreu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compressstoreu_epi64.html\" title=\"fn core::arch::x86::_mm_mask_compressstoreu_epi64\">_mm_mask_compressstoreu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compressstoreu_pd.html\" title=\"fn core::arch::x86::_mm_mask_compressstoreu_pd\">_mm_mask_compressstoreu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_compressstoreu_ps.html\" title=\"fn core::arch::x86::_mm_mask_compressstoreu_ps\">_mm_mask_compressstoreu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_conflict_epi32.html\" title=\"fn core::arch::x86::_mm_mask_conflict_epi32\">_mm_mask_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_conflict_epi64.html\" title=\"fn core::arch::x86::_mm_mask_conflict_epi64\">_mm_mask_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm_mask_cvt_roundps_ph\">_mm_mask_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvt_roundsd_ss.html\" title=\"fn core::arch::x86::_mm_mask_cvt_roundsd_ss\">_mm_mask_cvt_roundsd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvt_roundss_sd.html\" title=\"fn core::arch::x86::_mm_mask_cvt_roundss_sd\">_mm_mask_cvt_roundss_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi8_epi16\">_mm_mask_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi8_epi32\">_mm_mask_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi8_epi64\">_mm_mask_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi16_epi8\">_mm_mask_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi16_epi32\">_mm_mask_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi16_epi64\">_mm_mask_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi16_storeu_epi8\">_mm_mask_cvtepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_epi8\">_mm_mask_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_epi16\">_mm_mask_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_epi64\">_mm_mask_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_pd\">_mm_mask_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_ps\">_mm_mask_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_storeu_epi8\">_mm_mask_cvtepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi32_storeu_epi16\">_mm_mask_cvtepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi64_epi8\">_mm_mask_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi64_epi16\">_mm_mask_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi64_epi32\">_mm_mask_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi64_storeu_epi8\">_mm_mask_cvtepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi64_storeu_epi16\">_mm_mask_cvtepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtepi64_storeu_epi32\">_mm_mask_cvtepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu8_epi16\">_mm_mask_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu8_epi32\">_mm_mask_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu8_epi64\">_mm_mask_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu16_epi32\">_mm_mask_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu16_epi64\">_mm_mask_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu32_epi64\">_mm_mask_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm_mask_cvtepu32_pd\">_mm_mask_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm_mask_cvtne2ps_pbh\">_mm_mask_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results\nin single vector dst using writemask k (elements are copied from src when the\ncorresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&amp;avx512techs=AVX512_BF16&amp;text=_mm_mask_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtpd_epi32\">_mm_mask_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm_mask_cvtpd_epu32\">_mm_mask_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm_mask_cvtpd_ps\">_mm_mask_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtph_ps.html\" title=\"fn core::arch::x86::_mm_mask_cvtph_ps\">_mm_mask_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtps_epi32\">_mm_mask_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm_mask_cvtps_epu32\">_mm_mask_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtps_ph.html\" title=\"fn core::arch::x86::_mm_mask_cvtps_ph\">_mm_mask_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsd_ss.html\" title=\"fn core::arch::x86::_mm_mask_cvtsd_ss\">_mm_mask_cvtsd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi16_epi8\">_mm_mask_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi16_storeu_epi8\">_mm_mask_cvtsepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi32_epi8\">_mm_mask_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi32_epi16\">_mm_mask_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi32_storeu_epi8\">_mm_mask_cvtsepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi32_storeu_epi16\">_mm_mask_cvtsepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi64_epi8\">_mm_mask_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi64_epi16\">_mm_mask_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi64_epi32\">_mm_mask_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi64_storeu_epi8\">_mm_mask_cvtsepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi64_storeu_epi16\">_mm_mask_cvtsepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtsepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtsepi64_storeu_epi32\">_mm_mask_cvtsepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtss_sd.html\" title=\"fn core::arch::x86::_mm_mask_cvtss_sd\">_mm_mask_cvtss_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvttpd_epi32\">_mm_mask_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm_mask_cvttpd_epu32\">_mm_mask_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvttps_epi32\">_mm_mask_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm_mask_cvttps_epu32\">_mm_mask_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi16_epi8\">_mm_mask_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi16_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi16_storeu_epi8\">_mm_mask_cvtusepi16_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi32_epi8\">_mm_mask_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi32_epi16\">_mm_mask_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi32_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi32_storeu_epi8\">_mm_mask_cvtusepi32_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi32_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi32_storeu_epi16\">_mm_mask_cvtusepi32_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi64_epi8\">_mm_mask_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi64_epi16\">_mm_mask_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi64_epi32\">_mm_mask_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi64_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi64_storeu_epi8\">_mm_mask_cvtusepi64_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi64_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi64_storeu_epi16\">_mm_mask_cvtusepi64_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_cvtusepi64_storeu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_cvtusepi64_storeu_epi32\">_mm_mask_cvtusepi64_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm_mask_dbsad_epu8\">_mm_mask_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_div_pd.html\" title=\"fn core::arch::x86::_mm_mask_div_pd\">_mm_mask_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_div_ps.html\" title=\"fn core::arch::x86::_mm_mask_div_ps\">_mm_mask_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_div_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_div_round_sd\">_mm_mask_div_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_div_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_div_round_ss\">_mm_mask_div_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_div_sd.html\" title=\"fn core::arch::x86::_mm_mask_div_sd\">_mm_mask_div_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_div_ss.html\" title=\"fn core::arch::x86::_mm_mask_div_ss\">_mm_mask_div_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm_mask_dpbf16_ps\">_mm_mask_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm_mask_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm_mask_dpbusd_epi32\">_mm_mask_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm_mask_dpbusds_epi32\">_mm_mask_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm_mask_dpwssd_epi32\">_mm_mask_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm_mask_dpwssds_epi32\">_mm_mask_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expand_epi8.html\" title=\"fn core::arch::x86::_mm_mask_expand_epi8\">_mm_mask_expand_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expand_epi16.html\" title=\"fn core::arch::x86::_mm_mask_expand_epi16\">_mm_mask_expand_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expand_epi32.html\" title=\"fn core::arch::x86::_mm_mask_expand_epi32\">_mm_mask_expand_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expand_epi64.html\" title=\"fn core::arch::x86::_mm_mask_expand_epi64\">_mm_mask_expand_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expand_pd.html\" title=\"fn core::arch::x86::_mm_mask_expand_pd\">_mm_mask_expand_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expand_ps.html\" title=\"fn core::arch::x86::_mm_mask_expand_ps\">_mm_mask_expand_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expandloadu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_expandloadu_epi8\">_mm_mask_expandloadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expandloadu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_expandloadu_epi16\">_mm_mask_expandloadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expandloadu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_expandloadu_epi32\">_mm_mask_expandloadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expandloadu_epi64.html\" title=\"fn core::arch::x86::_mm_mask_expandloadu_epi64\">_mm_mask_expandloadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expandloadu_pd.html\" title=\"fn core::arch::x86::_mm_mask_expandloadu_pd\">_mm_mask_expandloadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_expandloadu_ps.html\" title=\"fn core::arch::x86::_mm_mask_expandloadu_ps\">_mm_mask_expandloadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm_mask_fixupimm_pd\">_mm_mask_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm_mask_fixupimm_ps\">_mm_mask_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fixupimm_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_fixupimm_round_sd\">_mm_mask_fixupimm_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fixupimm_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_fixupimm_round_ss\">_mm_mask_fixupimm_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fixupimm_sd.html\" title=\"fn core::arch::x86::_mm_mask_fixupimm_sd\">_mm_mask_fixupimm_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fixupimm_ss.html\" title=\"fn core::arch::x86::_mm_mask_fixupimm_ss\">_mm_mask_fixupimm_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmadd_pd.html\" title=\"fn core::arch::x86::_mm_mask_fmadd_pd\">_mm_mask_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmadd_ps.html\" title=\"fn core::arch::x86::_mm_mask_fmadd_ps\">_mm_mask_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_fmadd_round_sd\">_mm_mask_fmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_fmadd_round_ss\">_mm_mask_fmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmadd_sd.html\" title=\"fn core::arch::x86::_mm_mask_fmadd_sd\">_mm_mask_fmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmadd_ss.html\" title=\"fn core::arch::x86::_mm_mask_fmadd_ss\">_mm_mask_fmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm_mask_fmaddsub_pd\">_mm_mask_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm_mask_fmaddsub_ps\">_mm_mask_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsub_pd.html\" title=\"fn core::arch::x86::_mm_mask_fmsub_pd\">_mm_mask_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsub_ps.html\" title=\"fn core::arch::x86::_mm_mask_fmsub_ps\">_mm_mask_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_fmsub_round_sd\">_mm_mask_fmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_fmsub_round_ss\">_mm_mask_fmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsub_sd.html\" title=\"fn core::arch::x86::_mm_mask_fmsub_sd\">_mm_mask_fmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsub_ss.html\" title=\"fn core::arch::x86::_mm_mask_fmsub_ss\">_mm_mask_fmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm_mask_fmsubadd_pd\">_mm_mask_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm_mask_fmsubadd_ps\">_mm_mask_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm_mask_fnmadd_pd\">_mm_mask_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm_mask_fnmadd_ps\">_mm_mask_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_fnmadd_round_sd\">_mm_mask_fnmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_fnmadd_round_ss\">_mm_mask_fnmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmadd_sd.html\" title=\"fn core::arch::x86::_mm_mask_fnmadd_sd\">_mm_mask_fnmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmadd_ss.html\" title=\"fn core::arch::x86::_mm_mask_fnmadd_ss\">_mm_mask_fnmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm_mask_fnmsub_pd\">_mm_mask_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm_mask_fnmsub_ps\">_mm_mask_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_fnmsub_round_sd\">_mm_mask_fnmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_fnmsub_round_ss\">_mm_mask_fnmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmsub_sd.html\" title=\"fn core::arch::x86::_mm_mask_fnmsub_sd\">_mm_mask_fnmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_fnmsub_ss.html\" title=\"fn core::arch::x86::_mm_mask_fnmsub_ss\">_mm_mask_fnmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getexp_pd.html\" title=\"fn core::arch::x86::_mm_mask_getexp_pd\">_mm_mask_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getexp_ps.html\" title=\"fn core::arch::x86::_mm_mask_getexp_ps\">_mm_mask_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getexp_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_getexp_round_sd\">_mm_mask_getexp_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getexp_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_getexp_round_ss\">_mm_mask_getexp_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getexp_sd.html\" title=\"fn core::arch::x86::_mm_mask_getexp_sd\">_mm_mask_getexp_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getexp_ss.html\" title=\"fn core::arch::x86::_mm_mask_getexp_ss\">_mm_mask_getexp_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getmant_pd.html\" title=\"fn core::arch::x86::_mm_mask_getmant_pd\">_mm_mask_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getmant_ps.html\" title=\"fn core::arch::x86::_mm_mask_getmant_ps\">_mm_mask_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getmant_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_getmant_round_sd\">_mm_mask_getmant_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getmant_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_getmant_round_ss\">_mm_mask_getmant_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getmant_sd.html\" title=\"fn core::arch::x86::_mm_mask_getmant_sd\">_mm_mask_getmant_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_getmant_ss.html\" title=\"fn core::arch::x86::_mm_mask_getmant_ss\">_mm_mask_getmant_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_mask_gf2p8affine_epi64_epi8\">_mm_mask_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_mask_gf2p8affineinv_epi64_epi8\">_mm_mask_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm_mask_gf2p8mul_epi8\">_mm_mask_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_load_epi32.html\" title=\"fn core::arch::x86::_mm_mask_load_epi32\">_mm_mask_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_load_epi64.html\" title=\"fn core::arch::x86::_mm_mask_load_epi64\">_mm_mask_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_load_pd.html\" title=\"fn core::arch::x86::_mm_mask_load_pd\">_mm_mask_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_load_ps.html\" title=\"fn core::arch::x86::_mm_mask_load_ps\">_mm_mask_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_loadu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_loadu_epi8\">_mm_mask_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 8-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_loadu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_loadu_epi16\">_mm_mask_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 16-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_loadu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_loadu_epi32\">_mm_mask_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_loadu_epi64.html\" title=\"fn core::arch::x86::_mm_mask_loadu_epi64\">_mm_mask_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_loadu_pd.html\" title=\"fn core::arch::x86::_mm_mask_loadu_pd\">_mm_mask_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_loadu_ps.html\" title=\"fn core::arch::x86::_mm_mask_loadu_ps\">_mm_mask_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k\n(elements are copied from src when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm_mask_lzcnt_epi32\">_mm_mask_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm_mask_lzcnt_epi64\">_mm_mask_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_madd_epi16.html\" title=\"fn core::arch::x86::_mm_mask_madd_epi16\">_mm_mask_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm_mask_maddubs_epi16\">_mm_mask_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epi8.html\" title=\"fn core::arch::x86::_mm_mask_max_epi8\">_mm_mask_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epi16.html\" title=\"fn core::arch::x86::_mm_mask_max_epi16\">_mm_mask_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epi32.html\" title=\"fn core::arch::x86::_mm_mask_max_epi32\">_mm_mask_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epi64.html\" title=\"fn core::arch::x86::_mm_mask_max_epi64\">_mm_mask_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epu8.html\" title=\"fn core::arch::x86::_mm_mask_max_epu8\">_mm_mask_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epu16.html\" title=\"fn core::arch::x86::_mm_mask_max_epu16\">_mm_mask_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epu32.html\" title=\"fn core::arch::x86::_mm_mask_max_epu32\">_mm_mask_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_epu64.html\" title=\"fn core::arch::x86::_mm_mask_max_epu64\">_mm_mask_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_pd.html\" title=\"fn core::arch::x86::_mm_mask_max_pd\">_mm_mask_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_ps.html\" title=\"fn core::arch::x86::_mm_mask_max_ps\">_mm_mask_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_max_round_sd\">_mm_mask_max_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_max_round_ss\">_mm_mask_max_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_sd.html\" title=\"fn core::arch::x86::_mm_mask_max_sd\">_mm_mask_max_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_max_ss.html\" title=\"fn core::arch::x86::_mm_mask_max_ss\">_mm_mask_max_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epi8.html\" title=\"fn core::arch::x86::_mm_mask_min_epi8\">_mm_mask_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epi16.html\" title=\"fn core::arch::x86::_mm_mask_min_epi16\">_mm_mask_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epi32.html\" title=\"fn core::arch::x86::_mm_mask_min_epi32\">_mm_mask_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epu8.html\" title=\"fn core::arch::x86::_mm_mask_min_epu8\">_mm_mask_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epu16.html\" title=\"fn core::arch::x86::_mm_mask_min_epu16\">_mm_mask_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epu32.html\" title=\"fn core::arch::x86::_mm_mask_min_epu32\">_mm_mask_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_epu64.html\" title=\"fn core::arch::x86::_mm_mask_min_epu64\">_mm_mask_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_pd.html\" title=\"fn core::arch::x86::_mm_mask_min_pd\">_mm_mask_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_ps.html\" title=\"fn core::arch::x86::_mm_mask_min_ps\">_mm_mask_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_min_round_sd\">_mm_mask_min_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_min_round_ss\">_mm_mask_min_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_sd.html\" title=\"fn core::arch::x86::_mm_mask_min_sd\">_mm_mask_min_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_min_ss.html\" title=\"fn core::arch::x86::_mm_mask_min_ss\">_mm_mask_min_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mov_epi8.html\" title=\"fn core::arch::x86::_mm_mask_mov_epi8\">_mm_mask_mov_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mov_epi16.html\" title=\"fn core::arch::x86::_mm_mask_mov_epi16\">_mm_mask_mov_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mov_epi32.html\" title=\"fn core::arch::x86::_mm_mask_mov_epi32\">_mm_mask_mov_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mov_epi64.html\" title=\"fn core::arch::x86::_mm_mask_mov_epi64\">_mm_mask_mov_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mov_pd.html\" title=\"fn core::arch::x86::_mm_mask_mov_pd\">_mm_mask_mov_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mov_ps.html\" title=\"fn core::arch::x86::_mm_mask_mov_ps\">_mm_mask_mov_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_move_sd.html\" title=\"fn core::arch::x86::_mm_mask_move_sd\">_mm_mask_move_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_move_ss.html\" title=\"fn core::arch::x86::_mm_mask_move_ss\">_mm_mask_move_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_movedup_pd.html\" title=\"fn core::arch::x86::_mm_mask_movedup_pd\">_mm_mask_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_movehdup_ps.html\" title=\"fn core::arch::x86::_mm_mask_movehdup_ps\">_mm_mask_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_moveldup_ps.html\" title=\"fn core::arch::x86::_mm_mask_moveldup_ps\">_mm_mask_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_epi32.html\" title=\"fn core::arch::x86::_mm_mask_mul_epi32\">_mm_mask_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_epu32.html\" title=\"fn core::arch::x86::_mm_mask_mul_epu32\">_mm_mask_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_pd.html\" title=\"fn core::arch::x86::_mm_mask_mul_pd\">_mm_mask_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_ps.html\" title=\"fn core::arch::x86::_mm_mask_mul_ps\">_mm_mask_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_mul_round_sd\">_mm_mask_mul_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_mul_round_ss\">_mm_mask_mul_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_sd.html\" title=\"fn core::arch::x86::_mm_mask_mul_sd\">_mm_mask_mul_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mul_ss.html\" title=\"fn core::arch::x86::_mm_mask_mul_ss\">_mm_mask_mul_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm_mask_mulhi_epi16\">_mm_mask_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm_mask_mulhi_epu16\">_mm_mask_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm_mask_mulhrs_epi16\">_mm_mask_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mullo_epi16.html\" title=\"fn core::arch::x86::_mm_mask_mullo_epi16\">_mm_mask_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_mullo_epi32.html\" title=\"fn core::arch::x86::_mm_mask_mullo_epi32\">_mm_mask_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_mask_multishift_epi64_epi8\">_mm_mask_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_or_epi32.html\" title=\"fn core::arch::x86::_mm_mask_or_epi32\">_mm_mask_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_or_epi64.html\" title=\"fn core::arch::x86::_mm_mask_or_epi64\">_mm_mask_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_packs_epi16.html\" title=\"fn core::arch::x86::_mm_mask_packs_epi16\">_mm_mask_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_packs_epi32.html\" title=\"fn core::arch::x86::_mm_mask_packs_epi32\">_mm_mask_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_packus_epi16.html\" title=\"fn core::arch::x86::_mm_mask_packus_epi16\">_mm_mask_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_packus_epi32.html\" title=\"fn core::arch::x86::_mm_mask_packus_epi32\">_mm_mask_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permute_pd.html\" title=\"fn core::arch::x86::_mm_mask_permute_pd\">_mm_mask_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permute_ps.html\" title=\"fn core::arch::x86::_mm_mask_permute_ps\">_mm_mask_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutevar_pd.html\" title=\"fn core::arch::x86::_mm_mask_permutevar_pd\">_mm_mask_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutevar_ps.html\" title=\"fn core::arch::x86::_mm_mask_permutevar_ps\">_mm_mask_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm_mask_permutex2var_epi8\">_mm_mask_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm_mask_permutex2var_epi16\">_mm_mask_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm_mask_permutex2var_epi32\">_mm_mask_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm_mask_permutex2var_epi64\">_mm_mask_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm_mask_permutex2var_pd\">_mm_mask_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm_mask_permutex2var_ps\">_mm_mask_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm_mask_permutexvar_epi8\">_mm_mask_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm_mask_permutexvar_epi16\">_mm_mask_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm_mask_popcnt_epi8\">_mm_mask_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm_mask_popcnt_epi16\">_mm_mask_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm_mask_popcnt_epi32\">_mm_mask_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm_mask_popcnt_epi64\">_mm_mask_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rcp14_pd.html\" title=\"fn core::arch::x86::_mm_mask_rcp14_pd\">_mm_mask_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rcp14_ps.html\" title=\"fn core::arch::x86::_mm_mask_rcp14_ps\">_mm_mask_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rcp14_sd.html\" title=\"fn core::arch::x86::_mm_mask_rcp14_sd\">_mm_mask_rcp14_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rcp14_ss.html\" title=\"fn core::arch::x86::_mm_mask_rcp14_ss\">_mm_mask_rcp14_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rol_epi32.html\" title=\"fn core::arch::x86::_mm_mask_rol_epi32\">_mm_mask_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rol_epi64.html\" title=\"fn core::arch::x86::_mm_mask_rol_epi64\">_mm_mask_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rolv_epi32.html\" title=\"fn core::arch::x86::_mm_mask_rolv_epi32\">_mm_mask_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rolv_epi64.html\" title=\"fn core::arch::x86::_mm_mask_rolv_epi64\">_mm_mask_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_ror_epi32.html\" title=\"fn core::arch::x86::_mm_mask_ror_epi32\">_mm_mask_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_ror_epi64.html\" title=\"fn core::arch::x86::_mm_mask_ror_epi64\">_mm_mask_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rorv_epi32.html\" title=\"fn core::arch::x86::_mm_mask_rorv_epi32\">_mm_mask_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rorv_epi64.html\" title=\"fn core::arch::x86::_mm_mask_rorv_epi64\">_mm_mask_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_roundscale_pd.html\" title=\"fn core::arch::x86::_mm_mask_roundscale_pd\">_mm_mask_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_roundscale_ps.html\" title=\"fn core::arch::x86::_mm_mask_roundscale_ps\">_mm_mask_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_roundscale_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_roundscale_round_sd\">_mm_mask_roundscale_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_roundscale_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_roundscale_round_ss\">_mm_mask_roundscale_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_roundscale_sd.html\" title=\"fn core::arch::x86::_mm_mask_roundscale_sd\">_mm_mask_roundscale_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_roundscale_ss.html\" title=\"fn core::arch::x86::_mm_mask_roundscale_ss\">_mm_mask_roundscale_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm_mask_rsqrt14_pd\">_mm_mask_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm_mask_rsqrt14_ps\">_mm_mask_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rsqrt14_sd.html\" title=\"fn core::arch::x86::_mm_mask_rsqrt14_sd\">_mm_mask_rsqrt14_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_rsqrt14_ss.html\" title=\"fn core::arch::x86::_mm_mask_rsqrt14_ss\">_mm_mask_rsqrt14_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_scalef_pd.html\" title=\"fn core::arch::x86::_mm_mask_scalef_pd\">_mm_mask_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_scalef_ps.html\" title=\"fn core::arch::x86::_mm_mask_scalef_ps\">_mm_mask_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_scalef_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_scalef_round_sd\">_mm_mask_scalef_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_scalef_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_scalef_round_ss\">_mm_mask_scalef_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_scalef_sd.html\" title=\"fn core::arch::x86::_mm_mask_scalef_sd\">_mm_mask_scalef_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_scalef_ss.html\" title=\"fn core::arch::x86::_mm_mask_scalef_ss\">_mm_mask_scalef_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_set1_epi8.html\" title=\"fn core::arch::x86::_mm_mask_set1_epi8\">_mm_mask_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_set1_epi16.html\" title=\"fn core::arch::x86::_mm_mask_set1_epi16\">_mm_mask_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_set1_epi32.html\" title=\"fn core::arch::x86::_mm_mask_set1_epi32\">_mm_mask_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_set1_epi64.html\" title=\"fn core::arch::x86::_mm_mask_set1_epi64\">_mm_mask_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shldi_epi16.html\" title=\"fn core::arch::x86::_mm_mask_shldi_epi16\">_mm_mask_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shldi_epi32.html\" title=\"fn core::arch::x86::_mm_mask_shldi_epi32\">_mm_mask_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shldi_epi64.html\" title=\"fn core::arch::x86::_mm_mask_shldi_epi64\">_mm_mask_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shldv_epi16.html\" title=\"fn core::arch::x86::_mm_mask_shldv_epi16\">_mm_mask_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shldv_epi32.html\" title=\"fn core::arch::x86::_mm_mask_shldv_epi32\">_mm_mask_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shldv_epi64.html\" title=\"fn core::arch::x86::_mm_mask_shldv_epi64\">_mm_mask_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm_mask_shrdi_epi16\">_mm_mask_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm_mask_shrdi_epi32\">_mm_mask_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm_mask_shrdi_epi64\">_mm_mask_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm_mask_shrdv_epi16\">_mm_mask_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm_mask_shrdv_epi32\">_mm_mask_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm_mask_shrdv_epi64\">_mm_mask_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm_mask_shuffle_epi8\">_mm_mask_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm_mask_shuffle_epi32\">_mm_mask_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shuffle_pd.html\" title=\"fn core::arch::x86::_mm_mask_shuffle_pd\">_mm_mask_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shuffle_ps.html\" title=\"fn core::arch::x86::_mm_mask_shuffle_ps\">_mm_mask_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm_mask_shufflehi_epi16\">_mm_mask_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm_mask_shufflelo_epi16\">_mm_mask_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sll_epi16.html\" title=\"fn core::arch::x86::_mm_mask_sll_epi16\">_mm_mask_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sll_epi32.html\" title=\"fn core::arch::x86::_mm_mask_sll_epi32\">_mm_mask_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sll_epi64.html\" title=\"fn core::arch::x86::_mm_mask_sll_epi64\">_mm_mask_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_slli_epi16.html\" title=\"fn core::arch::x86::_mm_mask_slli_epi16\">_mm_mask_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_slli_epi32.html\" title=\"fn core::arch::x86::_mm_mask_slli_epi32\">_mm_mask_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_slli_epi64.html\" title=\"fn core::arch::x86::_mm_mask_slli_epi64\">_mm_mask_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sllv_epi16.html\" title=\"fn core::arch::x86::_mm_mask_sllv_epi16\">_mm_mask_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sllv_epi32.html\" title=\"fn core::arch::x86::_mm_mask_sllv_epi32\">_mm_mask_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sllv_epi64.html\" title=\"fn core::arch::x86::_mm_mask_sllv_epi64\">_mm_mask_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sqrt_pd.html\" title=\"fn core::arch::x86::_mm_mask_sqrt_pd\">_mm_mask_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sqrt_ps.html\" title=\"fn core::arch::x86::_mm_mask_sqrt_ps\">_mm_mask_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sqrt_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_sqrt_round_sd\">_mm_mask_sqrt_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sqrt_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_sqrt_round_ss\">_mm_mask_sqrt_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sqrt_sd.html\" title=\"fn core::arch::x86::_mm_mask_sqrt_sd\">_mm_mask_sqrt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sqrt_ss.html\" title=\"fn core::arch::x86::_mm_mask_sqrt_ss\">_mm_mask_sqrt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sra_epi16.html\" title=\"fn core::arch::x86::_mm_mask_sra_epi16\">_mm_mask_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sra_epi32.html\" title=\"fn core::arch::x86::_mm_mask_sra_epi32\">_mm_mask_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sra_epi64.html\" title=\"fn core::arch::x86::_mm_mask_sra_epi64\">_mm_mask_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srai_epi16.html\" title=\"fn core::arch::x86::_mm_mask_srai_epi16\">_mm_mask_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srai_epi32.html\" title=\"fn core::arch::x86::_mm_mask_srai_epi32\">_mm_mask_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srai_epi64.html\" title=\"fn core::arch::x86::_mm_mask_srai_epi64\">_mm_mask_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srav_epi16.html\" title=\"fn core::arch::x86::_mm_mask_srav_epi16\">_mm_mask_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srav_epi32.html\" title=\"fn core::arch::x86::_mm_mask_srav_epi32\">_mm_mask_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srav_epi64.html\" title=\"fn core::arch::x86::_mm_mask_srav_epi64\">_mm_mask_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srl_epi16.html\" title=\"fn core::arch::x86::_mm_mask_srl_epi16\">_mm_mask_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srl_epi32.html\" title=\"fn core::arch::x86::_mm_mask_srl_epi32\">_mm_mask_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srl_epi64.html\" title=\"fn core::arch::x86::_mm_mask_srl_epi64\">_mm_mask_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srli_epi16.html\" title=\"fn core::arch::x86::_mm_mask_srli_epi16\">_mm_mask_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srli_epi32.html\" title=\"fn core::arch::x86::_mm_mask_srli_epi32\">_mm_mask_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srli_epi64.html\" title=\"fn core::arch::x86::_mm_mask_srli_epi64\">_mm_mask_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srlv_epi16.html\" title=\"fn core::arch::x86::_mm_mask_srlv_epi16\">_mm_mask_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srlv_epi32.html\" title=\"fn core::arch::x86::_mm_mask_srlv_epi32\">_mm_mask_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_srlv_epi64.html\" title=\"fn core::arch::x86::_mm_mask_srlv_epi64\">_mm_mask_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_store_epi32.html\" title=\"fn core::arch::x86::_mm_mask_store_epi32\">_mm_mask_store_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed 32-bit integers from a into memory using writemask k.\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_store_epi64.html\" title=\"fn core::arch::x86::_mm_mask_store_epi64\">_mm_mask_store_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed 64-bit integers from a into memory using writemask k.\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_store_pd.html\" title=\"fn core::arch::x86::_mm_mask_store_pd\">_mm_mask_store_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_store_ps.html\" title=\"fn core::arch::x86::_mm_mask_store_ps\">_mm_mask_store_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_mask_storeu_epi8\">_mm_mask_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed 8-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_mask_storeu_epi16\">_mm_mask_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed 16-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_storeu_epi32.html\" title=\"fn core::arch::x86::_mm_mask_storeu_epi32\">_mm_mask_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed 32-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_storeu_epi64.html\" title=\"fn core::arch::x86::_mm_mask_storeu_epi64\">_mm_mask_storeu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed 64-bit integers from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_storeu_pd.html\" title=\"fn core::arch::x86::_mm_mask_storeu_pd\">_mm_mask_storeu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_storeu_ps.html\" title=\"fn core::arch::x86::_mm_mask_storeu_ps\">_mm_mask_storeu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_epi8.html\" title=\"fn core::arch::x86::_mm_mask_sub_epi8\">_mm_mask_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_epi16.html\" title=\"fn core::arch::x86::_mm_mask_sub_epi16\">_mm_mask_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_epi32.html\" title=\"fn core::arch::x86::_mm_mask_sub_epi32\">_mm_mask_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_epi64.html\" title=\"fn core::arch::x86::_mm_mask_sub_epi64\">_mm_mask_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_pd.html\" title=\"fn core::arch::x86::_mm_mask_sub_pd\">_mm_mask_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_ps.html\" title=\"fn core::arch::x86::_mm_mask_sub_ps\">_mm_mask_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_round_sd.html\" title=\"fn core::arch::x86::_mm_mask_sub_round_sd\">_mm_mask_sub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_round_ss.html\" title=\"fn core::arch::x86::_mm_mask_sub_round_ss\">_mm_mask_sub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_sd.html\" title=\"fn core::arch::x86::_mm_mask_sub_sd\">_mm_mask_sub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_sub_ss.html\" title=\"fn core::arch::x86::_mm_mask_sub_ss\">_mm_mask_sub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_subs_epi8.html\" title=\"fn core::arch::x86::_mm_mask_subs_epi8\">_mm_mask_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_subs_epi16.html\" title=\"fn core::arch::x86::_mm_mask_subs_epi16\">_mm_mask_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_subs_epu8.html\" title=\"fn core::arch::x86::_mm_mask_subs_epu8\">_mm_mask_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_subs_epu16.html\" title=\"fn core::arch::x86::_mm_mask_subs_epu16\">_mm_mask_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm_mask_ternarylogic_epi32\">_mm_mask_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm_mask_ternarylogic_epi64\">_mm_mask_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_test_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_test_epi8_mask\">_mm_mask_test_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_test_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_test_epi16_mask\">_mm_mask_test_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_test_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_test_epi32_mask\">_mm_mask_test_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_test_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_test_epi64_mask\">_mm_mask_test_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_testn_epi8_mask.html\" title=\"fn core::arch::x86::_mm_mask_testn_epi8_mask\">_mm_mask_testn_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_testn_epi16_mask.html\" title=\"fn core::arch::x86::_mm_mask_testn_epi16_mask\">_mm_mask_testn_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_testn_epi32_mask.html\" title=\"fn core::arch::x86::_mm_mask_testn_epi32_mask\">_mm_mask_testn_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_testn_epi64_mask.html\" title=\"fn core::arch::x86::_mm_mask_testn_epi64_mask\">_mm_mask_testn_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm_mask_unpackhi_epi8\">_mm_mask_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm_mask_unpackhi_epi16\">_mm_mask_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm_mask_unpackhi_epi32\">_mm_mask_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm_mask_unpackhi_epi64\">_mm_mask_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm_mask_unpackhi_pd\">_mm_mask_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm_mask_unpackhi_ps\">_mm_mask_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm_mask_unpacklo_epi8\">_mm_mask_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm_mask_unpacklo_epi16\">_mm_mask_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm_mask_unpacklo_epi32\">_mm_mask_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm_mask_unpacklo_epi64\">_mm_mask_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm_mask_unpacklo_pd\">_mm_mask_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm_mask_unpacklo_ps\">_mm_mask_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_xor_epi32.html\" title=\"fn core::arch::x86::_mm_mask_xor_epi32\">_mm_mask_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mask_xor_epi64.html\" title=\"fn core::arch::x86::_mm_mask_xor_epi64\">_mm_mask_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_abs_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_abs_epi8\">_mm_maskz_abs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_abs_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_abs_epi16\">_mm_maskz_abs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_abs_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_abs_epi32\">_mm_maskz_abs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_add_epi8\">_mm_maskz_add_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_add_epi16\">_mm_maskz_add_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_add_epi32\">_mm_maskz_add_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_add_epi64\">_mm_maskz_add_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_pd.html\" title=\"fn core::arch::x86::_mm_maskz_add_pd\">_mm_maskz_add_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_ps.html\" title=\"fn core::arch::x86::_mm_maskz_add_ps\">_mm_maskz_add_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_add_round_sd\">_mm_maskz_add_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_add_round_ss\">_mm_maskz_add_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_sd.html\" title=\"fn core::arch::x86::_mm_maskz_add_sd\">_mm_maskz_add_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_add_ss.html\" title=\"fn core::arch::x86::_mm_maskz_add_ss\">_mm_maskz_add_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_adds_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_adds_epi8\">_mm_maskz_adds_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_adds_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_adds_epi16\">_mm_maskz_adds_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_adds_epu8.html\" title=\"fn core::arch::x86::_mm_maskz_adds_epu8\">_mm_maskz_adds_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_adds_epu16.html\" title=\"fn core::arch::x86::_mm_maskz_adds_epu16\">_mm_maskz_adds_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_alignr_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_alignr_epi8\">_mm_maskz_alignr_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_alignr_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_alignr_epi32\">_mm_maskz_alignr_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_alignr_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_alignr_epi64\">_mm_maskz_alignr_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_and_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_and_epi32\">_mm_maskz_and_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_and_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_and_epi64\">_mm_maskz_and_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_andnot_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_andnot_epi32\">_mm_maskz_andnot_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_andnot_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_andnot_epi64\">_mm_maskz_andnot_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_avg_epu8.html\" title=\"fn core::arch::x86::_mm_maskz_avg_epu8\">_mm_maskz_avg_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_avg_epu16.html\" title=\"fn core::arch::x86::_mm_maskz_avg_epu16\">_mm_maskz_avg_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_broadcastb_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_broadcastb_epi8\">_mm_maskz_broadcastb_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_broadcastd_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_broadcastd_epi32\">_mm_maskz_broadcastd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_broadcastq_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_broadcastq_epi64\">_mm_maskz_broadcastq_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_broadcastss_ps.html\" title=\"fn core::arch::x86::_mm_maskz_broadcastss_ps\">_mm_maskz_broadcastss_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_broadcastw_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_broadcastw_epi16\">_mm_maskz_broadcastw_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_compress_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_compress_epi8\">_mm_maskz_compress_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_compress_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_compress_epi16\">_mm_maskz_compress_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_compress_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_compress_epi32\">_mm_maskz_compress_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_compress_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_compress_epi64\">_mm_maskz_compress_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_compress_pd.html\" title=\"fn core::arch::x86::_mm_maskz_compress_pd\">_mm_maskz_compress_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_compress_ps.html\" title=\"fn core::arch::x86::_mm_maskz_compress_ps\">_mm_maskz_compress_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_conflict_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_conflict_epi32\">_mm_maskz_conflict_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_conflict_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_conflict_epi64\">_mm_maskz_conflict_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvt_roundps_ph.html\" title=\"fn core::arch::x86::_mm_maskz_cvt_roundps_ph\">_mm_maskz_cvt_roundps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvt_roundsd_ss.html\" title=\"fn core::arch::x86::_mm_maskz_cvt_roundsd_ss\">_mm_maskz_cvt_roundsd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the rounding[3:0] parameter, which can be one of:<br>\n(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br>\n(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br>\n(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br>\n(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br>\n_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvt_roundss_sd.html\" title=\"fn core::arch::x86::_mm_maskz_cvt_roundss_sd\">_mm_maskz_cvt_roundss_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi8_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi8_epi16\">_mm_maskz_cvtepi8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi8_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi8_epi32\">_mm_maskz_cvtepi8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi8_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi8_epi64\">_mm_maskz_cvtepi8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi16_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi16_epi8\">_mm_maskz_cvtepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi16_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi16_epi32\">_mm_maskz_cvtepi16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi16_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi16_epi64\">_mm_maskz_cvtepi16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi32_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi32_epi8\">_mm_maskz_cvtepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi32_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi32_epi16\">_mm_maskz_cvtepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi32_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi32_epi64\">_mm_maskz_cvtepi32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi32_pd.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi32_pd\">_mm_maskz_cvtepi32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi32_ps.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi32_ps\">_mm_maskz_cvtepi32_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi64_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi64_epi8\">_mm_maskz_cvtepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi64_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi64_epi16\">_mm_maskz_cvtepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepi64_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepi64_epi32\">_mm_maskz_cvtepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu8_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu8_epi16\">_mm_maskz_cvtepu8_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu8_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu8_epi32\">_mm_maskz_cvtepu8_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in th elow 4 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu8_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu8_epi64\">_mm_maskz_cvtepu8_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu16_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu16_epi32\">_mm_maskz_cvtepu16_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu16_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu16_epi64\">_mm_maskz_cvtepu16_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu32_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu32_epi64\">_mm_maskz_cvtepu32_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtepu32_pd.html\" title=\"fn core::arch::x86::_mm_maskz_cvtepu32_pd\">_mm_maskz_cvtepu32_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtne2ps_pbh.html\" title=\"fn core::arch::x86::_mm_maskz_cvtne2ps_pbh\">_mm_maskz_cvtne2ps_pbh</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in two vectors\na and b to packed BF16 (16-bit) floating-point elements, and store the results\nin single vector dst using zeromask k (elements are zeroed out when the corresponding\nmask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&amp;avx512techs=AVX512_BF16&amp;text=_mm_maskz_cvtne2ps_pbh\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtpd_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtpd_epi32\">_mm_maskz_cvtpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtpd_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtpd_epu32\">_mm_maskz_cvtpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtpd_ps.html\" title=\"fn core::arch::x86::_mm_maskz_cvtpd_ps\">_mm_maskz_cvtpd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtph_ps.html\" title=\"fn core::arch::x86::_mm_maskz_cvtph_ps\">_mm_maskz_cvtph_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtps_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtps_epi32\">_mm_maskz_cvtps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtps_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtps_epu32\">_mm_maskz_cvtps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtps_ph.html\" title=\"fn core::arch::x86::_mm_maskz_cvtps_ph\">_mm_maskz_cvtps_ph</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsd_ss.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsd_ss\">_mm_maskz_cvtsd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsepi16_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsepi16_epi8\">_mm_maskz_cvtsepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsepi32_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsepi32_epi8\">_mm_maskz_cvtsepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsepi32_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsepi32_epi16\">_mm_maskz_cvtsepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsepi64_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsepi64_epi8\">_mm_maskz_cvtsepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsepi64_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsepi64_epi16\">_mm_maskz_cvtsepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtsepi64_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtsepi64_epi32\">_mm_maskz_cvtsepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtss_sd.html\" title=\"fn core::arch::x86::_mm_maskz_cvtss_sd\">_mm_maskz_cvtss_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvttpd_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvttpd_epi32\">_mm_maskz_cvttpd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvttpd_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_cvttpd_epu32\">_mm_maskz_cvttpd_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvttps_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvttps_epi32\">_mm_maskz_cvttps_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvttps_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_cvttps_epu32\">_mm_maskz_cvttps_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtusepi16_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtusepi16_epi8\">_mm_maskz_cvtusepi16_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtusepi32_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtusepi32_epi8\">_mm_maskz_cvtusepi32_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtusepi32_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtusepi32_epi16\">_mm_maskz_cvtusepi32_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtusepi64_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_cvtusepi64_epi8\">_mm_maskz_cvtusepi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtusepi64_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_cvtusepi64_epi16\">_mm_maskz_cvtusepi64_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_cvtusepi64_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_cvtusepi64_epi32\">_mm_maskz_cvtusepi64_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_dbsad_epu8.html\" title=\"fn core::arch::x86::_mm_maskz_dbsad_epu8\">_mm_maskz_dbsad_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_div_pd.html\" title=\"fn core::arch::x86::_mm_maskz_div_pd\">_mm_maskz_div_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_div_ps.html\" title=\"fn core::arch::x86::_mm_maskz_div_ps\">_mm_maskz_div_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_div_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_div_round_sd\">_mm_maskz_div_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_div_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_div_round_ss\">_mm_maskz_div_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_div_sd.html\" title=\"fn core::arch::x86::_mm_maskz_div_sd\">_mm_maskz_div_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_div_ss.html\" title=\"fn core::arch::x86::_mm_maskz_div_ss\">_mm_maskz_div_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_dpbf16_ps.html\" title=\"fn core::arch::x86::_mm_maskz_dpbf16_ps\">_mm_maskz_dpbf16_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only\">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,\naccumulating the intermediate single-precision (32-bit) floating-point elements\nwith elements in src, and store the results in dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\n<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm_maskz_dpbf16_ps\">Intel’s documentation</a></div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_dpbusd_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_dpbusd_epi32\">_mm_maskz_dpbusd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_dpbusds_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_dpbusds_epi32\">_mm_maskz_dpbusds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_dpwssd_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_dpwssd_epi32\">_mm_maskz_dpwssd_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_dpwssds_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_dpwssds_epi32\">_mm_maskz_dpwssds_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only\">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expand_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_expand_epi8\">_mm_maskz_expand_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expand_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_expand_epi16\">_mm_maskz_expand_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expand_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_expand_epi32\">_mm_maskz_expand_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expand_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_expand_epi64\">_mm_maskz_expand_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expand_pd.html\" title=\"fn core::arch::x86::_mm_maskz_expand_pd\">_mm_maskz_expand_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expand_ps.html\" title=\"fn core::arch::x86::_mm_maskz_expand_ps\">_mm_maskz_expand_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expandloadu_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_expandloadu_epi8\">_mm_maskz_expandloadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expandloadu_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_expandloadu_epi16\">_mm_maskz_expandloadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expandloadu_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_expandloadu_epi32\">_mm_maskz_expandloadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expandloadu_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_expandloadu_epi64\">_mm_maskz_expandloadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expandloadu_pd.html\" title=\"fn core::arch::x86::_mm_maskz_expandloadu_pd\">_mm_maskz_expandloadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_expandloadu_ps.html\" title=\"fn core::arch::x86::_mm_maskz_expandloadu_ps\">_mm_maskz_expandloadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fixupimm_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fixupimm_pd\">_mm_maskz_fixupimm_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fixupimm_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fixupimm_ps\">_mm_maskz_fixupimm_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fixupimm_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fixupimm_round_sd\">_mm_maskz_fixupimm_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fixupimm_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fixupimm_round_ss\">_mm_maskz_fixupimm_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fixupimm_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fixupimm_sd\">_mm_maskz_fixupimm_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fixupimm_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fixupimm_ss\">_mm_maskz_fixupimm_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmadd_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fmadd_pd\">_mm_maskz_fmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmadd_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fmadd_ps\">_mm_maskz_fmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fmadd_round_sd\">_mm_maskz_fmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fmadd_round_ss\">_mm_maskz_fmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmadd_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fmadd_sd\">_mm_maskz_fmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmadd_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fmadd_ss\">_mm_maskz_fmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmaddsub_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fmaddsub_pd\">_mm_maskz_fmaddsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmaddsub_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fmaddsub_ps\">_mm_maskz_fmaddsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsub_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fmsub_pd\">_mm_maskz_fmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsub_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fmsub_ps\">_mm_maskz_fmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fmsub_round_sd\">_mm_maskz_fmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fmsub_round_ss\">_mm_maskz_fmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsub_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fmsub_sd\">_mm_maskz_fmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsub_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fmsub_ss\">_mm_maskz_fmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsubadd_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fmsubadd_pd\">_mm_maskz_fmsubadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fmsubadd_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fmsubadd_ps\">_mm_maskz_fmsubadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmadd_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fnmadd_pd\">_mm_maskz_fnmadd_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmadd_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fnmadd_ps\">_mm_maskz_fnmadd_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmadd_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fnmadd_round_sd\">_mm_maskz_fnmadd_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmadd_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fnmadd_round_ss\">_mm_maskz_fnmadd_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmadd_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fnmadd_sd\">_mm_maskz_fnmadd_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmadd_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fnmadd_ss\">_mm_maskz_fnmadd_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmsub_pd.html\" title=\"fn core::arch::x86::_mm_maskz_fnmsub_pd\">_mm_maskz_fnmsub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmsub_ps.html\" title=\"fn core::arch::x86::_mm_maskz_fnmsub_ps\">_mm_maskz_fnmsub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmsub_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fnmsub_round_sd\">_mm_maskz_fnmsub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmsub_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fnmsub_round_ss\">_mm_maskz_fnmsub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmsub_sd.html\" title=\"fn core::arch::x86::_mm_maskz_fnmsub_sd\">_mm_maskz_fnmsub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_fnmsub_ss.html\" title=\"fn core::arch::x86::_mm_maskz_fnmsub_ss\">_mm_maskz_fnmsub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getexp_pd.html\" title=\"fn core::arch::x86::_mm_maskz_getexp_pd\">_mm_maskz_getexp_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getexp_ps.html\" title=\"fn core::arch::x86::_mm_maskz_getexp_ps\">_mm_maskz_getexp_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getexp_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_getexp_round_sd\">_mm_maskz_getexp_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getexp_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_getexp_round_ss\">_mm_maskz_getexp_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getexp_sd.html\" title=\"fn core::arch::x86::_mm_maskz_getexp_sd\">_mm_maskz_getexp_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getexp_ss.html\" title=\"fn core::arch::x86::_mm_maskz_getexp_ss\">_mm_maskz_getexp_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getmant_pd.html\" title=\"fn core::arch::x86::_mm_maskz_getmant_pd\">_mm_maskz_getmant_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getmant_ps.html\" title=\"fn core::arch::x86::_mm_maskz_getmant_ps\">_mm_maskz_getmant_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getmant_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_getmant_round_sd\">_mm_maskz_getmant_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getmant_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_getmant_round_ss\">_mm_maskz_getmant_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getmant_sd.html\" title=\"fn core::arch::x86::_mm_maskz_getmant_sd\">_mm_maskz_getmant_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_getmant_ss.html\" title=\"fn core::arch::x86::_mm_maskz_getmant_ss\">_mm_maskz_getmant_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br>\nThe mantissa is normalized to the interval specified by interv, which can take the following values:<br>\n_MM_MANT_NORM_1_2     // interval [1, 2)<br>\n_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br>\n_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br>\n_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br>\nThe sign is determined by sc which can take the following values:<br>\n_MM_MANT_SIGN_src     // sign = sign(src)<br>\n_MM_MANT_SIGN_zero    // sign = 0<br>\n_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_gf2p8affine_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_gf2p8affine_epi64_epi8\">_mm_maskz_gf2p8affine_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the packed bytes in x.\nThat is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_gf2p8affineinv_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_gf2p8affineinv_epi64_epi8\">_mm_maskz_gf2p8affineinv_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs an affine transformation on the inverted packed bytes in x.\nThat is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix\nand b being a constant 8-bit immediate value.\nThe inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.\nThe inverse of 0 is 0.\nEach pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_gf2p8mul_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_gf2p8mul_epi8\">_mm_maskz_gf2p8mul_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only\">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Performs a multiplication in GF(2^8) on the packed bytes.\nThe field is in polynomial representation with the reduction polynomial\nx^8 + x^4 + x^3 + x + 1.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_load_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_load_epi32\">_mm_maskz_load_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_load_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_load_epi64\">_mm_maskz_load_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_load_pd.html\" title=\"fn core::arch::x86::_mm_maskz_load_pd\">_mm_maskz_load_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_load_ps.html\" title=\"fn core::arch::x86::_mm_maskz_load_ps\">_mm_maskz_load_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_loadu_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_loadu_epi8\">_mm_maskz_loadu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 8-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_loadu_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_loadu_epi16\">_mm_maskz_loadu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 16-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_loadu_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_loadu_epi32\">_mm_maskz_loadu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 32-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_loadu_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_loadu_epi64\">_mm_maskz_loadu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed 64-bit integers from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_loadu_pd.html\" title=\"fn core::arch::x86::_mm_maskz_loadu_pd\">_mm_maskz_loadu_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_loadu_ps.html\" title=\"fn core::arch::x86::_mm_maskz_loadu_ps\">_mm_maskz_loadu_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only\">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class=\"desc docblock-short\">Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k\n(elements are zeroed out when the corresponding mask bit is not set).\nmem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_lzcnt_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_lzcnt_epi32\">_mm_maskz_lzcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_lzcnt_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_lzcnt_epi64\">_mm_maskz_lzcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only\">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class=\"desc docblock-short\">Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_madd_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_madd_epi16\">_mm_maskz_madd_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_maddubs_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_maddubs_epi16\">_mm_maskz_maddubs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_max_epi8\">_mm_maskz_max_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_max_epi16\">_mm_maskz_max_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_max_epi32\">_mm_maskz_max_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_max_epi64\">_mm_maskz_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epu8.html\" title=\"fn core::arch::x86::_mm_maskz_max_epu8\">_mm_maskz_max_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epu16.html\" title=\"fn core::arch::x86::_mm_maskz_max_epu16\">_mm_maskz_max_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_max_epu32\">_mm_maskz_max_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_epu64.html\" title=\"fn core::arch::x86::_mm_maskz_max_epu64\">_mm_maskz_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_pd.html\" title=\"fn core::arch::x86::_mm_maskz_max_pd\">_mm_maskz_max_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_ps.html\" title=\"fn core::arch::x86::_mm_maskz_max_ps\">_mm_maskz_max_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_max_round_sd\">_mm_maskz_max_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_max_round_ss\">_mm_maskz_max_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_sd.html\" title=\"fn core::arch::x86::_mm_maskz_max_sd\">_mm_maskz_max_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_max_ss.html\" title=\"fn core::arch::x86::_mm_maskz_max_ss\">_mm_maskz_max_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_min_epi8\">_mm_maskz_min_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_min_epi16\">_mm_maskz_min_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_min_epi32\">_mm_maskz_min_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epu8.html\" title=\"fn core::arch::x86::_mm_maskz_min_epu8\">_mm_maskz_min_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epu16.html\" title=\"fn core::arch::x86::_mm_maskz_min_epu16\">_mm_maskz_min_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_min_epu32\">_mm_maskz_min_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_epu64.html\" title=\"fn core::arch::x86::_mm_maskz_min_epu64\">_mm_maskz_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_pd.html\" title=\"fn core::arch::x86::_mm_maskz_min_pd\">_mm_maskz_min_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_ps.html\" title=\"fn core::arch::x86::_mm_maskz_min_ps\">_mm_maskz_min_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_min_round_sd\">_mm_maskz_min_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_min_round_ss\">_mm_maskz_min_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_sd.html\" title=\"fn core::arch::x86::_mm_maskz_min_sd\">_mm_maskz_min_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_min_ss.html\" title=\"fn core::arch::x86::_mm_maskz_min_ss\">_mm_maskz_min_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mov_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_mov_epi8\">_mm_maskz_mov_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mov_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_mov_epi16\">_mm_maskz_mov_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mov_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_mov_epi32\">_mm_maskz_mov_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mov_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_mov_epi64\">_mm_maskz_mov_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mov_pd.html\" title=\"fn core::arch::x86::_mm_maskz_mov_pd\">_mm_maskz_mov_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mov_ps.html\" title=\"fn core::arch::x86::_mm_maskz_mov_ps\">_mm_maskz_mov_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_move_sd.html\" title=\"fn core::arch::x86::_mm_maskz_move_sd\">_mm_maskz_move_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_move_ss.html\" title=\"fn core::arch::x86::_mm_maskz_move_ss\">_mm_maskz_move_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_movedup_pd.html\" title=\"fn core::arch::x86::_mm_maskz_movedup_pd\">_mm_maskz_movedup_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_movehdup_ps.html\" title=\"fn core::arch::x86::_mm_maskz_movehdup_ps\">_mm_maskz_movehdup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_moveldup_ps.html\" title=\"fn core::arch::x86::_mm_maskz_moveldup_ps\">_mm_maskz_moveldup_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_mul_epi32\">_mm_maskz_mul_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_epu32.html\" title=\"fn core::arch::x86::_mm_maskz_mul_epu32\">_mm_maskz_mul_epu32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_pd.html\" title=\"fn core::arch::x86::_mm_maskz_mul_pd\">_mm_maskz_mul_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_ps.html\" title=\"fn core::arch::x86::_mm_maskz_mul_ps\">_mm_maskz_mul_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_mul_round_sd\">_mm_maskz_mul_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_mul_round_ss\">_mm_maskz_mul_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_sd.html\" title=\"fn core::arch::x86::_mm_maskz_mul_sd\">_mm_maskz_mul_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mul_ss.html\" title=\"fn core::arch::x86::_mm_maskz_mul_ss\">_mm_maskz_mul_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mulhi_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_mulhi_epi16\">_mm_maskz_mulhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mulhi_epu16.html\" title=\"fn core::arch::x86::_mm_maskz_mulhi_epu16\">_mm_maskz_mulhi_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mulhrs_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_mulhrs_epi16\">_mm_maskz_mulhrs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mullo_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_mullo_epi16\">_mm_maskz_mullo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_mullo_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_mullo_epi32\">_mm_maskz_mullo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_multishift_epi64_epi8\">_mm_maskz_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_or_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_or_epi32\">_mm_maskz_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_or_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_or_epi64\">_mm_maskz_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_packs_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_packs_epi16\">_mm_maskz_packs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_packs_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_packs_epi32\">_mm_maskz_packs_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_packus_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_packus_epi16\">_mm_maskz_packus_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_packus_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_packus_epi32\">_mm_maskz_packus_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permute_pd.html\" title=\"fn core::arch::x86::_mm_maskz_permute_pd\">_mm_maskz_permute_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permute_ps.html\" title=\"fn core::arch::x86::_mm_maskz_permute_ps\">_mm_maskz_permute_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutevar_pd.html\" title=\"fn core::arch::x86::_mm_maskz_permutevar_pd\">_mm_maskz_permutevar_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutevar_ps.html\" title=\"fn core::arch::x86::_mm_maskz_permutevar_ps\">_mm_maskz_permutevar_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_permutex2var_epi8\">_mm_maskz_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_permutex2var_epi16\">_mm_maskz_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_permutex2var_epi32\">_mm_maskz_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_permutex2var_epi64\">_mm_maskz_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm_maskz_permutex2var_pd\">_mm_maskz_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm_maskz_permutex2var_ps\">_mm_maskz_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_permutexvar_epi8\">_mm_maskz_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_permutexvar_epi16\">_mm_maskz_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_popcnt_epi8\">_mm_maskz_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_popcnt_epi16\">_mm_maskz_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_popcnt_epi32\">_mm_maskz_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_popcnt_epi64\">_mm_maskz_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rcp14_pd.html\" title=\"fn core::arch::x86::_mm_maskz_rcp14_pd\">_mm_maskz_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rcp14_ps.html\" title=\"fn core::arch::x86::_mm_maskz_rcp14_ps\">_mm_maskz_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rcp14_sd.html\" title=\"fn core::arch::x86::_mm_maskz_rcp14_sd\">_mm_maskz_rcp14_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rcp14_ss.html\" title=\"fn core::arch::x86::_mm_maskz_rcp14_ss\">_mm_maskz_rcp14_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rol_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_rol_epi32\">_mm_maskz_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rol_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_rol_epi64\">_mm_maskz_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rolv_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_rolv_epi32\">_mm_maskz_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rolv_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_rolv_epi64\">_mm_maskz_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_ror_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_ror_epi32\">_mm_maskz_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_ror_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_ror_epi64\">_mm_maskz_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rorv_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_rorv_epi32\">_mm_maskz_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rorv_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_rorv_epi64\">_mm_maskz_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_roundscale_pd.html\" title=\"fn core::arch::x86::_mm_maskz_roundscale_pd\">_mm_maskz_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_roundscale_ps.html\" title=\"fn core::arch::x86::_mm_maskz_roundscale_ps\">_mm_maskz_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_roundscale_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_roundscale_round_sd\">_mm_maskz_roundscale_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_roundscale_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_roundscale_round_ss\">_mm_maskz_roundscale_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_roundscale_sd.html\" title=\"fn core::arch::x86::_mm_maskz_roundscale_sd\">_mm_maskz_roundscale_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_roundscale_ss.html\" title=\"fn core::arch::x86::_mm_maskz_roundscale_ss\">_mm_maskz_roundscale_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rsqrt14_pd.html\" title=\"fn core::arch::x86::_mm_maskz_rsqrt14_pd\">_mm_maskz_rsqrt14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rsqrt14_ps.html\" title=\"fn core::arch::x86::_mm_maskz_rsqrt14_ps\">_mm_maskz_rsqrt14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rsqrt14_sd.html\" title=\"fn core::arch::x86::_mm_maskz_rsqrt14_sd\">_mm_maskz_rsqrt14_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_rsqrt14_ss.html\" title=\"fn core::arch::x86::_mm_maskz_rsqrt14_ss\">_mm_maskz_rsqrt14_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_scalef_pd.html\" title=\"fn core::arch::x86::_mm_maskz_scalef_pd\">_mm_maskz_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_scalef_ps.html\" title=\"fn core::arch::x86::_mm_maskz_scalef_ps\">_mm_maskz_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_scalef_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_scalef_round_sd\">_mm_maskz_scalef_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_scalef_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_scalef_round_ss\">_mm_maskz_scalef_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_scalef_sd.html\" title=\"fn core::arch::x86::_mm_maskz_scalef_sd\">_mm_maskz_scalef_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_scalef_ss.html\" title=\"fn core::arch::x86::_mm_maskz_scalef_ss\">_mm_maskz_scalef_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_set1_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_set1_epi8\">_mm_maskz_set1_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_set1_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_set1_epi16\">_mm_maskz_set1_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_set1_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_set1_epi32\">_mm_maskz_set1_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_set1_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_set1_epi64\">_mm_maskz_set1_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shldi_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_shldi_epi16\">_mm_maskz_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shldi_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_shldi_epi32\">_mm_maskz_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shldi_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_shldi_epi64\">_mm_maskz_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shldv_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_shldv_epi16\">_mm_maskz_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shldv_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_shldv_epi32\">_mm_maskz_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shldv_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_shldv_epi64\">_mm_maskz_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_shrdi_epi16\">_mm_maskz_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_shrdi_epi32\">_mm_maskz_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_shrdi_epi64\">_mm_maskz_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_shrdv_epi16\">_mm_maskz_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_shrdv_epi32\">_mm_maskz_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_shrdv_epi64\">_mm_maskz_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shuffle_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_shuffle_epi8\">_mm_maskz_shuffle_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shuffle_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_shuffle_epi32\">_mm_maskz_shuffle_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shuffle_pd.html\" title=\"fn core::arch::x86::_mm_maskz_shuffle_pd\">_mm_maskz_shuffle_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shuffle_ps.html\" title=\"fn core::arch::x86::_mm_maskz_shuffle_ps\">_mm_maskz_shuffle_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shufflehi_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_shufflehi_epi16\">_mm_maskz_shufflehi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_shufflelo_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_shufflelo_epi16\">_mm_maskz_shufflelo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sll_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_sll_epi16\">_mm_maskz_sll_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sll_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_sll_epi32\">_mm_maskz_sll_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sll_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_sll_epi64\">_mm_maskz_sll_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_slli_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_slli_epi16\">_mm_maskz_slli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_slli_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_slli_epi32\">_mm_maskz_slli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_slli_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_slli_epi64\">_mm_maskz_slli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sllv_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_sllv_epi16\">_mm_maskz_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sllv_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_sllv_epi32\">_mm_maskz_sllv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sllv_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_sllv_epi64\">_mm_maskz_sllv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sqrt_pd.html\" title=\"fn core::arch::x86::_mm_maskz_sqrt_pd\">_mm_maskz_sqrt_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sqrt_ps.html\" title=\"fn core::arch::x86::_mm_maskz_sqrt_ps\">_mm_maskz_sqrt_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sqrt_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_sqrt_round_sd\">_mm_maskz_sqrt_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sqrt_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_sqrt_round_ss\">_mm_maskz_sqrt_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sqrt_sd.html\" title=\"fn core::arch::x86::_mm_maskz_sqrt_sd\">_mm_maskz_sqrt_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sqrt_ss.html\" title=\"fn core::arch::x86::_mm_maskz_sqrt_ss\">_mm_maskz_sqrt_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sra_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_sra_epi16\">_mm_maskz_sra_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sra_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_sra_epi32\">_mm_maskz_sra_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sra_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_sra_epi64\">_mm_maskz_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srai_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_srai_epi16\">_mm_maskz_srai_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srai_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_srai_epi32\">_mm_maskz_srai_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srai_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_srai_epi64\">_mm_maskz_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srav_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_srav_epi16\">_mm_maskz_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srav_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_srav_epi32\">_mm_maskz_srav_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srav_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_srav_epi64\">_mm_maskz_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srl_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_srl_epi16\">_mm_maskz_srl_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srl_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_srl_epi32\">_mm_maskz_srl_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srl_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_srl_epi64\">_mm_maskz_srl_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srli_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_srli_epi16\">_mm_maskz_srli_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srli_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_srli_epi32\">_mm_maskz_srli_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srli_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_srli_epi64\">_mm_maskz_srli_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srlv_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_srlv_epi16\">_mm_maskz_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srlv_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_srlv_epi32\">_mm_maskz_srlv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_srlv_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_srlv_epi64\">_mm_maskz_srlv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_sub_epi8\">_mm_maskz_sub_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_sub_epi16\">_mm_maskz_sub_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_sub_epi32\">_mm_maskz_sub_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_sub_epi64\">_mm_maskz_sub_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_pd.html\" title=\"fn core::arch::x86::_mm_maskz_sub_pd\">_mm_maskz_sub_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_ps.html\" title=\"fn core::arch::x86::_mm_maskz_sub_ps\">_mm_maskz_sub_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_round_sd.html\" title=\"fn core::arch::x86::_mm_maskz_sub_round_sd\">_mm_maskz_sub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_round_ss.html\" title=\"fn core::arch::x86::_mm_maskz_sub_round_ss\">_mm_maskz_sub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_sd.html\" title=\"fn core::arch::x86::_mm_maskz_sub_sd\">_mm_maskz_sub_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_sub_ss.html\" title=\"fn core::arch::x86::_mm_maskz_sub_ss\">_mm_maskz_sub_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_subs_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_subs_epi8\">_mm_maskz_subs_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_subs_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_subs_epi16\">_mm_maskz_subs_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_subs_epu8.html\" title=\"fn core::arch::x86::_mm_maskz_subs_epu8\">_mm_maskz_subs_epu8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_subs_epu16.html\" title=\"fn core::arch::x86::_mm_maskz_subs_epu16\">_mm_maskz_subs_epu16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_ternarylogic_epi32\">_mm_maskz_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_ternarylogic_epi64\">_mm_maskz_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpackhi_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_unpackhi_epi8\">_mm_maskz_unpackhi_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpackhi_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_unpackhi_epi16\">_mm_maskz_unpackhi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpackhi_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_unpackhi_epi32\">_mm_maskz_unpackhi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpackhi_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_unpackhi_epi64\">_mm_maskz_unpackhi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpackhi_pd.html\" title=\"fn core::arch::x86::_mm_maskz_unpackhi_pd\">_mm_maskz_unpackhi_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpackhi_ps.html\" title=\"fn core::arch::x86::_mm_maskz_unpackhi_ps\">_mm_maskz_unpackhi_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpacklo_epi8.html\" title=\"fn core::arch::x86::_mm_maskz_unpacklo_epi8\">_mm_maskz_unpacklo_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpacklo_epi16.html\" title=\"fn core::arch::x86::_mm_maskz_unpacklo_epi16\">_mm_maskz_unpacklo_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpacklo_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_unpacklo_epi32\">_mm_maskz_unpacklo_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpacklo_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_unpacklo_epi64\">_mm_maskz_unpacklo_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpacklo_pd.html\" title=\"fn core::arch::x86::_mm_maskz_unpacklo_pd\">_mm_maskz_unpacklo_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_unpacklo_ps.html\" title=\"fn core::arch::x86::_mm_maskz_unpacklo_ps\">_mm_maskz_unpacklo_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_xor_epi32.html\" title=\"fn core::arch::x86::_mm_maskz_xor_epi32\">_mm_maskz_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_maskz_xor_epi64.html\" title=\"fn core::arch::x86::_mm_maskz_xor_epi64\">_mm_maskz_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epi64.html\" title=\"fn core::arch::x86::_mm_max_epi64\">_mm_max_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_epu64.html\" title=\"fn core::arch::x86::_mm_max_epu64\">_mm_max_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_round_sd.html\" title=\"fn core::arch::x86::_mm_max_round_sd\">_mm_max_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_max_round_ss.html\" title=\"fn core::arch::x86::_mm_max_round_ss\">_mm_max_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_epu64.html\" title=\"fn core::arch::x86::_mm_min_epu64\">_mm_min_epu64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_round_sd.html\" title=\"fn core::arch::x86::_mm_min_round_sd\">_mm_min_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst , and copy the upper element from a to the upper element of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_min_round_ss.html\" title=\"fn core::arch::x86::_mm_min_round_ss\">_mm_min_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nExceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movepi8_mask.html\" title=\"fn core::arch::x86::_mm_movepi8_mask\">_mm_movepi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movepi16_mask.html\" title=\"fn core::arch::x86::_mm_movepi16_mask\">_mm_movepi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movm_epi8.html\" title=\"fn core::arch::x86::_mm_movm_epi8\">_mm_movm_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_movm_epi16.html\" title=\"fn core::arch::x86::_mm_movm_epi16\">_mm_movm_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_round_sd.html\" title=\"fn core::arch::x86::_mm_mul_round_sd\">_mm_mul_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_mul_round_ss.html\" title=\"fn core::arch::x86::_mm_mul_round_ss\">_mm_mul_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_multishift_epi64_epi8.html\" title=\"fn core::arch::x86::_mm_multishift_epi64_epi8\">_mm_multishift_epi64_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_or_epi32.html\" title=\"fn core::arch::x86::_mm_or_epi32\">_mm_or_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_or_epi64.html\" title=\"fn core::arch::x86::_mm_or_epi64\">_mm_or_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutex2var_epi8.html\" title=\"fn core::arch::x86::_mm_permutex2var_epi8\">_mm_permutex2var_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutex2var_epi16.html\" title=\"fn core::arch::x86::_mm_permutex2var_epi16\">_mm_permutex2var_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutex2var_epi32.html\" title=\"fn core::arch::x86::_mm_permutex2var_epi32\">_mm_permutex2var_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutex2var_epi64.html\" title=\"fn core::arch::x86::_mm_permutex2var_epi64\">_mm_permutex2var_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutex2var_pd.html\" title=\"fn core::arch::x86::_mm_permutex2var_pd\">_mm_permutex2var_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutex2var_ps.html\" title=\"fn core::arch::x86::_mm_permutex2var_ps\">_mm_permutex2var_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutexvar_epi8.html\" title=\"fn core::arch::x86::_mm_permutexvar_epi8\">_mm_permutexvar_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_permutexvar_epi16.html\" title=\"fn core::arch::x86::_mm_permutexvar_epi16\">_mm_permutexvar_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_popcnt_epi8.html\" title=\"fn core::arch::x86::_mm_popcnt_epi8\">_mm_popcnt_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 8-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_popcnt_epi16.html\" title=\"fn core::arch::x86::_mm_popcnt_epi16\">_mm_popcnt_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only\">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 16-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_popcnt_epi32.html\" title=\"fn core::arch::x86::_mm_popcnt_epi32\">_mm_popcnt_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 32-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_popcnt_epi64.html\" title=\"fn core::arch::x86::_mm_popcnt_epi64\">_mm_popcnt_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only\">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class=\"desc docblock-short\">For each packed 64-bit integer maps the value to the number of logical 1 bits.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rcp14_pd.html\" title=\"fn core::arch::x86::_mm_rcp14_pd\">_mm_rcp14_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rcp14_ps.html\" title=\"fn core::arch::x86::_mm_rcp14_ps\">_mm_rcp14_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rcp14_sd.html\" title=\"fn core::arch::x86::_mm_rcp14_sd\">_mm_rcp14_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rcp14_ss.html\" title=\"fn core::arch::x86::_mm_rcp14_ss\">_mm_rcp14_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rol_epi32.html\" title=\"fn core::arch::x86::_mm_rol_epi32\">_mm_rol_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rol_epi64.html\" title=\"fn core::arch::x86::_mm_rol_epi64\">_mm_rol_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rolv_epi32.html\" title=\"fn core::arch::x86::_mm_rolv_epi32\">_mm_rolv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rolv_epi64.html\" title=\"fn core::arch::x86::_mm_rolv_epi64\">_mm_rolv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ror_epi32.html\" title=\"fn core::arch::x86::_mm_ror_epi32\">_mm_ror_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ror_epi64.html\" title=\"fn core::arch::x86::_mm_ror_epi64\">_mm_ror_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rorv_epi32.html\" title=\"fn core::arch::x86::_mm_rorv_epi32\">_mm_rorv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rorv_epi64.html\" title=\"fn core::arch::x86::_mm_rorv_epi64\">_mm_rorv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_roundscale_pd.html\" title=\"fn core::arch::x86::_mm_roundscale_pd\">_mm_roundscale_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_roundscale_ps.html\" title=\"fn core::arch::x86::_mm_roundscale_ps\">_mm_roundscale_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_roundscale_round_sd.html\" title=\"fn core::arch::x86::_mm_roundscale_round_sd\">_mm_roundscale_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_roundscale_round_ss.html\" title=\"fn core::arch::x86::_mm_roundscale_round_ss\">_mm_roundscale_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_roundscale_sd.html\" title=\"fn core::arch::x86::_mm_roundscale_sd\">_mm_roundscale_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_roundscale_ss.html\" title=\"fn core::arch::x86::_mm_roundscale_ss\">_mm_roundscale_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br>\nRounding is done according to the imm8[2:0] parameter, which can be one of:<br>\n_MM_FROUND_TO_NEAREST_INT // round to nearest<br>\n_MM_FROUND_TO_NEG_INF     // round down<br>\n_MM_FROUND_TO_POS_INF     // round up<br>\n_MM_FROUND_TO_ZERO        // truncate<br>\n_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rsqrt14_sd.html\" title=\"fn core::arch::x86::_mm_rsqrt14_sd\">_mm_rsqrt14_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_rsqrt14_ss.html\" title=\"fn core::arch::x86::_mm_rsqrt14_ss\">_mm_rsqrt14_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_scalef_pd.html\" title=\"fn core::arch::x86::_mm_scalef_pd\">_mm_scalef_pd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_scalef_ps.html\" title=\"fn core::arch::x86::_mm_scalef_ps\">_mm_scalef_ps</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_scalef_round_sd.html\" title=\"fn core::arch::x86::_mm_scalef_round_sd\">_mm_scalef_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_scalef_round_ss.html\" title=\"fn core::arch::x86::_mm_scalef_round_ss\">_mm_scalef_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_scalef_sd.html\" title=\"fn core::arch::x86::_mm_scalef_sd\">_mm_scalef_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_scalef_ss.html\" title=\"fn core::arch::x86::_mm_scalef_ss\">_mm_scalef_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shldi_epi16.html\" title=\"fn core::arch::x86::_mm_shldi_epi16\">_mm_shldi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shldi_epi32.html\" title=\"fn core::arch::x86::_mm_shldi_epi32\">_mm_shldi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shldi_epi64.html\" title=\"fn core::arch::x86::_mm_shldi_epi64\">_mm_shldi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shldv_epi16.html\" title=\"fn core::arch::x86::_mm_shldv_epi16\">_mm_shldv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shldv_epi32.html\" title=\"fn core::arch::x86::_mm_shldv_epi32\">_mm_shldv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shldv_epi64.html\" title=\"fn core::arch::x86::_mm_shldv_epi64\">_mm_shldv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shrdi_epi16.html\" title=\"fn core::arch::x86::_mm_shrdi_epi16\">_mm_shrdi_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shrdi_epi32.html\" title=\"fn core::arch::x86::_mm_shrdi_epi32\">_mm_shrdi_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shrdi_epi64.html\" title=\"fn core::arch::x86::_mm_shrdi_epi64\">_mm_shrdi_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shrdv_epi16.html\" title=\"fn core::arch::x86::_mm_shrdv_epi16\">_mm_shrdv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shrdv_epi32.html\" title=\"fn core::arch::x86::_mm_shrdv_epi32\">_mm_shrdv_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_shrdv_epi64.html\" title=\"fn core::arch::x86::_mm_shrdv_epi64\">_mm_shrdv_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only\">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class=\"desc docblock-short\">Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sllv_epi16.html\" title=\"fn core::arch::x86::_mm_sllv_epi16\">_mm_sllv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sqrt_round_sd.html\" title=\"fn core::arch::x86::_mm_sqrt_round_sd\">_mm_sqrt_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sqrt_round_ss.html\" title=\"fn core::arch::x86::_mm_sqrt_round_ss\">_mm_sqrt_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sra_epi64.html\" title=\"fn core::arch::x86::_mm_sra_epi64\">_mm_sra_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srai_epi64.html\" title=\"fn core::arch::x86::_mm_srai_epi64\">_mm_srai_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srav_epi16.html\" title=\"fn core::arch::x86::_mm_srav_epi16\">_mm_srav_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srav_epi64.html\" title=\"fn core::arch::x86::_mm_srav_epi64\">_mm_srav_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_srlv_epi16.html\" title=\"fn core::arch::x86::_mm_srlv_epi16\">_mm_srlv_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_epi32.html\" title=\"fn core::arch::x86::_mm_store_epi32\">_mm_store_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_store_epi64.html\" title=\"fn core::arch::x86::_mm_store_epi64\">_mm_store_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_epi8.html\" title=\"fn core::arch::x86::_mm_storeu_epi8\">_mm_storeu_epi8</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 128-bits (composed of 16 packed 8-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_epi16.html\" title=\"fn core::arch::x86::_mm_storeu_epi16\">_mm_storeu_epi16</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 128-bits (composed of 8 packed 16-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_epi32.html\" title=\"fn core::arch::x86::_mm_storeu_epi32\">_mm_storeu_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_storeu_epi64.html\" title=\"fn core::arch::x86::_mm_storeu_epi64\">_mm_storeu_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_round_sd.html\" title=\"fn core::arch::x86::_mm_sub_round_sd\">_mm_sub_round_sd</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_sub_round_ss.html\" title=\"fn core::arch::x86::_mm_sub_round_ss\">_mm_sub_round_ss</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f` only\">(x86 or x86-64) and <code>avx512f</code></span></div><div class=\"desc docblock-short\">Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ternarylogic_epi32.html\" title=\"fn core::arch::x86::_mm_ternarylogic_epi32\">_mm_ternarylogic_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_ternarylogic_epi64.html\" title=\"fn core::arch::x86::_mm_ternarylogic_epi64\">_mm_ternarylogic_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_epi8_mask.html\" title=\"fn core::arch::x86::_mm_test_epi8_mask\">_mm_test_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_epi16_mask.html\" title=\"fn core::arch::x86::_mm_test_epi16_mask\">_mm_test_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_epi32_mask.html\" title=\"fn core::arch::x86::_mm_test_epi32_mask\">_mm_test_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_test_epi64_mask.html\" title=\"fn core::arch::x86::_mm_test_epi64_mask\">_mm_test_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testn_epi8_mask.html\" title=\"fn core::arch::x86::_mm_testn_epi8_mask\">_mm_testn_epi8_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testn_epi16_mask.html\" title=\"fn core::arch::x86::_mm_testn_epi16_mask\">_mm_testn_epi16_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only\">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testn_epi32_mask.html\" title=\"fn core::arch::x86::_mm_testn_epi32_mask\">_mm_testn_epi32_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_testn_epi64_mask.html\" title=\"fn core::arch::x86::_mm_testn_epi64_mask\">_mm_testn_epi64_mask</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_xor_epi32.html\" title=\"fn core::arch::x86::_mm_xor_epi32\">_mm_xor_epi32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._mm_xor_epi64.html\" title=\"fn core::arch::x86::_mm_xor_epi64\">_mm_xor_epi64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only\">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class=\"desc docblock-short\">Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._store_mask32.html\" title=\"fn core::arch::x86::_store_mask32\">_store_mask32</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Store 32-bit mask from a into memory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._store_mask64.html\" title=\"fn core::arch::x86::_store_mask64\">_store_mask64</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `avx512bw` only\">(x86 or x86-64) and <code>avx512bw</code></span></div><div class=\"desc docblock-short\">Store 64-bit mask from a into memory.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xabort.html\" title=\"fn core::arch::x86::_xabort\">_xabort</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rtm` only\">(x86 or x86-64) and <code>rtm</code></span></div><div class=\"desc docblock-short\">Forces a restricted transactional memory (RTM) region to abort.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xabort_code.html\" title=\"fn core::arch::x86::_xabort_code\">_xabort_code</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Retrieves the parameter passed to <a href=\"fn._xabort.html\" title=\"fn core::arch::x86::_xabort\"><code>_xabort</code></a> when <a href=\"fn._xbegin.html\" title=\"fn core::arch::x86::_xbegin\"><code>_xbegin</code></a>’s status has the\n<code>_XABORT_EXPLICIT</code> flag set.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xbegin.html\" title=\"fn core::arch::x86::_xbegin\">_xbegin</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rtm` only\">(x86 or x86-64) and <code>rtm</code></span></div><div class=\"desc docblock-short\">Specifies the start of a restricted transactional memory (RTM) code region and returns a value\nindicating status.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xend.html\" title=\"fn core::arch::x86::_xend\">_xend</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rtm` only\">(x86 or x86-64) and <code>rtm</code></span></div><div class=\"desc docblock-short\">Specifies the end of a restricted transactional memory (RTM) code region.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn._xtest.html\" title=\"fn core::arch::x86::_xtest\">_xtest</a><sup title=\"unsafe function\">⚠</sup><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on (x86 or x86-64) and target feature `rtm` only\">(x86 or x86-64) and <code>rtm</code></span></div><div class=\"desc docblock-short\">Queries whether the processor is executing in a transactional region identified by restricted\ntransactional memory (RTM) or hardware lock elision (HLE).</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.has_cpuid.html\" title=\"fn core::arch::x86::has_cpuid\">has_cpuid</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">Does the host support the <code>cpuid</code> instruction?</div></li></ul><h2 id=\"types\" class=\"section-header\">Type Aliases<a href=\"#types\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"type\" href=\"type._MM_CMPINT_ENUM.html\" title=\"type core::arch::x86::_MM_CMPINT_ENUM\">_MM_CMPINT_ENUM</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>_MM_CMPINT_ENUM</code> type used to specify comparison operations in AVX-512 intrinsics.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type._MM_MANTISSA_NORM_ENUM.html\" title=\"type core::arch::x86::_MM_MANTISSA_NORM_ENUM\">_MM_MANTISSA_NORM_ENUM</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa normalized operations in AVX-512 intrinsics.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type._MM_MANTISSA_SIGN_ENUM.html\" title=\"type core::arch::x86::_MM_MANTISSA_SIGN_ENUM\">_MM_MANTISSA_SIGN_ENUM</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa signed operations in AVX-512 intrinsics.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type._MM_PERM_ENUM.html\" title=\"type core::arch::x86::_MM_PERM_ENUM\">_MM_PERM_ENUM</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>MM_PERM_ENUM</code> type used to specify shuffle operations in AVX-512 intrinsics.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.__mmask8.html\" title=\"type core::arch::x86::__mmask8\">__mmask8</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit integer</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.__mmask16.html\" title=\"type core::arch::x86::__mmask16\">__mmask16</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit integer</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.__mmask32.html\" title=\"type core::arch::x86::__mmask32\">__mmask32</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit integer</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.__mmask64.html\" title=\"type core::arch::x86::__mmask64\">__mmask64</a><span class=\"stab unstable\" title=\"\">Experimental</span><span class=\"stab portability\" title=\"Available on x86 or x86-64 only\">x86 or x86-64</span></div><div class=\"desc docblock-short\">The <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit integer</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:22:25.076Z"
}