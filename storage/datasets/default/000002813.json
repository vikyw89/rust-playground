{
	"title": "BTreeMap in std::collections::btree_map - Rust",
	"url": "https://doc.rust-lang.org/stable/std/collections/btree_map/struct.BTreeMap.html",
	"markdown": "# BTreeMap in std::collections::btree\\_map - Rust\n\n```\npub struct BTreeMap<K, V, A = Global>where\n    A: Allocator + Clone,{ /* private fields */ }\n```\n\nExpand description\n\nAn ordered map based on a [B-Tree](https://en.wikipedia.org/wiki/B-tree).\n\nB-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log2n). However, in practice the way this is done is _very_ inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to, at the very least, reconsider the BST strategy.\n\nA B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do _more_ comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every ith element for some choice of i.\n\nCurrently, our implementation simply performs naive linear search. This provides excellent performance on _small_ nodes of elements which are cheap to compare. However in the future we would like to further explore choosing the optimal search strategy based on the choice of B, and possibly other factors. Using linear search, searching for a random element is expected to take B \\* log(n) comparisons, which is generally worse than a BST. In practice, however, performance is excellent.\n\nIt is a logic error for a key to be modified in such a way that the keys ordering relative to any other key, as determined by the [`Ord`](../../cmp/trait.Ord.html \"trait std::cmp::Ord\") trait, changes while it is in the map. This is normally only possible through [`Cell`](../../cell/struct.Cell.html \"struct std::cell::Cell\"), [`RefCell`](../../cell/struct.RefCell.html \"struct std::cell::RefCell\"), global state, I/O, or unsafe code. The behavior resulting from such a logic error is not specified, but will be encapsulated to the `BTreeMap` that observed the logic error and not result in undefined behavior. This could include panics, incorrect results, aborts, memory leaks, and non-termination.\n\nIterators obtained from functions such as [`BTreeMap::iter`](about:blank/struct.BTreeMap.html#method.iter \"method std::collections::BTreeMap::iter\"), [`BTreeMap::into_iter`](about:blank/struct.BTreeMap.html#method.into_iter \"method std::collections::BTreeMap::into_iter\"), [`BTreeMap::values`](about:blank/struct.BTreeMap.html#method.values \"method std::collections::BTreeMap::values\"), or [`BTreeMap::keys`](about:blank/struct.BTreeMap.html#method.keys \"method std::collections::BTreeMap::keys\") produce their items in order by key, and take worst-case logarithmic and amortized constant time per item returned.\n\n## [搂](#examples)Examples\n\n```\nuse std::collections::BTreeMap;\n\n// type inference lets us omit an explicit type signature (which\n// would be `BTreeMap<&str, &str>` in this example).\nlet mut movie_reviews = BTreeMap::new();\n\n// review some movies.\nmovie_reviews.insert(\"Office Space\",       \"Deals with real issues in the workplace.\");\nmovie_reviews.insert(\"Pulp Fiction\",       \"Masterpiece.\");\nmovie_reviews.insert(\"The Godfather\",      \"Very enjoyable.\");\nmovie_reviews.insert(\"The Blues Brothers\", \"Eye lyked it a lot.\");\n\n// check for a specific one.\nif !movie_reviews.contains_key(\"Les Mis茅rables\") {\n    println!(\"We've got {} reviews, but Les Mis茅rables ain't one.\",\n             movie_reviews.len());\n}\n\n// oops, this review has a lot of spelling mistakes, let's delete it.\nmovie_reviews.remove(\"The Blues Brothers\");\n\n// look up the values associated with some keys.\nlet to_find = [\"Up!\", \"Office Space\"];\nfor movie in &to_find {\n    match movie_reviews.get(movie) {\n       Some(review) => println!(\"{movie}: {review}\"),\n       None => println!(\"{movie} is unreviewed.\")\n    }\n}\n\n// Look up the value for a key (will panic if the key is not found).\nprintln!(\"Movie review: {}\", movie_reviews[\"Office Space\"]);\n\n// iterate over everything.\nfor (movie, review) in &movie_reviews {\n    println!(\"{movie}: \\\"{review}\\\"\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++//+type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BTreeMap%3C%26str,+%26str%3E%60+in+this+example).%0A++++let+mut+movie_reviews+=+BTreeMap::new();%0A++++%0A++++//+review+some+movies.%0A++++movie_reviews.insert(%22Office+Space%22,+++++++%22Deals+with+real+issues+in+the+workplace.%22);%0A++++movie_reviews.insert(%22Pulp+Fiction%22,+++++++%22Masterpiece.%22);%0A++++movie_reviews.insert(%22The+Godfather%22,++++++%22Very+enjoyable.%22);%0A++++movie_reviews.insert(%22The+Blues+Brothers%22,+%22Eye+lyked+it+a+lot.%22);%0A++++%0A++++//+check+for+a+specific+one.%0A++++if+!movie_reviews.contains_key(%22Les+Mis%C3%A9rables%22)+%7B%0A++++++++println!(%22We%27ve+got+%7B%7D+reviews,+but+Les+Mis%C3%A9rables+ain%27t+one.%22,%0A+++++++++++++++++movie_reviews.len());%0A++++%7D%0A++++%0A++++//+oops,+this+review+has+a+lot+of+spelling+mistakes,+let%27s+delete+it.%0A++++movie_reviews.remove(%22The+Blues+Brothers%22);%0A++++%0A++++//+look+up+the+values+associated+with+some+keys.%0A++++let+to_find+=+%5B%22Up!%22,+%22Office+Space%22%5D;%0A++++for+movie+in+%26to_find+%7B%0A++++++++match+movie_reviews.get(movie)+%7B%0A+++++++++++Some(review)+=%3E+println!(%22%7Bmovie%7D:+%7Breview%7D%22),%0A+++++++++++None+=%3E+println!(%22%7Bmovie%7D+is+unreviewed.%22)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Look+up+the+value+for+a+key+(will+panic+if+the+key+is+not+found).%0A++++println!(%22Movie+review:+%7B%7D%22,+movie_reviews%5B%22Office+Space%22%5D);%0A++++%0A++++//+iterate+over+everything.%0A++++for+(movie,+review)+in+%26movie_reviews+%7B%0A++++++++println!(%22%7Bmovie%7D:+%5C%22%7Breview%7D%5C%22%22);%0A++++%7D%0A%7D&edition=2021)\n\nA `BTreeMap` with a known list of items can be initialized from an array:\n\n```\nuse std::collections::BTreeMap;\n\nlet solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n    (\"Earth\", 1.0),\n    (\"Mars\", 1.5),\n]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+solar_distance+=+BTreeMap::from(%5B%0A++++++++(%22Mercury%22,+0.4),%0A++++++++(%22Venus%22,+0.7),%0A++++++++(%22Earth%22,+1.0),%0A++++++++(%22Mars%22,+1.5),%0A++++%5D);%0A%7D&edition=2021)\n\n`BTreeMap` implements an [`Entry API`](about:blank/struct.BTreeMap.html#method.entry \"method std::collections::BTreeMap::entry\"), which allows for complex methods of getting, setting, updating and removing keys and their values:\n\n```\nuse std::collections::BTreeMap;\n\n// type inference lets us omit an explicit type signature (which\n// would be `BTreeMap<&str, u8>` in this example).\nlet mut player_stats = BTreeMap::new();\n\nfn random_stat_buff() -> u8 {\n    // could actually return some random value here - let's just return\n    // some fixed value for now\n    42\n}\n\n// insert a key only if it doesn't already exist\nplayer_stats.entry(\"health\").or_insert(100);\n\n// insert a key using a function that provides a new value only if it\n// doesn't already exist\nplayer_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n\n// update a key, guarding against the key possibly not being set\nlet stat = player_stats.entry(\"attack\").or_insert(100);\n*stat += random_stat_buff();\n\n// modify an entry before an insert with in-place mutation\nplayer_stats.entry(\"mana\").and_modify(|mana| *mana += 200).or_insert(100);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++//+type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BTreeMap%3C%26str,+u8%3E%60+in+this+example).%0A++++let+mut+player_stats+=+BTreeMap::new();%0A++++%0A++++fn+random_stat_buff()+-%3E+u8+%7B%0A++++++++//+could+actually+return+some+random+value+here+-+let%27s+just+return%0A++++++++//+some+fixed+value+for+now%0A++++++++42%0A++++%7D%0A++++%0A++++//+insert+a+key+only+if+it+doesn%27t+already+exist%0A++++player_stats.entry(%22health%22).or_insert(100);%0A++++%0A++++//+insert+a+key+using+a+function+that+provides+a+new+value+only+if+it%0A++++//+doesn%27t+already+exist%0A++++player_stats.entry(%22defence%22).or_insert_with(random_stat_buff);%0A++++%0A++++//+update+a+key,+guarding+against+the+key+possibly+not+being+set%0A++++let+stat+=+player_stats.entry(%22attack%22).or_insert(100);%0A++++*stat+%2B=+random_stat_buff();%0A++++%0A++++//+modify+an+entry+before+an+insert+with+in-place+mutation%0A++++player_stats.entry(%22mana%22).and_modify(%7Cmana%7C+*mana+%2B=+200).or_insert(100);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#610)[搂](#impl-BTreeMap%3CK,+V%3E)\n\n1.0.0 (const: 1.66.0) 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#629)\n\nMakes a new, empty `BTreeMap`.\n\nDoes not allocate anything on its own.\n\n##### [搂](#examples-1)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\n\n// entries can now be inserted into the empty map\nmap.insert(1, \"a\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++%0A++++//+entries+can+now+be+inserted+into+the+empty+map%0A++++map.insert(1,+%22a%22);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#634)[搂](#impl-BTreeMap%3CK,+V,+A%3E)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#648)\n\nClears the map, removing all elements.\n\n##### [搂](#examples-2)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(1, \"a\");\na.clear();\nassert!(a.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22a%22);%0A++++a.clear();%0A++++assert!(a.is_empty());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#674)\n\nThis is a nightly-only experimental API. (`btreemap_alloc`[#32838](https://github.com/rust-lang/rust/issues/32838))\n\nMakes a new empty BTreeMap with a reasonable choice for B.\n\n##### [搂](#examples-3)Examples\n\n```\nuse std::collections::BTreeMap;\nuse std::alloc::Global;\n\nlet mut map = BTreeMap::new_in(Global);\n\n// entries can now be inserted into the empty map\nmap.insert(1, \"a\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%23!%5Bfeature(btreemap_alloc)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::alloc::Global;%0A++++%0A++++let+mut+map+=+BTreeMap::new_in(Global);%0A++++%0A++++//+entries+can+now+be+inserted+into+the+empty+map%0A++++map.insert(1,+%22a%22);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#679)[搂](#impl-BTreeMap%3CK,+V,+A%3E-1)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#696-699)\n\nReturns a reference to the value corresponding to the key.\n\nThe key may be any borrowed form of the maps key type, but the ordering on the borrowed form _must_ match the ordering on the key type.\n\n##### [搂](#examples-4)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.get(&1), Some(&\"a\"));\nassert_eq!(map.get(&2), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.get(%261),+Some(%26%22a%22));%0A++++assert_eq!(map.get(%262),+None);%0A%7D&edition=2021)\n\n1.40.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#724-727)\n\nReturns the key-value pair corresponding to the supplied key.\n\nThe supplied key may be any borrowed form of the maps key type, but the ordering on the borrowed form _must_ match the ordering on the key type.\n\n##### [搂](#examples-5)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\nassert_eq!(map.get_key_value(&2), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.get_key_value(%261),+Some((%261,+%26%22a%22)));%0A++++assert_eq!(map.get_key_value(%262),+None);%0A%7D&edition=2021)\n\n1.66.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#751-753)\n\nReturns the first key-value pair in the map. The key in this pair is the minimum key in the map.\n\n##### [搂](#examples-6)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nassert_eq!(map.first_key_value(), None);\nmap.insert(1, \"b\");\nmap.insert(2, \"a\");\nassert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++assert_eq!(map.first_key_value(),+None);%0A++++map.insert(1,+%22b%22);%0A++++map.insert(2,+%22a%22);%0A++++assert_eq!(map.first_key_value(),+Some((%261,+%26%22b%22)));%0A%7D&edition=2021)\n\n1.66.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#779-781)\n\nReturns the first entry in the map for in-place manipulation. The key of this entry is the minimum key in the map.\n\n##### [搂](#examples-7)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nmap.insert(2, \"b\");\nif let Some(mut entry) = map.first_entry() {\n    if *entry.key() > 0 {\n        entry.insert(\"first\");\n    }\n}\nassert_eq!(*map.get(&1).unwrap(), \"first\");\nassert_eq!(*map.get(&2).unwrap(), \"b\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++if+let+Some(mut+entry)+=+map.first_entry()+%7B%0A++++++++if+*entry.key()+%3E+0+%7B%0A++++++++++++entry.insert(%22first%22);%0A++++++++%7D%0A++++%7D%0A++++assert_eq!(*map.get(%261).unwrap(),+%22first%22);%0A++++assert_eq!(*map.get(%262).unwrap(),+%22b%22);%0A%7D&edition=2021)\n\n1.66.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#813-815)\n\nRemoves and returns the first element in the map. The key of this element is the minimum key that was in the map.\n\n##### [搂](#examples-8)Examples\n\nDraining elements in ascending order, while keeping a usable map each iteration.\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nmap.insert(2, \"b\");\nwhile let Some((key, _val)) = map.pop_first() {\n    assert!(map.iter().all(|(k, _v)| *k > key));\n}\nassert!(map.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++while+let+Some((key,+_val))+=+map.pop_first()+%7B%0A++++++++assert!(map.iter().all(%7C(k,+_v)%7C+*k+%3E+key));%0A++++%7D%0A++++assert!(map.is_empty());%0A%7D&edition=2021)\n\n1.66.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#834-836)\n\nReturns the last key-value pair in the map. The key in this pair is the maximum key in the map.\n\n##### [搂](#examples-9)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"b\");\nmap.insert(2, \"a\");\nassert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22b%22);%0A++++map.insert(2,+%22a%22);%0A++++assert_eq!(map.last_key_value(),+Some((%262,+%26%22a%22)));%0A%7D&edition=2021)\n\n1.66.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#862-864)\n\nReturns the last entry in the map for in-place manipulation. The key of this entry is the maximum key in the map.\n\n##### [搂](#examples-10)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nmap.insert(2, \"b\");\nif let Some(mut entry) = map.last_entry() {\n    if *entry.key() > 0 {\n        entry.insert(\"last\");\n    }\n}\nassert_eq!(*map.get(&1).unwrap(), \"a\");\nassert_eq!(*map.get(&2).unwrap(), \"last\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++if+let+Some(mut+entry)+=+map.last_entry()+%7B%0A++++++++if+*entry.key()+%3E+0+%7B%0A++++++++++++entry.insert(%22last%22);%0A++++++++%7D%0A++++%7D%0A++++assert_eq!(*map.get(%261).unwrap(),+%22a%22);%0A++++assert_eq!(*map.get(%262).unwrap(),+%22last%22);%0A%7D&edition=2021)\n\n1.66.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#896-898)\n\nRemoves and returns the last element in the map. The key of this element is the maximum key that was in the map.\n\n##### [搂](#examples-11)Examples\n\nDraining elements in descending order, while keeping a usable map each iteration.\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nmap.insert(2, \"b\");\nwhile let Some((key, _val)) = map.pop_last() {\n    assert!(map.iter().all(|(k, _v)| *k < key));\n}\nassert!(map.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++while+let+Some((key,+_val))+=+map.pop_last()+%7B%0A++++++++assert!(map.iter().all(%7C(k,+_v)%7C+*k+%3C+key));%0A++++%7D%0A++++assert!(map.is_empty());%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#919-922)\n\nReturns `true` if the map contains a value for the specified key.\n\nThe key may be any borrowed form of the maps key type, but the ordering on the borrowed form _must_ match the ordering on the key type.\n\n##### [搂](#examples-12)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.contains_key(&1), true);\nassert_eq!(map.contains_key(&2), false);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.contains_key(%261),+true);%0A++++assert_eq!(map.contains_key(%262),+false);%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#946-949)\n\nReturns a mutable reference to the value corresponding to the key.\n\nThe key may be any borrowed form of the maps key type, but the ordering on the borrowed form _must_ match the ordering on the key type.\n\n##### [搂](#examples-13)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nif let Some(x) = map.get_mut(&1) {\n    *x = \"b\";\n}\nassert_eq!(map[&1], \"b\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++if+let+Some(x)+=+map.get_mut(%261)+%7B%0A++++++++*x+=+%22b%22;%0A++++%7D%0A++++assert_eq!(map%5B%261%5D,+%22b%22);%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#984-986)\n\nInserts a key-value pair into the map.\n\nIf the map did not have this key present, `None` is returned.\n\nIf the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be `==` without being identical. See the [module-level documentation](about:blank/index.html#insert-and-complex-keys) for more.\n\n##### [搂](#examples-14)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nassert_eq!(map.insert(37, \"a\"), None);\nassert_eq!(map.is_empty(), false);\n\nmap.insert(37, \"b\");\nassert_eq!(map.insert(37, \"c\"), Some(\"b\"));\nassert_eq!(map[&37], \"c\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++assert_eq!(map.insert(37,+%22a%22),+None);%0A++++assert_eq!(map.is_empty(),+false);%0A++++%0A++++map.insert(37,+%22b%22);%0A++++assert_eq!(map.insert(37,+%22c%22),+Some(%22b%22));%0A++++assert_eq!(map%5B%2637%5D,+%22c%22);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1019-1021)\n\nThis is a nightly-only experimental API. (`map_try_insert`[#82766](https://github.com/rust-lang/rust/issues/82766))\n\nTries to insert a key-value pair into the map, and returns a mutable reference to the value in the entry.\n\nIf the map already had this key present, nothing is updated, and an error containing the occupied entry and the value is returned.\n\n##### [搂](#examples-15)Examples\n\n```\n#![feature(map_try_insert)]\n\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nassert_eq!(map.try_insert(37, \"a\").unwrap(), &\"a\");\n\nlet err = map.try_insert(37, \"b\").unwrap_err();\nassert_eq!(err.entry.key(), &37);\nassert_eq!(err.entry.get(), &\"a\");\nassert_eq!(err.value, \"b\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(map_try_insert)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++assert_eq!(map.try_insert(37,+%22a%22).unwrap(),+%26%22a%22);%0A++++%0A++++let+err+=+map.try_insert(37,+%22b%22).unwrap_err();%0A++++assert_eq!(err.entry.key(),+%2637);%0A++++assert_eq!(err.entry.get(),+%26%22a%22);%0A++++assert_eq!(err.value,+%22b%22);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1047-1050)\n\nRemoves a key from the map, returning the value at the key if the key was previously in the map.\n\nThe key may be any borrowed form of the maps key type, but the ordering on the borrowed form _must_ match the ordering on the key type.\n\n##### [搂](#examples-16)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.remove(&1), Some(\"a\"));\nassert_eq!(map.remove(&1), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.remove(%261),+Some(%22a%22));%0A++++assert_eq!(map.remove(%261),+None);%0A%7D&edition=2021)\n\n1.45.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1072-1075)\n\nRemoves a key from the map, returning the stored key and value if the key was previously in the map.\n\nThe key may be any borrowed form of the maps key type, but the ordering on the borrowed form _must_ match the ordering on the key type.\n\n##### [搂](#examples-17)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.remove_entry(&1), Some((1, \"a\")));\nassert_eq!(map.remove_entry(&1), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.remove_entry(%261),+Some((1,+%22a%22)));%0A++++assert_eq!(map.remove_entry(%261),+None);%0A%7D&edition=2021)\n\n1.53.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1110-1113)\n\nRetains only the elements specified by the predicate.\n\nIn other words, remove all pairs `(k, v)` for which `f(&k, &mut v)` returns `false`. The elements are visited in ascending key order.\n\n##### [搂](#examples-18)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x*10)).collect();\n// Keep only the elements with even-numbered keys.\nmap.retain(|&k, _| k % 2 == 0);\nassert!(map.into_iter().eq(vec![(0, 0), (2, 20), (4, 40), (6, 60)]));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map:+BTreeMap%3Ci32,+i32%3E+=+(0..8).map(%7Cx%7C+(x,+x*10)).collect();%0A++++//+Keep+only+the+elements+with+even-numbered+keys.%0A++++map.retain(%7C%26k,+_%7C+k+%25+2+==+0);%0A++++assert!(map.into_iter().eq(vec!%5B(0,+0),+(2,+20),+(4,+40),+(6,+60)%5D));%0A%7D&edition=2021)\n\n1.11.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1150-1153)\n\nMoves all elements from `other` into `self`, leaving `other` empty.\n\nIf a key from `other` is already present in `self`, the respective value from `self` will be overwritten with the respective value from `other`.\n\n##### [搂](#examples-19)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(1, \"a\");\na.insert(2, \"b\");\na.insert(3, \"c\"); // Note: Key (3) also present in b.\n\nlet mut b = BTreeMap::new();\nb.insert(3, \"d\"); // Note: Key (3) also present in a.\nb.insert(4, \"e\");\nb.insert(5, \"f\");\n\na.append(&mut b);\n\nassert_eq!(a.len(), 5);\nassert_eq!(b.len(), 0);\n\nassert_eq!(a[&1], \"a\");\nassert_eq!(a[&2], \"b\");\nassert_eq!(a[&3], \"d\"); // Note: \"c\" has been overwritten.\nassert_eq!(a[&4], \"e\");\nassert_eq!(a[&5], \"f\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22a%22);%0A++++a.insert(2,+%22b%22);%0A++++a.insert(3,+%22c%22);+//+Note:+Key+(3)+also+present+in+b.%0A++++%0A++++let+mut+b+=+BTreeMap::new();%0A++++b.insert(3,+%22d%22);+//+Note:+Key+(3)+also+present+in+a.%0A++++b.insert(4,+%22e%22);%0A++++b.insert(5,+%22f%22);%0A++++%0A++++a.append(%26mut+b);%0A++++%0A++++assert_eq!(a.len(),+5);%0A++++assert_eq!(b.len(),+0);%0A++++%0A++++assert_eq!(a%5B%261%5D,+%22a%22);%0A++++assert_eq!(a%5B%262%5D,+%22b%22);%0A++++assert_eq!(a%5B%263%5D,+%22d%22);+//+Note:+%22c%22+has+been+overwritten.%0A++++assert_eq!(a%5B%264%5D,+%22e%22);%0A++++assert_eq!(a%5B%265%5D,+%22f%22);%0A%7D&edition=2021)\n\n1.17.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1205-1209)\n\nConstructs a double-ended iterator over a sub-range of elements in the map. The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will yield elements from min (inclusive) to max (exclusive). The range may also be entered as `(Bound<T>, Bound<T>)`, so for example `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive range from 4 to 10.\n\n##### [搂](#panics)Panics\n\nPanics if range `start > end`. Panics if range `start == end` and both bounds are `Excluded`.\n\n##### [搂](#examples-20)Examples\n\n```\nuse std::collections::BTreeMap;\nuse std::ops::Bound::Included;\n\nlet mut map = BTreeMap::new();\nmap.insert(3, \"a\");\nmap.insert(5, \"b\");\nmap.insert(8, \"c\");\nfor (&key, &value) in map.range((Included(&4), Included(&8))) {\n    println!(\"{key}: {value}\");\n}\nassert_eq!(Some((&5, &\"b\")), map.range(4..).next());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound::Included;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(3,+%22a%22);%0A++++map.insert(5,+%22b%22);%0A++++map.insert(8,+%22c%22);%0A++++for+(%26key,+%26value)+in+map.range((Included(%264),+Included(%268)))+%7B%0A++++++++println!(%22%7Bkey%7D:+%7Bvalue%7D%22);%0A++++%7D%0A++++assert_eq!(Some((%265,+%26%22b%22)),+map.range(4..).next());%0A%7D&edition=2021)\n\n1.17.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1245-1249)\n\nConstructs a mutable double-ended iterator over a sub-range of elements in the map. The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will yield elements from min (inclusive) to max (exclusive). The range may also be entered as `(Bound<T>, Bound<T>)`, so for example `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive range from 4 to 10.\n\n##### [搂](#panics-1)Panics\n\nPanics if range `start > end`. Panics if range `start == end` and both bounds are `Excluded`.\n\n##### [搂](#examples-21)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map: BTreeMap<&str, i32> =\n    [(\"Alice\", 0), (\"Bob\", 0), (\"Carol\", 0), (\"Cheryl\", 0)].into();\nfor (_, balance) in map.range_mut(\"B\"..\"Cheryl\") {\n    *balance += 100;\n}\nfor (name, balance) in &map {\n    println!(\"{name} => {balance}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map:+BTreeMap%3C%26str,+i32%3E+=%0A++++++++%5B(%22Alice%22,+0),+(%22Bob%22,+0),+(%22Carol%22,+0),+(%22Cheryl%22,+0)%5D.into();%0A++++for+(_,+balance)+in+map.range_mut(%22B%22..%22Cheryl%22)+%7B%0A++++++++*balance+%2B=+100;%0A++++%7D%0A++++for+(name,+balance)+in+%26map+%7B%0A++++++++println!(%22%7Bname%7D+=%3E+%7Bbalance%7D%22);%0A++++%7D%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1277-1279)\n\nGets the given keys corresponding entry in the map for in-place manipulation.\n\n##### [搂](#examples-22)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut count: BTreeMap<&str, usize> = BTreeMap::new();\n\n// count the number of occurrences of letters in the vec\nfor x in [\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"] {\n    count.entry(x).and_modify(|curr| *curr += 1).or_insert(1);\n}\n\nassert_eq!(count[\"a\"], 3);\nassert_eq!(count[\"b\"], 2);\nassert_eq!(count[\"c\"], 1);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+count:+BTreeMap%3C%26str,+usize%3E+=+BTreeMap::new();%0A++++%0A++++//+count+the+number+of+occurrences+of+letters+in+the+vec%0A++++for+x+in+%5B%22a%22,+%22b%22,+%22a%22,+%22c%22,+%22a%22,+%22b%22%5D+%7B%0A++++++++count.entry(x).and_modify(%7Ccurr%7C+*curr+%2B=+1).or_insert(1);%0A++++%7D%0A++++%0A++++assert_eq!(count%5B%22a%22%5D,+3);%0A++++assert_eq!(count%5B%22b%22%5D,+2);%0A++++assert_eq!(count%5B%22c%22%5D,+1);%0A%7D&edition=2021)\n\n1.11.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1336-1339)\n\nSplits the collection into two at the given key. Returns everything after the given key, including the key.\n\n##### [搂](#examples-23)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(1, \"a\");\na.insert(2, \"b\");\na.insert(3, \"c\");\na.insert(17, \"d\");\na.insert(41, \"e\");\n\nlet b = a.split_off(&3);\n\nassert_eq!(a.len(), 2);\nassert_eq!(b.len(), 3);\n\nassert_eq!(a[&1], \"a\");\nassert_eq!(a[&2], \"b\");\n\nassert_eq!(b[&3], \"c\");\nassert_eq!(b[&17], \"d\");\nassert_eq!(b[&41], \"e\");\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22a%22);%0A++++a.insert(2,+%22b%22);%0A++++a.insert(3,+%22c%22);%0A++++a.insert(17,+%22d%22);%0A++++a.insert(41,+%22e%22);%0A++++%0A++++let+b+=+a.split_off(%263);%0A++++%0A++++assert_eq!(a.len(),+2);%0A++++assert_eq!(b.len(),+3);%0A++++%0A++++assert_eq!(a%5B%261%5D,+%22a%22);%0A++++assert_eq!(a%5B%262%5D,+%22b%22);%0A++++%0A++++assert_eq!(b%5B%263%5D,+%22c%22);%0A++++assert_eq!(b%5B%2617%5D,+%22d%22);%0A++++assert_eq!(b%5B%2641%5D,+%22e%22);%0A%7D&edition=2021)\n\nThis is a nightly-only experimental API. (`btree_extract_if`[#70530](https://github.com/rust-lang/rust/issues/70530))\n\nCreates an iterator that visits all elements (key-value pairs) in ascending key order and uses a closure to determine if an element should be removed. If the closure returns `true`, the element is removed from the map and yielded. If the closure returns `false`, or panics, the element remains in the map and will not be yielded.\n\nThe iterator also lets you mutate the value of each element in the closure, regardless of whether you choose to keep or remove it.\n\nIf the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating or the iteration short-circuits, then the remaining elements will be retained. Use [`retain`](about:blank/struct.BTreeMap.html#method.retain \"method std::collections::BTreeMap::retain\") with a negated predicate if you do not need the returned iterator.\n\n##### [搂](#examples-24)Examples\n\nSplitting a map into even and odd keys, reusing the original map:\n\n```\n#![feature(btree_extract_if)]\nuse std::collections::BTreeMap;\n\nlet mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\nlet evens: BTreeMap<_, _> = map.extract_if(|k, _v| k % 2 == 0).collect();\nlet odds = map;\nassert_eq!(evens.keys().copied().collect::<Vec<_>>(), [0, 2, 4, 6]);\nassert_eq!(odds.keys().copied().collect::<Vec<_>>(), [1, 3, 5, 7]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_extract_if)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map:+BTreeMap%3Ci32,+i32%3E+=+(0..8).map(%7Cx%7C+(x,+x)).collect();%0A++++let+evens:+BTreeMap%3C_,+_%3E+=+map.extract_if(%7Ck,+_v%7C+k+%25+2+==+0).collect();%0A++++let+odds+=+map;%0A++++assert_eq!(evens.keys().copied().collect::%3CVec%3C_%3E%3E(),+%5B0,+2,+4,+6%5D);%0A++++assert_eq!(odds.keys().copied().collect::%3CVec%3C_%3E%3E(),+%5B1,+3,+5,+7%5D);%0A%7D&version=nightly&edition=2021)\n\n1.54.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1445)\n\nCreates a consuming iterator visiting all the keys, in sorted order. The map cannot be used after calling this. The iterator element type is `K`.\n\n##### [搂](#examples-25)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(2, \"b\");\na.insert(1, \"a\");\n\nlet keys: Vec<i32> = a.into_keys().collect();\nassert_eq!(keys, [1, 2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(2,+%22b%22);%0A++++a.insert(1,+%22a%22);%0A++++%0A++++let+keys:+Vec%3Ci32%3E+=+a.into_keys().collect();%0A++++assert_eq!(keys,+%5B1,+2%5D);%0A%7D&edition=2021)\n\n1.54.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1467)\n\nCreates a consuming iterator visiting all the values, in order by key. The map cannot be used after calling this. The iterator element type is `V`.\n\n##### [搂](#examples-26)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(1, \"hello\");\na.insert(2, \"goodbye\");\n\nlet values: Vec<&str> = a.into_values().collect();\nassert_eq!(values, [\"hello\", \"goodbye\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22hello%22);%0A++++a.insert(2,+%22goodbye%22);%0A++++%0A++++let+values:+Vec%3C%26str%3E+=+a.into_values().collect();%0A++++assert_eq!(values,+%5B%22hello%22,+%22goodbye%22%5D);%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2359)[搂](#impl-BTreeMap%3CK,+V,+A%3E-2)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2380)\n\nGets an iterator over the entries of the map, sorted by key.\n\n##### [搂](#examples-27)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::new();\nmap.insert(3, \"c\");\nmap.insert(2, \"b\");\nmap.insert(1, \"a\");\n\nfor (key, value) in map.iter() {\n    println!(\"{key}: {value}\");\n}\n\nlet (first_key, first_value) = map.iter().next().unwrap();\nassert_eq!((*first_key, *first_value), (1, \"a\"));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(3,+%22c%22);%0A++++map.insert(2,+%22b%22);%0A++++map.insert(1,+%22a%22);%0A++++%0A++++for+(key,+value)+in+map.iter()+%7B%0A++++++++println!(%22%7Bkey%7D:+%7Bvalue%7D%22);%0A++++%7D%0A++++%0A++++let+(first_key,+first_value)+=+map.iter().next().unwrap();%0A++++assert_eq!((*first_key,+*first_value),+(1,+%22a%22));%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2411)\n\nGets a mutable iterator over the entries of the map, sorted by key.\n\n##### [搂](#examples-28)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut map = BTreeMap::from([\n   (\"a\", 1),\n   (\"b\", 2),\n   (\"c\", 3),\n]);\n\n// add 10 to the value if the key isn't \"a\"\nfor (key, value) in map.iter_mut() {\n    if key != &\"a\" {\n        *value += 10;\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::from(%5B%0A+++++++(%22a%22,+1),%0A+++++++(%22b%22,+2),%0A+++++++(%22c%22,+3),%0A++++%5D);%0A++++%0A++++//+add+10+to+the+value+if+the+key+isn%27t+%22a%22%0A++++for+(key,+value)+in+map.iter_mut()+%7B%0A++++++++if+key+!=+%26%22a%22+%7B%0A++++++++++++*value+%2B=+10;%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2436)\n\nGets an iterator over the keys of the map, in sorted order.\n\n##### [搂](#examples-29)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(2, \"b\");\na.insert(1, \"a\");\n\nlet keys: Vec<_> = a.keys().cloned().collect();\nassert_eq!(keys, [1, 2]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(2,+%22b%22);%0A++++a.insert(1,+%22a%22);%0A++++%0A++++let+keys:+Vec%3C_%3E+=+a.keys().cloned().collect();%0A++++assert_eq!(keys,+%5B1,+2%5D);%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2455)\n\nGets an iterator over the values of the map, in order by key.\n\n##### [搂](#examples-30)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(1, \"hello\");\na.insert(2, \"goodbye\");\n\nlet values: Vec<&str> = a.values().cloned().collect();\nassert_eq!(values, [\"hello\", \"goodbye\"]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22hello%22);%0A++++a.insert(2,+%22goodbye%22);%0A++++%0A++++let+values:+Vec%3C%26str%3E+=+a.values().cloned().collect();%0A++++assert_eq!(values,+%5B%22hello%22,+%22goodbye%22%5D);%0A%7D&edition=2021)\n\n1.10.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2479)\n\nGets a mutable iterator over the values of the map, in order by key.\n\n##### [搂](#examples-31)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\na.insert(1, String::from(\"hello\"));\na.insert(2, String::from(\"goodbye\"));\n\nfor value in a.values_mut() {\n    value.push_str(\"!\");\n}\n\nlet values: Vec<String> = a.values().cloned().collect();\nassert_eq!(values, [String::from(\"hello!\"),\n                    String::from(\"goodbye!\")]);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+String::from(%22hello%22));%0A++++a.insert(2,+String::from(%22goodbye%22));%0A++++%0A++++for+value+in+a.values_mut()+%7B%0A++++++++value.push_str(%22!%22);%0A++++%7D%0A++++%0A++++let+values:+Vec%3CString%3E+=+a.values().cloned().collect();%0A++++assert_eq!(values,+%5BString::from(%22hello!%22),%0A++++++++++++++++++++++++String::from(%22goodbye!%22)%5D);%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/71835 \"Tracking issue for const_btree_len\")) 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2503)\n\nReturns the number of elements in the map.\n\n##### [搂](#examples-32)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\nassert_eq!(a.len(), 0);\na.insert(1, \"a\");\nassert_eq!(a.len(), 1);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++assert_eq!(a.len(),+0);%0A++++a.insert(1,+%22a%22);%0A++++assert_eq!(a.len(),+1);%0A%7D&edition=2021)\n\n1.0.0 (const: [unstable](https://github.com/rust-lang/rust/issues/71835 \"Tracking issue for const_btree_len\")) 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2526)\n\nReturns `true` if the map contains no elements.\n\n##### [搂](#examples-33)Examples\n\n```\nuse std::collections::BTreeMap;\n\nlet mut a = BTreeMap::new();\nassert!(a.is_empty());\na.insert(1, \"a\");\nassert!(!a.is_empty());\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++assert!(a.is_empty());%0A++++a.insert(1,+%22a%22);%0A++++assert!(!a.is_empty());%0A%7D&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2570-2573)\n\nThis is a nightly-only experimental API. (`btree_cursors`[#107540](https://github.com/rust-lang/rust/issues/107540))\n\nReturns a [`Cursor`](struct.Cursor.html \"struct std::collections::btree_map::Cursor\") pointing at the gap before the smallest key greater than the given bound.\n\nPassing `Bound::Included(x)` will return a cursor pointing to the gap before the smallest key greater than or equal to `x`.\n\nPassing `Bound::Excluded(x)` will return a cursor pointing to the gap before the smallest key greater than `x`.\n\nPassing `Bound::Unbounded` will return a cursor pointing to the gap before the smallest key in the map.\n\n##### [搂](#examples-34)Examples\n\n```\n#![feature(btree_cursors)]\n\nuse std::collections::BTreeMap;\nuse std::ops::Bound;\n\nlet map = BTreeMap::from([\n    (1, \"a\"),\n    (2, \"b\"),\n    (3, \"c\"),\n    (4, \"d\"),\n]);\n\nlet cursor = map.lower_bound(Bound::Included(&2));\nassert_eq!(cursor.peek_prev(), Some((&1, &\"a\")));\nassert_eq!(cursor.peek_next(), Some((&2, &\"b\")));\n\nlet cursor = map.lower_bound(Bound::Excluded(&2));\nassert_eq!(cursor.peek_prev(), Some((&2, &\"b\")));\nassert_eq!(cursor.peek_next(), Some((&3, &\"c\")));\n\nlet cursor = map.lower_bound(Bound::Unbounded);\nassert_eq!(cursor.peek_prev(), None);\nassert_eq!(cursor.peek_next(), Some((&1, &\"a\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+cursor+=+map.lower_bound(Bound::Included(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%261,+%26%22a%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%262,+%26%22b%22)));%0A++++%0A++++let+cursor+=+map.lower_bound(Bound::Excluded(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26%22c%22)));%0A++++%0A++++let+cursor+=+map.lower_bound(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+None);%0A++++assert_eq!(cursor.peek_next(),+Some((%261,+%26%22a%22)));%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2623-2626)\n\nThis is a nightly-only experimental API. (`btree_cursors`[#107540](https://github.com/rust-lang/rust/issues/107540))\n\nReturns a [`CursorMut`](struct.CursorMut.html \"struct std::collections::btree_map::CursorMut\") pointing at the gap before the smallest key greater than the given bound.\n\nPassing `Bound::Included(x)` will return a cursor pointing to the gap before the smallest key greater than or equal to `x`.\n\nPassing `Bound::Excluded(x)` will return a cursor pointing to the gap before the smallest key greater than `x`.\n\nPassing `Bound::Unbounded` will return a cursor pointing to the gap before the smallest key in the map.\n\n##### [搂](#examples-35)Examples\n\n```\n#![feature(btree_cursors)]\n\nuse std::collections::BTreeMap;\nuse std::ops::Bound;\n\nlet mut map = BTreeMap::from([\n    (1, \"a\"),\n    (2, \"b\"),\n    (3, \"c\"),\n    (4, \"d\"),\n]);\n\nlet mut cursor = map.lower_bound_mut(Bound::Included(&2));\nassert_eq!(cursor.peek_prev(), Some((&1, &mut \"a\")));\nassert_eq!(cursor.peek_next(), Some((&2, &mut \"b\")));\n\nlet mut cursor = map.lower_bound_mut(Bound::Excluded(&2));\nassert_eq!(cursor.peek_prev(), Some((&2, &mut \"b\")));\nassert_eq!(cursor.peek_next(), Some((&3, &mut \"c\")));\n\nlet mut cursor = map.lower_bound_mut(Bound::Unbounded);\nassert_eq!(cursor.peek_prev(), None);\nassert_eq!(cursor.peek_next(), Some((&1, &mut \"a\")));\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+mut+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+mut+cursor+=+map.lower_bound_mut(Bound::Included(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%261,+%26mut+%22a%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%262,+%26mut+%22b%22)));%0A++++%0A++++let+mut+cursor+=+map.lower_bound_mut(Bound::Excluded(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26mut+%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26mut+%22c%22)));%0A++++%0A++++let+mut+cursor+=+map.lower_bound_mut(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+None);%0A++++assert_eq!(cursor.peek_next(),+Some((%261,+%26mut+%22a%22)));%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2693-2696)\n\nThis is a nightly-only experimental API. (`btree_cursors`[#107540](https://github.com/rust-lang/rust/issues/107540))\n\nReturns a [`Cursor`](struct.Cursor.html \"struct std::collections::btree_map::Cursor\") pointing at the gap after the greatest key smaller than the given bound.\n\nPassing `Bound::Included(x)` will return a cursor pointing to the gap after the greatest key smaller than or equal to `x`.\n\nPassing `Bound::Excluded(x)` will return a cursor pointing to the gap after the greatest key smaller than `x`.\n\nPassing `Bound::Unbounded` will return a cursor pointing to the gap after the greatest key in the map.\n\n##### [搂](#examples-36)Examples\n\n```\n#![feature(btree_cursors)]\n\nuse std::collections::BTreeMap;\nuse std::ops::Bound;\n\nlet map = BTreeMap::from([\n    (1, \"a\"),\n    (2, \"b\"),\n    (3, \"c\"),\n    (4, \"d\"),\n]);\n\nlet cursor = map.upper_bound(Bound::Included(&3));\nassert_eq!(cursor.peek_prev(), Some((&3, &\"c\")));\nassert_eq!(cursor.peek_next(), Some((&4, &\"d\")));\n\nlet cursor = map.upper_bound(Bound::Excluded(&3));\nassert_eq!(cursor.peek_prev(), Some((&2, &\"b\")));\nassert_eq!(cursor.peek_next(), Some((&3, &\"c\")));\n\nlet cursor = map.upper_bound(Bound::Unbounded);\nassert_eq!(cursor.peek_prev(), Some((&4, &\"d\")));\nassert_eq!(cursor.peek_next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+cursor+=+map.upper_bound(Bound::Included(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%263,+%26%22c%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%264,+%26%22d%22)));%0A++++%0A++++let+cursor+=+map.upper_bound(Bound::Excluded(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26%22c%22)));%0A++++%0A++++let+cursor+=+map.upper_bound(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+Some((%264,+%26%22d%22)));%0A++++assert_eq!(cursor.peek_next(),+None);%0A%7D&version=nightly&edition=2021)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2746-2749)\n\nThis is a nightly-only experimental API. (`btree_cursors`[#107540](https://github.com/rust-lang/rust/issues/107540))\n\nReturns a [`CursorMut`](struct.CursorMut.html \"struct std::collections::btree_map::CursorMut\") pointing at the gap after the greatest key smaller than the given bound.\n\nPassing `Bound::Included(x)` will return a cursor pointing to the gap after the greatest key smaller than or equal to `x`.\n\nPassing `Bound::Excluded(x)` will return a cursor pointing to the gap after the greatest key smaller than `x`.\n\nPassing `Bound::Unbounded` will return a cursor pointing to the gap after the greatest key in the map.\n\n##### [搂](#examples-37)Examples\n\n```\n#![feature(btree_cursors)]\n\nuse std::collections::BTreeMap;\nuse std::ops::Bound;\n\nlet mut map = BTreeMap::from([\n    (1, \"a\"),\n    (2, \"b\"),\n    (3, \"c\"),\n    (4, \"d\"),\n]);\n\nlet mut cursor = map.upper_bound_mut(Bound::Included(&3));\nassert_eq!(cursor.peek_prev(), Some((&3, &mut \"c\")));\nassert_eq!(cursor.peek_next(), Some((&4, &mut \"d\")));\n\nlet mut cursor = map.upper_bound_mut(Bound::Excluded(&3));\nassert_eq!(cursor.peek_prev(), Some((&2, &mut \"b\")));\nassert_eq!(cursor.peek_next(), Some((&3, &mut \"c\")));\n\nlet mut cursor = map.upper_bound_mut(Bound::Unbounded);\nassert_eq!(cursor.peek_prev(), Some((&4, &mut \"d\")));\nassert_eq!(cursor.peek_next(), None);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+mut+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+mut+cursor+=+map.upper_bound_mut(Bound::Included(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%263,+%26mut+%22c%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%264,+%26mut+%22d%22)));%0A++++%0A++++let+mut+cursor+=+map.upper_bound_mut(Bound::Excluded(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26mut+%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26mut+%22c%22)));%0A++++%0A++++let+mut+cursor+=+map.upper_bound_mut(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+Some((%264,+%26mut+%22d%22)));%0A++++assert_eq!(cursor.peek_next(),+None);%0A%7D&version=nightly&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#207)[搂](#impl-Clone-for-BTreeMap%3CK,+V,+A%3E)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2312)[搂](#impl-Debug-for-BTreeMap%3CK,+V,+A%3E)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2278)[搂](#impl-Default-for-BTreeMap%3CK,+V%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2280)[搂](#method.default)\n\nCreates an empty `BTreeMap`.\n\n1.7.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#187)[搂](#impl-Drop-for-BTreeMap%3CK,+V,+A%3E)\n\n1.2.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2254-2255)[搂](#impl-Extend%3C(%26K,+%26V)%3E-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2257)[搂](#method.extend-1)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2262)[搂](#method.extend_one-1)\n\nThis is a nightly-only experimental API. (`extend_one`[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461)[搂](#method.extend_reserve-1)\n\nThis is a nightly-only experimental API. (`extend_one`[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2239)[搂](#impl-Extend%3C(K,+V)%3E-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2241)[搂](#method.extend)\n\nExtends a collection with the contents of an iterator. [Read more](about:blank/iter/trait.Extend.html#tymethod.extend)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2248)[搂](#method.extend_one)\n\nThis is a nightly-only experimental API. (`extend_one`[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nExtends a collection with exactly one element.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461)[搂](#method.extend_reserve)\n\nThis is a nightly-only experimental API. (`extend_one`[#72631](https://github.com/rust-lang/rust/issues/72631))\n\nReserves capacity in a collection for the given number of additional elements. [Read more](about:blank/iter/trait.Extend.html#method.extend_reserve)\n\n1.56.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2338)[搂](#impl-From%3C%5B(K,+V);+N%5D%3E-for-BTreeMap%3CK,+V%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2348)[搂](#method.from)\n\nConverts a `[(K, V); N]` into a `BTreeMap<(K, V)>`.\n\n```\nuse std::collections::BTreeMap;\n\nlet map1 = BTreeMap::from([(1, 2), (3, 4)]);\nlet map2: BTreeMap<_, _> = [(1, 2), (3, 4)].into();\nassert_eq!(map1, map2);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+map1+=+BTreeMap::from(%5B(1,+2),+(3,+4)%5D);%0A++++let+map2:+BTreeMap%3C_,+_%3E+=+%5B(1,+2),+(3,+4)%5D.into();%0A++++assert_eq!(map1,+map2);%0A%7D&edition=2021)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2224)[搂](#impl-FromIterator%3C(K,+V)%3E-for-BTreeMap%3CK,+V%3E)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2268)[搂](#impl-Hash-for-BTreeMap%3CK,+V,+A%3E)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2319-2322)[搂](#impl-Index%3C%26Q%3E-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2332)[搂](#method.index)\n\nReturns a reference to the value corresponding to the supplied key.\n\n##### [搂](#panics-2)Panics\n\nPanics if the key is not present in the `BTreeMap`.\n\n[搂](#associatedtype.Output)\n\nThe returned type after indexing.\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1485)[搂](#impl-IntoIterator-for-%26BTreeMap%3CK,+V,+A%3E)\n\n[搂](#associatedtype.Item-1)\n\nThe type of the elements being iterated over.\n\n[搂](#associatedtype.IntoIter-1)\n\nWhich kind of iterator are we turning this into?\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1489)[搂](#method.into_iter-1)\n\nCreates an iterator from a value. [Read more](about:blank/iter/trait.IntoIterator.html#tymethod.into_iter)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1560)[搂](#impl-IntoIterator-for-%26mut+BTreeMap%3CK,+V,+A%3E)\n\n[搂](#associatedtype.Item-2)\n\nThe type of the elements being iterated over.\n\n[搂](#associatedtype.IntoIter-2)\n\nWhich kind of iterator are we turning this into?\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1564)[搂](#method.into_iter-2)\n\nCreates an iterator from a value. [Read more](about:blank/iter/trait.IntoIterator.html#tymethod.into_iter)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1636)[搂](#impl-IntoIterator-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1641)[搂](#method.into_iter)\n\nGets an owning iterator over the entries of the map, sorted by key.\n\n[搂](#associatedtype.Item)\n\nThe type of the elements being iterated over.\n\n[搂](#associatedtype.IntoIter)\n\nWhich kind of iterator are we turning this into?\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2304)[搂](#impl-Ord-for-BTreeMap%3CK,+V,+A%3E)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2286)[搂](#impl-PartialEq-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2287)[搂](#method.eq)\n\nThis method tests for `self` and `other` values to be equal, and is used by `==`.\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263)[搂](#method.ne)\n\nThis method tests for `!=`. The default implementation is almost always sufficient, and should not be overridden without very good reason.\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2296)[搂](#impl-PartialOrd-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2298)[搂](#method.partial_cmp)\n\nThis method returns an ordering between `self` and `other` values if one exists. [Read more](about:blank/cmp/trait.PartialOrd.html#tymethod.partial_cmp)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180)[搂](#method.lt)\n\nThis method tests less than (for `self` and `other`) and is used by the `<` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.lt)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198)[搂](#method.le)\n\nThis method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.le)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215)[搂](#method.gt)\n\nThis method tests greater than (for `self` and `other`) and is used by the `>` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.gt)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233)[搂](#method.ge)\n\nThis method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator. [Read more](about:blank/cmp/trait.PartialOrd.html#method.ge)\n\n1.0.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2293)[搂](#impl-Eq-for-BTreeMap%3CK,+V,+A%3E)\n\n1.64.0 路 [source](https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#198-202)[搂](#impl-UnwindSafe-for-BTreeMap%3CK,+V,+A%3E)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140)[搂](#impl-Any-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208)[搂](#impl-Borrow%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216)[搂](#impl-BorrowMut%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765)[搂](#impl-From%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768)[搂](#method.from-1)\n\nReturns the argument unchanged.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750)[搂](#impl-Into%3CU%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758)[搂](#method.into)\n\nCalls `U::from(self)`.\n\nThat is, this conversion is whatever the implementation of `[From](../../convert/trait.From.html \"trait std::convert::From\")<T> for U` chooses to do.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85)[搂](#impl-ToOwned-for-T)\n\n[搂](#associatedtype.Owned)\n\nThe resulting type after obtaining ownership.\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88)[搂](#method.to_owned)\n\nCreates owned data from borrowed data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#tymethod.to_owned)\n\n[source](https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92)[搂](#method.clone_into)\n\nUses borrowed data to replace owned data, usually by cloning. [Read more](about:blank/borrow/trait.ToOwned.html#method.clone_into)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807)[搂](#impl-TryFrom%3CU%3E-for-T)\n\n[搂](#associatedtype.Error-1)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812)[搂](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792)[搂](#impl-TryInto%3CU%3E-for-T)\n\n[搂](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797)[搂](#method.try_into)\n\nPerforms the conversion.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"An ordered map based on a B-Tree.\"><title>BTreeMap in std::collections::btree_map - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../\" data-static-root-path=\"../../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">BTreeMap</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">BTreeMap</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.append\">append</a></li><li><a href=\"#method.clear\">clear</a></li><li><a href=\"#method.contains_key\">contains_key</a></li><li><a href=\"#method.entry\">entry</a></li><li><a href=\"#method.extract_if\">extract_if</a></li><li><a href=\"#method.first_entry\">first_entry</a></li><li><a href=\"#method.first_key_value\">first_key_value</a></li><li><a href=\"#method.get\">get</a></li><li><a href=\"#method.get_key_value\">get_key_value</a></li><li><a href=\"#method.get_mut\">get_mut</a></li><li><a href=\"#method.insert\">insert</a></li><li><a href=\"#method.into_keys\">into_keys</a></li><li><a href=\"#method.into_values\">into_values</a></li><li><a href=\"#method.is_empty\">is_empty</a></li><li><a href=\"#method.iter\">iter</a></li><li><a href=\"#method.iter_mut\">iter_mut</a></li><li><a href=\"#method.keys\">keys</a></li><li><a href=\"#method.last_entry\">last_entry</a></li><li><a href=\"#method.last_key_value\">last_key_value</a></li><li><a href=\"#method.len\">len</a></li><li><a href=\"#method.lower_bound\">lower_bound</a></li><li><a href=\"#method.lower_bound_mut\">lower_bound_mut</a></li><li><a href=\"#method.new\">new</a></li><li><a href=\"#method.new_in\">new_in</a></li><li><a href=\"#method.pop_first\">pop_first</a></li><li><a href=\"#method.pop_last\">pop_last</a></li><li><a href=\"#method.range\">range</a></li><li><a href=\"#method.range_mut\">range_mut</a></li><li><a href=\"#method.remove\">remove</a></li><li><a href=\"#method.remove_entry\">remove_entry</a></li><li><a href=\"#method.retain\">retain</a></li><li><a href=\"#method.split_off\">split_off</a></li><li><a href=\"#method.try_insert\">try_insert</a></li><li><a href=\"#method.upper_bound\">upper_bound</a></li><li><a href=\"#method.upper_bound_mut\">upper_bound_mut</a></li><li><a href=\"#method.values\">values</a></li><li><a href=\"#method.values_mut\">values_mut</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-Clone-for-BTreeMap%3CK,+V,+A%3E\">Clone</a></li><li><a href=\"#impl-Debug-for-BTreeMap%3CK,+V,+A%3E\">Debug</a></li><li><a href=\"#impl-Default-for-BTreeMap%3CK,+V%3E\">Default</a></li><li><a href=\"#impl-Drop-for-BTreeMap%3CK,+V,+A%3E\">Drop</a></li><li><a href=\"#impl-Eq-for-BTreeMap%3CK,+V,+A%3E\">Eq</a></li><li><a href=\"#impl-Extend%3C(%26K,+%26V)%3E-for-BTreeMap%3CK,+V,+A%3E\">Extend&lt;(&amp;'a K, &amp;'a V)&gt;</a></li><li><a href=\"#impl-Extend%3C(K,+V)%3E-for-BTreeMap%3CK,+V,+A%3E\">Extend&lt;(K, V)&gt;</a></li><li><a href=\"#impl-From%3C%5B(K,+V);+N%5D%3E-for-BTreeMap%3CK,+V%3E\">From&lt;[(K, V); N]&gt;</a></li><li><a href=\"#impl-FromIterator%3C(K,+V)%3E-for-BTreeMap%3CK,+V%3E\">FromIterator&lt;(K, V)&gt;</a></li><li><a href=\"#impl-Hash-for-BTreeMap%3CK,+V,+A%3E\">Hash</a></li><li><a href=\"#impl-Index%3C%26Q%3E-for-BTreeMap%3CK,+V,+A%3E\">Index&lt;&amp;Q&gt;</a></li><li><a href=\"#impl-IntoIterator-for-%26BTreeMap%3CK,+V,+A%3E\">IntoIterator</a></li><li><a href=\"#impl-IntoIterator-for-%26mut+BTreeMap%3CK,+V,+A%3E\">IntoIterator</a></li><li><a href=\"#impl-IntoIterator-for-BTreeMap%3CK,+V,+A%3E\">IntoIterator</a></li><li><a href=\"#impl-Ord-for-BTreeMap%3CK,+V,+A%3E\">Ord</a></li><li><a href=\"#impl-PartialEq-for-BTreeMap%3CK,+V,+A%3E\">PartialEq</a></li><li><a href=\"#impl-PartialOrd-for-BTreeMap%3CK,+V,+A%3E\">PartialOrd</a></li><li><a href=\"#impl-UnwindSafe-for-BTreeMap%3CK,+V,+A%3E\">UnwindSafe</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-BTreeMap%3CK,+V,+A%3E\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-BTreeMap%3CK,+V,+A%3E\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-BTreeMap%3CK,+V,+A%3E\">Send</a></li><li><a href=\"#impl-Sync-for-BTreeMap%3CK,+V,+A%3E\">Sync</a></li><li><a href=\"#impl-Unpin-for-BTreeMap%3CK,+V,+A%3E\">Unpin</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-ToOwned-for-T\">ToOwned</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::collections::btree_map</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.BTreeMap.html\">BTreeMap</a></li><li><a href=\"struct.Cursor.html\">Cursor</a></li><li><a href=\"struct.CursorMut.html\">CursorMut</a></li><li><a href=\"struct.CursorMutKey.html\">CursorMutKey</a></li><li><a href=\"struct.ExtractIf.html\">ExtractIf</a></li><li><a href=\"struct.IntoIter.html\">IntoIter</a></li><li><a href=\"struct.IntoKeys.html\">IntoKeys</a></li><li><a href=\"struct.IntoValues.html\">IntoValues</a></li><li><a href=\"struct.Iter.html\">Iter</a></li><li><a href=\"struct.IterMut.html\">IterMut</a></li><li><a href=\"struct.Keys.html\">Keys</a></li><li><a href=\"struct.OccupiedEntry.html\">OccupiedEntry</a></li><li><a href=\"struct.OccupiedError.html\">OccupiedError</a></li><li><a href=\"struct.Range.html\">Range</a></li><li><a href=\"struct.RangeMut.html\">RangeMut</a></li><li><a href=\"struct.UnorderedKeyError.html\">UnorderedKeyError</a></li><li><a href=\"struct.VacantEntry.html\">VacantEntry</a></li><li><a href=\"struct.Values.html\">Values</a></li><li><a href=\"struct.ValuesMut.html\">ValuesMut</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.Entry.html\">Entry</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type S or / to search, ? for more options\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../../index.html\">std</a>::<wbr><a href=\"../index.html\">collections</a>::<wbr><a href=\"index.html\">btree_map</a>::<wbr><a class=\"struct\" href=\"#\">BTreeMap</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#173-177\">source</a> 路 <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span></span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct BTreeMap&lt;K, V, A = <a class=\"struct\" href=\"../../alloc/struct.Global.html\" title=\"struct std::alloc::Global\">Global</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div>{ <span class=\"comment\">/* private fields */</span> }</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>An ordered map based on a <a href=\"https://en.wikipedia.org/wiki/B-tree\">B-Tree</a>.</p>\n<p>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\nthe amount of work performed in a search. In theory, a binary search tree (BST) is the optimal\nchoice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of\ncomparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this\nis done is <em>very</em> inefficient for modern computer architectures. In particular, every element\nis stored in its own individually heap-allocated node. This means that every single insertion\ntriggers a heap-allocation, and every single comparison should be a cache-miss. Since these\nare both notably expensive things to do in practice, we are forced to, at the very least,\nreconsider the BST strategy.</p>\n<p>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing\nthis, we reduce the number of allocations by a factor of B, and improve cache efficiency in\nsearches. However, this does mean that searches will have to do <em>more</em> comparisons on average.\nThe precise number of comparisons depends on the node search strategy used. For optimal cache\nefficiency, one could search the nodes linearly. For optimal comparisons, one could search\nthe node using binary search. As a compromise, one could also perform a linear search\nthat initially only checks every i<sup>th</sup> element for some choice of i.</p>\n<p>Currently, our implementation simply performs naive linear search. This provides excellent\nperformance on <em>small</em> nodes of elements which are cheap to compare. However in the future we\nwould like to further explore choosing the optimal search strategy based on the choice of B,\nand possibly other factors. Using linear search, searching for a random element is expected\nto take B * log(n) comparisons, which is generally worse than a BST. In practice,\nhowever, performance is excellent.</p>\n<p>It is a logic error for a key to be modified in such a way that the keys ordering relative to\nany other key, as determined by the <a href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\"><code>Ord</code></a> trait, changes while it is in the map. This is\nnormally only possible through <a href=\"../../cell/struct.Cell.html\" title=\"struct std::cell::Cell\"><code>Cell</code></a>, <a href=\"../../cell/struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell</code></a>, global state, I/O, or unsafe code.\nThe behavior resulting from such a logic error is not specified, but will be encapsulated to the\n<code>BTreeMap</code> that observed the logic error and not result in undefined behavior. This could\ninclude panics, incorrect results, aborts, memory leaks, and non-termination.</p>\n<p>Iterators obtained from functions such as <a href=\"../struct.BTreeMap.html#method.iter\" title=\"method std::collections::BTreeMap::iter\"><code>BTreeMap::iter</code></a>, <a href=\"../struct.BTreeMap.html#method.into_iter\" title=\"method std::collections::BTreeMap::into_iter\"><code>BTreeMap::into_iter</code></a>, <a href=\"../struct.BTreeMap.html#method.values\" title=\"method std::collections::BTreeMap::values\"><code>BTreeMap::values</code></a>, or\n<a href=\"../struct.BTreeMap.html#method.keys\" title=\"method std::collections::BTreeMap::keys\"><code>BTreeMap::keys</code></a> produce their items in order by key, and take worst-case logarithmic and\namortized constant time per item returned.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">搂</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"comment\">// type inference lets us omit an explicit type signature (which\n// would be `BTreeMap&lt;&amp;str, &amp;str&gt;` in this example).\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>movie_reviews = BTreeMap::new();\n\n<span class=\"comment\">// review some movies.\n</span>movie_reviews.insert(<span class=\"string\">\"Office Space\"</span>,       <span class=\"string\">\"Deals with real issues in the workplace.\"</span>);\nmovie_reviews.insert(<span class=\"string\">\"Pulp Fiction\"</span>,       <span class=\"string\">\"Masterpiece.\"</span>);\nmovie_reviews.insert(<span class=\"string\">\"The Godfather\"</span>,      <span class=\"string\">\"Very enjoyable.\"</span>);\nmovie_reviews.insert(<span class=\"string\">\"The Blues Brothers\"</span>, <span class=\"string\">\"Eye lyked it a lot.\"</span>);\n\n<span class=\"comment\">// check for a specific one.\n</span><span class=\"kw\">if </span>!movie_reviews.contains_key(<span class=\"string\">\"Les Mis茅rables\"</span>) {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"We've got {} reviews, but Les Mis茅rables ain't one.\"</span>,\n             movie_reviews.len());\n}\n\n<span class=\"comment\">// oops, this review has a lot of spelling mistakes, let's delete it.\n</span>movie_reviews.remove(<span class=\"string\">\"The Blues Brothers\"</span>);\n\n<span class=\"comment\">// look up the values associated with some keys.\n</span><span class=\"kw\">let </span>to_find = [<span class=\"string\">\"Up!\"</span>, <span class=\"string\">\"Office Space\"</span>];\n<span class=\"kw\">for </span>movie <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>to_find {\n    <span class=\"kw\">match </span>movie_reviews.get(movie) {\n       <span class=\"prelude-val\">Some</span>(review) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"{movie}: {review}\"</span>),\n       <span class=\"prelude-val\">None </span>=&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"{movie} is unreviewed.\"</span>)\n    }\n}\n\n<span class=\"comment\">// Look up the value for a key (will panic if the key is not found).\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"Movie review: {}\"</span>, movie_reviews[<span class=\"string\">\"Office Space\"</span>]);\n\n<span class=\"comment\">// iterate over everything.\n</span><span class=\"kw\">for </span>(movie, review) <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>movie_reviews {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{movie}: \\\"{review}\\\"\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++//+type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BTreeMap%3C%26str,+%26str%3E%60+in+this+example).%0A++++let+mut+movie_reviews+=+BTreeMap::new();%0A++++%0A++++//+review+some+movies.%0A++++movie_reviews.insert(%22Office+Space%22,+++++++%22Deals+with+real+issues+in+the+workplace.%22);%0A++++movie_reviews.insert(%22Pulp+Fiction%22,+++++++%22Masterpiece.%22);%0A++++movie_reviews.insert(%22The+Godfather%22,++++++%22Very+enjoyable.%22);%0A++++movie_reviews.insert(%22The+Blues+Brothers%22,+%22Eye+lyked+it+a+lot.%22);%0A++++%0A++++//+check+for+a+specific+one.%0A++++if+!movie_reviews.contains_key(%22Les+Mis%C3%A9rables%22)+%7B%0A++++++++println!(%22We've+got+%7B%7D+reviews,+but+Les+Mis%C3%A9rables+ain't+one.%22,%0A+++++++++++++++++movie_reviews.len());%0A++++%7D%0A++++%0A++++//+oops,+this+review+has+a+lot+of+spelling+mistakes,+let's+delete+it.%0A++++movie_reviews.remove(%22The+Blues+Brothers%22);%0A++++%0A++++//+look+up+the+values+associated+with+some+keys.%0A++++let+to_find+=+%5B%22Up!%22,+%22Office+Space%22%5D;%0A++++for+movie+in+%26to_find+%7B%0A++++++++match+movie_reviews.get(movie)+%7B%0A+++++++++++Some(review)+=%3E+println!(%22%7Bmovie%7D:+%7Breview%7D%22),%0A+++++++++++None+=%3E+println!(%22%7Bmovie%7D+is+unreviewed.%22)%0A++++++++%7D%0A++++%7D%0A++++%0A++++//+Look+up+the+value+for+a+key+(will+panic+if+the+key+is+not+found).%0A++++println!(%22Movie+review:+%7B%7D%22,+movie_reviews%5B%22Office+Space%22%5D);%0A++++%0A++++//+iterate+over+everything.%0A++++for+(movie,+review)+in+%26movie_reviews+%7B%0A++++++++println!(%22%7Bmovie%7D:+%5C%22%7Breview%7D%5C%22%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>A <code>BTreeMap</code> with a known list of items can be initialized from an array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span>solar_distance = BTreeMap::from([\n    (<span class=\"string\">\"Mercury\"</span>, <span class=\"number\">0.4</span>),\n    (<span class=\"string\">\"Venus\"</span>, <span class=\"number\">0.7</span>),\n    (<span class=\"string\">\"Earth\"</span>, <span class=\"number\">1.0</span>),\n    (<span class=\"string\">\"Mars\"</span>, <span class=\"number\">1.5</span>),\n]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+solar_distance+=+BTreeMap::from(%5B%0A++++++++(%22Mercury%22,+0.4),%0A++++++++(%22Venus%22,+0.7),%0A++++++++(%22Earth%22,+1.0),%0A++++++++(%22Mars%22,+1.5),%0A++++%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n<p><code>BTreeMap</code> implements an <a href=\"../struct.BTreeMap.html#method.entry\" title=\"method std::collections::BTreeMap::entry\"><code>Entry API</code></a>, which allows for complex\nmethods of getting, setting, updating and removing keys and their values:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"comment\">// type inference lets us omit an explicit type signature (which\n// would be `BTreeMap&lt;&amp;str, u8&gt;` in this example).\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>player_stats = BTreeMap::new();\n\n<span class=\"kw\">fn </span>random_stat_buff() -&gt; u8 {\n    <span class=\"comment\">// could actually return some random value here - let's just return\n    // some fixed value for now\n    </span><span class=\"number\">42\n</span>}\n\n<span class=\"comment\">// insert a key only if it doesn't already exist\n</span>player_stats.entry(<span class=\"string\">\"health\"</span>).or_insert(<span class=\"number\">100</span>);\n\n<span class=\"comment\">// insert a key using a function that provides a new value only if it\n// doesn't already exist\n</span>player_stats.entry(<span class=\"string\">\"defence\"</span>).or_insert_with(random_stat_buff);\n\n<span class=\"comment\">// update a key, guarding against the key possibly not being set\n</span><span class=\"kw\">let </span>stat = player_stats.entry(<span class=\"string\">\"attack\"</span>).or_insert(<span class=\"number\">100</span>);\n<span class=\"kw-2\">*</span>stat += random_stat_buff();\n\n<span class=\"comment\">// modify an entry before an insert with in-place mutation\n</span>player_stats.entry(<span class=\"string\">\"mana\"</span>).and_modify(|mana| <span class=\"kw-2\">*</span>mana += <span class=\"number\">200</span>).or_insert(<span class=\"number\">100</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++//+type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BTreeMap%3C%26str,+u8%3E%60+in+this+example).%0A++++let+mut+player_stats+=+BTreeMap::new();%0A++++%0A++++fn+random_stat_buff()+-%3E+u8+%7B%0A++++++++//+could+actually+return+some+random+value+here+-+let's+just+return%0A++++++++//+some+fixed+value+for+now%0A++++++++42%0A++++%7D%0A++++%0A++++//+insert+a+key+only+if+it+doesn't+already+exist%0A++++player_stats.entry(%22health%22).or_insert(100);%0A++++%0A++++//+insert+a+key+using+a+function+that+provides+a+new+value+only+if+it%0A++++//+doesn't+already+exist%0A++++player_stats.entry(%22defence%22).or_insert_with(random_stat_buff);%0A++++%0A++++//+update+a+key,+guarding+against+the+key+possibly+not+being+set%0A++++let+stat+=+player_stats.entry(%22attack%22).or_insert(100);%0A++++*stat+%2B=+random_stat_buff();%0A++++%0A++++//+modify+an+entry+before+an+insert+with+in-place+mutation%0A++++player_stats.entry(%22mana%22).and_modify(%7Cmana%7C+*mana+%2B=+200).or_insert(100);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">搂</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BTreeMap%3CK,+V%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#610\">source</a><a href=\"#impl-BTreeMap%3CK,+V%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.66.0\">1.0.0 (const: 1.66.0)</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#629\">source</a></span><h4 class=\"code-header\">pub const fn <a href=\"#method.new\" class=\"fn\">new</a>() -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;</h4></section></summary><div class=\"docblock\"><p>Makes a new, empty <code>BTreeMap</code>.</p>\n<p>Does not allocate anything on its own.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\n\n<span class=\"comment\">// entries can now be inserted into the empty map\n</span>map.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++%0A++++//+entries+can+now+be+inserted+into+the+empty+map%0A++++map.insert(1,+%22a%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#634\">source</a><a href=\"#impl-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clear\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#648\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.clear\" class=\"fn\">clear</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Clears the map, removing all elements.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\na.clear();\n<span class=\"macro\">assert!</span>(a.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22a%22);%0A++++a.clear();%0A++++assert!(a.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.new_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#674\">source</a><h4 class=\"code-header\">pub const fn <a href=\"#method.new_in\" class=\"fn\">new_in</a>(alloc: A) -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>btreemap_alloc</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/32838\">#32838</a>)</span></div></span></summary><div class=\"docblock\"><p>Makes a new empty BTreeMap with a reasonable choice for B.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::alloc::Global;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new_in(Global);\n\n<span class=\"comment\">// entries can now be inserted into the empty map\n</span>map.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%23!%5Bfeature(btreemap_alloc)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::alloc::Global;%0A++++%0A++++let+mut+map+=+BTreeMap::new_in(Global);%0A++++%0A++++//+entries+can+now+be+inserted+into+the+empty+map%0A++++map.insert(1,+%22a%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BTreeMap%3CK,+V,+A%3E-1\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#679\">source</a><a href=\"#impl-BTreeMap%3CK,+V,+A%3E-1\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#696-699\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get\" class=\"fn\">get</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;V</a>&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns a reference to the value corresponding to the key.</p>\n<p>The key may be any borrowed form of the maps key type, but the ordering\non the borrowed form <em>must</em> match the ordering on the key type.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.get(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>));\n<span class=\"macro\">assert_eq!</span>(map.get(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.get(%261),+Some(%26%22a%22));%0A++++assert_eq!(map.get(%262),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_key_value\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0\">1.40.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#724-727\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get_key_value\" class=\"fn\">get_key_value</a>&lt;Q&gt;(&amp;self, k: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;V</a>)&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the key-value pair corresponding to the supplied key.</p>\n<p>The supplied key may be any borrowed form of the maps key type, but the ordering\non the borrowed form <em>must</em> match the ordering on the key type.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.get_key_value(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>)));\n<span class=\"macro\">assert_eq!</span>(map.get_key_value(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.get_key_value(%261),+Some((%261,+%26%22a%22)));%0A++++assert_eq!(map.get_key_value(%262),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.first_key_value\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.66.0\">1.66.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#751-753\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.first_key_value\" class=\"fn\">first_key_value</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;V</a>)&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the first key-value pair in the map.\nThe key in this pair is the minimum key in the map.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\n<span class=\"macro\">assert_eq!</span>(map.first_key_value(), <span class=\"prelude-val\">None</span>);\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.first_key_value(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"b\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++assert_eq!(map.first_key_value(),+None);%0A++++map.insert(1,+%22b%22);%0A++++map.insert(2,+%22a%22);%0A++++assert_eq!(map.first_key_value(),+Some((%261,+%26%22b%22)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.first_entry\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.66.0\">1.66.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#779-781\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.first_entry\" class=\"fn\">first_entry</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.OccupiedEntry.html\" title=\"struct std::collections::btree_map::OccupiedEntry\">OccupiedEntry</a>&lt;'_, K, V, A&gt;&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the first entry in the map for in-place manipulation.\nThe key of this entry is the minimum key in the map.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">mut </span>entry) = map.first_entry() {\n    <span class=\"kw\">if </span><span class=\"kw-2\">*</span>entry.key() &gt; <span class=\"number\">0 </span>{\n        entry.insert(<span class=\"string\">\"first\"</span>);\n    }\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>map.get(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>).unwrap(), <span class=\"string\">\"first\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>map.get(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>).unwrap(), <span class=\"string\">\"b\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++if+let+Some(mut+entry)+=+map.first_entry()+%7B%0A++++++++if+*entry.key()+%3E+0+%7B%0A++++++++++++entry.insert(%22first%22);%0A++++++++%7D%0A++++%7D%0A++++assert_eq!(*map.get(%261).unwrap(),+%22first%22);%0A++++assert_eq!(*map.get(%262).unwrap(),+%22b%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pop_first\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.66.0\">1.66.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#813-815\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pop_first\" class=\"fn\">pop_first</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Removes and returns the first element in the map.\nThe key of this element is the minimum key that was in the map.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">搂</a>Examples</h5>\n<p>Draining elements in ascending order, while keeping a usable map each iteration.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\n<span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>((key, _val)) = map.pop_first() {\n    <span class=\"macro\">assert!</span>(map.iter().all(|(k, _v)| <span class=\"kw-2\">*</span>k &gt; key));\n}\n<span class=\"macro\">assert!</span>(map.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++while+let+Some((key,+_val))+=+map.pop_first()+%7B%0A++++++++assert!(map.iter().all(%7C(k,+_v)%7C+*k+%3E+key));%0A++++%7D%0A++++assert!(map.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.last_key_value\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.66.0\">1.66.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#834-836\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.last_key_value\" class=\"fn\">last_key_value</a>(&amp;self) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;V</a>)&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the last key-value pair in the map.\nThe key in this pair is the maximum key in the map.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.last_key_value(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22b%22);%0A++++map.insert(2,+%22a%22);%0A++++assert_eq!(map.last_key_value(),+Some((%262,+%26%22a%22)));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.last_entry\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.66.0\">1.66.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#862-864\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.last_entry\" class=\"fn\">last_entry</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.OccupiedEntry.html\" title=\"struct std::collections::btree_map::OccupiedEntry\">OccupiedEntry</a>&lt;'_, K, V, A&gt;&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the last entry in the map for in-place manipulation.\nThe key of this entry is the maximum key in the map.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">mut </span>entry) = map.last_entry() {\n    <span class=\"kw\">if </span><span class=\"kw-2\">*</span>entry.key() &gt; <span class=\"number\">0 </span>{\n        entry.insert(<span class=\"string\">\"last\"</span>);\n    }\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>map.get(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>).unwrap(), <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>map.get(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>).unwrap(), <span class=\"string\">\"last\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++if+let+Some(mut+entry)+=+map.last_entry()+%7B%0A++++++++if+*entry.key()+%3E+0+%7B%0A++++++++++++entry.insert(%22last%22);%0A++++++++%7D%0A++++%7D%0A++++assert_eq!(*map.get(%261).unwrap(),+%22a%22);%0A++++assert_eq!(*map.get(%262).unwrap(),+%22last%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pop_last\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.66.0\">1.66.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#896-898\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pop_last\" class=\"fn\">pop_last</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Removes and returns the last element in the map.\nThe key of this element is the maximum key that was in the map.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">搂</a>Examples</h5>\n<p>Draining elements in descending order, while keeping a usable map each iteration.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\n<span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>((key, _val)) = map.pop_last() {\n    <span class=\"macro\">assert!</span>(map.iter().all(|(k, _v)| <span class=\"kw-2\">*</span>k &lt; key));\n}\n<span class=\"macro\">assert!</span>(map.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++map.insert(2,+%22b%22);%0A++++while+let+Some((key,+_val))+=+map.pop_last()+%7B%0A++++++++assert!(map.iter().all(%7C(k,+_v)%7C+*k+%3C+key));%0A++++%7D%0A++++assert!(map.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.contains_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#919-922\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.contains_key\" class=\"fn\">contains_key</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a><div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the map contains a value for the specified key.</p>\n<p>The key may be any borrowed form of the maps key type, but the ordering\non the borrowed form <em>must</em> match the ordering on the key type.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.contains_key(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert_eq!</span>(map.contains_key(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>), <span class=\"bool-val\">false</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.contains_key(%261),+true);%0A++++assert_eq!(map.contains_key(%262),+false);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#946-949\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.get_mut\" class=\"fn\">get_mut</a>&lt;Q&gt;(&amp;mut self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut V</a>&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the value corresponding to the key.</p>\n<p>The key may be any borrowed form of the maps key type, but the ordering\non the borrowed form <em>must</em> match the ordering on the key type.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(x) = map.get_mut(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>) {\n    <span class=\"kw-2\">*</span>x = <span class=\"string\">\"b\"</span>;\n}\n<span class=\"macro\">assert_eq!</span>(map[<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>], <span class=\"string\">\"b\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++if+let+Some(x)+=+map.get_mut(%261)+%7B%0A++++++++*x+=+%22b%22;%0A++++%7D%0A++++assert_eq!(map%5B%261%5D,+%22b%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.insert\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#984-986\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.insert\" class=\"fn\">insert</a>(&amp;mut self, key: K, value: V) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Inserts a key-value pair into the map.</p>\n<p>If the map did not have this key present, <code>None</code> is returned.</p>\n<p>If the map did have this key present, the value is updated, and the old\nvalue is returned. The key is not updated, though; this matters for\ntypes that can be <code>==</code> without being identical. See the <a href=\"index.html#insert-and-complex-keys\">module-level\ndocumentation</a> for more.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\n<span class=\"macro\">assert_eq!</span>(map.insert(<span class=\"number\">37</span>, <span class=\"string\">\"a\"</span>), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(map.is_empty(), <span class=\"bool-val\">false</span>);\n\nmap.insert(<span class=\"number\">37</span>, <span class=\"string\">\"b\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.insert(<span class=\"number\">37</span>, <span class=\"string\">\"c\"</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"b\"</span>));\n<span class=\"macro\">assert_eq!</span>(map[<span class=\"kw-2\">&amp;</span><span class=\"number\">37</span>], <span class=\"string\">\"c\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++assert_eq!(map.insert(37,+%22a%22),+None);%0A++++assert_eq!(map.is_empty(),+false);%0A++++%0A++++map.insert(37,+%22b%22);%0A++++assert_eq!(map.insert(37,+%22c%22),+Some(%22b%22));%0A++++assert_eq!(map%5B%2637%5D,+%22c%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_insert\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1019-1021\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.try_insert\" class=\"fn\">try_insert</a>(\n    &amp;mut self,\n    key: K,\n    value: V,\n) -&gt; <a class=\"enum\" href=\"../../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut V</a>, <a class=\"struct\" href=\"struct.OccupiedError.html\" title=\"struct std::collections::btree_map::OccupiedError\">OccupiedError</a>&lt;'_, K, V, A&gt;&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>map_try_insert</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/82766\">#82766</a>)</span></div></span></summary><div class=\"docblock\"><p>Tries to insert a key-value pair into the map, and returns\na mutable reference to the value in the entry.</p>\n<p>If the map already had this key present, nothing is updated, and\nan error containing the occupied entry and the value is returned.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(map_try_insert)]\n\n</span><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\n<span class=\"macro\">assert_eq!</span>(map.try_insert(<span class=\"number\">37</span>, <span class=\"string\">\"a\"</span>).unwrap(), <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>);\n\n<span class=\"kw\">let </span>err = map.try_insert(<span class=\"number\">37</span>, <span class=\"string\">\"b\"</span>).unwrap_err();\n<span class=\"macro\">assert_eq!</span>(err.entry.key(), <span class=\"kw-2\">&amp;</span><span class=\"number\">37</span>);\n<span class=\"macro\">assert_eq!</span>(err.entry.get(), <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(err.value, <span class=\"string\">\"b\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(map_try_insert)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++assert_eq!(map.try_insert(37,+%22a%22).unwrap(),+%26%22a%22);%0A++++%0A++++let+err+=+map.try_insert(37,+%22b%22).unwrap_err();%0A++++assert_eq!(err.entry.key(),+%2637);%0A++++assert_eq!(err.entry.get(),+%26%22a%22);%0A++++assert_eq!(err.value,+%22b%22);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.remove\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1047-1050\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.remove\" class=\"fn\">remove</a>&lt;Q&gt;(&amp;mut self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Removes a key from the map, returning the value at the key if the key\nwas previously in the map.</p>\n<p>The key may be any borrowed form of the maps key type, but the ordering\non the borrowed form <em>must</em> match the ordering on the key type.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.remove(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">\"a\"</span>));\n<span class=\"macro\">assert_eq!</span>(map.remove(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.remove(%261),+Some(%22a%22));%0A++++assert_eq!(map.remove(%261),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.remove_entry\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.45.0\">1.45.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1072-1075\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.remove_entry\" class=\"fn\">remove_entry</a>&lt;Q&gt;(&amp;mut self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Removes a key from the map, returning the stored key and value if the key\nwas previously in the map.</p>\n<p>The key may be any borrowed form of the maps key type, but the ordering\non the borrowed form <em>must</em> match the ordering on the key type.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(map.remove_entry(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"prelude-val\">Some</span>((<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>)));\n<span class=\"macro\">assert_eq!</span>(map.remove_entry(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(1,+%22a%22);%0A++++assert_eq!(map.remove_entry(%261),+Some((1,+%22a%22)));%0A++++assert_eq!(map.remove_entry(%261),+None);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.retain\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.53.0\">1.53.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1110-1113\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.retain\" class=\"fn\">retain</a>&lt;F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    F: <a class=\"trait\" href=\"../../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut V</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Retains only the elements specified by the predicate.</p>\n<p>In other words, remove all pairs <code>(k, v)</code> for which <code>f(&amp;k, &amp;mut v)</code> returns <code>false</code>.\nThe elements are visited in ascending key order.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map: BTreeMap&lt;i32, i32&gt; = (<span class=\"number\">0</span>..<span class=\"number\">8</span>).map(|x| (x, x<span class=\"kw-2\">*</span><span class=\"number\">10</span>)).collect();\n<span class=\"comment\">// Keep only the elements with even-numbered keys.\n</span>map.retain(|<span class=\"kw-2\">&amp;</span>k, <span class=\"kw\">_</span>| k % <span class=\"number\">2 </span>== <span class=\"number\">0</span>);\n<span class=\"macro\">assert!</span>(map.into_iter().eq(<span class=\"macro\">vec!</span>[(<span class=\"number\">0</span>, <span class=\"number\">0</span>), (<span class=\"number\">2</span>, <span class=\"number\">20</span>), (<span class=\"number\">4</span>, <span class=\"number\">40</span>), (<span class=\"number\">6</span>, <span class=\"number\">60</span>)]));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map:+BTreeMap%3Ci32,+i32%3E+=+(0..8).map(%7Cx%7C+(x,+x*10)).collect();%0A++++//+Keep+only+the+elements+with+even-numbered+keys.%0A++++map.retain(%7C%26k,+_%7C+k+%25+2+==+0);%0A++++assert!(map.into_iter().eq(vec!%5B(0,+0),+(2,+20),+(4,+40),+(6,+60)%5D));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.append\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.11.0\">1.11.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1150-1153\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.append\" class=\"fn\">append</a>(&amp;mut self, other: &amp;mut <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;)<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Moves all elements from <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>\n<p>If a key from <code>other</code> is already present in <code>self</code>, the respective\nvalue from <code>self</code> will be overwritten with the respective value from <code>other</code>.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\na.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\na.insert(<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>); <span class=\"comment\">// Note: Key (3) also present in b.\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>b = BTreeMap::new();\nb.insert(<span class=\"number\">3</span>, <span class=\"string\">\"d\"</span>); <span class=\"comment\">// Note: Key (3) also present in a.\n</span>b.insert(<span class=\"number\">4</span>, <span class=\"string\">\"e\"</span>);\nb.insert(<span class=\"number\">5</span>, <span class=\"string\">\"f\"</span>);\n\na.append(<span class=\"kw-2\">&amp;mut </span>b);\n\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">5</span>);\n<span class=\"macro\">assert_eq!</span>(b.len(), <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>], <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>], <span class=\"string\">\"b\"</span>);\n<span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>], <span class=\"string\">\"d\"</span>); <span class=\"comment\">// Note: \"c\" has been overwritten.\n</span><span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>], <span class=\"string\">\"e\"</span>);\n<span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>], <span class=\"string\">\"f\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22a%22);%0A++++a.insert(2,+%22b%22);%0A++++a.insert(3,+%22c%22);+//+Note:+Key+(3)+also+present+in+b.%0A++++%0A++++let+mut+b+=+BTreeMap::new();%0A++++b.insert(3,+%22d%22);+//+Note:+Key+(3)+also+present+in+a.%0A++++b.insert(4,+%22e%22);%0A++++b.insert(5,+%22f%22);%0A++++%0A++++a.append(%26mut+b);%0A++++%0A++++assert_eq!(a.len(),+5);%0A++++assert_eq!(b.len(),+0);%0A++++%0A++++assert_eq!(a%5B%261%5D,+%22a%22);%0A++++assert_eq!(a%5B%262%5D,+%22b%22);%0A++++assert_eq!(a%5B%263%5D,+%22d%22);+//+Note:+%22c%22+has+been+overwritten.%0A++++assert_eq!(a%5B%264%5D,+%22e%22);%0A++++assert_eq!(a%5B%265%5D,+%22f%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.range\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1205-1209\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.range\" class=\"fn\">range</a>&lt;T, R&gt;(&amp;self, range: R) -&gt; <a class=\"struct\" href=\"struct.Range.html\" title=\"struct std::collections::btree_map::Range\">Range</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Range<'_, K, V>\"></a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    R: <a class=\"trait\" href=\"../../ops/trait.RangeBounds.html\" title=\"trait std::ops::RangeBounds\">RangeBounds</a>&lt;T&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Constructs a double-ended iterator over a sub-range of elements in the map.\nThe simplest way is to use the range syntax <code>min..max</code>, thus <code>range(min..max)</code> will\nyield elements from min (inclusive) to max (exclusive).\nThe range may also be entered as <code>(Bound&lt;T&gt;, Bound&lt;T&gt;)</code>, so for example\n<code>range((Excluded(4), Included(10)))</code> will yield a left-exclusive, right-inclusive\nrange from 4 to 10.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">搂</a>Panics</h5>\n<p>Panics if range <code>start &gt; end</code>.\nPanics if range <code>start == end</code> and both bounds are <code>Excluded</code>.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::ops::Bound::Included;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">3</span>, <span class=\"string\">\"a\"</span>);\nmap.insert(<span class=\"number\">5</span>, <span class=\"string\">\"b\"</span>);\nmap.insert(<span class=\"number\">8</span>, <span class=\"string\">\"c\"</span>);\n<span class=\"kw\">for </span>(<span class=\"kw-2\">&amp;</span>key, <span class=\"kw-2\">&amp;</span>value) <span class=\"kw\">in </span>map.range((Included(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>), Included(<span class=\"kw-2\">&amp;</span><span class=\"number\">8</span>))) {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{key}: {value}\"</span>);\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">5</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"b\"</span>)), map.range(<span class=\"number\">4</span>..).next());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound::Included;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(3,+%22a%22);%0A++++map.insert(5,+%22b%22);%0A++++map.insert(8,+%22c%22);%0A++++for+(%26key,+%26value)+in+map.range((Included(%264),+Included(%268)))+%7B%0A++++++++println!(%22%7Bkey%7D:+%7Bvalue%7D%22);%0A++++%7D%0A++++assert_eq!(Some((%265,+%26%22b%22)),+map.range(4..).next());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.range_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.17.0\">1.17.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1245-1249\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.range_mut\" class=\"fn\">range_mut</a>&lt;T, R&gt;(&amp;mut self, range: R) -&gt; <a class=\"struct\" href=\"struct.RangeMut.html\" title=\"struct std::collections::btree_map::RangeMut\">RangeMut</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"RangeMut<'_, K, V>\"></a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    R: <a class=\"trait\" href=\"../../ops/trait.RangeBounds.html\" title=\"trait std::ops::RangeBounds\">RangeBounds</a>&lt;T&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Constructs a mutable double-ended iterator over a sub-range of elements in the map.\nThe simplest way is to use the range syntax <code>min..max</code>, thus <code>range(min..max)</code> will\nyield elements from min (inclusive) to max (exclusive).\nThe range may also be entered as <code>(Bound&lt;T&gt;, Bound&lt;T&gt;)</code>, so for example\n<code>range((Excluded(4), Included(10)))</code> will yield a left-exclusive, right-inclusive\nrange from 4 to 10.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">搂</a>Panics</h5>\n<p>Panics if range <code>start &gt; end</code>.\nPanics if range <code>start == end</code> and both bounds are <code>Excluded</code>.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map: BTreeMap&lt;<span class=\"kw-2\">&amp;</span>str, i32&gt; =\n    [(<span class=\"string\">\"Alice\"</span>, <span class=\"number\">0</span>), (<span class=\"string\">\"Bob\"</span>, <span class=\"number\">0</span>), (<span class=\"string\">\"Carol\"</span>, <span class=\"number\">0</span>), (<span class=\"string\">\"Cheryl\"</span>, <span class=\"number\">0</span>)].into();\n<span class=\"kw\">for </span>(<span class=\"kw\">_</span>, balance) <span class=\"kw\">in </span>map.range_mut(<span class=\"string\">\"B\"</span>..<span class=\"string\">\"Cheryl\"</span>) {\n    <span class=\"kw-2\">*</span>balance += <span class=\"number\">100</span>;\n}\n<span class=\"kw\">for </span>(name, balance) <span class=\"kw\">in </span><span class=\"kw-2\">&amp;</span>map {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{name} =&gt; {balance}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map:+BTreeMap%3C%26str,+i32%3E+=%0A++++++++%5B(%22Alice%22,+0),+(%22Bob%22,+0),+(%22Carol%22,+0),+(%22Cheryl%22,+0)%5D.into();%0A++++for+(_,+balance)+in+map.range_mut(%22B%22..%22Cheryl%22)+%7B%0A++++++++*balance+%2B=+100;%0A++++%7D%0A++++for+(name,+balance)+in+%26map+%7B%0A++++++++println!(%22%7Bname%7D+=%3E+%7Bbalance%7D%22);%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.entry\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1277-1279\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.entry\" class=\"fn\">entry</a>(&amp;mut self, key: K) -&gt; <a class=\"enum\" href=\"enum.Entry.html\" title=\"enum std::collections::btree_map::Entry\">Entry</a>&lt;'_, K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Gets the given keys corresponding entry in the map for in-place manipulation.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count: BTreeMap&lt;<span class=\"kw-2\">&amp;</span>str, usize&gt; = BTreeMap::new();\n\n<span class=\"comment\">// count the number of occurrences of letters in the vec\n</span><span class=\"kw\">for </span>x <span class=\"kw\">in </span>[<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>] {\n    count.entry(x).and_modify(|curr| <span class=\"kw-2\">*</span>curr += <span class=\"number\">1</span>).or_insert(<span class=\"number\">1</span>);\n}\n\n<span class=\"macro\">assert_eq!</span>(count[<span class=\"string\">\"a\"</span>], <span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(count[<span class=\"string\">\"b\"</span>], <span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(count[<span class=\"string\">\"c\"</span>], <span class=\"number\">1</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+count:+BTreeMap%3C%26str,+usize%3E+=+BTreeMap::new();%0A++++%0A++++//+count+the+number+of+occurrences+of+letters+in+the+vec%0A++++for+x+in+%5B%22a%22,+%22b%22,+%22a%22,+%22c%22,+%22a%22,+%22b%22%5D+%7B%0A++++++++count.entry(x).and_modify(%7Ccurr%7C+*curr+%2B=+1).or_insert(1);%0A++++%7D%0A++++%0A++++assert_eq!(count%5B%22a%22%5D,+3);%0A++++assert_eq!(count%5B%22b%22%5D,+2);%0A++++assert_eq!(count%5B%22c%22%5D,+1);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.split_off\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.11.0\">1.11.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1336-1339\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.split_off\" class=\"fn\">split_off</a>&lt;Q&gt;(&amp;mut self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Splits the collection into two at the given key. Returns everything after the given key,\nincluding the key.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\na.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\na.insert(<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>);\na.insert(<span class=\"number\">17</span>, <span class=\"string\">\"d\"</span>);\na.insert(<span class=\"number\">41</span>, <span class=\"string\">\"e\"</span>);\n\n<span class=\"kw\">let </span>b = a.split_off(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>);\n\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(b.len(), <span class=\"number\">3</span>);\n\n<span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>], <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(a[<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>], <span class=\"string\">\"b\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(b[<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>], <span class=\"string\">\"c\"</span>);\n<span class=\"macro\">assert_eq!</span>(b[<span class=\"kw-2\">&amp;</span><span class=\"number\">17</span>], <span class=\"string\">\"d\"</span>);\n<span class=\"macro\">assert_eq!</span>(b[<span class=\"kw-2\">&amp;</span><span class=\"number\">41</span>], <span class=\"string\">\"e\"</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22a%22);%0A++++a.insert(2,+%22b%22);%0A++++a.insert(3,+%22c%22);%0A++++a.insert(17,+%22d%22);%0A++++a.insert(41,+%22e%22);%0A++++%0A++++let+b+=+a.split_off(%263);%0A++++%0A++++assert_eq!(a.len(),+2);%0A++++assert_eq!(b.len(),+3);%0A++++%0A++++assert_eq!(a%5B%261%5D,+%22a%22);%0A++++assert_eq!(a%5B%262%5D,+%22b%22);%0A++++%0A++++assert_eq!(b%5B%263%5D,+%22c%22);%0A++++assert_eq!(b%5B%2617%5D,+%22d%22);%0A++++assert_eq!(b%5B%2641%5D,+%22e%22);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extract_if\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1391-1394\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.extract_if\" class=\"fn\">extract_if</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class=\"struct\" href=\"struct.ExtractIf.html\" title=\"struct std::collections::btree_map::ExtractIf\">ExtractIf</a>&lt;'_, K, V, F, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"ExtractIf<'_, K, V, F, A>\"></a><div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    F: <a class=\"trait\" href=\"../../ops/trait.FnMut.html\" title=\"trait std::ops::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut V</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>btree_extract_if</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/70530\">#70530</a>)</span></div></span></summary><div class=\"docblock\"><p>Creates an iterator that visits all elements (key-value pairs) in\nascending key order and uses a closure to determine if an element should\nbe removed. If the closure returns <code>true</code>, the element is removed from\nthe map and yielded. If the closure returns <code>false</code>, or panics, the\nelement remains in the map and will not be yielded.</p>\n<p>The iterator also lets you mutate the value of each element in the\nclosure, regardless of whether you choose to keep or remove it.</p>\n<p>If the returned <code>ExtractIf</code> is not exhausted, e.g. because it is dropped without iterating\nor the iteration short-circuits, then the remaining elements will be retained.\nUse <a href=\"../struct.BTreeMap.html#method.retain\" title=\"method std::collections::BTreeMap::retain\"><code>retain</code></a> with a negated predicate if you do not need the returned iterator.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">搂</a>Examples</h5>\n<p>Splitting a map into even and odd keys, reusing the original map:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(btree_extract_if)]\n</span><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map: BTreeMap&lt;i32, i32&gt; = (<span class=\"number\">0</span>..<span class=\"number\">8</span>).map(|x| (x, x)).collect();\n<span class=\"kw\">let </span>evens: BTreeMap&lt;<span class=\"kw\">_</span>, <span class=\"kw\">_</span>&gt; = map.extract_if(|k, _v| k % <span class=\"number\">2 </span>== <span class=\"number\">0</span>).collect();\n<span class=\"kw\">let </span>odds = map;\n<span class=\"macro\">assert_eq!</span>(evens.keys().copied().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]);\n<span class=\"macro\">assert_eq!</span>(odds.keys().copied().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_extract_if)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map:+BTreeMap%3Ci32,+i32%3E+=+(0..8).map(%7Cx%7C+(x,+x)).collect();%0A++++let+evens:+BTreeMap%3C_,+_%3E+=+map.extract_if(%7Ck,+_v%7C+k+%25+2+==+0).collect();%0A++++let+odds+=+map;%0A++++assert_eq!(evens.keys().copied().collect::%3CVec%3C_%3E%3E(),+%5B0,+2,+4,+6%5D);%0A++++assert_eq!(odds.keys().copied().collect::%3CVec%3C_%3E%3E(),+%5B1,+3,+5,+7%5D);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_keys\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.54.0\">1.54.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1445\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_keys\" class=\"fn\">into_keys</a>(self) -&gt; <a class=\"struct\" href=\"struct.IntoKeys.html\" title=\"struct std::collections::btree_map::IntoKeys\">IntoKeys</a>&lt;K, V, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntoKeys<K, V, A>\"></a></h4></section></summary><div class=\"docblock\"><p>Creates a consuming iterator visiting all the keys, in sorted order.\nThe map cannot be used after calling this.\nThe iterator element type is <code>K</code>.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n\n<span class=\"kw\">let </span>keys: Vec&lt;i32&gt; = a.into_keys().collect();\n<span class=\"macro\">assert_eq!</span>(keys, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(2,+%22b%22);%0A++++a.insert(1,+%22a%22);%0A++++%0A++++let+keys:+Vec%3Ci32%3E+=+a.into_keys().collect();%0A++++assert_eq!(keys,+%5B1,+2%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_values\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.54.0\">1.54.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1467\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.into_values\" class=\"fn\">into_values</a>(self) -&gt; <a class=\"struct\" href=\"struct.IntoValues.html\" title=\"struct std::collections::btree_map::IntoValues\">IntoValues</a>&lt;K, V, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntoValues<K, V, A>\"></a></h4></section></summary><div class=\"docblock\"><p>Creates a consuming iterator visiting all the values, in order by key.\nThe map cannot be used after calling this.\nThe iterator element type is <code>V</code>.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"hello\"</span>);\na.insert(<span class=\"number\">2</span>, <span class=\"string\">\"goodbye\"</span>);\n\n<span class=\"kw\">let </span>values: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = a.into_values().collect();\n<span class=\"macro\">assert_eq!</span>(values, [<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"goodbye\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22hello%22);%0A++++a.insert(2,+%22goodbye%22);%0A++++%0A++++let+values:+Vec%3C%26str%3E+=+a.into_values().collect();%0A++++assert_eq!(values,+%5B%22hello%22,+%22goodbye%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-BTreeMap%3CK,+V,+A%3E-2\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2359\">source</a><a href=\"#impl-BTreeMap%3CK,+V,+A%3E-2\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.iter\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2380\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.iter\" class=\"fn\">iter</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct std::collections::btree_map::Iter\">Iter</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Iter<'_, K, V>\"></a></h4></section></summary><div class=\"docblock\"><p>Gets an iterator over the entries of the map, sorted by key.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::new();\nmap.insert(<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>);\nmap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\nmap.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n\n<span class=\"kw\">for </span>(key, value) <span class=\"kw\">in </span>map.iter() {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{key}: {value}\"</span>);\n}\n\n<span class=\"kw\">let </span>(first_key, first_value) = map.iter().next().unwrap();\n<span class=\"macro\">assert_eq!</span>((<span class=\"kw-2\">*</span>first_key, <span class=\"kw-2\">*</span>first_value), (<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::new();%0A++++map.insert(3,+%22c%22);%0A++++map.insert(2,+%22b%22);%0A++++map.insert(1,+%22a%22);%0A++++%0A++++for+(key,+value)+in+map.iter()+%7B%0A++++++++println!(%22%7Bkey%7D:+%7Bvalue%7D%22);%0A++++%7D%0A++++%0A++++let+(first_key,+first_value)+=+map.iter().next().unwrap();%0A++++assert_eq!((*first_key,+*first_value),+(1,+%22a%22));%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.iter_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2411\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.iter_mut\" class=\"fn\">iter_mut</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct std::collections::btree_map::IterMut\">IterMut</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IterMut<'_, K, V>\"></a></h4></section></summary><div class=\"docblock\"><p>Gets a mutable iterator over the entries of the map, sorted by key.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::from([\n   (<span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>),\n   (<span class=\"string\">\"b\"</span>, <span class=\"number\">2</span>),\n   (<span class=\"string\">\"c\"</span>, <span class=\"number\">3</span>),\n]);\n\n<span class=\"comment\">// add 10 to the value if the key isn't \"a\"\n</span><span class=\"kw\">for </span>(key, value) <span class=\"kw\">in </span>map.iter_mut() {\n    <span class=\"kw\">if </span>key != <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\" </span>{\n        <span class=\"kw-2\">*</span>value += <span class=\"number\">10</span>;\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+map+=+BTreeMap::from(%5B%0A+++++++(%22a%22,+1),%0A+++++++(%22b%22,+2),%0A+++++++(%22c%22,+3),%0A++++%5D);%0A++++%0A++++//+add+10+to+the+value+if+the+key+isn't+%22a%22%0A++++for+(key,+value)+in+map.iter_mut()+%7B%0A++++++++if+key+!=+%26%22a%22+%7B%0A++++++++++++*value+%2B=+10;%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.keys\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2436\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.keys\" class=\"fn\">keys</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.Keys.html\" title=\"struct std::collections::btree_map::Keys\">Keys</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Keys<'_, K, V>\"></a></h4></section></summary><div class=\"docblock\"><p>Gets an iterator over the keys of the map, in sorted order.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>);\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n\n<span class=\"kw\">let </span>keys: Vec&lt;<span class=\"kw\">_</span>&gt; = a.keys().cloned().collect();\n<span class=\"macro\">assert_eq!</span>(keys, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(2,+%22b%22);%0A++++a.insert(1,+%22a%22);%0A++++%0A++++let+keys:+Vec%3C_%3E+=+a.keys().cloned().collect();%0A++++assert_eq!(keys,+%5B1,+2%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.values\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2455\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.values\" class=\"fn\">values</a>(&amp;self) -&gt; <a class=\"struct\" href=\"struct.Values.html\" title=\"struct std::collections::btree_map::Values\">Values</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Values<'_, K, V>\"></a></h4></section></summary><div class=\"docblock\"><p>Gets an iterator over the values of the map, in order by key.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"hello\"</span>);\na.insert(<span class=\"number\">2</span>, <span class=\"string\">\"goodbye\"</span>);\n\n<span class=\"kw\">let </span>values: Vec&lt;<span class=\"kw-2\">&amp;</span>str&gt; = a.values().cloned().collect();\n<span class=\"macro\">assert_eq!</span>(values, [<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"goodbye\"</span>]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+%22hello%22);%0A++++a.insert(2,+%22goodbye%22);%0A++++%0A++++let+values:+Vec%3C%26str%3E+=+a.values().cloned().collect();%0A++++assert_eq!(values,+%5B%22hello%22,+%22goodbye%22%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.values_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2479\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.values_mut\" class=\"fn\">values_mut</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"struct.ValuesMut.html\" title=\"struct std::collections::btree_map::ValuesMut\">ValuesMut</a>&lt;'_, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"ValuesMut<'_, K, V>\"></a></h4></section></summary><div class=\"docblock\"><p>Gets a mutable iterator over the values of the map, in order by key.</p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\na.insert(<span class=\"number\">1</span>, String::from(<span class=\"string\">\"hello\"</span>));\na.insert(<span class=\"number\">2</span>, String::from(<span class=\"string\">\"goodbye\"</span>));\n\n<span class=\"kw\">for </span>value <span class=\"kw\">in </span>a.values_mut() {\n    value.push_str(<span class=\"string\">\"!\"</span>);\n}\n\n<span class=\"kw\">let </span>values: Vec&lt;String&gt; = a.values().cloned().collect();\n<span class=\"macro\">assert_eq!</span>(values, [String::from(<span class=\"string\">\"hello!\"</span>),\n                    String::from(<span class=\"string\">\"goodbye!\"</span>)]);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++a.insert(1,+String::from(%22hello%22));%0A++++a.insert(2,+String::from(%22goodbye%22));%0A++++%0A++++for+value+in+a.values_mut()+%7B%0A++++++++value.push_str(%22!%22);%0A++++%7D%0A++++%0A++++let+values:+Vec%3CString%3E+=+a.values().cloned().collect();%0A++++assert_eq!(values,+%5BString::from(%22hello!%22),%0A++++++++++++++++++++++++String::from(%22goodbye!%22)%5D);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.len\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/71835\" title=\"Tracking issue for const_btree_len\">unstable</a>)</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2503\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.len\" class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../../primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of elements in the map.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">0</span>);\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">1</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++assert_eq!(a.len(),+0);%0A++++a.insert(1,+%22a%22);%0A++++assert_eq!(a.len(),+1);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.is_empty\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const unstable\">1.0.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/71835\" title=\"Tracking issue for const_btree_len\">unstable</a>)</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2526\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.is_empty\" class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the map contains no elements.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = BTreeMap::new();\n<span class=\"macro\">assert!</span>(a.is_empty());\na.insert(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>);\n<span class=\"macro\">assert!</span>(!a.is_empty());</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+mut+a+=+BTreeMap::new();%0A++++assert!(a.is_empty());%0A++++a.insert(1,+%22a%22);%0A++++assert!(!a.is_empty());%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lower_bound\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2570-2573\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.lower_bound\" class=\"fn\">lower_bound</a>&lt;Q&gt;(&amp;self, bound: <a class=\"enum\" href=\"../../ops/enum.Bound.html\" title=\"enum std::ops::Bound\">Bound</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.Cursor.html\" title=\"struct std::collections::btree_map::Cursor\">Cursor</a>&lt;'_, K, V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>btree_cursors</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/107540\">#107540</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a <a href=\"struct.Cursor.html\" title=\"struct std::collections::btree_map::Cursor\"><code>Cursor</code></a> pointing at the gap before the smallest key\ngreater than the given bound.</p>\n<p>Passing <code>Bound::Included(x)</code> will return a cursor pointing to the\ngap before the smallest key greater than or equal to <code>x</code>.</p>\n<p>Passing <code>Bound::Excluded(x)</code> will return a cursor pointing to the\ngap before the smallest key greater than <code>x</code>.</p>\n<p>Passing <code>Bound::Unbounded</code> will return a cursor pointing to the\ngap before the smallest key in the map.</p>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(btree_cursors)]\n\n</span><span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::ops::Bound;\n\n<span class=\"kw\">let </span>map = BTreeMap::from([\n    (<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>),\n    (<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>),\n    (<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>),\n    (<span class=\"number\">4</span>, <span class=\"string\">\"d\"</span>),\n]);\n\n<span class=\"kw\">let </span>cursor = map.lower_bound(Bound::Included(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"b\"</span>)));\n\n<span class=\"kw\">let </span>cursor = map.lower_bound(Bound::Excluded(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"b\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"c\"</span>)));\n\n<span class=\"kw\">let </span>cursor = map.lower_bound(Bound::Unbounded);\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"a\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+cursor+=+map.lower_bound(Bound::Included(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%261,+%26%22a%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%262,+%26%22b%22)));%0A++++%0A++++let+cursor+=+map.lower_bound(Bound::Excluded(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26%22c%22)));%0A++++%0A++++let+cursor+=+map.lower_bound(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+None);%0A++++assert_eq!(cursor.peek_next(),+Some((%261,+%26%22a%22)));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lower_bound_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2623-2626\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.lower_bound_mut\" class=\"fn\">lower_bound_mut</a>&lt;Q&gt;(&amp;mut self, bound: <a class=\"enum\" href=\"../../ops/enum.Bound.html\" title=\"enum std::ops::Bound\">Bound</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.CursorMut.html\" title=\"struct std::collections::btree_map::CursorMut\">CursorMut</a>&lt;'_, K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>btree_cursors</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/107540\">#107540</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a <a href=\"struct.CursorMut.html\" title=\"struct std::collections::btree_map::CursorMut\"><code>CursorMut</code></a> pointing at the gap before the smallest key\ngreater than the given bound.</p>\n<p>Passing <code>Bound::Included(x)</code> will return a cursor pointing to the\ngap before the smallest key greater than or equal to <code>x</code>.</p>\n<p>Passing <code>Bound::Excluded(x)</code> will return a cursor pointing to the\ngap before the smallest key greater than <code>x</code>.</p>\n<p>Passing <code>Bound::Unbounded</code> will return a cursor pointing to the\ngap before the smallest key in the map.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(btree_cursors)]\n\n</span><span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::ops::Bound;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::from([\n    (<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>),\n    (<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>),\n    (<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>),\n    (<span class=\"number\">4</span>, <span class=\"string\">\"d\"</span>),\n]);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>cursor = map.lower_bound_mut(Bound::Included(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"a\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"b\"</span>)));\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>cursor = map.lower_bound_mut(Bound::Excluded(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"b\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"c\"</span>)));\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>cursor = map.lower_bound_mut(Bound::Unbounded);\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"a\"</span>)));</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+mut+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+mut+cursor+=+map.lower_bound_mut(Bound::Included(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%261,+%26mut+%22a%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%262,+%26mut+%22b%22)));%0A++++%0A++++let+mut+cursor+=+map.lower_bound_mut(Bound::Excluded(%262));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26mut+%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26mut+%22c%22)));%0A++++%0A++++let+mut+cursor+=+map.lower_bound_mut(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+None);%0A++++assert_eq!(cursor.peek_next(),+Some((%261,+%26mut+%22a%22)));%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.upper_bound\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2693-2696\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.upper_bound\" class=\"fn\">upper_bound</a>&lt;Q&gt;(&amp;self, bound: <a class=\"enum\" href=\"../../ops/enum.Bound.html\" title=\"enum std::ops::Bound\">Bound</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.Cursor.html\" title=\"struct std::collections::btree_map::Cursor\">Cursor</a>&lt;'_, K, V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>btree_cursors</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/107540\">#107540</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a <a href=\"struct.Cursor.html\" title=\"struct std::collections::btree_map::Cursor\"><code>Cursor</code></a> pointing at the gap after the greatest key\nsmaller than the given bound.</p>\n<p>Passing <code>Bound::Included(x)</code> will return a cursor pointing to the\ngap after the greatest key smaller than or equal to <code>x</code>.</p>\n<p>Passing <code>Bound::Excluded(x)</code> will return a cursor pointing to the\ngap after the greatest key smaller than <code>x</code>.</p>\n<p>Passing <code>Bound::Unbounded</code> will return a cursor pointing to the\ngap after the greatest key in the map.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(btree_cursors)]\n\n</span><span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::ops::Bound;\n\n<span class=\"kw\">let </span>map = BTreeMap::from([\n    (<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>),\n    (<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>),\n    (<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>),\n    (<span class=\"number\">4</span>, <span class=\"string\">\"d\"</span>),\n]);\n\n<span class=\"kw\">let </span>cursor = map.upper_bound(Bound::Included(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"c\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"d\"</span>)));\n\n<span class=\"kw\">let </span>cursor = map.upper_bound(Bound::Excluded(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"b\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"c\"</span>)));\n\n<span class=\"kw\">let </span>cursor = map.upper_bound(Bound::Unbounded);\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>, <span class=\"kw-2\">&amp;</span><span class=\"string\">\"d\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+cursor+=+map.upper_bound(Bound::Included(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%263,+%26%22c%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%264,+%26%22d%22)));%0A++++%0A++++let+cursor+=+map.upper_bound(Bound::Excluded(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26%22c%22)));%0A++++%0A++++let+cursor+=+map.upper_bound(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+Some((%264,+%26%22d%22)));%0A++++assert_eq!(cursor.peek_next(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.upper_bound_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2746-2749\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.upper_bound_mut\" class=\"fn\">upper_bound_mut</a>&lt;Q&gt;(&amp;mut self, bound: <a class=\"enum\" href=\"../../ops/enum.Bound.html\" title=\"enum std::ops::Bound\">Bound</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>&gt;) -&gt; <a class=\"struct\" href=\"struct.CursorMut.html\" title=\"struct std::collections::btree_map::CursorMut\">CursorMut</a>&lt;'_, K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>btree_cursors</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/107540\">#107540</a>)</span></div></span></summary><div class=\"docblock\"><p>Returns a <a href=\"struct.CursorMut.html\" title=\"struct std::collections::btree_map::CursorMut\"><code>CursorMut</code></a> pointing at the gap after the greatest key\nsmaller than the given bound.</p>\n<p>Passing <code>Bound::Included(x)</code> will return a cursor pointing to the\ngap after the greatest key smaller than or equal to <code>x</code>.</p>\n<p>Passing <code>Bound::Excluded(x)</code> will return a cursor pointing to the\ngap after the greatest key smaller than <code>x</code>.</p>\n<p>Passing <code>Bound::Unbounded</code> will return a cursor pointing to the\ngap after the greatest key in the map.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">搂</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(btree_cursors)]\n\n</span><span class=\"kw\">use </span>std::collections::BTreeMap;\n<span class=\"kw\">use </span>std::ops::Bound;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map = BTreeMap::from([\n    (<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>),\n    (<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>),\n    (<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>),\n    (<span class=\"number\">4</span>, <span class=\"string\">\"d\"</span>),\n]);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>cursor = map.upper_bound_mut(Bound::Included(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"c\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"d\"</span>)));\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>cursor = map.upper_bound_mut(Bound::Excluded(<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"b\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">3</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"c\"</span>)));\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>cursor = map.upper_bound_mut(Bound::Unbounded);\n<span class=\"macro\">assert_eq!</span>(cursor.peek_prev(), <span class=\"prelude-val\">Some</span>((<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>, <span class=\"kw-2\">&amp;mut </span><span class=\"string\">\"d\"</span>)));\n<span class=\"macro\">assert_eq!</span>(cursor.peek_next(), <span class=\"prelude-val\">None</span>);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(btree_cursors)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++use+std::ops::Bound;%0A++++%0A++++let+mut+map+=+BTreeMap::from(%5B%0A++++++++(1,+%22a%22),%0A++++++++(2,+%22b%22),%0A++++++++(3,+%22c%22),%0A++++++++(4,+%22d%22),%0A++++%5D);%0A++++%0A++++let+mut+cursor+=+map.upper_bound_mut(Bound::Included(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%263,+%26mut+%22c%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%264,+%26mut+%22d%22)));%0A++++%0A++++let+mut+cursor+=+map.upper_bound_mut(Bound::Excluded(%263));%0A++++assert_eq!(cursor.peek_prev(),+Some((%262,+%26mut+%22b%22)));%0A++++assert_eq!(cursor.peek_next(),+Some((%263,+%26mut+%22c%22)));%0A++++%0A++++let+mut+cursor+=+map.upper_bound_mut(Bound::Unbounded);%0A++++assert_eq!(cursor.peek_prev(),+Some((%264,+%26mut+%22d%22)));%0A++++assert_eq!(cursor.peek_next(),+None);%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">搂</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Clone-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#207\">source</a></span><a href=\"#impl-Clone-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    V: <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#208\">source</a><a href=\"#method.clone\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;</h4></section></summary><div class=\"docblock\">Returns a copy of the value. <a href=\"../../clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class=\"docblock\">Performs copy-assignment from <code>source</code>. <a href=\"../../clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2312\">source</a></span><a href=\"#impl-Debug-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a>,\n    V: <a class=\"trait\" href=\"../../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2313\">source</a><a href=\"#method.fmt\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"../../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"../../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../primitive.unit.html\">()</a>, <a class=\"struct\" href=\"../../fmt/struct.Error.html\" title=\"struct std::fmt::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Default-for-BTreeMap%3CK,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2278\">source</a></span><a href=\"#impl-Default-for-BTreeMap%3CK,+V%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V&gt; <a class=\"trait\" href=\"../../default/trait.Default.html\" title=\"trait std::default::Default\">Default</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2280\">source</a><a href=\"#method.default\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>BTreeMap</code>.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Drop-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#187\">source</a></span><a href=\"#impl-Drop-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../ops/trait.Drop.html\" title=\"trait std::ops::Drop\">Drop</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.drop\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#188\">source</a><a href=\"#method.drop\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../ops/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\">Executes the destructor for this type. <a href=\"../../ops/trait.Drop.html#tymethod.drop\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3C(%26K,+%26V)%3E-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2254-2255\">source</a></span><a href=\"#impl-Extend%3C(%26K,+%26V)%3E-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;'a, K, V, A&gt; <a class=\"trait\" href=\"../../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;(<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a V</a>)&gt; for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + <a class=\"trait\" href=\"../../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,\n    V: <a class=\"trait\" href=\"../../marker/trait.Copy.html\" title=\"trait std::marker::Copy\">Copy</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2257\">source</a><a href=\"#method.extend-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: <a class=\"trait\" href=\"../../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = (<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a V</a>)&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2262\">source</a><a href=\"#method.extend_one-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, _: (<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a V</a>))</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461\">source</a><a href=\"#method.extend_reserve-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Extend%3C(K,+V)%3E-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2239\">source</a></span><a href=\"#impl-Extend%3C(K,+V)%3E-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../iter/trait.Extend.html\" title=\"trait std::iter::Extend\">Extend</a>&lt;<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt; for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2241\">source</a><a href=\"#method.extend\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.Extend.html#tymethod.extend\" class=\"fn\">extend</a>&lt;T&gt;(&amp;mut self, iter: T)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Extends a collection with the contents of an iterator. <a href=\"../../iter/trait.Extend.html#tymethod.extend\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2248\">source</a><a href=\"#method.extend_one\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.Extend.html#method.extend_one\" class=\"fn\">extend_one</a>(&amp;mut self, _: <a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/iter/traits/collect.rs.html#461\">source</a><a href=\"#method.extend_reserve\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.Extend.html#method.extend_reserve\" class=\"fn\">extend_reserve</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"../../primitive.usize.html\">usize</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\"></span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/72631\">#72631</a>)</span></div></span><div class=\"docblock\">Reserves capacity in a collection for the given number of additional elements. <a href=\"../../iter/trait.Extend.html#method.extend_reserve\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3C%5B(K,+V);+N%5D%3E-for-BTreeMap%3CK,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.56.0\">1.56.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2338\">source</a></span><a href=\"#impl-From%3C%5B(K,+V);+N%5D%3E-for-BTreeMap%3CK,+V%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, const N: <a class=\"primitive\" href=\"../../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;[<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>; <a class=\"primitive\" href=\"../../primitive.array.html\">N</a>]&gt; for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2348\">source</a><a href=\"#method.from\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(arr: [<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>; <a class=\"primitive\" href=\"../../primitive.array.html\">N</a>]) -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>[(K, V); N]</code> into a <code>BTreeMap&lt;(K, V)&gt;</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::BTreeMap;\n\n<span class=\"kw\">let </span>map1 = BTreeMap::from([(<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>)]);\n<span class=\"kw\">let </span>map2: BTreeMap&lt;<span class=\"kw\">_</span>, <span class=\"kw\">_</span>&gt; = [(<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>)].into();\n<span class=\"macro\">assert_eq!</span>(map1, map2);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BTreeMap;%0A++++%0A++++let+map1+=+BTreeMap::from(%5B(1,+2),+(3,+4)%5D);%0A++++let+map2:+BTreeMap%3C_,+_%3E+=+%5B(1,+2),+(3,+4)%5D.into();%0A++++assert_eq!(map1,+map2);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromIterator%3C(K,+V)%3E-for-BTreeMap%3CK,+V%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2224\">source</a></span><a href=\"#impl-FromIterator%3C(K,+V)%3E-for-BTreeMap%3CK,+V%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V&gt; <a class=\"trait\" href=\"../../iter/trait.FromIterator.html\" title=\"trait std::iter::FromIterator\">FromIterator</a>&lt;<a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt; for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2225\">source</a><a href=\"#method.from_iter\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.FromIterator.html#tymethod.from_iter\" class=\"fn\">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a>&lt;Item = <a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a>&gt;,</div></h4></section></summary><div class=\"docblock\">Creates a value from an iterator. <a href=\"../../iter/trait.FromIterator.html#tymethod.from_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Hash-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2268\">source</a></span><a href=\"#impl-Hash-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a>,\n    V: <a class=\"trait\" href=\"../../hash/trait.Hash.html\" title=\"trait std::hash::Hash\">Hash</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2269\">source</a><a href=\"#method.hash\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;H&gt;(&amp;self, state: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class=\"docblock\">Feeds this value into the given <a href=\"../../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../../hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240\">source</a></span><a href=\"#method.hash_slice\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../hash/trait.Hash.html#method.hash_slice\" class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;<a class=\"primitive\" href=\"../../primitive.slice.html\">[Self]</a>, state: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"../../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\">Hasher</a>,\n    Self: <a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Feeds a slice of this type into the given <a href=\"../../hash/trait.Hasher.html\" title=\"trait std::hash::Hasher\"><code>Hasher</code></a>. <a href=\"../../hash/trait.Hash.html#method.hash_slice\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Index%3C%26Q%3E-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2319-2322\">source</a></span><a href=\"#impl-Index%3C%26Q%3E-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, Q, V, A&gt; <a class=\"trait\" href=\"../../ops/trait.Index.html\" title=\"trait std::ops::Index\">Index</a>&lt;<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>&gt; for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,\n    K: <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;Q&gt; + <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    Q: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.index\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2332\">source</a><a href=\"#method.index\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../ops/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, key: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;V</a></h4></section></summary><div class=\"docblock\"><p>Returns a reference to the value corresponding to the supplied key.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">搂</a>Panics</h5>\n<p>Panics if the key is not present in the <code>BTreeMap</code>.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../ops/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = V</h4></section></summary><div class=\"docblock\">The returned type after indexing.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IntoIterator-for-%26BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1485\">source</a></span><a href=\"#impl-IntoIterator-for-%26BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;'a, K, V, A&gt; <a class=\"trait\" href=\"../../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a> for &amp;'a <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Item-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../iter/trait.IntoIterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a V</a>)</h4></section></summary><div class=\"docblock\">The type of the elements being iterated over.</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.IntoIter-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.IntoIter-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../iter/trait.IntoIterator.html#associatedtype.IntoIter\" class=\"associatedtype\">IntoIter</a> = <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct std::collections::btree_map::Iter\">Iter</a>&lt;'a, K, V&gt;</h4></section></summary><div class=\"docblock\">Which kind of iterator are we turning this into?</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_iter-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1489\">source</a><a href=\"#method.into_iter-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.IntoIterator.html#tymethod.into_iter\" class=\"fn\">into_iter</a>(self) -&gt; <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct std::collections::btree_map::Iter\">Iter</a>&lt;'a, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Iter<'a, K, V>\"></a></h4></section></summary><div class=\"docblock\">Creates an iterator from a value. <a href=\"../../iter/trait.IntoIterator.html#tymethod.into_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IntoIterator-for-%26mut+BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1560\">source</a></span><a href=\"#impl-IntoIterator-for-%26mut+BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;'a, K, V, A&gt; <a class=\"trait\" href=\"../../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a> for &amp;'a mut <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Item-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item-2\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../iter/trait.IntoIterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a K</a>, <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;'a mut V</a>)</h4></section></summary><div class=\"docblock\">The type of the elements being iterated over.</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.IntoIter-2\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.IntoIter-2\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../iter/trait.IntoIterator.html#associatedtype.IntoIter\" class=\"associatedtype\">IntoIter</a> = <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct std::collections::btree_map::IterMut\">IterMut</a>&lt;'a, K, V&gt;</h4></section></summary><div class=\"docblock\">Which kind of iterator are we turning this into?</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_iter-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1564\">source</a><a href=\"#method.into_iter-2\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.IntoIterator.html#tymethod.into_iter\" class=\"fn\">into_iter</a>(self) -&gt; <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct std::collections::btree_map::IterMut\">IterMut</a>&lt;'a, K, V&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IterMut<'a, K, V>\"></a></h4></section></summary><div class=\"docblock\">Creates an iterator from a value. <a href=\"../../iter/trait.IntoIterator.html#tymethod.into_iter\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IntoIterator-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1636\">source</a></span><a href=\"#impl-IntoIterator-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../iter/trait.IntoIterator.html\" title=\"trait std::iter::IntoIterator\">IntoIterator</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#1641\">source</a><a href=\"#method.into_iter\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../iter/trait.IntoIterator.html#tymethod.into_iter\" class=\"fn\">into_iter</a>(self) -&gt; <a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct std::collections::btree_map::IntoIter\">IntoIter</a>&lt;K, V, A&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"IntoIter<K, V, A>\"></a></h4></section></summary><div class=\"docblock\"><p>Gets an owning iterator over the entries of the map, sorted by key.</p>\n</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../iter/trait.IntoIterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"../../primitive.tuple.html\">(K, V)</a></h4></section></summary><div class=\"docblock\">The type of the elements being iterated over.</div></details><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.IntoIter\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.IntoIter\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../iter/trait.IntoIterator.html#associatedtype.IntoIter\" class=\"associatedtype\">IntoIter</a> = <a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct std::collections::btree_map::IntoIter\">IntoIter</a>&lt;K, V, A&gt;</h4></section></summary><div class=\"docblock\">Which kind of iterator are we turning this into?</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Ord-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2304\">source</a></span><a href=\"#impl-Ord-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    V: <a class=\"trait\" href=\"../../cmp/trait.Ord.html\" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2306\">source</a><a href=\"#method.cmp\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;) -&gt; <a class=\"enum\" href=\"../../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a></h4></section></summary><div class=\"docblock\">This method returns an <a href=\"../../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href=\"../../cmp/trait.Ord.html#tymethod.cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858\">source</a></span><a href=\"#method.max\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.Ord.html#method.max\" class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the maximum of two values. <a href=\"../../cmp/trait.Ord.html#method.max\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.21.0\">1.21.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879\">source</a></span><a href=\"#method.min\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.Ord.html#method.min\" class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\">Compares and returns the minimum of two values. <a href=\"../../cmp/trait.Ord.html#method.min\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906\">source</a></span><a href=\"#method.clamp\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.Ord.html#method.clamp\" class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: <a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"../../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\">Restrict a value to a certain interval. <a href=\"../../cmp/trait.Ord.html#method.clamp\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialEq-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2286\">source</a></span><a href=\"#impl-PartialEq-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>,\n    V: <a class=\"trait\" href=\"../../cmp/trait.PartialEq.html\" title=\"trait std::cmp::PartialEq\">PartialEq</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2287\">source</a><a href=\"#method.eq\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263\">source</a></span><a href=\"#method.ne\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-PartialOrd-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2296\">source</a></span><a href=\"#impl-PartialOrd-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,\n    V: <a class=\"trait\" href=\"../../cmp/trait.PartialOrd.html\" title=\"trait std::cmp::PartialOrd\">PartialOrd</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2298\">source</a><a href=\"#method.partial_cmp\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;) -&gt; <a class=\"enum\" href=\"../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"../../cmp/enum.Ordering.html\" title=\"enum std::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class=\"docblock\">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"../../cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180\">source</a></span><a href=\"#method.lt\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"../../cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198\">source</a></span><a href=\"#method.le\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a href=\"../../cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215\">source</a></span><a href=\"#method.gt\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href=\"../../cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233\">source</a></span><a href=\"#method.ge\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"../../primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a href=\"../../cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details><section id=\"impl-Eq-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#2293\">source</a></span><a href=\"#impl-Eq-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"../../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a>,\n    V: <a class=\"trait\" href=\"../../cmp/trait.Eq.html\" title=\"trait std::cmp::Eq\">Eq</a>,\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section><section id=\"impl-UnwindSafe-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.64.0\">1.64.0</span> 路 <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/collections/btree/map.rs.html#198-202\">source</a></span><a href=\"#impl-UnwindSafe-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a> + <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"../../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a>,\n    K: <a class=\"trait\" href=\"../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,\n    V: <a class=\"trait\" href=\"../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,</div></h3></section></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">搂</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><a href=\"#impl-Freeze-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a>,</div></h3></section><section id=\"impl-RefUnwindSafe-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,\n    K: <a class=\"trait\" href=\"../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,\n    V: <a class=\"trait\" href=\"../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a>,</div></h3></section><section id=\"impl-Send-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><a href=\"#impl-Send-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,\n    K: <a class=\"trait\" href=\"../../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,\n    V: <a class=\"trait\" href=\"../../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a>,</div></h3></section><section id=\"impl-Sync-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><a href=\"#impl-Sync-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,\n    K: <a class=\"trait\" href=\"../../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,\n    V: <a class=\"trait\" href=\"../../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a>,</div></h3></section><section id=\"impl-Unpin-for-BTreeMap%3CK,+V,+A%3E\" class=\"impl\"><a href=\"#impl-Unpin-for-BTreeMap%3CK,+V,+A%3E\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;K, V, A&gt; <a class=\"trait\" href=\"../../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"../struct.BTreeMap.html\" title=\"struct std::collections::BTreeMap\">BTreeMap</a>&lt;K, V, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a>,</div></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">搂</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-ToOwned-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85\">source</a><a href=\"#impl-ToOwned-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../borrow/trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> for T<div class=\"where\">where\n    T: <a class=\"trait\" href=\"../../clone/trait.Clone.html\" title=\"trait std::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Owned\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = T</h4></section></summary><div class=\"docblock\">The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88\">source</a><a href=\"#method.to_owned\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\">Creates owned data from borrowed data, usually by cloning. <a href=\"../../borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92\">source</a><a href=\"#method.clone_into\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: <a class=\"primitive\" href=\"../../primitive.reference.html\">&amp;mut T</a>)</h4></section></summary><div class=\"docblock\">Uses borrowed data to replace owned data, usually by cloning. <a href=\"../../borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">搂</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">搂</a><h4 class=\"code-header\">type <a href=\"../../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">搂</a><h4 class=\"code-header\">fn <a href=\"../../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div><script type=\"text/json\" id=\"notable-traits-data\">{\"ExtractIf<'_, K, V, F, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.ExtractIf.html\\\" title=\\\"struct std::collections::btree_map::ExtractIf\\\">ExtractIf</a>&lt;'_, K, V, F, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;K, V, F, A&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.ExtractIf.html\\\" title=\\\"struct std::collections::btree_map::ExtractIf\\\">ExtractIf</a>&lt;'_, K, V, F, A&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"../../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a> + <a class=\\\"trait\\\" href=\\\"../../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a>,\\n    F: <a class=\\\"trait\\\" href=\\\"../../ops/trait.FnMut.html\\\" title=\\\"trait std::ops::FnMut\\\">FnMut</a>(<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;mut V</a>) -&gt; <a class=\\\"primitive\\\" href=\\\"../../primitive.bool.html\\\">bool</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../../primitive.tuple.html\\\">(K, V)</a>;</div>\",\"IntoIter<K, V, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.IntoIter.html\\\" title=\\\"struct std::collections::btree_map::IntoIter\\\">IntoIter</a>&lt;K, V, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;K, V, A&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.IntoIter.html\\\" title=\\\"struct std::collections::btree_map::IntoIter\\\">IntoIter</a>&lt;K, V, A&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"../../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a> + <a class=\\\"trait\\\" href=\\\"../../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../../primitive.tuple.html\\\">(K, V)</a>;</div>\",\"IntoKeys<K, V, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.IntoKeys.html\\\" title=\\\"struct std::collections::btree_map::IntoKeys\\\">IntoKeys</a>&lt;K, V, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;K, V, A&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.IntoKeys.html\\\" title=\\\"struct std::collections::btree_map::IntoKeys\\\">IntoKeys</a>&lt;K, V, A&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"../../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a> + <a class=\\\"trait\\\" href=\\\"../../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = K;</div>\",\"IntoValues<K, V, A>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.IntoValues.html\\\" title=\\\"struct std::collections::btree_map::IntoValues\\\">IntoValues</a>&lt;K, V, A&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;K, V, A&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.IntoValues.html\\\" title=\\\"struct std::collections::btree_map::IntoValues\\\">IntoValues</a>&lt;K, V, A&gt;<div class=\\\"where\\\">where\\n    A: <a class=\\\"trait\\\" href=\\\"../../alloc/trait.Allocator.html\\\" title=\\\"trait std::alloc::Allocator\\\">Allocator</a> + <a class=\\\"trait\\\" href=\\\"../../clone/trait.Clone.html\\\" title=\\\"trait std::clone::Clone\\\">Clone</a>,</div></div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = V;</div>\",\"Iter<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Iter.html\\\" title=\\\"struct std::collections::btree_map::Iter\\\">Iter</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Iter.html\\\" title=\\\"struct std::collections::btree_map::Iter\\\">Iter</a>&lt;'a, K, V&gt;<div class=\\\"where\\\">where\\n    K: 'a,\\n    V: 'a,</div></div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a V</a>);</div>\",\"Iter<'a, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Iter.html\\\" title=\\\"struct std::collections::btree_map::Iter\\\">Iter</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Iter.html\\\" title=\\\"struct std::collections::btree_map::Iter\\\">Iter</a>&lt;'a, K, V&gt;<div class=\\\"where\\\">where\\n    K: 'a,\\n    V: 'a,</div></div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a V</a>);</div>\",\"IterMut<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.IterMut.html\\\" title=\\\"struct std::collections::btree_map::IterMut\\\">IterMut</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.IterMut.html\\\" title=\\\"struct std::collections::btree_map::IterMut\\\">IterMut</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a mut V</a>);</div>\",\"IterMut<'a, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.IterMut.html\\\" title=\\\"struct std::collections::btree_map::IterMut\\\">IterMut</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.IterMut.html\\\" title=\\\"struct std::collections::btree_map::IterMut\\\">IterMut</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a mut V</a>);</div>\",\"Keys<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Keys.html\\\" title=\\\"struct std::collections::btree_map::Keys\\\">Keys</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Keys.html\\\" title=\\\"struct std::collections::btree_map::Keys\\\">Keys</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>;</div>\",\"Range<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Range.html\\\" title=\\\"struct std::collections::btree_map::Range\\\">Range</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Range.html\\\" title=\\\"struct std::collections::btree_map::Range\\\">Range</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a V</a>);</div>\",\"RangeMut<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.RangeMut.html\\\" title=\\\"struct std::collections::btree_map::RangeMut\\\">RangeMut</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.RangeMut.html\\\" title=\\\"struct std::collections::btree_map::RangeMut\\\">RangeMut</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = (<a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a K</a>, <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a mut V</a>);</div>\",\"Values<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.Values.html\\\" title=\\\"struct std::collections::btree_map::Values\\\">Values</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.Values.html\\\" title=\\\"struct std::collections::btree_map::Values\\\">Values</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a V</a>;</div>\",\"ValuesMut<'_, K, V>\":\"<h3>Notable traits for <code><a class=\\\"struct\\\" href=\\\"struct.ValuesMut.html\\\" title=\\\"struct std::collections::btree_map::ValuesMut\\\">ValuesMut</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\\\"where\\\">impl&lt;'a, K, V&gt; <a class=\\\"trait\\\" href=\\\"../../iter/trait.Iterator.html\\\" title=\\\"trait std::iter::Iterator\\\">Iterator</a> for <a class=\\\"struct\\\" href=\\\"struct.ValuesMut.html\\\" title=\\\"struct std::collections::btree_map::ValuesMut\\\">ValuesMut</a>&lt;'a, K, V&gt;</div><div class=\\\"where\\\">    type <a href=\\\"../../iter/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\">Item</a> = <a class=\\\"primitive\\\" href=\\\"../../primitive.reference.html\\\">&amp;'a mut V</a>;</div>\"}</script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:25:58.935Z"
}