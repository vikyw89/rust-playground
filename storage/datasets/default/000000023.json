{
	"title": "Method Syntax - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html",
	"markdown": "# Method Syntax - The Rust Programming Language\n\n_Methods_ are similar to functions: we declare them with the `fn` keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum or a trait object, which we cover in [Chapter 6](ch06-00-enums.html) and [Chapter 17](ch17-02-trait-objects.html), respectively), and their first parameter is always `self`, which represents the instance of the struct the method is being called on.\n\n### [Defining Methods](#defining-methods)\n\nLet’s change the `area` function that has a `Rectangle` instance as a parameter and instead make an `area` method defined on the `Rectangle` struct, as shown in Listing 5-13.\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n```\n\nListing 5-13: Defining an `area` method on the `Rectangle` struct\n\nTo define the function within the context of `Rectangle`, we start an `impl` (implementation) block for `Rectangle`. Everything within this `impl` block will be associated with the `Rectangle` type. Then we move the `area` function within the `impl` curly brackets and change the first (and in this case, only) parameter to be `self` in the signature and everywhere within the body. In `main`, where we called the `area` function and passed `rect1` as an argument, we can instead use _method syntax_ to call the `area` method on our `Rectangle` instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.\n\nIn the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`. The `&self` is actually short for `self: &Self`. Within an `impl` block, the type `Self` is an alias for the type that the `impl` block is for. Methods must have a parameter named `self` of type `Self` for their first parameter, so Rust lets you abbreviate this with only the name `self` in the first parameter spot. Note that we still need to use the `&` in front of the `self` shorthand to indicate that this method borrows the `Self` instance, just as we did in `rectangle: &Rectangle`. Methods can take ownership of `self`, borrow `self` immutably, as we’ve done here, or borrow `self` mutably, just as they can any other parameter.\n\nWe chose `&self` here for the same reason we used `&Rectangle` in the function version: we don’t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use `&mut self` as the first parameter. Having a method that takes ownership of the instance by using just `self` as the first parameter is rare; this technique is usually used when the method transforms `self` into something else and you want to prevent the caller from using the original instance after the transformation.\n\nThe main reason for using methods instead of functions, in addition to providing method syntax and not having to repeat the type of `self` in every method’s signature, is for organization. We’ve put all the things we can do with an instance of a type in one `impl` block rather than making future users of our code search for capabilities of `Rectangle` in various places in the library we provide.\n\nNote that we can choose to give a method the same name as one of the struct’s fields. For example, we can define a method on `Rectangle` that is also named `width`:\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn width(&self) -> bool {\n        self.width > 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    if rect1.width() {\n        println!(\"The rectangle has a nonzero width; it is {}\", rect1.width);\n    }\n}\n```\n\nHere, we’re choosing to make the `width` method return `true` if the value in the instance’s `width` field is greater than `0` and `false` if the value is `0`: we can use a field within a method of the same name for any purpose. In `main`, when we follow `rect1.width` with parentheses, Rust knows we mean the method `width`. When we don’t use parentheses, Rust knows we mean the field `width`.\n\nOften, but not always, when we give a method the same name as a field we want it to only return the value in the field and do nothing else. Methods like this are called _getters_, and Rust does not implement them automatically for struct fields as some other languages do. Getters are useful because you can make the field private but the method public, and thus enable read-only access to that field as part of the type’s public API. We will discuss what public and private are and how to designate a field or method as public or private in [Chapter 7](about:blank/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword).\n\n### [Where’s the `->` Operator?](#wheres-the---operator)\n\nIn C and C++, two different operators are used for calling methods: you use `.` if you’re calling a method on the object directly and `->` if you’re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if `object` is a pointer, `object->something()` is similar to `(*object).something()`.\n\nRust doesn’t have an equivalent to the `->` operator; instead, Rust has a feature called _automatic referencing and dereferencing_. Calling methods is one of the few places in Rust that has this behavior.\n\nHere’s how it works: when you call a method with `object.something()`, Rust automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of the method. In other words, the following are the same:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[derive(Debug,Copy,Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl Point {\n   fn distance(&self, other: &Point) -> f64 {\n       let x_squared = f64::powi(other.x - self.x, 2);\n       let y_squared = f64::powi(other.y - self.y, 2);\n\n       f64::sqrt(x_squared + y_squared)\n   }\n}\nlet p1 = Point { x: 0.0, y: 0.0 };\nlet p2 = Point { x: 5.0, y: 6.5 };\np1.distance(&p2);\n(&p1).distance(&p2);\n}\n```\n\nThe first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver—the type of `self`. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.\n\n### [Methods with More Parameters](#methods-with-more-parameters)\n\nLet’s practice using methods by implementing a second method on the `Rectangle` struct. This time we want an instance of `Rectangle` to take another instance of `Rectangle` and return `true` if the second `Rectangle` can fit completely within `self` (the first `Rectangle`); otherwise, it should return `false`. That is, once we’ve defined the `can_hold` method, we want to be able to write the program shown in Listing 5-14.\n\nFilename: src/main.rs\n\n```rust\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n}\n```\n\nListing 5-14: Using the as-yet-unwritten `can_hold` method\n\nThe expected output would look like the following because both dimensions of `rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider than `rect1`:\n\n```text\nCan rect1 hold rect2? true\nCan rect1 hold rect3? false\n\n```\n\nWe know we want to define a method, so it will be within the `impl Rectangle` block. The method name will be `can_hold`, and it will take an immutable borrow of another `Rectangle` as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: `rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to `rect2`, an instance of `Rectangle`. This makes sense because we only need to read `rect2` (rather than write, which would mean we’d need a mutable borrow), and we want `main` to retain ownership of `rect2` so we can use it again after calling the `can_hold` method. The return value of `can_hold` will be a Boolean, and the implementation will check whether the width and height of `self` are greater than the width and height of the other `Rectangle`, respectively. Let’s add the new `can_hold` method to the `impl` block from Listing 5-13, shown in Listing 5-15.\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n}\n```\n\nListing 5-15: Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter\n\nWhen we run this code with the `main` function in Listing 5-14, we’ll get our desired output. Methods can take multiple parameters that we add to the signature after the `self` parameter, and those parameters work just like parameters in functions.\n\n### [Associated Functions](#associated-functions)\n\nAll functions defined within an `impl` block are called _associated functions_ because they’re associated with the type named after the `impl`. We can define associated functions that don’t have `self` as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with. We’ve already used one function like this: the `String::from` function that’s defined on the `String` type.\n\nAssociated functions that aren’t methods are often used for constructors that will return a new instance of the struct. These are often called `new`, but `new` isn’t a special name and isn’t built into the language. For example, we could choose to provide an associated function named `square` that would have one dimension parameter and use that as both width and height, thus making it easier to create a square `Rectangle` rather than having to specify the same value twice:\n\nFilename: src/main.rs\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn square(size: u32) -> Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nfn main() {\n    let sq = Rectangle::square(3);\n}\n```\n\nThe `Self` keywords in the return type and in the body of the function are aliases for the type that appears after the `impl` keyword, which in this case is `Rectangle`.\n\nTo call this associated function, we use the `::` syntax with the struct name; `let sq = Rectangle::square(3);` is an example. This function is namespaced by the struct: the `::` syntax is used for both associated functions and namespaces created by modules. We’ll discuss modules in [Chapter 7](ch07-02-defining-modules-to-control-scope-and-privacy.html).\n\n### [Multiple `impl` Blocks](#multiple-impl-blocks)\n\nEach struct is allowed to have multiple `impl` blocks. For example, Listing 5-15 is equivalent to the code shown in Listing 5-16, which has each method in its own `impl` block.\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n}\n```\n\nListing 5-16: Rewriting Listing 5-15 using multiple `impl` blocks\n\nThere’s no reason to separate these methods into multiple `impl` blocks here, but this is valid syntax. We’ll see a case in which multiple `impl` blocks are useful in Chapter 10, where we discuss generic types and traits.\n\n## [Summary](#summary)\n\nStructs let you create custom types that are meaningful for your domain. By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear. In `impl` blocks, you can define functions that are associated with your type, and methods are a kind of associated function that let you specify the behavior that instances of your structs have.\n\nBut structs aren’t the only way you can create custom types: let’s turn to Rust’s enum feature to add another tool to your toolbox.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Method Syntax - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"method-syntax\"><a class=\"header\" href=\"#method-syntax\">Method Syntax</a></h2>\n<p><em>Methods</em> are similar to functions: we declare them with the <code class=\"hljs\">fn</code> keyword and a\nname, they can have parameters and a return value, and they contain some code\nthat’s run when the method is called from somewhere else. Unlike functions,\nmethods are defined within the context of a struct (or an enum or a trait\nobject, which we cover in <a href=\"ch06-00-enums.html\">Chapter 6</a><!-- ignore --> and <a href=\"ch17-02-trait-objects.html\">Chapter\n17</a><!-- ignore -->, respectively), and their first parameter is\nalways <code class=\"hljs\">self</code>, which represents the instance of the struct the method is being\ncalled on.</p>\n<h3 id=\"defining-methods\"><a class=\"header\" href=\"#defining-methods\">Defining Methods</a></h3>\n<p>Let’s change the <code class=\"hljs\">area</code> function that has a <code class=\"hljs\">Rectangle</code> instance as a parameter\nand instead make an <code class=\"hljs\">area</code> method defined on the <code class=\"hljs\">Rectangle</code> struct, as shown\nin Listing 5-13.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button></div><code class=\"language-rust hljs\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n    width: <span class=\"hljs-built_in\">u32</span>,\n    height: <span class=\"hljs-built_in\">u32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">area</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">u32</span> {\n        <span class=\"hljs-keyword\">self</span>.width * <span class=\"hljs-keyword\">self</span>.height\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> rect1 = Rectangle {\n        width: <span class=\"hljs-number\">30</span>,\n        height: <span class=\"hljs-number\">50</span>,\n    };\n\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"The area of the rectangle is {} square pixels.\"</span>,\n        rect1.area()\n    );\n}</code></pre></pre>\n<p><span class=\"caption\">Listing 5-13: Defining an <code class=\"hljs\">area</code> method on the\n<code class=\"hljs\">Rectangle</code> struct</span></p>\n<p>To define the function within the context of <code class=\"hljs\">Rectangle</code>, we start an <code class=\"hljs\">impl</code>\n(implementation) block for <code class=\"hljs\">Rectangle</code>. Everything within this <code class=\"hljs\">impl</code> block\nwill be associated with the <code class=\"hljs\">Rectangle</code> type. Then we move the <code class=\"hljs\">area</code> function\nwithin the <code class=\"hljs\">impl</code> curly brackets and change the first (and in this case, only)\nparameter to be <code class=\"hljs\">self</code> in the signature and everywhere within the body. In\n<code class=\"hljs\">main</code>, where we called the <code class=\"hljs\">area</code> function and passed <code class=\"hljs\">rect1</code> as an argument,\nwe can instead use <em>method syntax</em> to call the <code class=\"hljs\">area</code> method on our <code class=\"hljs\">Rectangle</code>\ninstance. The method syntax goes after an instance: we add a dot followed by\nthe method name, parentheses, and any arguments.</p>\n<p>In the signature for <code class=\"hljs\">area</code>, we use <code class=\"hljs\">&amp;self</code> instead of <code class=\"hljs\">rectangle: &amp;Rectangle</code>.\nThe <code class=\"hljs\">&amp;self</code> is actually short for <code class=\"hljs\">self: &amp;Self</code>. Within an <code class=\"hljs\">impl</code> block, the\ntype <code class=\"hljs\">Self</code> is an alias for the type that the <code class=\"hljs\">impl</code> block is for. Methods must\nhave a parameter named <code class=\"hljs\">self</code> of type <code class=\"hljs\">Self</code> for their first parameter, so Rust\nlets you abbreviate this with only the name <code class=\"hljs\">self</code> in the first parameter spot.\nNote that we still need to use the <code class=\"hljs\">&amp;</code> in front of the <code class=\"hljs\">self</code> shorthand to\nindicate that this method borrows the <code class=\"hljs\">Self</code> instance, just as we did in\n<code class=\"hljs\">rectangle: &amp;Rectangle</code>. Methods can take ownership of <code class=\"hljs\">self</code>, borrow <code class=\"hljs\">self</code>\nimmutably, as we’ve done here, or borrow <code class=\"hljs\">self</code> mutably, just as they can any\nother parameter.</p>\n<p>We chose <code class=\"hljs\">&amp;self</code> here for the same reason we used <code class=\"hljs\">&amp;Rectangle</code> in the function\nversion: we don’t want to take ownership, and we just want to read the data in\nthe struct, not write to it. If we wanted to change the instance that we’ve\ncalled the method on as part of what the method does, we’d use <code class=\"hljs\">&amp;mut self</code> as\nthe first parameter. Having a method that takes ownership of the instance by\nusing just <code class=\"hljs\">self</code> as the first parameter is rare; this technique is usually\nused when the method transforms <code class=\"hljs\">self</code> into something else and you want to\nprevent the caller from using the original instance after the transformation.</p>\n<p>The main reason for using methods instead of functions, in addition to\nproviding method syntax and not having to repeat the type of <code class=\"hljs\">self</code> in every\nmethod’s signature, is for organization. We’ve put all the things we can do\nwith an instance of a type in one <code class=\"hljs\">impl</code> block rather than making future users\nof our code search for capabilities of <code class=\"hljs\">Rectangle</code> in various places in the\nlibrary we provide.</p>\n<p>Note that we can choose to give a method the same name as one of the struct’s\nfields. For example, we can define a method on <code class=\"hljs\">Rectangle</code> that is also named\n<code class=\"hljs\">width</code>:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">width</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.width &gt; <span class=\"hljs-number\">0</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> rect1 = Rectangle {\n        width: <span class=\"hljs-number\">30</span>,\n        height: <span class=\"hljs-number\">50</span>,\n    };\n\n    <span class=\"hljs-keyword\">if</span> rect1.width() {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The rectangle has a nonzero width; it is {}\"</span>, rect1.width);\n    }\n}</code></pre></pre>\n<p>Here, we’re choosing to make the <code class=\"hljs\">width</code> method return <code class=\"hljs\">true</code> if the value in\nthe instance’s <code class=\"hljs\">width</code> field is greater than <code class=\"hljs\">0</code> and <code class=\"hljs\">false</code> if the value is\n<code class=\"hljs\">0</code>: we can use a field within a method of the same name for any purpose. In\n<code class=\"hljs\">main</code>, when we follow <code class=\"hljs\">rect1.width</code> with parentheses, Rust knows we mean the\nmethod <code class=\"hljs\">width</code>. When we don’t use parentheses, Rust knows we mean the field\n<code class=\"hljs\">width</code>.</p>\n<p>Often, but not always, when we give a method the same name as a field we want\nit to only return the value in the field and do nothing else. Methods like this\nare called <em>getters</em>, and Rust does not implement them automatically for struct\nfields as some other languages do. Getters are useful because you can make the\nfield private but the method public, and thus enable read-only access to that\nfield as part of the type’s public API. We will discuss what public and private\nare and how to designate a field or method as public or private in <a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword\">Chapter\n7</a><!-- ignore -->.</p>\n<section class=\"note\" aria-role=\"note\">\n<h3 id=\"wheres-the---operator\"><a class=\"header\" href=\"#wheres-the---operator\">Where’s the <code>-&gt;</code> Operator?</a></h3>\n<p>In C and C++, two different operators are used for calling methods: you use\n<code class=\"hljs\">.</code> if you’re calling a method on the object directly and <code class=\"hljs\">-&gt;</code> if you’re\ncalling the method on a pointer to the object and need to dereference the\npointer first. In other words, if <code class=\"hljs\">object</code> is a pointer,\n<code class=\"hljs\">object-&gt;something()</code> is similar to <code class=\"hljs\">(*object).something()</code>.</p>\n<p>Rust doesn’t have an equivalent to the <code class=\"hljs\">-&gt;</code> operator; instead, Rust has a\nfeature called <em>automatic referencing and dereferencing</em>. Calling methods is\none of the few places in Rust that has this behavior.</p>\n<p>Here’s how it works: when you call a method with <code class=\"hljs\">object.something()</code>, Rust\nautomatically adds in <code class=\"hljs\">&amp;</code>, <code class=\"hljs\">&amp;mut</code>, or <code class=\"hljs\">*</code> so <code class=\"hljs\">object</code> matches the signature of\nthe method. In other words, the following are the same:</p>\n<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug,Copy,Clone)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Point</span></span> {\n</span><span class=\"boring\">    x: <span class=\"hljs-built_in\">f64</span>,\n</span><span class=\"boring\">    y: <span class=\"hljs-built_in\">f64</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Point {\n</span><span class=\"boring\">   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">distance</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Point) -&gt; <span class=\"hljs-built_in\">f64</span> {\n</span><span class=\"boring\">       <span class=\"hljs-keyword\">let</span> x_squared = <span class=\"hljs-built_in\">f64</span>::powi(other.x - <span class=\"hljs-keyword\">self</span>.x, <span class=\"hljs-number\">2</span>);\n</span><span class=\"boring\">       <span class=\"hljs-keyword\">let</span> y_squared = <span class=\"hljs-built_in\">f64</span>::powi(other.y - <span class=\"hljs-keyword\">self</span>.y, <span class=\"hljs-number\">2</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">       <span class=\"hljs-built_in\">f64</span>::sqrt(x_squared + y_squared)\n</span><span class=\"boring\">   }\n</span><span class=\"boring\">}\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> p1 = Point { x: <span class=\"hljs-number\">0.0</span>, y: <span class=\"hljs-number\">0.0</span> };\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> p2 = Point { x: <span class=\"hljs-number\">5.0</span>, y: <span class=\"hljs-number\">6.5</span> };\n</span>p1.distance(&amp;p2);\n(&amp;p1).distance(&amp;p2);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The first one looks much cleaner. This automatic referencing behavior works\nbecause methods have a clear receiver—the type of <code class=\"hljs\">self</code>. Given the receiver\nand name of a method, Rust can figure out definitively whether the method is\nreading (<code class=\"hljs\">&amp;self</code>), mutating (<code class=\"hljs\">&amp;mut self</code>), or consuming (<code class=\"hljs\">self</code>). The fact\nthat Rust makes borrowing implicit for method receivers is a big part of\nmaking ownership ergonomic in practice.</p>\n</section>\n<h3 id=\"methods-with-more-parameters\"><a class=\"header\" href=\"#methods-with-more-parameters\">Methods with More Parameters</a></h3>\n<p>Let’s practice using methods by implementing a second method on the <code class=\"hljs\">Rectangle</code>\nstruct. This time we want an instance of <code class=\"hljs\">Rectangle</code> to take another instance\nof <code class=\"hljs\">Rectangle</code> and return <code class=\"hljs\">true</code> if the second <code class=\"hljs\">Rectangle</code> can fit completely\nwithin <code class=\"hljs\">self</code> (the first <code class=\"hljs\">Rectangle</code>); otherwise, it should return <code class=\"hljs\">false</code>.\nThat is, once we’ve defined the <code class=\"hljs\">can_hold</code> method, we want to be able to write\nthe program shown in Listing 5-14.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> rect1 = Rectangle {\n        width: <span class=\"hljs-number\">30</span>,\n        height: <span class=\"hljs-number\">50</span>,\n    };\n    <span class=\"hljs-keyword\">let</span> rect2 = Rectangle {\n        width: <span class=\"hljs-number\">10</span>,\n        height: <span class=\"hljs-number\">40</span>,\n    };\n    <span class=\"hljs-keyword\">let</span> rect3 = Rectangle {\n        width: <span class=\"hljs-number\">60</span>,\n        height: <span class=\"hljs-number\">45</span>,\n    };\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can rect1 hold rect2? {}\"</span>, rect1.can_hold(&amp;rect2));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can rect1 hold rect3? {}\"</span>, rect1.can_hold(&amp;rect3));\n}</code></pre>\n<p><span class=\"caption\">Listing 5-14: Using the as-yet-unwritten <code class=\"hljs\">can_hold</code>\nmethod</span></p>\n<p>The expected output would look like the following because both dimensions of\n<code class=\"hljs\">rect2</code> are smaller than the dimensions of <code class=\"hljs\">rect1</code>, but <code class=\"hljs\">rect3</code> is wider than\n<code class=\"hljs\">rect1</code>:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-text hljs plaintext\">Can rect1 hold rect2? true\nCan rect1 hold rect3? false\n</code></pre>\n<p>We know we want to define a method, so it will be within the <code class=\"hljs\">impl Rectangle</code>\nblock. The method name will be <code class=\"hljs\">can_hold</code>, and it will take an immutable borrow\nof another <code class=\"hljs\">Rectangle</code> as a parameter. We can tell what the type of the\nparameter will be by looking at the code that calls the method:\n<code class=\"hljs\">rect1.can_hold(&amp;rect2)</code> passes in <code class=\"hljs\">&amp;rect2</code>, which is an immutable borrow to\n<code class=\"hljs\">rect2</code>, an instance of <code class=\"hljs\">Rectangle</code>. This makes sense because we only need to\nread <code class=\"hljs\">rect2</code> (rather than write, which would mean we’d need a mutable borrow),\nand we want <code class=\"hljs\">main</code> to retain ownership of <code class=\"hljs\">rect2</code> so we can use it again after\ncalling the <code class=\"hljs\">can_hold</code> method. The return value of <code class=\"hljs\">can_hold</code> will be a\nBoolean, and the implementation will check whether the width and height of\n<code class=\"hljs\">self</code> are greater than the width and height of the other <code class=\"hljs\">Rectangle</code>,\nrespectively. Let’s add the new <code class=\"hljs\">can_hold</code> method to the <code class=\"hljs\">impl</code> block from\nListing 5-13, shown in Listing 5-15.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">area</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">u32</span> {\n        <span class=\"hljs-keyword\">self</span>.width * <span class=\"hljs-keyword\">self</span>.height\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">can_hold</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rectangle) -&gt; <span class=\"hljs-built_in\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.width &gt; other.width &amp;&amp; <span class=\"hljs-keyword\">self</span>.height &gt; other.height\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> rect1 = Rectangle {\n</span><span class=\"boring\">        width: <span class=\"hljs-number\">30</span>,\n</span><span class=\"boring\">        height: <span class=\"hljs-number\">50</span>,\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> rect2 = Rectangle {\n</span><span class=\"boring\">        width: <span class=\"hljs-number\">10</span>,\n</span><span class=\"boring\">        height: <span class=\"hljs-number\">40</span>,\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> rect3 = Rectangle {\n</span><span class=\"boring\">        width: <span class=\"hljs-number\">60</span>,\n</span><span class=\"boring\">        height: <span class=\"hljs-number\">45</span>,\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can rect1 hold rect2? {}\"</span>, rect1.can_hold(&amp;rect2));\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can rect1 hold rect3? {}\"</span>, rect1.can_hold(&amp;rect3));\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 5-15: Implementing the <code class=\"hljs\">can_hold</code> method on\n<code class=\"hljs\">Rectangle</code> that takes another <code class=\"hljs\">Rectangle</code> instance as a parameter</span></p>\n<p>When we run this code with the <code class=\"hljs\">main</code> function in Listing 5-14, we’ll get our\ndesired output. Methods can take multiple parameters that we add to the\nsignature after the <code class=\"hljs\">self</code> parameter, and those parameters work just like\nparameters in functions.</p>\n<h3 id=\"associated-functions\"><a class=\"header\" href=\"#associated-functions\">Associated Functions</a></h3>\n<p>All functions defined within an <code class=\"hljs\">impl</code> block are called <em>associated functions</em>\nbecause they’re associated with the type named after the <code class=\"hljs\">impl</code>. We can define\nassociated functions that don’t have <code class=\"hljs\">self</code> as their first parameter (and thus\nare not methods) because they don’t need an instance of the type to work with.\nWe’ve already used one function like this: the <code class=\"hljs\">String::from</code> function that’s\ndefined on the <code class=\"hljs\">String</code> type.</p>\n<p>Associated functions that aren’t methods are often used for constructors that\nwill return a new instance of the struct. These are often called <code class=\"hljs\">new</code>, but\n<code class=\"hljs\">new</code> isn’t a special name and isn’t built into the language. For example, we\ncould choose to provide an associated function named <code class=\"hljs\">square</code> that would have\none dimension parameter and use that as both width and height, thus making it\neasier to create a square <code class=\"hljs\">Rectangle</code> rather than having to specify the same\nvalue twice:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">square</span></span>(size: <span class=\"hljs-built_in\">u32</span>) -&gt; <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">Self</span> {\n            width: size,\n            height: size,\n        }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> sq = Rectangle::square(<span class=\"hljs-number\">3</span>);\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>The <code class=\"hljs\">Self</code> keywords in the return type and in the body of the function are\naliases for the type that appears after the <code class=\"hljs\">impl</code> keyword, which in this case\nis <code class=\"hljs\">Rectangle</code>.</p>\n<p>To call this associated function, we use the <code class=\"hljs\">::</code> syntax with the struct name;\n<code class=\"hljs\">let sq = Rectangle::square(3);</code> is an example. This function is namespaced by\nthe struct: the <code class=\"hljs\">::</code> syntax is used for both associated functions and\nnamespaces created by modules. We’ll discuss modules in <a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\">Chapter\n7</a><!-- ignore -->.</p>\n<h3 id=\"multiple-impl-blocks\"><a class=\"header\" href=\"#multiple-impl-blocks\">Multiple <code>impl</code> Blocks</a></h3>\n<p>Each struct is allowed to have multiple <code class=\"hljs\">impl</code> blocks. For example, Listing\n5-15 is equivalent to the code shown in Listing 5-16, which has each method in\nits own <code class=\"hljs\">impl</code> block.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#[derive(Debug)]</span>\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Rectangle</span></span> {\n</span><span class=\"boring\">    width: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">    height: <span class=\"hljs-built_in\">u32</span>,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">area</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">u32</span> {\n        <span class=\"hljs-keyword\">self</span>.width * <span class=\"hljs-keyword\">self</span>.height\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> Rectangle {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">can_hold</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rectangle) -&gt; <span class=\"hljs-built_in\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.width &gt; other.width &amp;&amp; <span class=\"hljs-keyword\">self</span>.height &gt; other.height\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> rect1 = Rectangle {\n</span><span class=\"boring\">        width: <span class=\"hljs-number\">30</span>,\n</span><span class=\"boring\">        height: <span class=\"hljs-number\">50</span>,\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> rect2 = Rectangle {\n</span><span class=\"boring\">        width: <span class=\"hljs-number\">10</span>,\n</span><span class=\"boring\">        height: <span class=\"hljs-number\">40</span>,\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> rect3 = Rectangle {\n</span><span class=\"boring\">        width: <span class=\"hljs-number\">60</span>,\n</span><span class=\"boring\">        height: <span class=\"hljs-number\">45</span>,\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can rect1 hold rect2? {}\"</span>, rect1.can_hold(&amp;rect2));\n</span><span class=\"boring\">    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Can rect1 hold rect3? {}\"</span>, rect1.can_hold(&amp;rect3));\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p><span class=\"caption\">Listing 5-16: Rewriting Listing 5-15 using multiple <code class=\"hljs\">impl</code>\nblocks</span></p>\n<p>There’s no reason to separate these methods into multiple <code class=\"hljs\">impl</code> blocks here,\nbut this is valid syntax. We’ll see a case in which multiple <code class=\"hljs\">impl</code> blocks are\nuseful in Chapter 10, where we discuss generic types and traits.</p>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<p>Structs let you create custom types that are meaningful for your domain. By\nusing structs, you can keep associated pieces of data connected to each other\nand name each piece to make your code clear. In <code class=\"hljs\">impl</code> blocks, you can define\nfunctions that are associated with your type, and methods are a kind of\nassociated function that let you specify the behavior that instances of your\nstructs have.</p>\n<p>But structs aren’t the only way you can create custom types: let’s turn to\nRust’s enum feature to add another tool to your toolbox.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch05-02-example-structs.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"ch06-00-enums.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch05-02-example-structs.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"ch06-00-enums.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:16.723Z"
}