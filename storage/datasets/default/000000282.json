{
	"title": "std::io - Rust",
	"url": "https://doc.rust-lang.org/stable/std/io/index.html",
	"markdown": "# std::io - Rust\n\n## Module [std](../index.html)::[io](#)\n\n1.0.0 · [source](about:blank/src/std/io/mod.rs.html#1-3195) ·\n\nExpand description\n\nTraits, helpers, and type definitions for core I/O functionality.\n\nThe `std::io` module contains a number of common things you’ll need when doing input and output. The most core part of this module is the [`Read`](trait.Read.html \"trait std::io::Read\") and [`Write`](trait.Write.html \"trait std::io::Write\") traits, which provide the most general interface for reading and writing input and output.\n\n### [§](#read-and-write)Read and Write\n\nBecause they are traits, [`Read`](trait.Read.html \"trait std::io::Read\") and [`Write`](trait.Write.html \"trait std::io::Write\") are implemented by a number of other types, and you can implement them for your types too. As such, you’ll see a few different types of I/O throughout the documentation in this module: [`File`](../fs/struct.File.html \"struct std::fs::File\")s, [`TcpStream`](../net/struct.TcpStream.html \"struct std::net::TcpStream\")s, and sometimes even [`Vec<T>`](../vec/struct.Vec.html \"struct std::vec::Vec\")s. For example, [`Read`](trait.Read.html \"trait std::io::Read\") adds a [`read`](about:blank/trait.Read.html#tymethod.read \"method std::io::Read::read\") method, which we can use on [`File`](../fs/struct.File.html \"struct std::fs::File\")s:\n\n```\nuse std::io;\nuse std::io::prelude::*;\nuse std::fs::File;\n\nfn main() -> io::Result<()> {\n    let mut f = File::open(\"foo.txt\")?;\n    let mut buffer = [0; 10];\n\n    // read up to 10 bytes\n    let n = f.read(&mut buffer)?;\n\n    println!(\"The bytes: {:?}\", &buffer[..n]);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+f+=+File::open(%22foo.txt%22)?;%0A++++let+mut+buffer+=+%5B0;+10%5D;%0A%0A++++//+read+up+to+10+bytes%0A++++let+n+=+f.read(%26mut+buffer)?;%0A%0A++++println!(%22The+bytes:+%7B:?%7D%22,+%26buffer%5B..n%5D);%0A++++Ok(())%0A%7D&edition=2021)\n\n[`Read`](trait.Read.html \"trait std::io::Read\") and [`Write`](trait.Write.html \"trait std::io::Write\") are so important, implementors of the two traits have a nickname: readers and writers. So you’ll sometimes see ‘a reader’ instead of ‘a type that implements the [`Read`](trait.Read.html \"trait std::io::Read\") trait’. Much easier!\n\n### [§](#seek-and-bufread)Seek and BufRead\n\nBeyond that, there are two important traits that are provided: [`Seek`](trait.Seek.html \"trait std::io::Seek\") and [`BufRead`](trait.BufRead.html \"trait std::io::BufRead\"). Both of these build on top of a reader to control how the reading happens. [`Seek`](trait.Seek.html \"trait std::io::Seek\") lets you control where the next byte is coming from:\n\n```\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::SeekFrom;\nuse std::fs::File;\n\nfn main() -> io::Result<()> {\n    let mut f = File::open(\"foo.txt\")?;\n    let mut buffer = [0; 10];\n\n    // skip to the last 10 bytes of the file\n    f.seek(SeekFrom::End(-10))?;\n\n    // read up to 10 bytes\n    let n = f.read(&mut buffer)?;\n\n    println!(\"The bytes: {:?}\", &buffer[..n]);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::SeekFrom;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+f+=+File::open(%22foo.txt%22)?;%0A++++let+mut+buffer+=+%5B0;+10%5D;%0A%0A++++//+skip+to+the+last+10+bytes+of+the+file%0A++++f.seek(SeekFrom::End(-10))?;%0A%0A++++//+read+up+to+10+bytes%0A++++let+n+=+f.read(%26mut+buffer)?;%0A%0A++++println!(%22The+bytes:+%7B:?%7D%22,+%26buffer%5B..n%5D);%0A++++Ok(())%0A%7D&edition=2021)\n\n[`BufRead`](trait.BufRead.html \"trait std::io::BufRead\") uses an internal buffer to provide a number of other ways to read, but to show it off, we’ll need to talk about buffers in general. Keep reading!\n\n### [§](#bufreader-and-bufwriter)BufReader and BufWriter\n\nByte-based interfaces are unwieldy and can be inefficient, as we’d need to be making near-constant calls to the operating system. To help with this, `std::io` comes with two structs, [`BufReader`](struct.BufReader.html \"struct std::io::BufReader\") and [`BufWriter`](struct.BufWriter.html \"struct std::io::BufWriter\"), which wrap readers and writers. The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.\n\nFor example, [`BufReader`](struct.BufReader.html \"struct std::io::BufReader\") works with the [`BufRead`](trait.BufRead.html \"trait std::io::BufRead\") trait to add extra methods to any reader:\n\n```\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::fs::File;\n\nfn main() -> io::Result<()> {\n    let f = File::open(\"foo.txt\")?;\n    let mut reader = BufReader::new(f);\n    let mut buffer = String::new();\n\n    // read a line into buffer\n    reader.read_line(&mut buffer)?;\n\n    println!(\"{buffer}\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::BufReader;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+f+=+File::open(%22foo.txt%22)?;%0A++++let+mut+reader+=+BufReader::new(f);%0A++++let+mut+buffer+=+String::new();%0A%0A++++//+read+a+line+into+buffer%0A++++reader.read_line(%26mut+buffer)?;%0A%0A++++println!(%22%7Bbuffer%7D%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n[`BufWriter`](struct.BufWriter.html \"struct std::io::BufWriter\") doesn’t add any new ways of writing; it just buffers every call to [`write`](about:blank/trait.Write.html#tymethod.write \"method std::io::Write::write\"):\n\n```\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufWriter;\nuse std::fs::File;\n\nfn main() -> io::Result<()> {\n    let f = File::create(\"foo.txt\")?;\n    {\n        let mut writer = BufWriter::new(f);\n\n        // write a byte to the buffer\n        writer.write(&[42])?;\n\n    } // the buffer is flushed once writer goes out of scope\n\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::BufWriter;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+f+=+File::create(%22foo.txt%22)?;%0A++++%7B%0A++++++++let+mut+writer+=+BufWriter::new(f);%0A%0A++++++++//+write+a+byte+to+the+buffer%0A++++++++writer.write(%26%5B42%5D)?;%0A%0A++++%7D+//+the+buffer+is+flushed+once+writer+goes+out+of+scope%0A%0A++++Ok(())%0A%7D&edition=2021)\n\n### [§](#standard-input-and-output)Standard input and output\n\nA very common source of input is standard input:\n\n```\nuse std::io;\n\nfn main() -> io::Result<()> {\n    let mut input = String::new();\n\n    io::stdin().read_line(&mut input)?;\n\n    println!(\"You typed: {}\", input.trim());\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+input+=+String::new();%0A%0A++++io::stdin().read_line(%26mut+input)?;%0A%0A++++println!(%22You+typed:+%7B%7D%22,+input.trim());%0A++++Ok(())%0A%7D&edition=2021)\n\nNote that you cannot use the [`?` operator](../../book/appendix-02-operators.html) in functions that do not return a [`Result<T, E>`](../result/enum.Result.html \"enum std::result::Result\"). Instead, you can call [`.unwrap()`](about:blank/result/enum.Result.html#method.unwrap \"method std::result::Result::unwrap\") or `match` on the return value to catch any possible errors:\n\n```\nuse std::io;\n\nlet mut input = String::new();\n\nio::stdin().read_line(&mut input).unwrap();\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::io;%0A++++%0A++++let+mut+input+=+String::new();%0A++++%0A++++io::stdin().read_line(%26mut+input).unwrap();%0A%7D&edition=2021)\n\nAnd a very common source of output is standard output:\n\n```\nuse std::io;\nuse std::io::prelude::*;\n\nfn main() -> io::Result<()> {\n    io::stdout().write(&[42])?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++io::stdout().write(%26%5B42%5D)?;%0A++++Ok(())%0A%7D&edition=2021)\n\nOf course, using [`io::stdout`](fn.stdout.html \"fn std::io::stdout\") directly is less common than something like [`println!`](../macro.println.html \"macro std::println\").\n\n### [§](#iterator-types)Iterator types\n\nA large number of the structures provided by `std::io` are for various ways of iterating over I/O. For example, [`Lines`](struct.Lines.html \"struct std::io::Lines\") is used to split over lines:\n\n```\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::fs::File;\n\nfn main() -> io::Result<()> {\n    let f = File::open(\"foo.txt\")?;\n    let reader = BufReader::new(f);\n\n    for line in reader.lines() {\n        println!(\"{}\", line?);\n    }\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::BufReader;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+f+=+File::open(%22foo.txt%22)?;%0A++++let+reader+=+BufReader::new(f);%0A%0A++++for+line+in+reader.lines()+%7B%0A++++++++println!(%22%7B%7D%22,+line?);%0A++++%7D%0A++++Ok(())%0A%7D&edition=2021)\n\n### [§](#functions)Functions\n\nThere are a number of [functions](#functions-1) that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:\n\n```\nuse std::io;\n\nfn main() -> io::Result<()> {\n    io::copy(&mut io::stdin(), &mut io::stdout())?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++io::copy(%26mut+io::stdin(),+%26mut+io::stdout())?;%0A++++Ok(())%0A%7D&edition=2021)\n\n### [§](#ioresult)io::Result\n\nLast, but certainly not least, is [`io::Result`](type.Result.html \"type std::io::Result\"). This type is used as the return type of many `std::io` functions that can cause an error, and can be returned from your own functions as well. Many of the examples in this module use the [`?` operator](../../book/appendix-02-operators.html):\n\n```\nuse std::io;\n\nfn read_input() -> io::Result<()> {\n    let mut input = String::new();\n\n    io::stdin().read_line(&mut input)?;\n\n    println!(\"You typed: {}\", input.trim());\n\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::io;%0A++++%0A++++fn+read_input()+-%3E+io::Result%3C()%3E+%7B%0A++++++++let+mut+input+=+String::new();%0A++++%0A++++++++io::stdin().read_line(%26mut+input)?;%0A++++%0A++++++++println!(%22You+typed:+%7B%7D%22,+input.trim());%0A++++%0A++++++++Ok(())%0A++++%7D%0A%7D&edition=2021)\n\nThe return type of `read_input()`, [`io::Result<()>`](type.Result.html \"type std::io::Result\"), is a very common type for functions which don’t have a ‘real’ return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use `()`.\n\n### [§](#platform-specific-behavior)Platform-specific behavior\n\nMany I/O functions throughout the standard library are documented to indicate what various library or syscalls they are delegated to. This is done to help applications both understand what’s happening under the hood as well as investigate any possibly unclear semantics. Note, however, that this is informative, not a binding contract. The implementation of many of these functions are subject to change over time and may call fewer or more syscalls/library functions.\n\n### [§](#io-safety)I/O Safety\n\nRust follows an I/O safety discipline that is comparable to its memory safety discipline. This means that file descriptors can be _exclusively owned_. (Here, “file descriptor” is meant to subsume similar concepts that exist across a wide range of operating systems even if they might use a different name, such as “handle”.) An exclusively owned file descriptor is one that no other code is allowed to access in any way, but the owner is allowed to access and even close it any time. A type that owns its file descriptor should usually close it in its `drop` function. Types like [`File`](../fs/struct.File.html \"struct std::fs::File\") own their file descriptor. Similarly, file descriptors can be _borrowed_, granting the temporary right to perform operations on this file descriptor. This indicates that the file descriptor will not be closed for the lifetime of the borrow, but it does _not_ imply any right to close this file descriptor, since it will likely be owned by someone else.\n\nThe platform-specific parts of the Rust standard library expose types that reflect these concepts, see [`os::unix`](../os/unix/io/index.html) and [`os::windows`](../os/windows/io/index.html).\n\nTo uphold I/O safety, it is crucial that no code acts on file descriptors it does not own or borrow, and no code closes file descriptors it does not own. In other words, a safe function that takes a regular integer, treats it as a file descriptor, and acts on it, is _unsound_.\n\nNot upholding I/O safety and acting on a file descriptor without proof of ownership can lead to misbehavior and even Undefined Behavior in code that relies on ownership of its file descriptors: a closed file descriptor could be re-allocated, so the original owner of that file descriptor is now working on the wrong file. Some code might even rely on fully encapsulating its file descriptors with no operations being performed by any other part of the program.\n\nNote that exclusive ownership of a file descriptor does _not_ imply exclusive ownership of the underlying kernel object that the file descriptor references (also called “open file description” on some operating systems). File descriptors basically work like [`Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\"): when you receive an owned file descriptor, you cannot know whether there are any other file descriptors that reference the same kernel object. However, when you create a new kernel object, you know that you are holding the only reference to it. Just be careful not to lend it to anyone, since they can obtain a clone and then you can no longer know what the reference count is! In that sense, [`OwnedFd`](../os/fd/struct.OwnedFd.html) is like `Arc` and [`BorrowedFd<'a>`](../os/fd/struct.BorrowedFd.html) is like `&'a Arc` (and similar for the Windows types). In particular, given a `BorrowedFd<'a>`, you are not allowed to close the file descriptor – just like how, given a `&'a Arc`, you are not allowed to decrement the reference count and potentially free the underlying object. There is no equivalent to `Box` for file descriptors in the standard library (that would be a type that guarantees that the reference count is `1`), however, it would be possible for a crate to define a type with those semantics.\n\n-   The I/O Prelude.\n    \n\n-   The `BufReader<R>` struct adds buffering to any reader.\n    \n-   Wraps a writer and buffers its output.\n    \n-   An iterator over `u8` values of a reader.\n    \n-   Adapter to chain together two readers.\n    \n-   A `Cursor` wraps an in-memory buffer and provides it with a [`Seek`](trait.Seek.html \"trait std::io::Seek\") implementation.\n    \n-   `Empty` ignores any data written via [`Write`](trait.Write.html \"trait std::io::Write\"), and will always be empty (returning zero bytes) when read via [`Read`](trait.Read.html \"trait std::io::Read\").\n    \n-   The error type for I/O operations of the [`Read`](trait.Read.html \"trait std::io::Read\"), [`Write`](trait.Write.html \"trait std::io::Write\"), [`Seek`](trait.Seek.html \"trait std::io::Seek\"), and associated traits.\n    \n-   An error returned by [`BufWriter::into_inner`](about:blank/struct.BufWriter.html#method.into_inner \"method std::io::BufWriter::into_inner\") which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.\n    \n-   A buffer type used with `Write::write_vectored`.\n    \n-   A buffer type used with `Read::read_vectored`.\n    \n-   Wraps a writer and buffers output to it, flushing whenever a newline (`0x0a`, `'\\n'`) is detected.\n    \n-   An iterator over the lines of an instance of `BufRead`.\n    \n-   A reader which yields one byte over and over and over and over and over and…\n    \n-   A writer which will move data into the void.\n    \n-   An iterator over the contents of an instance of `BufRead` split on a particular byte.\n    \n-   A handle to the standard error stream of a process.\n    \n-   A locked reference to the [`Stderr`](struct.Stderr.html \"struct std::io::Stderr\") handle.\n    \n-   A handle to the standard input stream of a process.\n    \n-   A locked reference to the [`Stdin`](struct.Stdin.html \"struct std::io::Stdin\") handle.\n    \n-   A handle to the global standard output stream of the current process.\n    \n-   A locked reference to the [`Stdout`](struct.Stdout.html \"struct std::io::Stdout\") handle.\n    \n-   Reader adapter which limits the bytes read from an underlying reader.\n    \n-   Error returned for the buffered data from `BufWriter::into_parts`, when the underlying writer has previously panicked. Contains the (possibly partly written) buffered data.\n    \n-   A borrowed byte buffer which is incrementally filled and initialized.\n    \n-   A writeable view of the unfilled portion of a [`BorrowedBuf`](struct.BorrowedBuf.html \"struct std::io::BorrowedBuf\").\n    \n\n-   A list specifying general categories of I/O error.\n    \n-   Enumeration of possible methods to seek within an I/O object.\n    \n\n-   A `BufRead` is a type of `Read`er which has an internal buffer, allowing it to perform extra ways of reading.\n    \n-   Trait to determine if a descriptor/handle refers to a terminal/tty.\n    \n-   The `Read` trait allows for reading bytes from a source.\n    \n-   The `Seek` trait provides a cursor which can be moved within a stream of bytes.\n    \n-   A trait for objects which are byte-oriented sinks.\n    \n\n-   Copies the entire contents of a reader into a writer.\n    \n-   Creates a value that is always at EOF for reads, and ignores all data written.\n    \n\n-   Creates an instance of a reader that infinitely repeats one byte.\n    \n-   Creates an instance of a writer which will successfully consume all data.\n    \n-   Constructs a new handle to the standard error of the current process.\n    \n-   Constructs a new handle to the standard input of the current process.\n    \n-   Constructs a new handle to the standard output of the current process.\n    \n\n-   A specialized [`Result`](../result/enum.Result.html \"enum std::result::Result\") type for I/O operations.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Traits, helpers, and type definitions for core I/O functionality.\"><title>std::io - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module io</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module io</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#modules\">Modules</a></li><li><a href=\"#structs\">Structs</a></li><li><a href=\"#enums\">Enums</a></li><li><a href=\"#traits\">Traits</a></li><li><a href=\"#functions\">Functions</a></li><li><a href=\"#types\">Type Aliases</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">io</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/io/mod.rs.html#1-3195\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Traits, helpers, and type definitions for core I/O functionality.</p>\n<p>The <code>std::io</code> module contains a number of common things you’ll need\nwhen doing input and output. The most core part of this module is\nthe <a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a> and <a href=\"trait.Write.html\" title=\"trait std::io::Write\"><code>Write</code></a> traits, which provide the\nmost general interface for reading and writing input and output.</p>\n<h3 id=\"read-and-write\"><a class=\"doc-anchor\" href=\"#read-and-write\">§</a>Read and Write</h3>\n<p>Because they are traits, <a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a> and <a href=\"trait.Write.html\" title=\"trait std::io::Write\"><code>Write</code></a> are implemented by a number\nof other types, and you can implement them for your types too. As such,\nyou’ll see a few different types of I/O throughout the documentation in\nthis module: <a href=\"../fs/struct.File.html\" title=\"struct std::fs::File\"><code>File</code></a>s, <a href=\"../net/struct.TcpStream.html\" title=\"struct std::net::TcpStream\"><code>TcpStream</code></a>s, and sometimes even <a href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\"><code>Vec&lt;T&gt;</code></a>s. For\nexample, <a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a> adds a <a href=\"trait.Read.html#tymethod.read\" title=\"method std::io::Read::read\"><code>read</code></a> method, which we can use on\n<a href=\"../fs/struct.File.html\" title=\"struct std::fs::File\"><code>File</code></a>s:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::fs::File;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>f = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer = [<span class=\"number\">0</span>; <span class=\"number\">10</span>];\n\n    <span class=\"comment\">// read up to 10 bytes\n    </span><span class=\"kw\">let </span>n = f.read(<span class=\"kw-2\">&amp;mut </span>buffer)<span class=\"question-mark\">?</span>;\n\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"The bytes: {:?}\"</span>, <span class=\"kw-2\">&amp;</span>buffer[..n]);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+f+=+File::open(%22foo.txt%22)?;%0A++++let+mut+buffer+=+%5B0;+10%5D;%0A%0A++++//+read+up+to+10+bytes%0A++++let+n+=+f.read(%26mut+buffer)?;%0A%0A++++println!(%22The+bytes:+%7B:?%7D%22,+%26buffer%5B..n%5D);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a> and <a href=\"trait.Write.html\" title=\"trait std::io::Write\"><code>Write</code></a> are so important, implementors of the two traits have a\nnickname: readers and writers. So you’ll sometimes see ‘a reader’ instead\nof ‘a type that implements the <a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a> trait’. Much easier!</p>\n<h3 id=\"seek-and-bufread\"><a class=\"doc-anchor\" href=\"#seek-and-bufread\">§</a>Seek and BufRead</h3>\n<p>Beyond that, there are two important traits that are provided: <a href=\"trait.Seek.html\" title=\"trait std::io::Seek\"><code>Seek</code></a>\nand <a href=\"trait.BufRead.html\" title=\"trait std::io::BufRead\"><code>BufRead</code></a>. Both of these build on top of a reader to control\nhow the reading happens. <a href=\"trait.Seek.html\" title=\"trait std::io::Seek\"><code>Seek</code></a> lets you control where the next byte is\ncoming from:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::io::SeekFrom;\n<span class=\"kw\">use </span>std::fs::File;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>f = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer = [<span class=\"number\">0</span>; <span class=\"number\">10</span>];\n\n    <span class=\"comment\">// skip to the last 10 bytes of the file\n    </span>f.seek(SeekFrom::End(-<span class=\"number\">10</span>))<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// read up to 10 bytes\n    </span><span class=\"kw\">let </span>n = f.read(<span class=\"kw-2\">&amp;mut </span>buffer)<span class=\"question-mark\">?</span>;\n\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"The bytes: {:?}\"</span>, <span class=\"kw-2\">&amp;</span>buffer[..n]);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::SeekFrom;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+f+=+File::open(%22foo.txt%22)?;%0A++++let+mut+buffer+=+%5B0;+10%5D;%0A%0A++++//+skip+to+the+last+10+bytes+of+the+file%0A++++f.seek(SeekFrom::End(-10))?;%0A%0A++++//+read+up+to+10+bytes%0A++++let+n+=+f.read(%26mut+buffer)?;%0A%0A++++println!(%22The+bytes:+%7B:?%7D%22,+%26buffer%5B..n%5D);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"trait.BufRead.html\" title=\"trait std::io::BufRead\"><code>BufRead</code></a> uses an internal buffer to provide a number of other ways to read, but\nto show it off, we’ll need to talk about buffers in general. Keep reading!</p>\n<h3 id=\"bufreader-and-bufwriter\"><a class=\"doc-anchor\" href=\"#bufreader-and-bufwriter\">§</a>BufReader and BufWriter</h3>\n<p>Byte-based interfaces are unwieldy and can be inefficient, as we’d need to be\nmaking near-constant calls to the operating system. To help with this,\n<code>std::io</code> comes with two structs, <a href=\"struct.BufReader.html\" title=\"struct std::io::BufReader\"><code>BufReader</code></a> and <a href=\"struct.BufWriter.html\" title=\"struct std::io::BufWriter\"><code>BufWriter</code></a>, which wrap\nreaders and writers. The wrapper uses a buffer, reducing the number of\ncalls and providing nicer methods for accessing exactly what you want.</p>\n<p>For example, <a href=\"struct.BufReader.html\" title=\"struct std::io::BufReader\"><code>BufReader</code></a> works with the <a href=\"trait.BufRead.html\" title=\"trait std::io::BufRead\"><code>BufRead</code></a> trait to add extra\nmethods to any reader:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::io::BufReader;\n<span class=\"kw\">use </span>std::fs::File;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>f = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>reader = BufReader::new(f);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer = String::new();\n\n    <span class=\"comment\">// read a line into buffer\n    </span>reader.read_line(<span class=\"kw-2\">&amp;mut </span>buffer)<span class=\"question-mark\">?</span>;\n\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{buffer}\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::BufReader;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+f+=+File::open(%22foo.txt%22)?;%0A++++let+mut+reader+=+BufReader::new(f);%0A++++let+mut+buffer+=+String::new();%0A%0A++++//+read+a+line+into+buffer%0A++++reader.read_line(%26mut+buffer)?;%0A%0A++++println!(%22%7Bbuffer%7D%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p><a href=\"struct.BufWriter.html\" title=\"struct std::io::BufWriter\"><code>BufWriter</code></a> doesn’t add any new ways of writing; it just buffers every call\nto <a href=\"trait.Write.html#tymethod.write\" title=\"method std::io::Write::write\"><code>write</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::io::BufWriter;\n<span class=\"kw\">use </span>std::fs::File;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>f = File::create(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n    {\n        <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>writer = BufWriter::new(f);\n\n        <span class=\"comment\">// write a byte to the buffer\n        </span>writer.write(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">42</span>])<span class=\"question-mark\">?</span>;\n\n    } <span class=\"comment\">// the buffer is flushed once writer goes out of scope\n\n    </span><span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::BufWriter;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+f+=+File::create(%22foo.txt%22)?;%0A++++%7B%0A++++++++let+mut+writer+=+BufWriter::new(f);%0A%0A++++++++//+write+a+byte+to+the+buffer%0A++++++++writer.write(%26%5B42%5D)?;%0A%0A++++%7D+//+the+buffer+is+flushed+once+writer+goes+out+of+scope%0A%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"standard-input-and-output\"><a class=\"doc-anchor\" href=\"#standard-input-and-output\">§</a>Standard input and output</h3>\n<p>A very common source of input is standard input:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>input = String::new();\n\n    io::stdin().read_line(<span class=\"kw-2\">&amp;mut </span>input)<span class=\"question-mark\">?</span>;\n\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"You typed: {}\"</span>, input.trim());\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+input+=+String::new();%0A%0A++++io::stdin().read_line(%26mut+input)?;%0A%0A++++println!(%22You+typed:+%7B%7D%22,+input.trim());%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that you cannot use the <a href=\"../../book/appendix-02-operators.html\"><code>?</code> operator</a> in functions that do not return\na <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result&lt;T, E&gt;</code></a>. Instead, you can call <a href=\"../result/enum.Result.html#method.unwrap\" title=\"method std::result::Result::unwrap\"><code>.unwrap()</code></a>\nor <code>match</code> on the return value to catch any possible errors:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>input = String::new();\n\nio::stdin().read_line(<span class=\"kw-2\">&amp;mut </span>input).unwrap();</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::io;%0A++++%0A++++let+mut+input+=+String::new();%0A++++%0A++++io::stdin().read_line(%26mut+input).unwrap();%0A%7D&amp;edition=2021\">Run</a></div>\n<p>And a very common source of output is standard output:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    io::stdout().write(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">42</span>])<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++io::stdout().write(%26%5B42%5D)?;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Of course, using <a href=\"fn.stdout.html\" title=\"fn std::io::stdout\"><code>io::stdout</code></a> directly is less common than something like\n<a href=\"../macro.println.html\" title=\"macro std::println\"><code>println!</code></a>.</p>\n<h3 id=\"iterator-types\"><a class=\"doc-anchor\" href=\"#iterator-types\">§</a>Iterator types</h3>\n<p>A large number of the structures provided by <code>std::io</code> are for various\nways of iterating over I/O. For example, <a href=\"struct.Lines.html\" title=\"struct std::io::Lines\"><code>Lines</code></a> is used to split over\nlines:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::io::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"kw\">use </span>std::io::BufReader;\n<span class=\"kw\">use </span>std::fs::File;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>f = File::open(<span class=\"string\">\"foo.txt\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>reader = BufReader::new(f);\n\n    <span class=\"kw\">for </span>line <span class=\"kw\">in </span>reader.lines() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, line<span class=\"question-mark\">?</span>);\n    }\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::io::prelude::*;%0Ause+std::io::BufReader;%0Ause+std::fs::File;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++let+f+=+File::open(%22foo.txt%22)?;%0A++++let+reader+=+BufReader::new(f);%0A%0A++++for+line+in+reader.lines()+%7B%0A++++++++println!(%22%7B%7D%22,+line?);%0A++++%7D%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"functions\"><a class=\"doc-anchor\" href=\"#functions\">§</a>Functions</h3>\n<p>There are a number of <a href=\"#functions-1\">functions</a> that offer access to various\nfeatures. For example, we can use three of these functions to copy everything\nfrom standard input to standard output:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">fn </span>main() -&gt; io::Result&lt;()&gt; {\n    io::copy(<span class=\"kw-2\">&amp;mut </span>io::stdin(), <span class=\"kw-2\">&amp;mut </span>io::stdout())<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0A%0Afn+main()+-%3E+io::Result%3C()%3E+%7B%0A++++io::copy(%26mut+io::stdin(),+%26mut+io::stdout())?;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"ioresult\"><a class=\"doc-anchor\" href=\"#ioresult\">§</a>io::Result</h3>\n<p>Last, but certainly not least, is <a href=\"type.Result.html\" title=\"type std::io::Result\"><code>io::Result</code></a>. This type is used\nas the return type of many <code>std::io</code> functions that can cause an error, and\ncan be returned from your own functions as well. Many of the examples in this\nmodule use the <a href=\"../../book/appendix-02-operators.html\"><code>?</code> operator</a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n\n<span class=\"kw\">fn </span>read_input() -&gt; io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>input = String::new();\n\n    io::stdin().read_line(<span class=\"kw-2\">&amp;mut </span>input)<span class=\"question-mark\">?</span>;\n\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"You typed: {}\"</span>, input.trim());\n\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::io;%0A++++%0A++++fn+read_input()+-%3E+io::Result%3C()%3E+%7B%0A++++++++let+mut+input+=+String::new();%0A++++%0A++++++++io::stdin().read_line(%26mut+input)?;%0A++++%0A++++++++println!(%22You+typed:+%7B%7D%22,+input.trim());%0A++++%0A++++++++Ok(())%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The return type of <code>read_input()</code>, <a href=\"type.Result.html\" title=\"type std::io::Result\"><code>io::Result&lt;()&gt;</code></a>, is a very\ncommon type for functions which don’t have a ‘real’ return value, but do want to\nreturn errors if they happen. In this case, the only purpose of this function is\nto read the line and print it, so we use <code>()</code>.</p>\n<h3 id=\"platform-specific-behavior\"><a class=\"doc-anchor\" href=\"#platform-specific-behavior\">§</a>Platform-specific behavior</h3>\n<p>Many I/O functions throughout the standard library are documented to indicate\nwhat various library or syscalls they are delegated to. This is done to help\napplications both understand what’s happening under the hood as well as investigate\nany possibly unclear semantics. Note, however, that this is informative, not a binding\ncontract. The implementation of many of these functions are subject to change over\ntime and may call fewer or more syscalls/library functions.</p>\n<h3 id=\"io-safety\"><a class=\"doc-anchor\" href=\"#io-safety\">§</a>I/O Safety</h3>\n<p>Rust follows an I/O safety discipline that is comparable to its memory safety discipline. This\nmeans that file descriptors can be <em>exclusively owned</em>. (Here, “file descriptor” is meant to\nsubsume similar concepts that exist across a wide range of operating systems even if they might\nuse a different name, such as “handle”.) An exclusively owned file descriptor is one that no\nother code is allowed to access in any way, but the owner is allowed to access and even close\nit any time. A type that owns its file descriptor should usually close it in its <code>drop</code>\nfunction. Types like <a href=\"../fs/struct.File.html\" title=\"struct std::fs::File\"><code>File</code></a> own their file descriptor. Similarly, file descriptors\ncan be <em>borrowed</em>, granting the temporary right to perform operations on this file descriptor.\nThis indicates that the file descriptor will not be closed for the lifetime of the borrow, but\nit does <em>not</em> imply any right to close this file descriptor, since it will likely be owned by\nsomeone else.</p>\n<p>The platform-specific parts of the Rust standard library expose types that reflect these\nconcepts, see <a href=\"../os/unix/io/index.html\"><code>os::unix</code></a> and <a href=\"../os/windows/io/index.html\"><code>os::windows</code></a>.</p>\n<p>To uphold I/O safety, it is crucial that no code acts on file descriptors it does not own or\nborrow, and no code closes file descriptors it does not own. In other words, a safe function\nthat takes a regular integer, treats it as a file descriptor, and acts on it, is <em>unsound</em>.</p>\n<p>Not upholding I/O safety and acting on a file descriptor without proof of ownership can lead to\nmisbehavior and even Undefined Behavior in code that relies on ownership of its file\ndescriptors: a closed file descriptor could be re-allocated, so the original owner of that file\ndescriptor is now working on the wrong file. Some code might even rely on fully encapsulating\nits file descriptors with no operations being performed by any other part of the program.</p>\n<p>Note that exclusive ownership of a file descriptor does <em>not</em> imply exclusive ownership of the\nunderlying kernel object that the file descriptor references (also called “open file description” on\nsome operating systems). File descriptors basically work like <a href=\"../sync/struct.Arc.html\" title=\"struct std::sync::Arc\"><code>Arc</code></a>: when you receive an owned\nfile descriptor, you cannot know whether there are any other file descriptors that reference the\nsame kernel object. However, when you create a new kernel object, you know that you are holding\nthe only reference to it. Just be careful not to lend it to anyone, since they can obtain a\nclone and then you can no longer know what the reference count is! In that sense, <a href=\"../os/fd/struct.OwnedFd.html\"><code>OwnedFd</code></a> is\nlike <code>Arc</code> and <a href=\"../os/fd/struct.BorrowedFd.html\"><code>BorrowedFd&lt;'a&gt;</code></a> is like <code>&amp;'a Arc</code> (and similar for the Windows types). In\nparticular, given a <code>BorrowedFd&lt;'a&gt;</code>, you are not allowed to close the file descriptor – just\nlike how, given a <code>&amp;'a Arc</code>, you are not allowed to decrement the reference count and\npotentially free the underlying object. There is no equivalent to <code>Box</code> for file descriptors in\nthe standard library (that would be a type that guarantees that the reference count is <code>1</code>),\nhowever, it would be possible for a crate to define a type with those semantics.</p>\n</div></details><h2 id=\"modules\" class=\"section-header\">Modules<a href=\"#modules\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"mod\" href=\"prelude/index.html\" title=\"mod std::io::prelude\">prelude</a></div><div class=\"desc docblock-short\">The I/O Prelude.</div></li></ul><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BufReader.html\" title=\"struct std::io::BufReader\">BufReader</a></div><div class=\"desc docblock-short\">The <code>BufReader&lt;R&gt;</code> struct adds buffering to any reader.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BufWriter.html\" title=\"struct std::io::BufWriter\">BufWriter</a></div><div class=\"desc docblock-short\">Wraps a writer and buffers its output.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Bytes.html\" title=\"struct std::io::Bytes\">Bytes</a></div><div class=\"desc docblock-short\">An iterator over <code>u8</code> values of a reader.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Chain.html\" title=\"struct std::io::Chain\">Chain</a></div><div class=\"desc docblock-short\">Adapter to chain together two readers.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Cursor.html\" title=\"struct std::io::Cursor\">Cursor</a></div><div class=\"desc docblock-short\">A <code>Cursor</code> wraps an in-memory buffer and provides it with a\n<a href=\"trait.Seek.html\" title=\"trait std::io::Seek\"><code>Seek</code></a> implementation.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Empty.html\" title=\"struct std::io::Empty\">Empty</a></div><div class=\"desc docblock-short\"><code>Empty</code> ignores any data written via <a href=\"trait.Write.html\" title=\"trait std::io::Write\"><code>Write</code></a>, and will always be empty\n(returning zero bytes) when read via <a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Error.html\" title=\"struct std::io::Error\">Error</a></div><div class=\"desc docblock-short\">The error type for I/O operations of the <a href=\"trait.Read.html\" title=\"trait std::io::Read\"><code>Read</code></a>, <a href=\"trait.Write.html\" title=\"trait std::io::Write\"><code>Write</code></a>, <a href=\"trait.Seek.html\" title=\"trait std::io::Seek\"><code>Seek</code></a>, and\nassociated traits.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IntoInnerError.html\" title=\"struct std::io::IntoInnerError\">IntoInnerError</a></div><div class=\"desc docblock-short\">An error returned by <a href=\"struct.BufWriter.html#method.into_inner\" title=\"method std::io::BufWriter::into_inner\"><code>BufWriter::into_inner</code></a> which combines an error that\nhappened while writing out the buffer, and the buffered writer object\nwhich may be used to recover from the condition.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a></div><div class=\"desc docblock-short\">A buffer type used with <code>Write::write_vectored</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.IoSliceMut.html\" title=\"struct std::io::IoSliceMut\">IoSliceMut</a></div><div class=\"desc docblock-short\">A buffer type used with <code>Read::read_vectored</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.LineWriter.html\" title=\"struct std::io::LineWriter\">LineWriter</a></div><div class=\"desc docblock-short\">Wraps a writer and buffers output to it, flushing whenever a newline\n(<code>0x0a</code>, <code>'\\n'</code>) is detected.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Lines.html\" title=\"struct std::io::Lines\">Lines</a></div><div class=\"desc docblock-short\">An iterator over the lines of an instance of <code>BufRead</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Repeat.html\" title=\"struct std::io::Repeat\">Repeat</a></div><div class=\"desc docblock-short\">A reader which yields one byte over and over and over and over and over and…</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Sink.html\" title=\"struct std::io::Sink\">Sink</a></div><div class=\"desc docblock-short\">A writer which will move data into the void.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Split.html\" title=\"struct std::io::Split\">Split</a></div><div class=\"desc docblock-short\">An iterator over the contents of an instance of <code>BufRead</code> split on a\nparticular byte.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Stderr.html\" title=\"struct std::io::Stderr\">Stderr</a></div><div class=\"desc docblock-short\">A handle to the standard error stream of a process.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.StderrLock.html\" title=\"struct std::io::StderrLock\">StderrLock</a></div><div class=\"desc docblock-short\">A locked reference to the <a href=\"struct.Stderr.html\" title=\"struct std::io::Stderr\"><code>Stderr</code></a> handle.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Stdin.html\" title=\"struct std::io::Stdin\">Stdin</a></div><div class=\"desc docblock-short\">A handle to the standard input stream of a process.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.StdinLock.html\" title=\"struct std::io::StdinLock\">StdinLock</a></div><div class=\"desc docblock-short\">A locked reference to the <a href=\"struct.Stdin.html\" title=\"struct std::io::Stdin\"><code>Stdin</code></a> handle.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Stdout.html\" title=\"struct std::io::Stdout\">Stdout</a></div><div class=\"desc docblock-short\">A handle to the global standard output stream of the current process.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.StdoutLock.html\" title=\"struct std::io::StdoutLock\">StdoutLock</a></div><div class=\"desc docblock-short\">A locked reference to the <a href=\"struct.Stdout.html\" title=\"struct std::io::Stdout\"><code>Stdout</code></a> handle.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Take.html\" title=\"struct std::io::Take\">Take</a></div><div class=\"desc docblock-short\">Reader adapter which limits the bytes read from an underlying reader.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.WriterPanicked.html\" title=\"struct std::io::WriterPanicked\">WriterPanicked</a></div><div class=\"desc docblock-short\">Error returned for the buffered data from <code>BufWriter::into_parts</code>, when the underlying\nwriter has previously panicked.  Contains the (possibly partly written) buffered data.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BorrowedBuf.html\" title=\"struct std::io::BorrowedBuf\">BorrowedBuf</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">A borrowed byte buffer which is incrementally filled and initialized.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BorrowedCursor.html\" title=\"struct std::io::BorrowedCursor\">BorrowedCursor</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">A writeable view of the unfilled portion of a <a href=\"struct.BorrowedBuf.html\" title=\"struct std::io::BorrowedBuf\"><code>BorrowedBuf</code></a>.</div></li></ul><h2 id=\"enums\" class=\"section-header\">Enums<a href=\"#enums\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.ErrorKind.html\" title=\"enum std::io::ErrorKind\">ErrorKind</a></div><div class=\"desc docblock-short\">A list specifying general categories of I/O error.</div></li><li><div class=\"item-name\"><a class=\"enum\" href=\"enum.SeekFrom.html\" title=\"enum std::io::SeekFrom\">SeekFrom</a></div><div class=\"desc docblock-short\">Enumeration of possible methods to seek within an I/O object.</div></li></ul><h2 id=\"traits\" class=\"section-header\">Traits<a href=\"#traits\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.BufRead.html\" title=\"trait std::io::BufRead\">BufRead</a></div><div class=\"desc docblock-short\">A <code>BufRead</code> is a type of <code>Read</code>er which has an internal buffer, allowing it\nto perform extra ways of reading.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.IsTerminal.html\" title=\"trait std::io::IsTerminal\">IsTerminal</a></div><div class=\"desc docblock-short\">Trait to determine if a descriptor/handle refers to a terminal/tty.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Read.html\" title=\"trait std::io::Read\">Read</a></div><div class=\"desc docblock-short\">The <code>Read</code> trait allows for reading bytes from a source.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Seek.html\" title=\"trait std::io::Seek\">Seek</a></div><div class=\"desc docblock-short\">The <code>Seek</code> trait provides a cursor which can be moved within a stream of\nbytes.</div></li><li><div class=\"item-name\"><a class=\"trait\" href=\"trait.Write.html\" title=\"trait std::io::Write\">Write</a></div><div class=\"desc docblock-short\">A trait for objects which are byte-oriented sinks.</div></li></ul><h2 id=\"functions-1\" class=\"section-header\">Functions<a href=\"#functions-1\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.copy.html\" title=\"fn std::io::copy\">copy</a></div><div class=\"desc docblock-short\">Copies the entire contents of a reader into a writer.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.empty.html\" title=\"fn std::io::empty\">empty</a></div><div class=\"desc docblock-short\">Creates a value that is always at EOF for reads, and ignores all data written.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.read_to_string.html\" title=\"fn std::io::read_to_string\">read_to_string</a></div><div class=\"desc docblock-short\">Read all bytes from a <a href=\"trait.Read.html\" title=\"trait std::io::Read\">reader</a> into a new <a href=\"../string/struct.String.html\" title=\"struct std::string::String\"><code>String</code></a>.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.repeat.html\" title=\"fn std::io::repeat\">repeat</a></div><div class=\"desc docblock-short\">Creates an instance of a reader that infinitely repeats one byte.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.sink.html\" title=\"fn std::io::sink\">sink</a></div><div class=\"desc docblock-short\">Creates an instance of a writer which will successfully consume all data.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.stderr.html\" title=\"fn std::io::stderr\">stderr</a></div><div class=\"desc docblock-short\">Constructs a new handle to the standard error of the current process.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.stdin.html\" title=\"fn std::io::stdin\">stdin</a></div><div class=\"desc docblock-short\">Constructs a new handle to the standard input of the current process.</div></li><li><div class=\"item-name\"><a class=\"fn\" href=\"fn.stdout.html\" title=\"fn std::io::stdout\">stdout</a></div><div class=\"desc docblock-short\">Constructs a new handle to the standard output of the current process.</div></li></ul><h2 id=\"types\" class=\"section-header\">Type Aliases<a href=\"#types\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"type\" href=\"type.Result.html\" title=\"type std::io::Result\">Result</a></div><div class=\"desc docblock-short\">A specialized <a href=\"../result/enum.Result.html\" title=\"enum std::result::Result\"><code>Result</code></a> type for I/O operations.</div></li><li><div class=\"item-name\"><a class=\"type\" href=\"type.RawOsError.html\" title=\"type std::io::RawOsError\">RawOsError</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\">The type of raw OS error codes returned by <a href=\"struct.Error.html#method.raw_os_error\" title=\"method std::io::Error::raw_os_error\"><code>Error::raw_os_error</code></a>.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:01.923Z"
}