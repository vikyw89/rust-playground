{
	"title": "std::cell - Rust",
	"url": "https://doc.rust-lang.org/stable/std/cell/index.html",
	"markdown": "# std::cell - Rust\n\n## Module [std](../index.html)::[cell](#)\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#393) ·\n\nExpand description\n\nShareable mutable containers.\n\nRust memory safety is based on this rule: Given an object `T`, it is only possible to have one of the following:\n\n-   Having several immutable references (`&T`) to the object (also known as **aliasing**).\n-   Having one mutable reference (`&mut T`) to the object (also known as **mutability**).\n\nThis is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.\n\nShareable mutable containers exist to permit mutability in a controlled manner, even in the presence of aliasing. [`Cell<T>`](struct.Cell.html \"struct std::cell::Cell\"), [`RefCell<T>`](struct.RefCell.html \"struct std::cell::RefCell\"), and [`OnceCell<T>`](struct.OnceCell.html \"struct std::cell::OnceCell\") allow doing this in a single-threaded way—they do not implement [`Sync`](../../std/marker/trait.Sync.html). (If you need to do aliasing and mutation among multiple threads, [`Mutex<T>`](../../std/sync/struct.Mutex.html), [`RwLock<T>`](../../std/sync/struct.RwLock.html), [`OnceLock<T>`](../../std/sync/struct.OnceLock.html) or [`atomic`](../sync/atomic/index.html \"mod std::sync::atomic\") types are the correct data structures to do so).\n\nValues of the `Cell<T>`, `RefCell<T>`, and `OnceCell<T>` types may be mutated through shared references (i.e. the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`) references. We say these cell types provide ‘interior mutability’ (mutable via `&T`), in contrast with typical Rust types that exhibit ‘inherited mutability’ (mutable only via `&mut T`).\n\nCell types come in three flavors: `Cell<T>`, `RefCell<T>`, and `OnceCell<T>`. Each provides a different way of providing safe interior mutability.\n\n### [§](#cellt)`Cell<T>`\n\n[`Cell<T>`](struct.Cell.html \"struct std::cell::Cell\") implements interior mutability by moving values in and out of the cell. That is, an `&mut T` to the inner value can never be obtained, and the value itself cannot be directly obtained without replacing it with something else. Both of these rules ensure that there is never more than one reference pointing to the inner value. This type provides the following methods:\n\n-   For types that implement [`Copy`](../marker/trait.Copy.html \"trait std::marker::Copy\"), the [`get`](about:blank/struct.Cell.html#method.get \"method std::cell::Cell::get\") method retrieves the current interior value by duplicating it.\n-   For types that implement [`Default`](../default/trait.Default.html \"trait std::default::Default\"), the [`take`](about:blank/struct.Cell.html#method.take \"method std::cell::Cell::take\") method replaces the current interior value with [`Default::default()`](about:blank/default/trait.Default.html#tymethod.default \"associated function std::default::Default::default\") and returns the replaced value.\n-   All types have:\n    -   [`replace`](about:blank/struct.Cell.html#method.replace \"method std::cell::Cell::replace\"): replaces the current interior value and returns the replaced value.\n    -   [`into_inner`](about:blank/struct.Cell.html#method.into_inner \"method std::cell::Cell::into_inner\"): this method consumes the `Cell<T>` and returns the interior value.\n    -   [`set`](about:blank/struct.Cell.html#method.set \"method std::cell::Cell::set\"): this method replaces the interior value, dropping the replaced value.\n\n`Cell<T>` is typically used for more simple types where copying or moving values isn’t too resource intensive (e.g. numbers), and should usually be preferred over other cell types when possible. For larger and non-copy types, `RefCell` provides some advantages.\n\n### [§](#refcellt)`RefCell<T>`\n\n[`RefCell<T>`](struct.RefCell.html \"struct std::cell::RefCell\") uses Rust’s lifetimes to implement “dynamic borrowing”, a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are tracked at _runtime_, unlike Rust’s native reference types which are entirely tracked statically, at compile time.\n\nAn immutable reference to a `RefCell`’s inner value (`&T`) can be obtained with [`borrow`](about:blank/struct.RefCell.html#method.borrow \"method std::cell::RefCell::borrow\"), and a mutable borrow (`&mut T`) can be obtained with [`borrow_mut`](about:blank/struct.RefCell.html#method.borrow_mut \"method std::cell::RefCell::borrow_mut\"). When these functions are called, they first verify that Rust’s borrow rules will be satisfied: any number of immutable borrows are allowed or a single mutable borrow is allowed, but never both. If a borrow is attempted that would violate these rules, the thread will panic.\n\nThe corresponding [`Sync`](../../std/marker/trait.Sync.html) version of `RefCell<T>` is [`RwLock<T>`](../../std/sync/struct.RwLock.html).\n\n### [§](#oncecellt)`OnceCell<T>`\n\n[`OnceCell<T>`](struct.OnceCell.html \"struct std::cell::OnceCell\") is somewhat of a hybrid of `Cell` and `RefCell` that works for values that typically only need to be set once. This means that a reference `&T` can be obtained without moving or copying the inner value (unlike `Cell`) but also without runtime checks (unlike `RefCell`). However, its value can also not be updated once set unless you have a mutable reference to the `OnceCell`.\n\n`OnceCell` provides the following methods:\n\n-   [`get`](about:blank/struct.OnceCell.html#method.get \"method std::cell::OnceCell::get\"): obtain a reference to the inner value\n-   [`set`](about:blank/struct.OnceCell.html#method.set \"method std::cell::OnceCell::set\"): set the inner value if it is unset (returns a `Result`)\n-   [`get_or_init`](about:blank/struct.OnceCell.html#method.get_or_init \"method std::cell::OnceCell::get_or_init\"): return the inner value, initializing it if needed\n-   [`get_mut`](about:blank/struct.OnceCell.html#method.get_mut \"method std::cell::OnceCell::get_mut\"): provide a mutable reference to the inner value, only available if you have a mutable reference to the cell itself.\n\nThe corresponding [`Sync`](../../std/marker/trait.Sync.html) version of `OnceCell<T>` is [`OnceLock<T>`](../../std/sync/struct.OnceLock.html).\n\n### [§](#lazycellt-f)`LazyCell<T, F>`\n\nA common pattern with OnceCell is, for a given OnceCell, to use the same function on every call to [`OnceCell::get_or_init`](about:blank/struct.OnceCell.html#method.get_or_init \"method std::cell::OnceCell::get_or_init\") with that cell. This is what is offered by [`LazyCell`](struct.LazyCell.html \"struct std::cell::LazyCell\"), which pairs cells of `T` with functions of `F`, and always calls `F` before it yields `&T`. This happens implicitly by simply attempting to dereference the LazyCell to get its contents, so its use is much more transparent with a place which has been initialized by a constant.\n\nMore complicated patterns that don’t fit this description can be built on `OnceCell<T>` instead.\n\n`LazyCell` works by providing an implementation of `impl Deref` that calls the function, so you can just use it by dereference (e.g. `*lazy_cell` or `lazy_cell.deref()`).\n\nThe corresponding [`Sync`](../../std/marker/trait.Sync.html) version of `LazyCell<T, F>` is [`LazyLock<T, F>`](../../std/sync/struct.LazyLock.html).\n\n## [§](#when-to-choose-interior-mutability)When to choose interior mutability\n\nThe more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even _must_ be used, e.g.\n\n-   Introducing mutability ‘inside’ of something immutable\n-   Implementation details of logically-immutable methods.\n-   Mutating implementations of [`Clone`](../clone/trait.Clone.html \"trait std::clone::Clone\").\n\n### [§](#introducing-mutability-inside-of-something-immutable)Introducing mutability ‘inside’ of something immutable\n\nMany shared smart pointer types, including [`Rc<T>`](../../std/rc/struct.Rc.html) and [`Arc<T>`](../../std/sync/struct.Arc.html), provide containers that can be cloned and shared between multiple parties. Because the contained values may be multiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be impossible to mutate data inside of these smart pointers at all.\n\nIt’s very common then to put a `RefCell<T>` inside shared pointer types to reintroduce mutability:\n\n```\nuse std::cell::{RefCell, RefMut};\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\nfn main() {\n    let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n    // Create a new block to limit the scope of the dynamic borrow\n    {\n        let mut map: RefMut<'_, _> = shared_map.borrow_mut();\n        map.insert(\"africa\", 92388);\n        map.insert(\"kyoto\", 11837);\n        map.insert(\"piccadilly\", 11826);\n        map.insert(\"marbles\", 38);\n    }\n\n    // Note that if we had not let the previous borrow of the cache fall out\n    // of scope then the subsequent borrow would cause a dynamic thread panic.\n    // This is the major hazard of using `RefCell`.\n    let total: i32 = shared_map.borrow().values().sum();\n    println!(\"{total}\");\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::cell::%7BRefCell,+RefMut%7D;%0Ause+std::collections::HashMap;%0Ause+std::rc::Rc;%0A%0Afn+main()+%7B%0A++++let+shared_map:+Rc%3CRefCell%3C_%3E%3E+=+Rc::new(RefCell::new(HashMap::new()));%0A++++//+Create+a+new+block+to+limit+the+scope+of+the+dynamic+borrow%0A++++%7B%0A++++++++let+mut+map:+RefMut%3C%27_,+_%3E+=+shared_map.borrow_mut();%0A++++++++map.insert(%22africa%22,+92388);%0A++++++++map.insert(%22kyoto%22,+11837);%0A++++++++map.insert(%22piccadilly%22,+11826);%0A++++++++map.insert(%22marbles%22,+38);%0A++++%7D%0A%0A++++//+Note+that+if+we+had+not+let+the+previous+borrow+of+the+cache+fall+out%0A++++//+of+scope+then+the+subsequent+borrow+would+cause+a+dynamic+thread+panic.%0A++++//+This+is+the+major+hazard+of+using+%60RefCell%60.%0A++++let+total:+i32+=+shared_map.borrow().values().sum();%0A++++println!(%22%7Btotal%7D%22);%0A%7D&edition=2021)\n\nNote that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded scenarios. Consider using [`RwLock<T>`](../../std/sync/struct.RwLock.html) or [`Mutex<T>`](../../std/sync/struct.Mutex.html) if you need shared mutability in a multi-threaded situation.\n\n### [§](#implementation-details-of-logically-immutable-methods)Implementation details of logically-immutable methods\n\nOccasionally it may be desirable not to expose in an API that there is mutation happening “under the hood”. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take `&self`.\n\n```\nuse std::cell::OnceCell;\n\nstruct Graph {\n    edges: Vec<(i32, i32)>,\n    span_tree_cache: OnceCell<Vec<(i32, i32)>>\n}\n\nimpl Graph {\n    fn minimum_spanning_tree(&self) -> Vec<(i32, i32)> {\n        self.span_tree_cache\n            .get_or_init(|| self.calc_span_tree())\n            .clone()\n    }\n\n    fn calc_span_tree(&self) -> Vec<(i32, i32)> {\n        // Expensive computation goes here\n        vec![]\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::cell::OnceCell;%0A++++%0A++++struct+Graph+%7B%0A++++++++edges:+Vec%3C(i32,+i32)%3E,%0A++++++++span_tree_cache:+OnceCell%3CVec%3C(i32,+i32)%3E%3E%0A++++%7D%0A++++%0A++++impl+Graph+%7B%0A++++++++fn+minimum_spanning_tree(%26self)+-%3E+Vec%3C(i32,+i32)%3E+%7B%0A++++++++++++self.span_tree_cache%0A++++++++++++++++.get_or_init(%7C%7C+self.calc_span_tree())%0A++++++++++++++++.clone()%0A++++++++%7D%0A++++%0A++++++++fn+calc_span_tree(%26self)+-%3E+Vec%3C(i32,+i32)%3E+%7B%0A++++++++++++//+Expensive+computation+goes+here%0A++++++++++++vec!%5B%5D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n### [§](#mutating-implementations-of-clone)Mutating implementations of `Clone`\n\nThis is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The [`clone`](about:blank/clone/trait.Clone.html#tymethod.clone \"method std::clone::Clone::clone\") method is expected to not change the source value, and is declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the `clone` method must use cell types. For example, [`Rc<T>`](../../std/rc/struct.Rc.html) maintains its reference counts within a `Cell<T>`.\n\n```\nuse std::cell::Cell;\nuse std::ptr::NonNull;\nuse std::process::abort;\nuse std::marker::PhantomData;\n\nstruct Rc<T: ?Sized> {\n    ptr: NonNull<RcBox<T>>,\n    phantom: PhantomData<RcBox<T>>,\n}\n\nstruct RcBox<T: ?Sized> {\n    strong: Cell<usize>,\n    refcount: Cell<usize>,\n    value: T,\n}\n\nimpl<T: ?Sized> Clone for Rc<T> {\n    fn clone(&self) -> Rc<T> {\n        self.inc_strong();\n        Rc {\n            ptr: self.ptr,\n            phantom: PhantomData,\n        }\n    }\n}\n\ntrait RcBoxPtr<T: ?Sized> {\n\n    fn inner(&self) -> &RcBox<T>;\n\n    fn strong(&self) -> usize {\n        self.inner().strong.get()\n    }\n\n    fn inc_strong(&self) {\n        self.inner()\n            .strong\n            .set(self.strong()\n                     .checked_add(1)\n                     .unwrap_or_else(|| abort() ));\n    }\n}\n\nimpl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n   fn inner(&self) -> &RcBox<T> {\n       unsafe {\n           self.ptr.as_ref()\n       }\n   }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++use+std::ptr::NonNull;%0A++++use+std::process::abort;%0A++++use+std::marker::PhantomData;%0A++++%0A++++struct+Rc%3CT:+?Sized%3E+%7B%0A++++++++ptr:+NonNull%3CRcBox%3CT%3E%3E,%0A++++++++phantom:+PhantomData%3CRcBox%3CT%3E%3E,%0A++++%7D%0A++++%0A++++struct+RcBox%3CT:+?Sized%3E+%7B%0A++++++++strong:+Cell%3Cusize%3E,%0A++++++++refcount:+Cell%3Cusize%3E,%0A++++++++value:+T,%0A++++%7D%0A++++%0A++++impl%3CT:+?Sized%3E+Clone+for+Rc%3CT%3E+%7B%0A++++++++fn+clone(%26self)+-%3E+Rc%3CT%3E+%7B%0A++++++++++++self.inc_strong();%0A++++++++++++Rc+%7B%0A++++++++++++++++ptr:+self.ptr,%0A++++++++++++++++phantom:+PhantomData,%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++trait+RcBoxPtr%3CT:+?Sized%3E+%7B%0A++++%0A++++++++fn+inner(%26self)+-%3E+%26RcBox%3CT%3E;%0A++++%0A++++++++fn+strong(%26self)+-%3E+usize+%7B%0A++++++++++++self.inner().strong.get()%0A++++++++%7D%0A++++%0A++++++++fn+inc_strong(%26self)+%7B%0A++++++++++++self.inner()%0A++++++++++++++++.strong%0A++++++++++++++++.set(self.strong()%0A+++++++++++++++++++++++++.checked_add(1)%0A+++++++++++++++++++++++++.unwrap_or_else(%7C%7C+abort()+));%0A++++++++%7D%0A++++%7D%0A++++%0A++++impl%3CT:+?Sized%3E+RcBoxPtr%3CT%3E+for+Rc%3CT%3E+%7B%0A+++++++fn+inner(%26self)+-%3E+%26RcBox%3CT%3E+%7B%0A+++++++++++unsafe+%7B%0A+++++++++++++++self.ptr.as_ref()%0A+++++++++++%7D%0A+++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\n-   A mutable memory location.\n    \n-   A value which is initialized on the first access.\n    \n-   A cell which can nominally be written to only once.\n    \n-   Wraps a borrowed reference to a value in a `RefCell` box. A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n    \n-   A mutable memory location with dynamically checked borrow rules\n    \n-   A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n    \n-   The core primitive for interior mutability in Rust.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"Shareable mutable containers.\"><title>std::cell - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"../sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc mod\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Module cell</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Module cell</a></h2><div class=\"sidebar-elems\"><section><ul class=\"block\"><li><a href=\"#structs\">Structs</a></li></ul></section><h2><a href=\"../index.html\">In crate std</a></h2><h3><a href=\"../index.html#primitives\">Primitive Types</a></h3><ul class=\"block primitive\"><li><a href=\"../primitive.array.html\">array</a></li><li><a href=\"../primitive.bool.html\">bool</a></li><li><a href=\"../primitive.char.html\">char</a></li><li><a href=\"../primitive.f128.html\">f128</a></li><li><a href=\"../primitive.f16.html\">f16</a></li><li><a href=\"../primitive.f32.html\">f32</a></li><li><a href=\"../primitive.f64.html\">f64</a></li><li><a href=\"../primitive.fn.html\">fn</a></li><li><a href=\"../primitive.i128.html\">i128</a></li><li><a href=\"../primitive.i16.html\">i16</a></li><li><a href=\"../primitive.i32.html\">i32</a></li><li><a href=\"../primitive.i64.html\">i64</a></li><li><a href=\"../primitive.i8.html\">i8</a></li><li><a href=\"../primitive.isize.html\">isize</a></li><li><a href=\"../primitive.never.html\">never</a></li><li><a href=\"../primitive.pointer.html\">pointer</a></li><li><a href=\"../primitive.reference.html\">reference</a></li><li><a href=\"../primitive.slice.html\">slice</a></li><li><a href=\"../primitive.str.html\">str</a></li><li><a href=\"../primitive.tuple.html\">tuple</a></li><li><a href=\"../primitive.u128.html\">u128</a></li><li><a href=\"../primitive.u16.html\">u16</a></li><li><a href=\"../primitive.u32.html\">u32</a></li><li><a href=\"../primitive.u64.html\">u64</a></li><li><a href=\"../primitive.u8.html\">u8</a></li><li><a href=\"../primitive.unit.html\">unit</a></li><li><a href=\"../primitive.usize.html\">usize</a></li></ul><h3><a href=\"../index.html#modules\">Modules</a></h3><ul class=\"block mod\"><li><a href=\"../alloc/index.html\">alloc</a></li><li><a href=\"../any/index.html\">any</a></li><li><a href=\"../arch/index.html\">arch</a></li><li><a href=\"../array/index.html\">array</a></li><li><a href=\"../ascii/index.html\">ascii</a></li><li><a href=\"../assert_matches/index.html\">assert_matches</a></li><li><a href=\"../async_iter/index.html\">async_iter</a></li><li><a href=\"../backtrace/index.html\">backtrace</a></li><li><a href=\"../borrow/index.html\">borrow</a></li><li><a href=\"../boxed/index.html\">boxed</a></li><li><a href=\"../cell/index.html\">cell</a></li><li><a href=\"../char/index.html\">char</a></li><li><a href=\"../clone/index.html\">clone</a></li><li><a href=\"../cmp/index.html\">cmp</a></li><li><a href=\"../collections/index.html\">collections</a></li><li><a href=\"../convert/index.html\">convert</a></li><li><a href=\"../default/index.html\">default</a></li><li><a href=\"../env/index.html\">env</a></li><li><a href=\"../error/index.html\">error</a></li><li><a href=\"../f128/index.html\">f128</a></li><li><a href=\"../f16/index.html\">f16</a></li><li><a href=\"../f32/index.html\">f32</a></li><li><a href=\"../f64/index.html\">f64</a></li><li><a href=\"../ffi/index.html\">ffi</a></li><li><a href=\"../fmt/index.html\">fmt</a></li><li><a href=\"../fs/index.html\">fs</a></li><li><a href=\"../future/index.html\">future</a></li><li><a href=\"../hash/index.html\">hash</a></li><li><a href=\"../hint/index.html\">hint</a></li><li><a href=\"../i128/index.html\">i128</a></li><li><a href=\"../i16/index.html\">i16</a></li><li><a href=\"../i32/index.html\">i32</a></li><li><a href=\"../i64/index.html\">i64</a></li><li><a href=\"../i8/index.html\">i8</a></li><li><a href=\"../intrinsics/index.html\">intrinsics</a></li><li><a href=\"../io/index.html\">io</a></li><li><a href=\"../isize/index.html\">isize</a></li><li><a href=\"../iter/index.html\">iter</a></li><li><a href=\"../marker/index.html\">marker</a></li><li><a href=\"../mem/index.html\">mem</a></li><li><a href=\"../net/index.html\">net</a></li><li><a href=\"../num/index.html\">num</a></li><li><a href=\"../ops/index.html\">ops</a></li><li><a href=\"../option/index.html\">option</a></li><li><a href=\"../os/index.html\">os</a></li><li><a href=\"../panic/index.html\">panic</a></li><li><a href=\"../pat/index.html\">pat</a></li><li><a href=\"../path/index.html\">path</a></li><li><a href=\"../pin/index.html\">pin</a></li><li><a href=\"../prelude/index.html\">prelude</a></li><li><a href=\"../primitive/index.html\">primitive</a></li><li><a href=\"../process/index.html\">process</a></li><li><a href=\"../ptr/index.html\">ptr</a></li><li><a href=\"../rc/index.html\">rc</a></li><li><a href=\"../result/index.html\">result</a></li><li><a href=\"../simd/index.html\">simd</a></li><li><a href=\"../slice/index.html\">slice</a></li><li><a href=\"../str/index.html\">str</a></li><li><a href=\"../string/index.html\">string</a></li><li><a href=\"../sync/index.html\">sync</a></li><li><a href=\"../task/index.html\">task</a></li><li><a href=\"../thread/index.html\">thread</a></li><li><a href=\"../time/index.html\">time</a></li><li><a href=\"../u128/index.html\">u128</a></li><li><a href=\"../u16/index.html\">u16</a></li><li><a href=\"../u32/index.html\">u32</a></li><li><a href=\"../u64/index.html\">u64</a></li><li><a href=\"../u8/index.html\">u8</a></li><li><a href=\"../usize/index.html\">usize</a></li><li><a href=\"../vec/index.html\">vec</a></li></ul><h3><a href=\"../index.html#macros\">Macros</a></h3><ul class=\"block macro\"><li><a href=\"../macro.assert.html\">assert</a></li><li><a href=\"../macro.assert_eq.html\">assert_eq</a></li><li><a href=\"../macro.assert_ne.html\">assert_ne</a></li><li><a href=\"../macro.cfg.html\">cfg</a></li><li><a href=\"../macro.cfg_match.html\">cfg_match</a></li><li><a href=\"../macro.column.html\">column</a></li><li><a href=\"../macro.compile_error.html\">compile_error</a></li><li><a href=\"../macro.concat.html\">concat</a></li><li><a href=\"../macro.concat_bytes.html\">concat_bytes</a></li><li><a href=\"../macro.concat_idents.html\">concat_idents</a></li><li><a href=\"../macro.const_format_args.html\">const_format_args</a></li><li><a href=\"../macro.dbg.html\">dbg</a></li><li><a href=\"../macro.debug_assert.html\">debug_assert</a></li><li><a href=\"../macro.debug_assert_eq.html\">debug_assert_eq</a></li><li><a href=\"../macro.debug_assert_ne.html\">debug_assert_ne</a></li><li><a href=\"../macro.env.html\">env</a></li><li><a href=\"../macro.eprint.html\">eprint</a></li><li><a href=\"../macro.eprintln.html\">eprintln</a></li><li><a href=\"../macro.file.html\">file</a></li><li><a href=\"../macro.format.html\">format</a></li><li><a href=\"../macro.format_args.html\">format_args</a></li><li><a href=\"../macro.format_args_nl.html\">format_args_nl</a></li><li><a href=\"../macro.include.html\">include</a></li><li><a href=\"../macro.include_bytes.html\">include_bytes</a></li><li><a href=\"../macro.include_str.html\">include_str</a></li><li><a href=\"../macro.is_x86_feature_detected.html\">is_x86_feature_detected</a></li><li><a href=\"../macro.line.html\">line</a></li><li><a href=\"../macro.log_syntax.html\">log_syntax</a></li><li><a href=\"../macro.matches.html\">matches</a></li><li><a href=\"../macro.module_path.html\">module_path</a></li><li><a href=\"../macro.option_env.html\">option_env</a></li><li><a href=\"../macro.panic.html\">panic</a></li><li><a href=\"../macro.print.html\">print</a></li><li><a href=\"../macro.println.html\">println</a></li><li><a href=\"../macro.stringify.html\">stringify</a></li><li><a href=\"../macro.thread_local.html\">thread_local</a></li><li><a href=\"../macro.todo.html\">todo</a></li><li><a href=\"../macro.trace_macros.html\">trace_macros</a></li><li><a href=\"../macro.try.html\">try</a></li><li><a href=\"../macro.unimplemented.html\">unimplemented</a></li><li><a href=\"../macro.unreachable.html\">unreachable</a></li><li><a href=\"../macro.vec.html\">vec</a></li><li><a href=\"../macro.write.html\">write</a></li><li><a href=\"../macro.writeln.html\">writeln</a></li></ul><h3><a href=\"../index.html#keywords\">Keywords</a></h3><ul class=\"block keyword\"><li><a href=\"../keyword.SelfTy.html\">SelfTy</a></li><li><a href=\"../keyword.as.html\">as</a></li><li><a href=\"../keyword.async.html\">async</a></li><li><a href=\"../keyword.await.html\">await</a></li><li><a href=\"../keyword.break.html\">break</a></li><li><a href=\"../keyword.const.html\">const</a></li><li><a href=\"../keyword.continue.html\">continue</a></li><li><a href=\"../keyword.crate.html\">crate</a></li><li><a href=\"../keyword.dyn.html\">dyn</a></li><li><a href=\"../keyword.else.html\">else</a></li><li><a href=\"../keyword.enum.html\">enum</a></li><li><a href=\"../keyword.extern.html\">extern</a></li><li><a href=\"../keyword.false.html\">false</a></li><li><a href=\"../keyword.fn.html\">fn</a></li><li><a href=\"../keyword.for.html\">for</a></li><li><a href=\"../keyword.if.html\">if</a></li><li><a href=\"../keyword.impl.html\">impl</a></li><li><a href=\"../keyword.in.html\">in</a></li><li><a href=\"../keyword.let.html\">let</a></li><li><a href=\"../keyword.loop.html\">loop</a></li><li><a href=\"../keyword.match.html\">match</a></li><li><a href=\"../keyword.mod.html\">mod</a></li><li><a href=\"../keyword.move.html\">move</a></li><li><a href=\"../keyword.mut.html\">mut</a></li><li><a href=\"../keyword.pub.html\">pub</a></li><li><a href=\"../keyword.ref.html\">ref</a></li><li><a href=\"../keyword.return.html\">return</a></li><li><a href=\"../keyword.self.html\">self</a></li><li><a href=\"../keyword.static.html\">static</a></li><li><a href=\"../keyword.struct.html\">struct</a></li><li><a href=\"../keyword.super.html\">super</a></li><li><a href=\"../keyword.trait.html\">trait</a></li><li><a href=\"../keyword.true.html\">true</a></li><li><a href=\"../keyword.type.html\">type</a></li><li><a href=\"../keyword.union.html\">union</a></li><li><a href=\"../keyword.unsafe.html\">unsafe</a></li><li><a href=\"../keyword.use.html\">use</a></li><li><a href=\"../keyword.where.html\">where</a></li><li><a href=\"../keyword.while.html\">while</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Module <a href=\"../index.html\">std</a>::<wbr><a class=\"mod\" href=\"#\">cell</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/lib.rs.html#393\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>Shareable mutable containers.</p>\n<p>Rust memory safety is based on this rule: Given an object <code>T</code>, it is only possible to\nhave one of the following:</p>\n<ul>\n<li>Having several immutable references (<code>&amp;T</code>) to the object (also known as <strong>aliasing</strong>).</li>\n<li>Having one mutable reference (<code>&amp;mut T</code>) to the object (also known as <strong>mutability</strong>).</li>\n</ul>\n<p>This is enforced by the Rust compiler. However, there are situations where this rule is not\nflexible enough. Sometimes it is required to have multiple references to an object and yet\nmutate it.</p>\n<p>Shareable mutable containers exist to permit mutability in a controlled manner, even in the\npresence of aliasing. <a href=\"struct.Cell.html\" title=\"struct std::cell::Cell\"><code>Cell&lt;T&gt;</code></a>, <a href=\"struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a>, and <a href=\"struct.OnceCell.html\" title=\"struct std::cell::OnceCell\"><code>OnceCell&lt;T&gt;</code></a> allow doing this in\na single-threaded way—they do not implement <a href=\"../../std/marker/trait.Sync.html\"><code>Sync</code></a>. (If you need to do aliasing and\nmutation among multiple threads, <a href=\"../../std/sync/struct.Mutex.html\"><code>Mutex&lt;T&gt;</code></a>, <a href=\"../../std/sync/struct.RwLock.html\"><code>RwLock&lt;T&gt;</code></a>, <a href=\"../../std/sync/struct.OnceLock.html\"><code>OnceLock&lt;T&gt;</code></a> or <a href=\"../sync/atomic/index.html\" title=\"mod std::sync::atomic\"><code>atomic</code></a>\ntypes are the correct data structures to do so).</p>\n<p>Values of the <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, and <code>OnceCell&lt;T&gt;</code> types may be mutated through shared\nreferences (i.e. the common <code>&amp;T</code> type), whereas most Rust types can only be mutated through\nunique (<code>&amp;mut T</code>) references. We say these cell types provide ‘interior mutability’\n(mutable via <code>&amp;T</code>), in contrast with typical Rust types that exhibit ‘inherited mutability’\n(mutable only via <code>&amp;mut T</code>).</p>\n<p>Cell types come in three flavors: <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, and <code>OnceCell&lt;T&gt;</code>. Each provides\na different way of providing safe interior mutability.</p>\n<h3 id=\"cellt\"><a class=\"doc-anchor\" href=\"#cellt\">§</a><code>Cell&lt;T&gt;</code></h3>\n<p><a href=\"struct.Cell.html\" title=\"struct std::cell::Cell\"><code>Cell&lt;T&gt;</code></a> implements interior mutability by moving values in and out of the cell. That is, an\n<code>&amp;mut T</code> to the inner value can never be obtained, and the value itself cannot be directly\nobtained without replacing it with something else. Both of these rules ensure that there is\nnever more than one reference pointing to the inner value. This type provides the following\nmethods:</p>\n<ul>\n<li>For types that implement <a href=\"../marker/trait.Copy.html\" title=\"trait std::marker::Copy\"><code>Copy</code></a>, the <a href=\"struct.Cell.html#method.get\" title=\"method std::cell::Cell::get\"><code>get</code></a> method retrieves the current\ninterior value by duplicating it.</li>\n<li>For types that implement <a href=\"../default/trait.Default.html\" title=\"trait std::default::Default\"><code>Default</code></a>, the <a href=\"struct.Cell.html#method.take\" title=\"method std::cell::Cell::take\"><code>take</code></a> method replaces the current\ninterior value with <a href=\"../default/trait.Default.html#tymethod.default\" title=\"associated function std::default::Default::default\"><code>Default::default()</code></a> and returns the replaced value.</li>\n<li>All types have:\n<ul>\n<li><a href=\"struct.Cell.html#method.replace\" title=\"method std::cell::Cell::replace\"><code>replace</code></a>: replaces the current interior value and returns the replaced\nvalue.</li>\n<li><a href=\"struct.Cell.html#method.into_inner\" title=\"method std::cell::Cell::into_inner\"><code>into_inner</code></a>: this method consumes the <code>Cell&lt;T&gt;</code> and returns the\ninterior value.</li>\n<li><a href=\"struct.Cell.html#method.set\" title=\"method std::cell::Cell::set\"><code>set</code></a>: this method replaces the interior value, dropping the replaced value.</li>\n</ul>\n</li>\n</ul>\n<p><code>Cell&lt;T&gt;</code> is typically used for more simple types where copying or moving values isn’t too\nresource intensive (e.g. numbers), and should usually be preferred over other cell types when\npossible. For larger and non-copy types, <code>RefCell</code> provides some advantages.</p>\n<h3 id=\"refcellt\"><a class=\"doc-anchor\" href=\"#refcellt\">§</a><code>RefCell&lt;T&gt;</code></h3>\n<p><a href=\"struct.RefCell.html\" title=\"struct std::cell::RefCell\"><code>RefCell&lt;T&gt;</code></a> uses Rust’s lifetimes to implement “dynamic borrowing”, a process whereby one can\nclaim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are\ntracked at <em>runtime</em>, unlike Rust’s native reference types which are entirely tracked\nstatically, at compile time.</p>\n<p>An immutable reference to a <code>RefCell</code>’s inner value (<code>&amp;T</code>) can be obtained with\n<a href=\"struct.RefCell.html#method.borrow\" title=\"method std::cell::RefCell::borrow\"><code>borrow</code></a>, and a mutable borrow (<code>&amp;mut T</code>) can be obtained with\n<a href=\"struct.RefCell.html#method.borrow_mut\" title=\"method std::cell::RefCell::borrow_mut\"><code>borrow_mut</code></a>. When these functions are called, they first verify that\nRust’s borrow rules will be satisfied: any number of immutable borrows are allowed or a\nsingle mutable borrow is allowed, but never both. If a borrow is attempted that would violate\nthese rules, the thread will panic.</p>\n<p>The corresponding <a href=\"../../std/marker/trait.Sync.html\"><code>Sync</code></a> version of <code>RefCell&lt;T&gt;</code> is <a href=\"../../std/sync/struct.RwLock.html\"><code>RwLock&lt;T&gt;</code></a>.</p>\n<h3 id=\"oncecellt\"><a class=\"doc-anchor\" href=\"#oncecellt\">§</a><code>OnceCell&lt;T&gt;</code></h3>\n<p><a href=\"struct.OnceCell.html\" title=\"struct std::cell::OnceCell\"><code>OnceCell&lt;T&gt;</code></a> is somewhat of a hybrid of <code>Cell</code> and <code>RefCell</code> that works for values that\ntypically only need to be set once. This means that a reference <code>&amp;T</code> can be obtained without\nmoving or copying the inner value (unlike <code>Cell</code>) but also without runtime checks (unlike\n<code>RefCell</code>). However, its value can also not be updated once set unless you have a mutable\nreference to the <code>OnceCell</code>.</p>\n<p><code>OnceCell</code> provides the following methods:</p>\n<ul>\n<li><a href=\"struct.OnceCell.html#method.get\" title=\"method std::cell::OnceCell::get\"><code>get</code></a>: obtain a reference to the inner value</li>\n<li><a href=\"struct.OnceCell.html#method.set\" title=\"method std::cell::OnceCell::set\"><code>set</code></a>: set the inner value if it is unset (returns a <code>Result</code>)</li>\n<li><a href=\"struct.OnceCell.html#method.get_or_init\" title=\"method std::cell::OnceCell::get_or_init\"><code>get_or_init</code></a>: return the inner value, initializing it if needed</li>\n<li><a href=\"struct.OnceCell.html#method.get_mut\" title=\"method std::cell::OnceCell::get_mut\"><code>get_mut</code></a>: provide a mutable reference to the inner value, only available\nif you have a mutable reference to the cell itself.</li>\n</ul>\n<p>The corresponding <a href=\"../../std/marker/trait.Sync.html\"><code>Sync</code></a> version of <code>OnceCell&lt;T&gt;</code> is <a href=\"../../std/sync/struct.OnceLock.html\"><code>OnceLock&lt;T&gt;</code></a>.</p>\n<h3 id=\"lazycellt-f\"><a class=\"doc-anchor\" href=\"#lazycellt-f\">§</a><code>LazyCell&lt;T, F&gt;</code></h3>\n<p>A common pattern with OnceCell is, for a given OnceCell, to use the same function on every\ncall to <a href=\"struct.OnceCell.html#method.get_or_init\" title=\"method std::cell::OnceCell::get_or_init\"><code>OnceCell::get_or_init</code></a> with that cell. This is what is offered by <a href=\"struct.LazyCell.html\" title=\"struct std::cell::LazyCell\"><code>LazyCell</code></a>,\nwhich pairs cells of <code>T</code> with functions of <code>F</code>, and always calls <code>F</code> before it yields <code>&amp;T</code>.\nThis happens implicitly by simply attempting to dereference the LazyCell to get its contents,\nso its use is much more transparent with a place which has been initialized by a constant.</p>\n<p>More complicated patterns that don’t fit this description can be built on <code>OnceCell&lt;T&gt;</code> instead.</p>\n<p><code>LazyCell</code> works by providing an implementation of <code>impl Deref</code> that calls the function,\nso you can just use it by dereference (e.g. <code>*lazy_cell</code> or <code>lazy_cell.deref()</code>).</p>\n<p>The corresponding <a href=\"../../std/marker/trait.Sync.html\"><code>Sync</code></a> version of <code>LazyCell&lt;T, F&gt;</code> is <a href=\"../../std/sync/struct.LazyLock.html\"><code>LazyLock&lt;T, F&gt;</code></a>.</p>\n<h2 id=\"when-to-choose-interior-mutability\"><a class=\"doc-anchor\" href=\"#when-to-choose-interior-mutability\">§</a>When to choose interior mutability</h2>\n<p>The more common inherited mutability, where one must have unique access to mutate a value, is\none of the key language elements that enables Rust to reason strongly about pointer aliasing,\nstatically preventing crash bugs. Because of that, inherited mutability is preferred, and\ninterior mutability is something of a last resort. Since cell types enable mutation where it\nwould otherwise be disallowed though, there are occasions when interior mutability might be\nappropriate, or even <em>must</em> be used, e.g.</p>\n<ul>\n<li>Introducing mutability ‘inside’ of something immutable</li>\n<li>Implementation details of logically-immutable methods.</li>\n<li>Mutating implementations of <a href=\"../clone/trait.Clone.html\" title=\"trait std::clone::Clone\"><code>Clone</code></a>.</li>\n</ul>\n<h3 id=\"introducing-mutability-inside-of-something-immutable\"><a class=\"doc-anchor\" href=\"#introducing-mutability-inside-of-something-immutable\">§</a>Introducing mutability ‘inside’ of something immutable</h3>\n<p>Many shared smart pointer types, including <a href=\"../../std/rc/struct.Rc.html\"><code>Rc&lt;T&gt;</code></a> and <a href=\"../../std/sync/struct.Arc.html\"><code>Arc&lt;T&gt;</code></a>, provide containers that can\nbe cloned and shared between multiple parties. Because the contained values may be\nmultiply-aliased, they can only be borrowed with <code>&amp;</code>, not <code>&amp;mut</code>. Without cells it would be\nimpossible to mutate data inside of these smart pointers at all.</p>\n<p>It’s very common then to put a <code>RefCell&lt;T&gt;</code> inside shared pointer types to reintroduce\nmutability:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::{RefCell, RefMut};\n<span class=\"kw\">use </span>std::collections::HashMap;\n<span class=\"kw\">use </span>std::rc::Rc;\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>shared_map: Rc&lt;RefCell&lt;<span class=\"kw\">_</span>&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));\n    <span class=\"comment\">// Create a new block to limit the scope of the dynamic borrow\n    </span>{\n        <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>map: RefMut&lt;<span class=\"lifetime\">'_</span>, <span class=\"kw\">_</span>&gt; = shared_map.borrow_mut();\n        map.insert(<span class=\"string\">\"africa\"</span>, <span class=\"number\">92388</span>);\n        map.insert(<span class=\"string\">\"kyoto\"</span>, <span class=\"number\">11837</span>);\n        map.insert(<span class=\"string\">\"piccadilly\"</span>, <span class=\"number\">11826</span>);\n        map.insert(<span class=\"string\">\"marbles\"</span>, <span class=\"number\">38</span>);\n    }\n\n    <span class=\"comment\">// Note that if we had not let the previous borrow of the cache fall out\n    // of scope then the subsequent borrow would cause a dynamic thread panic.\n    // This is the major hazard of using `RefCell`.\n    </span><span class=\"kw\">let </span>total: i32 = shared_map.borrow().values().sum();\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{total}\"</span>);\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::cell::%7BRefCell,+RefMut%7D;%0Ause+std::collections::HashMap;%0Ause+std::rc::Rc;%0A%0Afn+main()+%7B%0A++++let+shared_map:+Rc%3CRefCell%3C_%3E%3E+=+Rc::new(RefCell::new(HashMap::new()));%0A++++//+Create+a+new+block+to+limit+the+scope+of+the+dynamic+borrow%0A++++%7B%0A++++++++let+mut+map:+RefMut%3C'_,+_%3E+=+shared_map.borrow_mut();%0A++++++++map.insert(%22africa%22,+92388);%0A++++++++map.insert(%22kyoto%22,+11837);%0A++++++++map.insert(%22piccadilly%22,+11826);%0A++++++++map.insert(%22marbles%22,+38);%0A++++%7D%0A%0A++++//+Note+that+if+we+had+not+let+the+previous+borrow+of+the+cache+fall+out%0A++++//+of+scope+then+the+subsequent+borrow+would+cause+a+dynamic+thread+panic.%0A++++//+This+is+the+major+hazard+of+using+%60RefCell%60.%0A++++let+total:+i32+=+shared_map.borrow().values().sum();%0A++++println!(%22%7Btotal%7D%22);%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Note that this example uses <code>Rc&lt;T&gt;</code> and not <code>Arc&lt;T&gt;</code>. <code>RefCell&lt;T&gt;</code>s are for single-threaded\nscenarios. Consider using <a href=\"../../std/sync/struct.RwLock.html\"><code>RwLock&lt;T&gt;</code></a> or <a href=\"../../std/sync/struct.Mutex.html\"><code>Mutex&lt;T&gt;</code></a> if you need shared mutability in a\nmulti-threaded situation.</p>\n<h3 id=\"implementation-details-of-logically-immutable-methods\"><a class=\"doc-anchor\" href=\"#implementation-details-of-logically-immutable-methods\">§</a>Implementation details of logically-immutable methods</h3>\n<p>Occasionally it may be desirable not to expose in an API that there is mutation happening\n“under the hood”. This may be because logically the operation is immutable, but e.g., caching\nforces the implementation to perform mutation; or because you must employ mutation to implement\na trait method that was originally defined to take <code>&amp;self</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::OnceCell;\n\n<span class=\"kw\">struct </span>Graph {\n    edges: Vec&lt;(i32, i32)&gt;,\n    span_tree_cache: OnceCell&lt;Vec&lt;(i32, i32)&gt;&gt;\n}\n\n<span class=\"kw\">impl </span>Graph {\n    <span class=\"kw\">fn </span>minimum_spanning_tree(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; Vec&lt;(i32, i32)&gt; {\n        <span class=\"self\">self</span>.span_tree_cache\n            .get_or_init(|| <span class=\"self\">self</span>.calc_span_tree())\n            .clone()\n    }\n\n    <span class=\"kw\">fn </span>calc_span_tree(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; Vec&lt;(i32, i32)&gt; {\n        <span class=\"comment\">// Expensive computation goes here\n        </span><span class=\"macro\">vec!</span>[]\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0A++++use+std::cell::OnceCell;%0A++++%0A++++struct+Graph+%7B%0A++++++++edges:+Vec%3C(i32,+i32)%3E,%0A++++++++span_tree_cache:+OnceCell%3CVec%3C(i32,+i32)%3E%3E%0A++++%7D%0A++++%0A++++impl+Graph+%7B%0A++++++++fn+minimum_spanning_tree(%26self)+-%3E+Vec%3C(i32,+i32)%3E+%7B%0A++++++++++++self.span_tree_cache%0A++++++++++++++++.get_or_init(%7C%7C+self.calc_span_tree())%0A++++++++++++++++.clone()%0A++++++++%7D%0A++++%0A++++++++fn+calc_span_tree(%26self)+-%3E+Vec%3C(i32,+i32)%3E+%7B%0A++++++++++++//+Expensive+computation+goes+here%0A++++++++++++vec!%5B%5D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<h3 id=\"mutating-implementations-of-clone\"><a class=\"doc-anchor\" href=\"#mutating-implementations-of-clone\">§</a>Mutating implementations of <code>Clone</code></h3>\n<p>This is simply a special - but common - case of the previous: hiding mutability for operations\nthat appear to be immutable. The <a href=\"../clone/trait.Clone.html#tymethod.clone\" title=\"method std::clone::Clone::clone\"><code>clone</code></a> method is expected to not change the\nsource value, and is declared to take <code>&amp;self</code>, not <code>&amp;mut self</code>. Therefore, any mutation that\nhappens in the <code>clone</code> method must use cell types. For example, <a href=\"../../std/rc/struct.Rc.html\"><code>Rc&lt;T&gt;</code></a> maintains its\nreference counts within a <code>Cell&lt;T&gt;</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n<span class=\"kw\">use </span>std::ptr::NonNull;\n<span class=\"kw\">use </span>std::process::abort;\n<span class=\"kw\">use </span>std::marker::PhantomData;\n\n<span class=\"kw\">struct </span>Rc&lt;T: <span class=\"question-mark\">?</span>Sized&gt; {\n    ptr: NonNull&lt;RcBox&lt;T&gt;&gt;,\n    phantom: PhantomData&lt;RcBox&lt;T&gt;&gt;,\n}\n\n<span class=\"kw\">struct </span>RcBox&lt;T: <span class=\"question-mark\">?</span>Sized&gt; {\n    strong: Cell&lt;usize&gt;,\n    refcount: Cell&lt;usize&gt;,\n    value: T,\n}\n\n<span class=\"kw\">impl</span>&lt;T: <span class=\"question-mark\">?</span>Sized&gt; Clone <span class=\"kw\">for </span>Rc&lt;T&gt; {\n    <span class=\"kw\">fn </span>clone(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; Rc&lt;T&gt; {\n        <span class=\"self\">self</span>.inc_strong();\n        Rc {\n            ptr: <span class=\"self\">self</span>.ptr,\n            phantom: PhantomData,\n        }\n    }\n}\n\n<span class=\"kw\">trait </span>RcBoxPtr&lt;T: <span class=\"question-mark\">?</span>Sized&gt; {\n\n    <span class=\"kw\">fn </span>inner(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; <span class=\"kw-2\">&amp;</span>RcBox&lt;T&gt;;\n\n    <span class=\"kw\">fn </span>strong(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; usize {\n        <span class=\"self\">self</span>.inner().strong.get()\n    }\n\n    <span class=\"kw\">fn </span>inc_strong(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) {\n        <span class=\"self\">self</span>.inner()\n            .strong\n            .set(<span class=\"self\">self</span>.strong()\n                     .checked_add(<span class=\"number\">1</span>)\n                     .unwrap_or_else(|| abort() ));\n    }\n}\n\n<span class=\"kw\">impl</span>&lt;T: <span class=\"question-mark\">?</span>Sized&gt; RcBoxPtr&lt;T&gt; <span class=\"kw\">for </span>Rc&lt;T&gt; {\n   <span class=\"kw\">fn </span>inner(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; <span class=\"kw-2\">&amp;</span>RcBox&lt;T&gt; {\n       <span class=\"kw\">unsafe </span>{\n           <span class=\"self\">self</span>.ptr.as_ref()\n       }\n   }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::cell::Cell;%0A++++use+std::ptr::NonNull;%0A++++use+std::process::abort;%0A++++use+std::marker::PhantomData;%0A++++%0A++++struct+Rc%3CT:+?Sized%3E+%7B%0A++++++++ptr:+NonNull%3CRcBox%3CT%3E%3E,%0A++++++++phantom:+PhantomData%3CRcBox%3CT%3E%3E,%0A++++%7D%0A++++%0A++++struct+RcBox%3CT:+?Sized%3E+%7B%0A++++++++strong:+Cell%3Cusize%3E,%0A++++++++refcount:+Cell%3Cusize%3E,%0A++++++++value:+T,%0A++++%7D%0A++++%0A++++impl%3CT:+?Sized%3E+Clone+for+Rc%3CT%3E+%7B%0A++++++++fn+clone(%26self)+-%3E+Rc%3CT%3E+%7B%0A++++++++++++self.inc_strong();%0A++++++++++++Rc+%7B%0A++++++++++++++++ptr:+self.ptr,%0A++++++++++++++++phantom:+PhantomData,%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++%0A++++trait+RcBoxPtr%3CT:+?Sized%3E+%7B%0A++++%0A++++++++fn+inner(%26self)+-%3E+%26RcBox%3CT%3E;%0A++++%0A++++++++fn+strong(%26self)+-%3E+usize+%7B%0A++++++++++++self.inner().strong.get()%0A++++++++%7D%0A++++%0A++++++++fn+inc_strong(%26self)+%7B%0A++++++++++++self.inner()%0A++++++++++++++++.strong%0A++++++++++++++++.set(self.strong()%0A+++++++++++++++++++++++++.checked_add(1)%0A+++++++++++++++++++++++++.unwrap_or_else(%7C%7C+abort()+));%0A++++++++%7D%0A++++%7D%0A++++%0A++++impl%3CT:+?Sized%3E+RcBoxPtr%3CT%3E+for+Rc%3CT%3E+%7B%0A+++++++fn+inner(%26self)+-%3E+%26RcBox%3CT%3E+%7B%0A+++++++++++unsafe+%7B%0A+++++++++++++++self.ptr.as_ref()%0A+++++++++++%7D%0A+++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"structs\" class=\"section-header\">Structs<a href=\"#structs\" class=\"anchor\">§</a></h2><ul class=\"item-table\"><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BorrowError.html\" title=\"struct std::cell::BorrowError\">BorrowError</a></div><div class=\"desc docblock-short\">An error returned by <a href=\"struct.RefCell.html#method.try_borrow\" title=\"method std::cell::RefCell::try_borrow\"><code>RefCell::try_borrow</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.BorrowMutError.html\" title=\"struct std::cell::BorrowMutError\">BorrowMutError</a></div><div class=\"desc docblock-short\">An error returned by <a href=\"struct.RefCell.html#method.try_borrow_mut\" title=\"method std::cell::RefCell::try_borrow_mut\"><code>RefCell::try_borrow_mut</code></a>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Cell.html\" title=\"struct std::cell::Cell\">Cell</a></div><div class=\"desc docblock-short\">A mutable memory location.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.LazyCell.html\" title=\"struct std::cell::LazyCell\">LazyCell</a></div><div class=\"desc docblock-short\">A value which is initialized on the first access.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.OnceCell.html\" title=\"struct std::cell::OnceCell\">OnceCell</a></div><div class=\"desc docblock-short\">A cell which can nominally be written to only once.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.Ref.html\" title=\"struct std::cell::Ref\">Ref</a></div><div class=\"desc docblock-short\">Wraps a borrowed reference to a value in a <code>RefCell</code> box.\nA wrapper type for an immutably borrowed value from a <code>RefCell&lt;T&gt;</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RefCell.html\" title=\"struct std::cell::RefCell\">RefCell</a></div><div class=\"desc docblock-short\">A mutable memory location with dynamically checked borrow rules</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.RefMut.html\" title=\"struct std::cell::RefMut\">RefMut</a></div><div class=\"desc docblock-short\">A wrapper type for a mutably borrowed value from a <code>RefCell&lt;T&gt;</code>.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.UnsafeCell.html\" title=\"struct std::cell::UnsafeCell\">UnsafeCell</a></div><div class=\"desc docblock-short\">The core primitive for interior mutability in Rust.</div></li><li><div class=\"item-name\"><a class=\"struct\" href=\"struct.SyncUnsafeCell.html\" title=\"struct std::cell::SyncUnsafeCell\">SyncUnsafeCell</a><span class=\"stab unstable\" title=\"\">Experimental</span></div><div class=\"desc docblock-short\"><a href=\"struct.UnsafeCell.html\" title=\"struct std::cell::UnsafeCell\"><code>UnsafeCell</code></a>, but <a href=\"../marker/trait.Sync.html\" title=\"trait std::marker::Sync\"><code>Sync</code></a>.</div></li></ul></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:10:49.866Z"
}