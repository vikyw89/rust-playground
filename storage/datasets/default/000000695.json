{
	"title": "Operator expressions - The Rust Reference",
	"url": "https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html",
	"markdown": "# Operator expressions - The Rust Reference\n\n> **Syntax**  \n> _OperatorExpression_ :  \n>       [_BorrowExpression_](#borrow-operators)  \n>    | [_DereferenceExpression_](#the-dereference-operator)  \n>    | [_ErrorPropagationExpression_](#the-question-mark-operator)  \n>    | [_NegationExpression_](#negation-operators)  \n>    | [_ArithmeticOrLogicalExpression_](#arithmetic-and-logical-binary-operators)  \n>    | [_ComparisonExpression_](#comparison-operators)  \n>    | [_LazyBooleanExpression_](#lazy-boolean-operators)  \n>    | [_TypeCastExpression_](#type-cast-expressions)  \n>    | [_AssignmentExpression_](#assignment-expressions)  \n>    | [_CompoundAssignmentExpression_](#compound-assignment-expressions)\n\nOperators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in `std::ops` or `std::cmp`.\n\n## [Overflow](#overflow)\n\nInteger operators will panic when they overflow when compiled in debug mode. The `-C debug-assertions` and `-C overflow-checks` compiler flags can be used to control this more directly. The following things are considered to be overflow:\n\n-   When `+`, `*` or binary `-` create a value greater than the maximum value, or less than the minimum value that can be stored.\n-   Applying unary `-` to the most negative value of any signed integer type, unless the operand is a [literal expression](about:blank/literal-expr.html#integer-literal-expressions) (or a literal expression standing alone inside one or more [grouped expressions](grouped-expr.html)).\n-   Using `/` or `%`, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is `-1`. These checks occur even when `-C overflow-checks` is disabled, for legacy reasons.\n-   Using `<<` or `>>` where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.\n\n> **Note**: The exception for literal expressions behind unary `-` means that forms such as `-128_i8` or `let j: i8 = -(128)` never cause a panic and have the expected value of -128.\n> \n> In these cases, the literal expression already has the most negative value for its type (for example, `128_i8` has the value -128) because integer literals are truncated to their type per the description in [Integer literal expressions](about:blank/literal-expr.html#integer-literal-expressions).\n> \n> Negation of these most negative values leaves the value unchanged due to two's complement overflow conventions.\n> \n> In `rustc`, these most negative expressions are also ignored by the `overflowing_literals` lint check.\n\n## [Borrow operators](#borrow-operators)\n\n> **Syntax**  \n> _BorrowExpression_ :  \n>       (`&`|`&&`) [_Expression_](../expressions.html)  \n>    | (`&`|`&&`) `mut` [_Expression_](../expressions.html)\n\nThe `&` (shared borrow) and `&mut` (mutable borrow) operators are unary prefix operators. When applied to a [place expression](about:blank/expressions.html#place-expressions-and-value-expressions), this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (`&`), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (`&mut`), the place may not be accessed in any way until the borrow expires. `&mut` evaluates its operand in a mutable place expression context. If the `&` or `&mut` operators are applied to a [value expression](about:blank/expressions.html#place-expressions-and-value-expressions), then a [temporary value](about:blank/expressions.html#temporaries) is created.\n\nThese operators cannot be overloaded.\n\n```rust\n#![allow(unused)]\nfn main() {\n{\n    // a temporary with value 7 is created that lasts for this scope.\n    let shared_reference = &7;\n}\nlet mut array = [-2, 3, 9];\n{\n    // Mutably borrows `array` for this scope.\n    // `array` may only be used through `mutable_reference`.\n    let mutable_reference = &mut array;\n}\n}\n```\n\nEven though `&&` is a single token ([the lazy 'and' operator](#lazy-boolean-operators)), when used in the context of borrow expressions it works as two borrows:\n\n```rust\n#![allow(unused)]\nfn main() {\n// same meanings:\nlet a = &&  10;\nlet a = & & 10;\n\n// same meanings:\nlet a = &&&&  mut 10;\nlet a = && && mut 10;\nlet a = & & & & mut 10;\n}\n```\n\n### [Raw address-of operators](#raw-address-of-operators)\n\nRelated to the borrow operators are the _raw address-of operators_, which do not have first-class syntax, but are exposed via the macros [`ptr::addr_of!(expr)`](../../std/ptr/macro.addr_of.html) and [`ptr::addr_of_mut!(expr)`](../../std/ptr/macro.addr_of_mut.html). The expression `expr` is evaluated in place expression context. `ptr::addr_of!(expr)` then creates a const raw pointer of type `*const T` to the given place, and `ptr::addr_of_mut!(expr)` creates a mutable raw pointer of type `*mut T`.\n\nThe raw address-of operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions. In those situations, using a borrow operator would cause [undefined behavior](../behavior-considered-undefined.html) by creating an invalid reference, but a raw pointer may still be constructed using an address-of operator.\n\nThe following is an example of creating a raw pointer to an unaligned place through a `packed` struct:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::ptr;\n\n#[repr(packed)]\nstruct Packed {\n    f1: u8,\n    f2: u16,\n}\n\nlet packed = Packed { f1: 1, f2: 2 };\n// `&packed.f2` would create an unaligned reference, and thus be Undefined Behavior!\nlet raw_f2 = ptr::addr_of!(packed.f2);\nassert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n}\n```\n\nThe following is an example of creating a raw pointer to a place that does not contain a valid value:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::{ptr, mem::MaybeUninit};\n\nstruct Demo {\n    field: bool,\n}\n\nlet mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be Undefined Behavior!\nlet f1_ptr = unsafe { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };\nunsafe { f1_ptr.write(true); }\nlet init = unsafe { uninit.assume_init() };\n}\n```\n\n## [The dereference operator](#the-dereference-operator)\n\n> **Syntax**  \n> _DereferenceExpression_ :  \n>    `*` [_Expression_](../expressions.html)\n\nThe `*` (dereference) operator is also a unary prefix operator. When applied to a [pointer](../types/pointer.html) it denotes the pointed-to location. If the expression is of type `&mut T` or `*mut T`, and is either a local variable, a (nested) field of a local variable or is a mutable [place expression](about:blank/expressions.html#place-expressions-and-value-expressions), then the resulting memory location can be assigned to. Dereferencing a raw pointer requires `unsafe`.\n\nOn non-pointer types `*x` is equivalent to `*std::ops::Deref::deref(&x)` in an [immutable place expression context](about:blank/expressions.html#mutability) and `*std::ops::DerefMut::deref_mut(&mut x)` in a mutable place expression context.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = &7;\nassert_eq!(*x, 7);\nlet y = &mut 9;\n*y = 11;\nassert_eq!(*y, 11);\n}\n```\n\n## [The question mark operator](#the-question-mark-operator)\n\n> **Syntax**  \n> _ErrorPropagationExpression_ :  \n>    [_Expression_](../expressions.html) `?`\n\nThe question mark operator (`?`) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types `Result<T, E>` and `Option<T>`.\n\nWhen applied to values of the `Result<T, E>` type, it propagates errors. If the value is `Err(e)`, then it will return `Err(From::from(e))` from the enclosing function or closure. If applied to `Ok(x)`, then it will unwrap the value to evaluate to `x`.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::num::ParseIntError;\nfn try_to_parse() -> Result<i32, ParseIntError> {\n    let x: i32 = \"123\".parse()?; // x = 123\n    let y: i32 = \"24a\".parse()?; // returns an Err() immediately\n    Ok(x + y)                    // Doesn't run.\n}\n\nlet res = try_to_parse();\nprintln!(\"{:?}\", res);\nassert!(res.is_err())\n}\n```\n\nWhen applied to values of the `Option<T>` type, it propagates `None`s. If the value is `None`, then it will return `None`. If applied to `Some(x)`, then it will unwrap the value to evaluate to `x`.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn try_option_some() -> Option<u8> {\n    let val = Some(1)?;\n    Some(val)\n}\nassert_eq!(try_option_some(), Some(1));\n\nfn try_option_none() -> Option<u8> {\n    let val = None?;\n    Some(val)\n}\nassert_eq!(try_option_none(), None);\n}\n```\n\n`?` cannot be overloaded.\n\n## [Negation operators](#negation-operators)\n\n> **Syntax**  \n> _NegationExpression_ :  \n>       `-` [_Expression_](../expressions.html)  \n>    | `!` [_Expression_](../expressions.html)\n\nThese are the last two unary operators. This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in [value expression context](about:blank/expressions.html#place-expressions-and-value-expressions) so are moved or copied.\n\n| Symbol | Integer | `bool` | Floating Point | Overloading Trait |\n| --- | --- | --- | --- | --- |\n| `-` | Negation\\* |  | Negation | `std::ops::Neg` |\n| `!` | Bitwise NOT | [Logical NOT](about:blank/types/boolean.html#logical-not) |  | `std::ops::Not` |\n\n\\* Only for signed integer types.\n\nHere are some example of these operators\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 6;\nassert_eq!(-x, -6);\nassert_eq!(!x, -7);\nassert_eq!(true, !false);\n}\n```\n\n## [Arithmetic and Logical Binary Operators](#arithmetic-and-logical-binary-operators)\n\n> **Syntax**  \n> _ArithmeticOrLogicalExpression_ :  \n>       [_Expression_](../expressions.html) `+` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `-` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `*` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `/` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `%` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `&` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `|` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `^` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `<<` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `>>` [_Expression_](../expressions.html)\n\nBinary operators expressions are all written with infix notation. This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in [value expression context](about:blank/expressions.html#place-expressions-and-value-expressions) so are moved or copied.\n\n| Symbol | Integer | `bool` | Floating Point | Overloading Trait | Overloading Compound Assignment Trait |\n| --- | --- | --- | --- | --- | --- |\n| `+` | Addition |  | Addition | `std::ops::Add` | `std::ops::AddAssign` |\n| `-` | Subtraction |  | Subtraction | `std::ops::Sub` | `std::ops::SubAssign` |\n| `*` | Multiplication |  | Multiplication | `std::ops::Mul` | `std::ops::MulAssign` |\n| `/` | Division\\*† |  | Division | `std::ops::Div` | `std::ops::DivAssign` |\n| `%` | Remainder\\*\\*† |  | Remainder | `std::ops::Rem` | `std::ops::RemAssign` |\n| `&` | Bitwise AND | [Logical AND](about:blank/types/boolean.html#logical-and) |  | `std::ops::BitAnd` | `std::ops::BitAndAssign` |\n| `|` | Bitwise OR | [Logical OR](about:blank/types/boolean.html#logical-or) |  | `std::ops::BitOr` | `std::ops::BitOrAssign` |\n| `^` | Bitwise XOR | [Logical XOR](about:blank/types/boolean.html#logical-xor) |  | `std::ops::BitXor` | `std::ops::BitXorAssign` |\n| `<<` | Left Shift |  |  | `std::ops::Shl` | `std::ops::ShlAssign` |\n| `>>` | Right Shift\\*\\*\\* |  |  | `std::ops::Shr` | `std::ops::ShrAssign` |\n\n\\* Integer division rounds towards zero.\n\n\\*\\* Rust uses a remainder defined with [truncating division](https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition). Given `remainder = dividend % divisor`, the remainder will have the same sign as the dividend.\n\n\\*\\*\\* Arithmetic right shift on signed integer types, logical right shift on unsigned integer types.\n\n† For integer types, division by zero panics.\n\nHere are examples of these operators being used.\n\n```rust\n#![allow(unused)]\nfn main() {\nassert_eq!(3 + 6, 9);\nassert_eq!(5.5 - 1.25, 4.25);\nassert_eq!(-5 * 14, -70);\nassert_eq!(14 / 3, 4);\nassert_eq!(100 % 7, 2);\nassert_eq!(0b1010 & 0b1100, 0b1000);\nassert_eq!(0b1010 | 0b1100, 0b1110);\nassert_eq!(0b1010 ^ 0b1100, 0b110);\nassert_eq!(13 << 3, 104);\nassert_eq!(-10 >> 2, -3);\n}\n```\n\n## [Comparison Operators](#comparison-operators)\n\n> **Syntax**  \n> _ComparisonExpression_ :  \n>       [_Expression_](../expressions.html) `==` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `!=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `>` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `<` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `>=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `<=` [_Expression_](../expressions.html)\n\nComparison operators are also defined both for primitive types and many types in the standard library. Parentheses are required when chaining comparison operators. For example, the expression `a == b == c` is invalid and may be written as `(a == b) == c`.\n\nUnlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in [place expression context](about:blank/expressions.html#place-expressions-and-value-expressions):\n\n```rust\n#![allow(unused)]\nfn main() {\nlet a = 1;\nlet b = 1;\na == b;\n// is equivalent to\n::std::cmp::PartialEq::eq(&a, &b);\n}\n```\n\nThis means that the operands don't have to be moved out of.\n\n| Symbol | Meaning | Overloading method |\n| --- | --- | --- |\n| `==` | Equal | `std::cmp::PartialEq::eq` |\n| `!=` | Not equal | `std::cmp::PartialEq::ne` |\n| `>` | Greater than | `std::cmp::PartialOrd::gt` |\n| `<` | Less than | `std::cmp::PartialOrd::lt` |\n| `>=` | Greater than or equal to | `std::cmp::PartialOrd::ge` |\n| `<=` | Less than or equal to | `std::cmp::PartialOrd::le` |\n\nHere are examples of the comparison operators being used.\n\n```rust\n#![allow(unused)]\nfn main() {\nassert!(123 == 123);\nassert!(23 != -12);\nassert!(12.5 > 12.2);\nassert!([1, 2, 3] < [1, 3, 4]);\nassert!('A' <= 'B');\nassert!(\"World\" >= \"Hello\");\n}\n```\n\n## [Lazy boolean operators](#lazy-boolean-operators)\n\n> **Syntax**  \n> _LazyBooleanExpression_ :  \n>       [_Expression_](../expressions.html) `||` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `&&` [_Expression_](../expressions.html)\n\nThe operators `||` and `&&` may be applied to operands of boolean type. The `||` operator denotes logical 'or', and the `&&` operator denotes logical 'and'. They differ from `|` and `&` in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, `||` only evaluates its right-hand operand when the left-hand operand evaluates to `false`, and `&&` only when it evaluates to `true`.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = false || true; // true\nlet y = false && panic!(); // false, doesn't evaluate `panic!()`\n}\n```\n\n## [Type cast expressions](#type-cast-expressions)\n\n> **Syntax**  \n> _TypeCastExpression_ :  \n>    [_Expression_](../expressions.html) `as` [_TypeNoBounds_](about:blank/types.html#type-expressions)\n\nA type cast expression is denoted with the binary operator `as`.\n\nExecuting an `as` expression casts the value on the left-hand side to the type on the right-hand side.\n\nAn example of an `as` expression:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn sum(values: &[f64]) -> f64 { 0.0 }\nfn len(values: &[f64]) -> i32 { 0 }\nfn average(values: &[f64]) -> f64 {\n    let sum: f64 = sum(values);\n    let size: f64 = len(values) as f64;\n    sum / size\n}\n}\n```\n\n`as` can be used to explicitly perform [coercions](../type-coercions.html), as well as the following additional casts. Any cast that does not fit either a coercion rule or an entry in the table is a compiler error. Here `*T` means either `*const T` or `*mut T`. `m` stands for optional `mut` in reference types and `mut` or `const` in pointer types.\n\n| Type of `e` | `U` | Cast performed by `e as U` |\n| --- | --- | --- |\n| Integer or Float type | Integer or Float type | Numeric cast |\n| Enumeration | Integer type | Enum cast |\n| `bool` or `char` | Integer type | Primitive to integer cast |\n| `u8` | `char` | `u8` to `char` cast |\n| `*T` | `*V` where `V: Sized` \\* | Pointer to pointer cast |\n| `*T` where `T: Sized` | Integer type | Pointer to address cast |\n| Integer type | `*V` where `V: Sized` | Address to pointer cast |\n| `&m₁ T` | `*m₂ T` \\*\\* | Reference to pointer cast |\n| `&m₁ [T; n]` | `*m₂ T` \\*\\* | Array to pointer cast |\n| [Function item](../types/function-item.html) | [Function pointer](../types/function-pointer.html) | Function item to function pointer cast |\n| [Function item](../types/function-item.html) | `*V` where `V: Sized` | Function item to pointer cast |\n| [Function item](../types/function-item.html) | Integer | Function item to address cast |\n| [Function pointer](../types/function-pointer.html) | `*V` where `V: Sized` | Function pointer to pointer cast |\n| [Function pointer](../types/function-pointer.html) | Integer | Function pointer to address cast |\n| Closure \\*\\*\\* | Function pointer | Closure to function pointer cast |\n\n\\* or `T` and `V` are compatible unsized types, e.g., both slices, both the same trait object.\n\n\\*\\* only when `m₁` is `mut` or `m₂` is `const`. Casting `mut` reference to `const` pointer is allowed.\n\n\\*\\*\\* only for closures that do not capture (close over) any local variables\n\n### [Semantics](#semantics)\n\n#### [Numeric cast](#numeric-cast)\n\n-   Casting between two integers of the same size (e.g. i32 -> u32) is a no-op (Rust uses 2's complement for negative values of fixed integers)\n-   Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will truncate\n-   Casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n    -   zero-extend if the source is unsigned\n    -   sign-extend if the source is signed\n-   Casting from a float to an integer will round the float towards zero\n    -   `NaN` will return `0`\n    -   Values larger than the maximum integer value, including `INFINITY`, will saturate to the maximum value of the integer type.\n    -   Values smaller than the minimum integer value, including `NEG_INFINITY`, will saturate to the minimum value of the integer type.\n-   Casting from an integer to float will produce the closest possible float \\*\n    -   if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*\n    -   on overflow, infinity (of the same sign as the input) is produced\n    -   note: with the current set of numeric types, overflow can only happen on `u128 as f32` for values greater or equal to `f32::MAX + (0.5 ULP)`\n-   Casting from an f32 to an f64 is perfect and lossless\n-   Casting from an f64 to an f32 will produce the closest possible f32 \\*\\*\n    -   if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*\n    -   on overflow, infinity (of the same sign as the input) is produced\n\n\\* if integer-to-float casts with this rounding mode and overflow behavior are not supported natively by the hardware, these casts will likely be slower than expected.\n\n\\*\\* if f64-to-f32 casts with this rounding mode and overflow behavior are not supported natively by the hardware, these casts will likely be slower than expected.\n\n\\*\\*\\* as defined in IEEE 754-2008 §4.3.1: pick the nearest floating point number, preferring the one with an even least significant digit if exactly halfway between two floating point numbers.\n\n#### [Enum cast](#enum-cast)\n\nCasts an enum to its discriminant, then uses a numeric cast if needed. Casting is limited to the following kinds of enumerations:\n\n-   [Unit-only enums](about:blank/items/enumerations.html#unit-only-enum)\n-   [Field-less enums](about:blank/items/enumerations.html#field-less-enum) without [explicit discriminants](about:blank/items/enumerations.html#explicit-discriminants), or where only unit-variants have explicit discriminants\n\n#### [Primitive to integer cast](#primitive-to-integer-cast)\n\n-   `false` casts to `0`, `true` casts to `1`\n-   `char` casts to the value of the code point, then uses a numeric cast if needed.\n\n#### [`u8` to `char` cast](#u8-to-char-cast)\n\nCasts to the `char` with the corresponding code point.\n\n#### [Pointer to address cast](#pointer-to-address-cast)\n\nCasting from a raw pointer to an integer produces the machine address of the referenced memory. If the integer type is smaller than the pointer type, the address may be truncated; using `usize` avoids this.\n\n#### [Address to pointer cast](#address-to-pointer-cast)\n\nCasting from an integer to a raw pointer interprets the integer as a memory address and produces a pointer referencing that memory.\n\nWarning: This interacts with the Rust memory model, which is still under development. A pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer. Dereferencing such a pointer may be [undefined behavior](../behavior-considered-undefined.html) if aliasing rules are not followed.\n\nA trivial example of sound address arithmetic:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut values: [i32; 2] = [1, 2];\nlet p1: *mut i32 = values.as_mut_ptr();\nlet first_address = p1 as usize;\nlet second_address = first_address + 4; // 4 == size_of::<i32>()\nlet p2 = second_address as *mut i32;\nunsafe {\n    *p2 += 1;\n}\nassert_eq!(values[1], 3);\n}\n```\n\n#### [Pointer-to-pointer cast](#pointer-to-pointer-cast)\n\n`*const T` / `*mut T` can be cast to `*const U` / `*mut U` with the following behavior:\n\n-   If `T` and `U` are both sized, the pointer is returned unchanged.\n    \n-   If `T` and `U` are both unsized, the pointer is also returned unchanged. In particular, the metadata is preserved exactly.\n    \n    For instance, a cast from `*const [T]` to `*const [U]` preserves the number of elements. Note that, as a consequence, such casts do not necessarily preserve the size of the pointer's referent (e.g., casting `*const [u16]` to `*const [u8]` will result in a raw pointer which refers to an object of half the size of the original). The same holds for `str` and any compound type whose unsized tail is a slice type, such as `struct Foo(i32, [u8])` or `(u64, Foo)`.\n    \n-   If `T` is unsized and `U` is sized, the cast discards all metadata that completes the wide pointer `T` and produces a thin pointer `U` consisting of the data part of the unsized pointer.\n    \n\n## [Assignment expressions](#assignment-expressions)\n\n> **Syntax**  \n> _AssignmentExpression_ :  \n>    [_Expression_](../expressions.html) `=` [_Expression_](../expressions.html)\n\nAn _assignment expression_ moves a value into a specified place.\n\nAn assignment expression consists of a [mutable](about:blank/expressions.html#mutability) [assignee expression](about:blank/expressions.html#place-expressions-and-value-expressions), the _assignee operand_, followed by an equals sign (`=`) and a [value expression](about:blank/expressions.html#place-expressions-and-value-expressions), the _assigned value operand_. In its most basic form, an assignee expression is a [place expression](about:blank/expressions.html#place-expressions-and-value-expressions), and we discuss this case first. The more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case.\n\n### [Basic assignments](#basic-assignments)\n\nEvaluating assignment expressions begins by evaluating its operands. The assigned value operand is evaluated first, followed by the assignee expression. For destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right.\n\n> **Note**: This is different than other expressions in that the right operand is evaluated before the left one.\n\nIt then has the effect of first [dropping](../destructors.html) the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable. Next it either [copies or moves](about:blank/expressions.html#moved-and-copied-types) the assigned value to the assigned place.\n\nAn assignment expression always produces [the unit value](../types/tuple.html).\n\nExample:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut x = 0;\nlet y = 0;\nx = y;\n}\n```\n\n### [Destructuring assignments](#destructuring-assignments)\n\nDestructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs. For instance, we may swap two mutable variables:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet (mut a, mut b) = (0, 1);\n// Swap `a` and `b` using destructuring assignment.\n(b, a) = (a, b);\n}\n```\n\nIn contrast to destructuring declarations using `let`, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities. Instead, a group of expressions that correspond to patterns are designated to be [assignee expressions](about:blank/expressions.html#place-expressions-and-value-expressions), and permitted on the left-hand side of an assignment. Assignee expressions are then desugared to pattern matches followed by sequential assignment. The desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice `[..]`, are permitted for destructuring assignment.\n\nThe desugaring method is straightforward, and is illustrated best by example.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Struct { x: u32, y: u32 }\nlet (mut a, mut b) = (0, 0);\n(a, b) = (3, 4);\n\n[a, b] = [3, 4];\n\nStruct { x: a, y: b } = Struct { x: 3, y: 4};\n\n// desugars to:\n\n{\n    let (_a, _b) = (3, 4);\n    a = _a;\n    b = _b;\n}\n\n{\n    let [_a, _b] = [3, 4];\n    a = _a;\n    b = _b;\n}\n\n{\n    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};\n    a = _a;\n    b = _b;\n}\n}\n```\n\nIdentifiers are not forbidden from being used multiple times in a single assignee expression.\n\n[Underscore expressions](./underscore-expr.html) and empty [range expressions](./range-expr.html) may be used to ignore certain values, without binding them.\n\nNote that default binding modes do not apply for the desugared expression.\n\n## [Compound assignment expressions](#compound-assignment-expressions)\n\n> **Syntax**  \n> _CompoundAssignmentExpression_ :  \n>       [_Expression_](../expressions.html) `+=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `-=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `*=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `/=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `%=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `&=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `|=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `^=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `<<=` [_Expression_](../expressions.html)  \n>    | [_Expression_](../expressions.html) `>>=` [_Expression_](../expressions.html)\n\n_Compound assignment expressions_ combine arithmetic and logical binary operators with assignment expressions.\n\nFor example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut x = 5;\nx += 1;\nassert!(x == 6);\n}\n```\n\nThe syntax of compound assignment is a [mutable](about:blank/expressions.html#mutability) [place expression](about:blank/expressions.html#place-expressions-and-value-expressions), the _assigned operand_, then one of the operators followed by an `=` as a single token (no whitespace), and then a [value expression](about:blank/expressions.html#place-expressions-and-value-expressions), the _modifying operand_.\n\nUnlike other place operands, the assigned place operand must be a place expression. Attempting to use a value expression is a compiler error rather than promoting it to a temporary.\n\nEvaluation of compound assignment expressions depends on the types of the operators.\n\nIf both types are primitives, then the modifying operand will be evaluated first followed by the assigned operand. It will then set the value of the assigned operand's place to the value of performing the operation of the operator with the values of the assigned operand and modifying operand.\n\n> **Note**: This is different than other expressions in that the right operand is evaluated before the left one.\n\nOtherwise, this expression is syntactic sugar for calling the function of the overloading compound assignment trait of the operator (see the table earlier in this chapter). A mutable borrow of the assigned operand is automatically taken.\n\nFor example, the following expression statements in `example` are equivalent:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Addable;\nuse std::ops::AddAssign;\n\nimpl AddAssign<Addable> for Addable {\n    /* */\nfn add_assign(&mut self, other: Addable) {}\n}\n\nfn example() {\nlet (mut a1, a2) = (Addable, Addable);\n  a1 += a2;\n\nlet (mut a1, a2) = (Addable, Addable);\n  AddAssign::add_assign(&mut a1, a2);\n}\n}\n```\n\nLike assignment expressions, compound assignment expressions always produce [the unit value](../types/tuple.html).\n\nWarning: The evaluation order of operands swaps depending on the types of the operands: with primitive types the right-hand side will get evaluated first, while with non-primitive types the left-hand side will get evaluated first. Try not to write code that depends on the evaluation order of operands in compound assignment expressions. See [this test](https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs) for an example of using this dependency.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Operator expressions - The Rust Reference</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"../favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"../favicon.png\">\n        <link rel=\"stylesheet\" href=\"../css/variables.css\">\n        <link rel=\"stylesheet\" href=\"../css/general.css\">\n        <link rel=\"stylesheet\" href=\"../css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"../css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"../FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"../fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"../highlight.css\">\n        <link rel=\"stylesheet\" href=\"../tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"../ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"../theme/reference.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"../\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"../introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"../notation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Notation</a></li><li class=\"chapter-item expanded \"><a href=\"../lexical-structure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Lexical structure</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../input-format.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.1.</strong> Input format</a></li><li class=\"chapter-item expanded \"><a href=\"../keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.2.</strong> Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"../identifiers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.3.</strong> Identifiers</a></li><li class=\"chapter-item expanded \"><a href=\"../comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"../whitespace.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.5.</strong> Whitespace</a></li><li class=\"chapter-item expanded \"><a href=\"../tokens.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.6.</strong> Tokens</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Macros</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../macros-by-example.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Macros By Example</a></li><li class=\"chapter-item expanded \"><a href=\"../procedural-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Procedural Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../crates-and-source-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Crates and source files</a></li><li class=\"chapter-item expanded \"><a href=\"../conditional-compilation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Conditional compilation</a></li><li class=\"chapter-item expanded \"><a href=\"../items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Items</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../items/modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Modules</a></li><li class=\"chapter-item expanded \"><a href=\"../items/extern-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> Extern crates</a></li><li class=\"chapter-item expanded \"><a href=\"../items/use-declarations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Use declarations</a></li><li class=\"chapter-item expanded \"><a href=\"../items/functions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.4.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"../items/type-aliases.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.5.</strong> Type aliases</a></li><li class=\"chapter-item expanded \"><a href=\"../items/structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.6.</strong> Structs</a></li><li class=\"chapter-item expanded \"><a href=\"../items/enumerations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.7.</strong> Enumerations</a></li><li class=\"chapter-item expanded \"><a href=\"../items/unions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.8.</strong> Unions</a></li><li class=\"chapter-item expanded \"><a href=\"../items/constant-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.9.</strong> Constant items</a></li><li class=\"chapter-item expanded \"><a href=\"../items/static-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.10.</strong> Static items</a></li><li class=\"chapter-item expanded \"><a href=\"../items/traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.11.</strong> Traits</a></li><li class=\"chapter-item expanded \"><a href=\"../items/implementations.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.12.</strong> Implementations</a></li><li class=\"chapter-item expanded \"><a href=\"../items/external-blocks.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.13.</strong> External blocks</a></li><li class=\"chapter-item expanded \"><a href=\"../items/generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.14.</strong> Generic parameters</a></li><li class=\"chapter-item expanded \"><a href=\"../items/associated-items.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.15.</strong> Associated Items</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../attributes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Attributes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../attributes/testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Testing</a></li><li class=\"chapter-item expanded \"><a href=\"../attributes/derive.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Derive</a></li><li class=\"chapter-item expanded \"><a href=\"../attributes/diagnostics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Diagnostics</a></li><li class=\"chapter-item expanded \"><a href=\"../attributes/codegen.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Code generation</a></li><li class=\"chapter-item expanded \"><a href=\"../attributes/limits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Limits</a></li><li class=\"chapter-item expanded \"><a href=\"../attributes/type_system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.6.</strong> Type System</a></li><li class=\"chapter-item expanded \"><a href=\"../attributes/debugger.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.7.</strong> Debugger</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../statements-and-expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Statements and expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../statements.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Statements</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Expressions</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../expressions/literal-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.1.</strong> Literal expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/path-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.2.</strong> Path expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/block-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.3.</strong> Block expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/operator-expr.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.4.</strong> Operator expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/grouped-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.5.</strong> Grouped expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/array-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.6.</strong> Array and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/tuple-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.7.</strong> Tuple and index expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/struct-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.8.</strong> Struct expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.9.</strong> Call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/method-call-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.10.</strong> Method call expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/field-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.11.</strong> Field access expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/closure-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.12.</strong> Closure expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/loop-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.13.</strong> Loop expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/range-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.14.</strong> Range expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/if-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.15.</strong> If and if let expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/match-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.16.</strong> Match expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/return-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.17.</strong> Return expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/await-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.18.</strong> Await expressions</a></li><li class=\"chapter-item expanded \"><a href=\"../expressions/underscore-expr.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.19.</strong> Underscore expressions</a></li></ol></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Patterns</a></li><li class=\"chapter-item expanded \"><a href=\"../type-system.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Type system</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Types</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../types/boolean.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.1.</strong> Boolean type</a></li><li class=\"chapter-item expanded \"><a href=\"../types/numeric.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.2.</strong> Numeric types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/textual.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.3.</strong> Textual types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/never.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.4.</strong> Never type</a></li><li class=\"chapter-item expanded \"><a href=\"../types/tuple.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.5.</strong> Tuple types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/array.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.6.</strong> Array types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/slice.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.7.</strong> Slice types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/struct.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.8.</strong> Struct types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.9.</strong> Enumerated types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/union.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.10.</strong> Union types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/function-item.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.11.</strong> Function item types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/closure.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.12.</strong> Closure types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.13.</strong> Pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/function-pointer.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.14.</strong> Function pointer types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/trait-object.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.15.</strong> Trait object types</a></li><li class=\"chapter-item expanded \"><a href=\"../types/impl-trait.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.16.</strong> Impl trait type</a></li><li class=\"chapter-item expanded \"><a href=\"../types/parameters.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.17.</strong> Type parameters</a></li><li class=\"chapter-item expanded \"><a href=\"../types/inferred.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.18.</strong> Inferred type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../dynamically-sized-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Dynamically Sized Types</a></li><li class=\"chapter-item expanded \"><a href=\"../type-layout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Type layout</a></li><li class=\"chapter-item expanded \"><a href=\"../interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.4.</strong> Interior mutability</a></li><li class=\"chapter-item expanded \"><a href=\"../subtyping.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.5.</strong> Subtyping and Variance</a></li><li class=\"chapter-item expanded \"><a href=\"../trait-bounds.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.6.</strong> Trait and lifetime bounds</a></li><li class=\"chapter-item expanded \"><a href=\"../type-coercions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.7.</strong> Type coercions</a></li><li class=\"chapter-item expanded \"><a href=\"../destructors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.8.</strong> Destructors</a></li><li class=\"chapter-item expanded \"><a href=\"../lifetime-elision.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.9.</strong> Lifetime elision</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../special-types-and-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Special types and traits</a></li><li class=\"chapter-item expanded \"><a href=\"../names.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> Names</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../names/namespaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Namespaces</a></li><li class=\"chapter-item expanded \"><a href=\"../names/scopes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Scopes</a></li><li class=\"chapter-item expanded \"><a href=\"../names/preludes.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Preludes</a></li><li class=\"chapter-item expanded \"><a href=\"../paths.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Paths</a></li><li class=\"chapter-item expanded \"><a href=\"../names/name-resolution.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Name resolution</a></li><li class=\"chapter-item expanded \"><a href=\"../visibility-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Visibility and privacy</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../memory-model.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Memory model</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../memory-allocation-and-lifetime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Memory allocation and lifetime</a></li><li class=\"chapter-item expanded \"><a href=\"../variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Variables</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../linkage.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> Linkage</a></li><li class=\"chapter-item expanded \"><a href=\"../inline-assembly.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Inline assembly</a></li><li class=\"chapter-item expanded \"><a href=\"../unsafety.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Unsafety</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../unsafe-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> The unsafe keyword</a></li><li class=\"chapter-item expanded \"><a href=\"../behavior-considered-undefined.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Behavior considered undefined</a></li><li class=\"chapter-item expanded \"><a href=\"../behavior-not-considered-unsafe.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Behavior not considered unsafe</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"../const_eval.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Constant Evaluation</a></li><li class=\"chapter-item expanded \"><a href=\"../abi.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Application Binary Interface</a></li><li class=\"chapter-item expanded \"><a href=\"../runtime.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> The Rust runtime</a></li><li class=\"chapter-item expanded \"><a href=\"../appendices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Appendices</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"../macro-ambiguity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class=\"chapter-item expanded \"><a href=\"../influences.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Influences</a></li><li class=\"chapter-item expanded \"><a href=\"../glossary.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Glossary</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Reference</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"../print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/reference/edit/master/src/expressions/operator-expr.md\" title=\"Suggest an edit\" aria-label=\"Suggest an edit\">\n                            <i id=\"git-edit-button\" class=\"fa fa-edit\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h1 id=\"operator-expressions\"><a class=\"header\" href=\"#operator-expressions\">Operator expressions</a></h1>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>OperatorExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"#borrow-operators\"><em>BorrowExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#the-dereference-operator\"><em>DereferenceExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#the-question-mark-operator\"><em>ErrorPropagationExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#negation-operators\"><em>NegationExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#arithmetic-and-logical-binary-operators\"><em>ArithmeticOrLogicalExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#comparison-operators\"><em>ComparisonExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#lazy-boolean-operators\"><em>LazyBooleanExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#type-cast-expressions\"><em>TypeCastExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#assignment-expressions\"><em>AssignmentExpression</em></a><br>\n&nbsp;&nbsp; | <a href=\"#compound-assignment-expressions\"><em>CompoundAssignmentExpression</em></a></p>\n</blockquote>\n<p>Operators are defined for built in types by the Rust language.\nMany of the following operators can also be overloaded using traits in <code class=\"hljs\">std::ops</code> or <code class=\"hljs\">std::cmp</code>.</p>\n<h2 id=\"overflow\"><a class=\"header\" href=\"#overflow\">Overflow</a></h2>\n<p>Integer operators will panic when they overflow when compiled in debug mode.\nThe <code class=\"hljs\">-C debug-assertions</code> and <code class=\"hljs\">-C overflow-checks</code> compiler flags can be used to control this more directly.\nThe following things are considered to be overflow:</p>\n<ul>\n<li>When <code class=\"hljs\">+</code>, <code class=\"hljs\">*</code> or binary <code class=\"hljs\">-</code> create a value greater than the maximum value, or less than the minimum value that can be stored.</li>\n<li>Applying unary <code class=\"hljs\">-</code> to the most negative value of any signed integer type, unless the operand is a <a href=\"literal-expr.html#integer-literal-expressions\">literal expression</a> (or a literal expression standing alone inside one or more <a href=\"grouped-expr.html\">grouped expressions</a>).</li>\n<li>Using <code class=\"hljs\">/</code> or <code class=\"hljs\">%</code>, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is <code class=\"hljs\">-1</code>.\nThese checks occur even when <code class=\"hljs\">-C overflow-checks</code> is disabled, for legacy reasons.</li>\n<li>Using <code class=\"hljs\">&lt;&lt;</code> or <code class=\"hljs\">&gt;&gt;</code> where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</li>\n</ul>\n<blockquote>\n<p><strong>Note</strong>: The exception for literal expressions behind unary <code class=\"hljs\">-</code> means that forms such as <code class=\"hljs\">-128_i8</code> or <code class=\"hljs\">let j: i8 = -(128)</code> never cause a panic and have the expected value of -128.</p>\n<p>In these cases, the literal expression already has the most negative value for its type (for example, <code class=\"hljs\">128_i8</code> has the value -128) because integer literals are truncated to their type per the description in <a href=\"literal-expr.html#integer-literal-expressions\">Integer literal expressions</a>.</p>\n<p>Negation of these most negative values leaves the value unchanged due to two's complement overflow conventions.</p>\n<p>In <code class=\"hljs\">rustc</code>, these most negative expressions are also ignored by the <code class=\"hljs\">overflowing_literals</code> lint check.</p>\n</blockquote>\n<h2 id=\"borrow-operators\"><a class=\"header\" href=\"#borrow-operators\">Borrow operators</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>BorrowExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; (<code class=\"hljs\">&amp;</code>|<code class=\"hljs\">&amp;&amp;</code>) <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | (<code class=\"hljs\">&amp;</code>|<code class=\"hljs\">&amp;&amp;</code>) <code class=\"hljs\">mut</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>The <code class=\"hljs\">&amp;</code> (shared borrow) and <code class=\"hljs\">&amp;mut</code> (mutable borrow) operators are unary prefix operators.\nWhen applied to a <a href=\"../expressions.html#place-expressions-and-value-expressions\">place expression</a>, this expressions produces a reference (pointer) to the location that the value refers to.\nThe memory location is also placed into a borrowed state for the duration of the reference.\nFor a shared borrow (<code class=\"hljs\">&amp;</code>), this implies that the place may not be mutated, but it may be read or shared again.\nFor a mutable borrow (<code class=\"hljs\">&amp;mut</code>), the place may not be accessed in any way until the borrow expires.\n<code class=\"hljs\">&amp;mut</code> evaluates its operand in a mutable place expression context.\nIf the <code class=\"hljs\">&amp;</code> or <code class=\"hljs\">&amp;mut</code> operators are applied to a <a href=\"../expressions.html#place-expressions-and-value-expressions\">value expression</a>, then a <a href=\"../expressions.html#temporaries\">temporary value</a> is created.</p>\n<p>These operators cannot be overloaded.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span>{\n    <span class=\"hljs-comment\">// a temporary with value 7 is created that lasts for this scope.</span>\n    <span class=\"hljs-keyword\">let</span> shared_reference = &amp;<span class=\"hljs-number\">7</span>;\n}\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> array = [-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>];\n{\n    <span class=\"hljs-comment\">// Mutably borrows `array` for this scope.</span>\n    <span class=\"hljs-comment\">// `array` may only be used through `mutable_reference`.</span>\n    <span class=\"hljs-keyword\">let</span> mutable_reference = &amp;<span class=\"hljs-keyword\">mut</span> array;\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Even though <code class=\"hljs\">&amp;&amp;</code> is a single token (<a href=\"#lazy-boolean-operators\">the lazy 'and' operator</a>), when used in the context of borrow expressions it works as two borrows:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-comment\">// same meanings:</span>\n<span class=\"hljs-keyword\">let</span> a = &amp;&amp;  <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">let</span> a = &amp; &amp; <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-comment\">// same meanings:</span>\n<span class=\"hljs-keyword\">let</span> a = &amp;&amp;&amp;&amp;  <span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">let</span> a = &amp;&amp; &amp;&amp; <span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">let</span> a = &amp; &amp; &amp; &amp; <span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">10</span>;\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"raw-address-of-operators\"><a class=\"header\" href=\"#raw-address-of-operators\">Raw address-of operators</a></h3>\n<p>Related to the borrow operators are the <em>raw address-of operators</em>, which do not have first-class syntax, but are exposed via the macros <a href=\"../../std/ptr/macro.addr_of.html\"><code class=\"hljs\">ptr::addr_of!(expr)</code></a> and <a href=\"../../std/ptr/macro.addr_of_mut.html\"><code class=\"hljs\">ptr::addr_of_mut!(expr)</code></a>.\nThe expression <code class=\"hljs\">expr</code> is evaluated in place expression context.\n<code class=\"hljs\">ptr::addr_of!(expr)</code> then creates a const raw pointer of type <code class=\"hljs\">*const T</code> to the given place, and <code class=\"hljs\">ptr::addr_of_mut!(expr)</code> creates a mutable raw pointer of type <code class=\"hljs\">*mut T</code>.</p>\n<p>The raw address-of operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions.\nIn those situations, using a borrow operator would cause <a href=\"../behavior-considered-undefined.html\">undefined behavior</a> by creating an invalid reference, but a raw pointer may still be constructed using an address-of operator.</p>\n<p>The following is an example of creating a raw pointer to an unaligned place through a <code class=\"hljs\">packed</code> struct:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::ptr;\n\n<span class=\"hljs-meta\">#[repr(packed)]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Packed</span></span> {\n    f1: <span class=\"hljs-built_in\">u8</span>,\n    f2: <span class=\"hljs-built_in\">u16</span>,\n}\n\n<span class=\"hljs-keyword\">let</span> packed = Packed { f1: <span class=\"hljs-number\">1</span>, f2: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-comment\">// `&amp;packed.f2` would create an unaligned reference, and thus be Undefined Behavior!</span>\n<span class=\"hljs-keyword\">let</span> raw_f2 = ptr::addr_of!(packed.f2);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-keyword\">unsafe</span> { raw_f2.read_unaligned() }, <span class=\"hljs-number\">2</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The following is an example of creating a raw pointer to a place that does not contain a valid value:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">use</span> std::{ptr, mem::MaybeUninit};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Demo</span></span> {\n    field: <span class=\"hljs-built_in\">bool</span>,\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> uninit = MaybeUninit::&lt;Demo&gt;::uninit();\n<span class=\"hljs-comment\">// `&amp;uninit.as_mut().field` would create a reference to an uninitialized `bool`,</span>\n<span class=\"hljs-comment\">// and thus be Undefined Behavior!</span>\n<span class=\"hljs-keyword\">let</span> f1_ptr = <span class=\"hljs-keyword\">unsafe</span> { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };\n<span class=\"hljs-keyword\">unsafe</span> { f1_ptr.write(<span class=\"hljs-literal\">true</span>); }\n<span class=\"hljs-keyword\">let</span> init = <span class=\"hljs-keyword\">unsafe</span> { uninit.assume_init() };\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"the-dereference-operator\"><a class=\"header\" href=\"#the-dereference-operator\">The dereference operator</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>DereferenceExpression</em> :<br>\n&nbsp;&nbsp; <code class=\"hljs\">*</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>The <code class=\"hljs\">*</code> (dereference) operator is also a unary prefix operator.\nWhen applied to a <a href=\"../types/pointer.html\">pointer</a> it denotes the pointed-to location.\nIf the expression is of type <code class=\"hljs\">&amp;mut T</code> or <code class=\"hljs\">*mut T</code>, and is either a local variable, a (nested) field of a local variable or is a mutable <a href=\"../expressions.html#place-expressions-and-value-expressions\">place expression</a>, then the resulting memory location can be assigned to.\nDereferencing a raw pointer requires <code class=\"hljs\">unsafe</code>.</p>\n<p>On non-pointer types <code class=\"hljs\">*x</code> is equivalent to <code class=\"hljs\">*std::ops::Deref::deref(&amp;x)</code> in an <a href=\"../expressions.html#mutability\">immutable place expression context</a> and <code class=\"hljs\">*std::ops::DerefMut::deref_mut(&amp;mut x)</code> in a mutable place expression context.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = &amp;<span class=\"hljs-number\">7</span>;\n<span class=\"hljs-built_in\">assert_eq!</span>(*x, <span class=\"hljs-number\">7</span>);\n<span class=\"hljs-keyword\">let</span> y = &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-number\">9</span>;\n*y = <span class=\"hljs-number\">11</span>;\n<span class=\"hljs-built_in\">assert_eq!</span>(*y, <span class=\"hljs-number\">11</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"the-question-mark-operator\"><a class=\"header\" href=\"#the-question-mark-operator\">The question mark operator</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>ErrorPropagationExpression</em> :<br>\n&nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">?</code></p>\n</blockquote>\n<p>The question mark operator (<code class=\"hljs\">?</code>) unwraps valid values or returns erroneous values, propagating them to the calling function.\nIt is a unary postfix operator that can only be applied to the types <code class=\"hljs\">Result&lt;T, E&gt;</code> and <code class=\"hljs\">Option&lt;T&gt;</code>.</p>\n<p>When applied to values of the <code class=\"hljs\">Result&lt;T, E&gt;</code> type, it propagates errors.\nIf the value is <code class=\"hljs\">Err(e)</code>, then it will return <code class=\"hljs\">Err(From::from(e))</code> from the enclosing function or closure.\nIf applied to <code class=\"hljs\">Ok(x)</code>, then it will unwrap the value to evaluate to <code class=\"hljs\">x</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::num::ParseIntError;\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">try_to_parse</span></span>() -&gt; <span class=\"hljs-built_in\">Result</span>&lt;<span class=\"hljs-built_in\">i32</span>, ParseIntError&gt; {\n    <span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-string\">\"123\"</span>.parse()?; <span class=\"hljs-comment\">// x = 123</span>\n    <span class=\"hljs-keyword\">let</span> y: <span class=\"hljs-built_in\">i32</span> = <span class=\"hljs-string\">\"24a\"</span>.parse()?; <span class=\"hljs-comment\">// returns an Err() immediately</span>\n    <span class=\"hljs-literal\">Ok</span>(x + y)                    <span class=\"hljs-comment\">// Doesn't run.</span>\n}\n\n<span class=\"hljs-keyword\">let</span> res = try_to_parse();\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{:?}\"</span>, res);\n<span class=\"boring\"><span class=\"hljs-built_in\">assert!</span>(res.is_err())\n</span><span class=\"boring\">}</span></code></pre></pre>\n<p>When applied to values of the <code class=\"hljs\">Option&lt;T&gt;</code> type, it propagates <code class=\"hljs\">None</code>s.\nIf the value is <code class=\"hljs\">None</code>, then it will return <code class=\"hljs\">None</code>.\nIf applied to <code class=\"hljs\">Some(x)</code>, then it will unwrap the value to evaluate to <code class=\"hljs\">x</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">try_option_some</span></span>() -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">1</span>)?;\n    <span class=\"hljs-literal\">Some</span>(val)\n}\n<span class=\"hljs-built_in\">assert_eq!</span>(try_option_some(), <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-number\">1</span>));\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">try_option_none</span></span>() -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">u8</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-literal\">None</span>?;\n    <span class=\"hljs-literal\">Some</span>(val)\n}\n<span class=\"hljs-built_in\">assert_eq!</span>(try_option_none(), <span class=\"hljs-literal\">None</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p><code class=\"hljs\">?</code> cannot be overloaded.</p>\n<h2 id=\"negation-operators\"><a class=\"header\" href=\"#negation-operators\">Negation operators</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>NegationExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <code class=\"hljs\">-</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <code class=\"hljs\">!</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>These are the last two unary operators.\nThis table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types.\nRemember that signed integers are always represented using two's complement.\nThe operands of all of these operators are evaluated in <a href=\"../expressions.html#place-expressions-and-value-expressions\">value expression context</a> so are moved or copied.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Symbol</th><th>Integer</th><th><code class=\"hljs\">bool</code></th><th>Floating Point</th><th>Overloading Trait</th></tr></thead><tbody>\n<tr><td><code class=\"hljs\">-</code></td><td>Negation*</td><td></td><td>Negation</td><td><code class=\"hljs\">std::ops::Neg</code></td></tr>\n<tr><td><code class=\"hljs\">!</code></td><td>Bitwise NOT</td><td><a href=\"../types/boolean.html#logical-not\">Logical NOT</a></td><td></td><td><code class=\"hljs\">std::ops::Not</code></td></tr>\n</tbody></table>\n</div>\n<p>* Only for signed integer types.</p>\n<p>Here are some example of these operators</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">6</span>;\n<span class=\"hljs-built_in\">assert_eq!</span>(-x, -<span class=\"hljs-number\">6</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(!x, -<span class=\"hljs-number\">7</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-literal\">true</span>, !<span class=\"hljs-literal\">false</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"arithmetic-and-logical-binary-operators\"><a class=\"header\" href=\"#arithmetic-and-logical-binary-operators\">Arithmetic and Logical Binary Operators</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>ArithmeticOrLogicalExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">+</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">-</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">*</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">/</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">%</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&amp;</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">|</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">^</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&lt;&lt;</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&gt;&gt;</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>Binary operators expressions are all written with infix notation.\nThis table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types.\nRemember that signed integers are always represented using two's complement.\nThe operands of all of these operators are evaluated in <a href=\"../expressions.html#place-expressions-and-value-expressions\">value expression context</a> so are moved or copied.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Symbol</th><th>Integer</th><th><code class=\"hljs\">bool</code></th><th>Floating Point</th><th>Overloading Trait</th><th>Overloading Compound Assignment Trait</th></tr></thead><tbody>\n<tr><td><code class=\"hljs\">+</code></td><td>Addition</td><td></td><td>Addition</td><td><code class=\"hljs\">std::ops::Add</code></td><td><code class=\"hljs\">std::ops::AddAssign</code></td></tr>\n<tr><td><code class=\"hljs\">-</code></td><td>Subtraction</td><td></td><td>Subtraction</td><td><code class=\"hljs\">std::ops::Sub</code></td><td><code class=\"hljs\">std::ops::SubAssign</code></td></tr>\n<tr><td><code class=\"hljs\">*</code></td><td>Multiplication</td><td></td><td>Multiplication</td><td><code class=\"hljs\">std::ops::Mul</code></td><td><code class=\"hljs\">std::ops::MulAssign</code></td></tr>\n<tr><td><code class=\"hljs\">/</code></td><td>Division*†</td><td></td><td>Division</td><td><code class=\"hljs\">std::ops::Div</code></td><td><code class=\"hljs\">std::ops::DivAssign</code></td></tr>\n<tr><td><code class=\"hljs\">%</code></td><td>Remainder**†</td><td></td><td>Remainder</td><td><code class=\"hljs\">std::ops::Rem</code></td><td><code class=\"hljs\">std::ops::RemAssign</code></td></tr>\n<tr><td><code class=\"hljs\">&amp;</code></td><td>Bitwise AND</td><td><a href=\"../types/boolean.html#logical-and\">Logical AND</a></td><td></td><td><code class=\"hljs\">std::ops::BitAnd</code></td><td><code class=\"hljs\">std::ops::BitAndAssign</code></td></tr>\n<tr><td><code class=\"hljs\">|</code></td><td>Bitwise OR</td><td><a href=\"../types/boolean.html#logical-or\">Logical OR</a></td><td></td><td><code class=\"hljs\">std::ops::BitOr</code></td><td><code class=\"hljs\">std::ops::BitOrAssign</code></td></tr>\n<tr><td><code class=\"hljs\">^</code></td><td>Bitwise XOR</td><td><a href=\"../types/boolean.html#logical-xor\">Logical XOR</a></td><td></td><td><code class=\"hljs\">std::ops::BitXor</code></td><td><code class=\"hljs\">std::ops::BitXorAssign</code></td></tr>\n<tr><td><code class=\"hljs\">&lt;&lt;</code></td><td>Left Shift</td><td></td><td></td><td><code class=\"hljs\">std::ops::Shl</code></td><td><code class=\"hljs\">std::ops::ShlAssign</code></td></tr>\n<tr><td><code class=\"hljs\">&gt;&gt;</code></td><td>Right Shift***</td><td></td><td></td><td><code class=\"hljs\">std::ops::Shr</code></td><td><code class=\"hljs\">std::ops::ShrAssign</code></td></tr>\n</tbody></table>\n</div>\n<p>* Integer division rounds towards zero.</p>\n<p>** Rust uses a remainder defined with <a href=\"https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition\">truncating division</a>. Given <code class=\"hljs\">remainder = dividend % divisor</code>, the remainder will have the same sign as the dividend.</p>\n<p>*** Arithmetic right shift on signed integer types, logical right shift on\nunsigned integer types.</p>\n<p>† For integer types, division by zero panics.</p>\n<p>Here are examples of these operators being used.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5.5</span> - <span class=\"hljs-number\">1.25</span>, <span class=\"hljs-number\">4.25</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(-<span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">14</span>, -<span class=\"hljs-number\">70</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">14</span> / <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">100</span> % <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0b1010</span> &amp; <span class=\"hljs-number\">0b1100</span>, <span class=\"hljs-number\">0b1000</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0b1010</span> | <span class=\"hljs-number\">0b1100</span>, <span class=\"hljs-number\">0b1110</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">0b1010</span> ^ <span class=\"hljs-number\">0b1100</span>, <span class=\"hljs-number\">0b110</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">13</span> &lt;&lt; <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">104</span>);\n<span class=\"hljs-built_in\">assert_eq!</span>(-<span class=\"hljs-number\">10</span> &gt;&gt; <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">3</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"comparison-operators\"><a class=\"header\" href=\"#comparison-operators\">Comparison Operators</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>ComparisonExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">==</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">!=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&gt;</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&lt;</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&gt;=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&lt;=</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>Comparison operators are also defined both for primitive types and many types in the standard library.\nParentheses are required when chaining comparison operators. For example, the expression <code class=\"hljs\">a == b == c</code> is invalid and may be written as <code class=\"hljs\">(a == b) == c</code>.</p>\n<p>Unlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds.\nMany functions and macros in the standard library can then use that assumption (although not to ensure safety).\nUnlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in <a href=\"../expressions.html#place-expressions-and-value-expressions\">place expression context</a>:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">1</span>;\n</span>a == b;\n<span class=\"hljs-comment\">// is equivalent to</span>\n::std::cmp::<span class=\"hljs-built_in\">PartialEq</span>::eq(&amp;a, &amp;b);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>This means that the operands don't have to be moved out of.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Symbol</th><th>Meaning</th><th>Overloading method</th></tr></thead><tbody>\n<tr><td><code class=\"hljs\">==</code></td><td>Equal</td><td><code class=\"hljs\">std::cmp::PartialEq::eq</code></td></tr>\n<tr><td><code class=\"hljs\">!=</code></td><td>Not equal</td><td><code class=\"hljs\">std::cmp::PartialEq::ne</code></td></tr>\n<tr><td><code class=\"hljs\">&gt;</code></td><td>Greater than</td><td><code class=\"hljs\">std::cmp::PartialOrd::gt</code></td></tr>\n<tr><td><code class=\"hljs\">&lt;</code></td><td>Less than</td><td><code class=\"hljs\">std::cmp::PartialOrd::lt</code></td></tr>\n<tr><td><code class=\"hljs\">&gt;=</code></td><td>Greater than or equal to</td><td><code class=\"hljs\">std::cmp::PartialOrd::ge</code></td></tr>\n<tr><td><code class=\"hljs\">&lt;=</code></td><td>Less than or equal to</td><td><code class=\"hljs\">std::cmp::PartialOrd::le</code></td></tr>\n</tbody></table>\n</div>\n<p>Here are examples of the comparison operators being used.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-number\">123</span> == <span class=\"hljs-number\">123</span>);\n<span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-number\">23</span> != -<span class=\"hljs-number\">12</span>);\n<span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-number\">12.5</span> &gt; <span class=\"hljs-number\">12.2</span>);\n<span class=\"hljs-built_in\">assert!</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] &lt; [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]);\n<span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-string\">'A'</span> &lt;= <span class=\"hljs-string\">'B'</span>);\n<span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-string\">\"World\"</span> &gt;= <span class=\"hljs-string\">\"Hello\"</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"lazy-boolean-operators\"><a class=\"header\" href=\"#lazy-boolean-operators\">Lazy boolean operators</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>LazyBooleanExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">||</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&amp;&amp;</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>The operators <code class=\"hljs\">||</code> and <code class=\"hljs\">&amp;&amp;</code> may be applied to operands of boolean type.\nThe <code class=\"hljs\">||</code> operator denotes logical 'or', and the <code class=\"hljs\">&amp;&amp;</code> operator denotes logical 'and'.\nThey differ from <code class=\"hljs\">|</code> and <code class=\"hljs\">&amp;</code> in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression.\nThat is, <code class=\"hljs\">||</code> only evaluates its right-hand operand when the left-hand operand evaluates to <code class=\"hljs\">false</code>, and <code class=\"hljs\">&amp;&amp;</code> only when it evaluates to <code class=\"hljs\">true</code>.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-literal\">false</span> || <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-literal\">false</span> &amp;&amp; <span class=\"hljs-built_in\">panic!</span>(); <span class=\"hljs-comment\">// false, doesn't evaluate `panic!()`</span>\n<span class=\"boring\">}</span></code></pre></pre>\n<h2 id=\"type-cast-expressions\"><a class=\"header\" href=\"#type-cast-expressions\">Type cast expressions</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>TypeCastExpression</em> :<br>\n&nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">as</code> <a href=\"../types.html#type-expressions\"><em>TypeNoBounds</em></a></p>\n</blockquote>\n<p>A type cast expression is denoted with the binary operator <code class=\"hljs\">as</code>.</p>\n<p>Executing an <code class=\"hljs\">as</code> expression casts the value on the left-hand side to the type on the right-hand side.</p>\n<p>An example of an <code class=\"hljs\">as</code> expression:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">sum</span></span>(values: &amp;[<span class=\"hljs-built_in\">f64</span>]) -&gt; <span class=\"hljs-built_in\">f64</span> { <span class=\"hljs-number\">0.0</span> }\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">len</span></span>(values: &amp;[<span class=\"hljs-built_in\">f64</span>]) -&gt; <span class=\"hljs-built_in\">i32</span> { <span class=\"hljs-number\">0</span> }\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">average</span></span>(values: &amp;[<span class=\"hljs-built_in\">f64</span>]) -&gt; <span class=\"hljs-built_in\">f64</span> {\n    <span class=\"hljs-keyword\">let</span> sum: <span class=\"hljs-built_in\">f64</span> = sum(values);\n    <span class=\"hljs-keyword\">let</span> size: <span class=\"hljs-built_in\">f64</span> = len(values) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">f64</span>;\n    sum / size\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p><code class=\"hljs\">as</code> can be used to explicitly perform <a href=\"../type-coercions.html\">coercions</a>, as well as the following additional casts.\nAny cast that does not fit either a coercion rule or an entry in the table is a compiler error.\nHere <code class=\"hljs\">*T</code> means either <code class=\"hljs\">*const T</code> or <code class=\"hljs\">*mut T</code>. <code class=\"hljs\">m</code> stands for optional <code class=\"hljs\">mut</code> in\nreference types and <code class=\"hljs\">mut</code> or <code class=\"hljs\">const</code> in pointer types.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Type of <code class=\"hljs\">e</code></th><th><code class=\"hljs\">U</code></th><th>Cast performed by <code class=\"hljs\">e as U</code></th></tr></thead><tbody>\n<tr><td>Integer or Float type</td><td>Integer or Float type</td><td>Numeric cast</td></tr>\n<tr><td>Enumeration</td><td>Integer type</td><td>Enum cast</td></tr>\n<tr><td><code class=\"hljs\">bool</code> or <code class=\"hljs\">char</code></td><td>Integer type</td><td>Primitive to integer cast</td></tr>\n<tr><td><code class=\"hljs\">u8</code></td><td><code class=\"hljs\">char</code></td><td><code class=\"hljs\">u8</code> to <code class=\"hljs\">char</code> cast</td></tr>\n<tr><td><code class=\"hljs\">*T</code></td><td><code class=\"hljs\">*V</code> where <code class=\"hljs\">V: Sized</code> *</td><td>Pointer to pointer cast</td></tr>\n<tr><td><code class=\"hljs\">*T</code> where <code class=\"hljs\">T: Sized</code></td><td>Integer type</td><td>Pointer to address cast</td></tr>\n<tr><td>Integer type</td><td><code class=\"hljs\">*V</code> where <code class=\"hljs\">V: Sized</code></td><td>Address to pointer cast</td></tr>\n<tr><td><code class=\"hljs\">&amp;m₁ T</code></td><td><code class=\"hljs\">*m₂ T</code> **</td><td>Reference to pointer cast</td></tr>\n<tr><td><code class=\"hljs\">&amp;m₁ [T; n]</code></td><td><code class=\"hljs\">*m₂ T</code> **</td><td>Array to pointer cast</td></tr>\n<tr><td><a href=\"../types/function-item.html\">Function item</a></td><td><a href=\"../types/function-pointer.html\">Function pointer</a></td><td>Function item to function pointer cast</td></tr>\n<tr><td><a href=\"../types/function-item.html\">Function item</a></td><td><code class=\"hljs\">*V</code> where <code class=\"hljs\">V: Sized</code></td><td>Function item to pointer cast</td></tr>\n<tr><td><a href=\"../types/function-item.html\">Function item</a></td><td>Integer</td><td>Function item to address cast</td></tr>\n<tr><td><a href=\"../types/function-pointer.html\">Function pointer</a></td><td><code class=\"hljs\">*V</code> where <code class=\"hljs\">V: Sized</code></td><td>Function pointer to pointer cast</td></tr>\n<tr><td><a href=\"../types/function-pointer.html\">Function pointer</a></td><td>Integer</td><td>Function pointer to address cast</td></tr>\n<tr><td>Closure ***</td><td>Function pointer</td><td>Closure to function pointer cast</td></tr>\n</tbody></table>\n</div>\n<p>* or <code class=\"hljs\">T</code> and <code class=\"hljs\">V</code> are compatible unsized types, e.g., both slices, both the same trait object.</p>\n<p>** only when <code class=\"hljs\">m₁</code> is <code class=\"hljs\">mut</code> or <code class=\"hljs\">m₂</code> is <code class=\"hljs\">const</code>. Casting <code class=\"hljs\">mut</code> reference to\n<code class=\"hljs\">const</code> pointer is allowed.</p>\n<p>*** only for closures that do not capture (close over) any local variables</p>\n<h3 id=\"semantics\"><a class=\"header\" href=\"#semantics\">Semantics</a></h3>\n<h4 id=\"numeric-cast\"><a class=\"header\" href=\"#numeric-cast\">Numeric cast</a></h4>\n<ul>\n<li>Casting between two integers of the same size (e.g. i32 -&gt; u32) is a no-op\n(Rust uses 2's complement for negative values of fixed integers)</li>\n<li>Casting from a larger integer to a smaller integer (e.g. u32 -&gt; u8) will\ntruncate</li>\n<li>Casting from a smaller integer to a larger integer (e.g. u8 -&gt; u32) will\n<ul>\n<li>zero-extend if the source is unsigned</li>\n<li>sign-extend if the source is signed</li>\n</ul>\n</li>\n<li>Casting from a float to an integer will round the float towards zero\n<ul>\n<li><code class=\"hljs\">NaN</code> will return <code class=\"hljs\">0</code></li>\n<li>Values larger than the maximum integer value, including <code class=\"hljs\">INFINITY</code>, will saturate to the maximum value of the integer type.</li>\n<li>Values smaller than the minimum integer value, including <code class=\"hljs\">NEG_INFINITY</code>, will saturate to the minimum value of the integer type.</li>\n</ul>\n</li>\n<li>Casting from an integer to float will produce the closest possible float *\n<ul>\n<li>if necessary, rounding is according to <code class=\"hljs\">roundTiesToEven</code> mode ***</li>\n<li>on overflow, infinity (of the same sign as the input) is produced</li>\n<li>note: with the current set of numeric types, overflow can only happen\non <code class=\"hljs\">u128 as f32</code> for values greater or equal to <code class=\"hljs\">f32::MAX + (0.5 ULP)</code></li>\n</ul>\n</li>\n<li>Casting from an f32 to an f64 is perfect and lossless</li>\n<li>Casting from an f64 to an f32 will produce the closest possible f32 **\n<ul>\n<li>if necessary, rounding is according to <code class=\"hljs\">roundTiesToEven</code> mode ***</li>\n<li>on overflow, infinity (of the same sign as the input) is produced</li>\n</ul>\n</li>\n</ul>\n<p>* if integer-to-float casts with this rounding mode and overflow behavior are\nnot supported natively by the hardware, these casts will likely be slower than\nexpected.</p>\n<p>** if f64-to-f32 casts with this rounding mode and overflow behavior are not\nsupported natively by the hardware, these casts will likely be slower than\nexpected.</p>\n<p>*** as defined in IEEE 754-2008 §4.3.1: pick the nearest floating point\nnumber, preferring the one with an even least significant digit if exactly\nhalfway between two floating point numbers.</p>\n<h4 id=\"enum-cast\"><a class=\"header\" href=\"#enum-cast\">Enum cast</a></h4>\n<p>Casts an enum to its discriminant, then uses a numeric cast if needed.\nCasting is limited to the following kinds of enumerations:</p>\n<ul>\n<li><a href=\"../items/enumerations.html#unit-only-enum\">Unit-only enums</a></li>\n<li><a href=\"../items/enumerations.html#field-less-enum\">Field-less enums</a> without <a href=\"../items/enumerations.html#explicit-discriminants\">explicit discriminants</a>, or where only unit-variants have explicit discriminants</li>\n</ul>\n<h4 id=\"primitive-to-integer-cast\"><a class=\"header\" href=\"#primitive-to-integer-cast\">Primitive to integer cast</a></h4>\n<ul>\n<li><code class=\"hljs\">false</code> casts to <code class=\"hljs\">0</code>, <code class=\"hljs\">true</code> casts to <code class=\"hljs\">1</code></li>\n<li><code class=\"hljs\">char</code> casts to the value of the code point, then uses a numeric cast if needed.</li>\n</ul>\n<h4 id=\"u8-to-char-cast\"><a class=\"header\" href=\"#u8-to-char-cast\"><code>u8</code> to <code>char</code> cast</a></h4>\n<p>Casts to the <code class=\"hljs\">char</code> with the corresponding code point.</p>\n<h4 id=\"pointer-to-address-cast\"><a class=\"header\" href=\"#pointer-to-address-cast\">Pointer to address cast</a></h4>\n<p>Casting from a raw pointer to an integer produces the machine address of the referenced memory.\nIf the integer type is smaller than the pointer type, the address may be truncated; using <code class=\"hljs\">usize</code> avoids this.</p>\n<h4 id=\"address-to-pointer-cast\"><a class=\"header\" href=\"#address-to-pointer-cast\">Address to pointer cast</a></h4>\n<p>Casting from an integer to a raw pointer interprets the integer as a memory address and produces a pointer referencing that memory.</p>\n<div class=\"warning\">\n<p>Warning:\nThis interacts with the Rust memory model, which is still under development.\nA pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer.\nDereferencing such a pointer may be <a href=\"../behavior-considered-undefined.html\">undefined behavior</a> if aliasing rules are not followed.</p>\n</div>\n<p>A trivial example of sound address arithmetic:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> values: [<span class=\"hljs-built_in\">i32</span>; <span class=\"hljs-number\">2</span>] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">let</span> p1: *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span> = values.as_mut_ptr();\n<span class=\"hljs-keyword\">let</span> first_address = p1 <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">usize</span>;\n<span class=\"hljs-keyword\">let</span> second_address = first_address + <span class=\"hljs-number\">4</span>; <span class=\"hljs-comment\">// 4 == size_of::&lt;i32&gt;()</span>\n<span class=\"hljs-keyword\">let</span> p2 = second_address <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">i32</span>;\n<span class=\"hljs-keyword\">unsafe</span> {\n    *p2 += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"hljs-built_in\">assert_eq!</span>(values[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">3</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<h4 id=\"pointer-to-pointer-cast\"><a class=\"header\" href=\"#pointer-to-pointer-cast\">Pointer-to-pointer cast</a></h4>\n<p><code class=\"hljs\">*const T</code> / <code class=\"hljs\">*mut T</code> can be cast to <code class=\"hljs\">*const U</code> / <code class=\"hljs\">*mut U</code> with the following behavior:</p>\n<ul>\n<li>\n<p>If <code class=\"hljs\">T</code> and <code class=\"hljs\">U</code> are both sized, the pointer is returned unchanged.</p>\n</li>\n<li>\n<p>If <code class=\"hljs\">T</code> and <code class=\"hljs\">U</code> are both unsized, the pointer is also returned unchanged.\nIn particular, the metadata is preserved exactly.</p>\n<p>For instance, a cast from <code class=\"hljs\">*const [T]</code> to <code class=\"hljs\">*const [U]</code> preserves the number of elements.\nNote that, as a consequence, such casts do not necessarily preserve the size of the pointer's referent\n(e.g., casting <code class=\"hljs\">*const [u16]</code> to <code class=\"hljs\">*const [u8]</code> will result in a raw pointer which refers to an object of half the size of the original).\nThe same holds for <code class=\"hljs\">str</code> and any compound type whose unsized tail is a slice type,\nsuch as <code class=\"hljs\">struct Foo(i32, [u8])</code> or <code class=\"hljs\">(u64, Foo)</code>.</p>\n</li>\n<li>\n<p>If <code class=\"hljs\">T</code> is unsized and <code class=\"hljs\">U</code> is sized, the cast discards all metadata that completes the wide pointer <code class=\"hljs\">T</code> and produces a thin pointer <code class=\"hljs\">U</code> consisting of the data part of the unsized pointer.</p>\n</li>\n</ul>\n<h2 id=\"assignment-expressions\"><a class=\"header\" href=\"#assignment-expressions\">Assignment expressions</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>AssignmentExpression</em> :<br>\n&nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">=</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p>An <em>assignment expression</em> moves a value into a specified place.</p>\n<p>An assignment expression consists of a <a href=\"../expressions.html#mutability\">mutable</a> <a href=\"../expressions.html#place-expressions-and-value-expressions\">assignee expression</a>, the <em>assignee operand</em>, followed by an equals sign (<code class=\"hljs\">=</code>) and a <a href=\"../expressions.html#place-expressions-and-value-expressions\">value expression</a>, the <em>assigned value operand</em>.\nIn its most basic form, an assignee expression is a <a href=\"../expressions.html#place-expressions-and-value-expressions\">place expression</a>, and we discuss this case first.\nThe more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case.</p>\n<h3 id=\"basic-assignments\"><a class=\"header\" href=\"#basic-assignments\">Basic assignments</a></h3>\n<p>Evaluating assignment expressions begins by evaluating its operands.\nThe assigned value operand is evaluated first, followed by the assignee expression.\nFor destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right.</p>\n<blockquote>\n<p><strong>Note</strong>: This is different than other expressions in that the right operand is evaluated before the left one.</p>\n</blockquote>\n<p>It then has the effect of first <a href=\"../destructors.html\">dropping</a> the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable.\nNext it either <a href=\"../expressions.html#moved-and-copied-types\">copies or moves</a> the assigned value to the assigned place.</p>\n<p>An assignment expression always produces <a href=\"../types/tuple.html\">the unit value</a>.</p>\n<p>Example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">0</span>;\nx = y;\n<span class=\"boring\">}</span></code></pre></pre>\n<h3 id=\"destructuring-assignments\"><a class=\"header\" href=\"#destructuring-assignments\">Destructuring assignments</a></h3>\n<p>Destructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs.\nFor instance, we may swap two mutable variables:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> (<span class=\"hljs-keyword\">mut</span> a, <span class=\"hljs-keyword\">mut</span> b) = (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-comment\">// Swap `a` and `b` using destructuring assignment.</span>\n(b, a) = (a, b);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>In contrast to destructuring declarations using <code class=\"hljs\">let</code>, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities.\nInstead, a group of expressions that correspond to patterns are designated to be <a href=\"../expressions.html#place-expressions-and-value-expressions\">assignee expressions</a>, and permitted on the left-hand side of an assignment.\nAssignee expressions are then desugared to pattern matches followed by sequential assignment.\nThe desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice <code class=\"hljs\">[..]</code>, are permitted for destructuring assignment.</p>\n<p>The desugaring method is straightforward, and is illustrated best by example.</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Struct</span></span> { x: <span class=\"hljs-built_in\">u32</span>, y: <span class=\"hljs-built_in\">u32</span> }\n</span><span class=\"boring\"><span class=\"hljs-keyword\">let</span> (<span class=\"hljs-keyword\">mut</span> a, <span class=\"hljs-keyword\">mut</span> b) = (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n</span>(a, b) = (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);\n\n[a, b] = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n\nStruct { x: a, y: b } = Struct { x: <span class=\"hljs-number\">3</span>, y: <span class=\"hljs-number\">4</span>};\n\n<span class=\"hljs-comment\">// desugars to:</span>\n\n{\n    <span class=\"hljs-keyword\">let</span> (_a, _b) = (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);\n    a = _a;\n    b = _b;\n}\n\n{\n    <span class=\"hljs-keyword\">let</span> [_a, _b] = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n    a = _a;\n    b = _b;\n}\n\n{\n    <span class=\"hljs-keyword\">let</span> Struct { x: _a, y: _b } = Struct { x: <span class=\"hljs-number\">3</span>, y: <span class=\"hljs-number\">4</span>};\n    a = _a;\n    b = _b;\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Identifiers are not forbidden from being used multiple times in a single assignee expression.</p>\n<p><a href=\"./underscore-expr.html\">Underscore expressions</a> and empty <a href=\"./range-expr.html\">range expressions</a> may be used to ignore certain values, without binding them.</p>\n<p>Note that default binding modes do not apply for the desugared expression.</p>\n<h2 id=\"compound-assignment-expressions\"><a class=\"header\" href=\"#compound-assignment-expressions\">Compound assignment expressions</a></h2>\n<blockquote>\n<p><strong><sup>Syntax</sup></strong><br>\n<em>CompoundAssignmentExpression</em> :<br>\n&nbsp;&nbsp; &nbsp;&nbsp; <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">+=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">-=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">*=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">/=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">%=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&amp;=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">|=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">^=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&lt;&lt;=</code> <a href=\"../expressions.html\"><em>Expression</em></a><br>\n&nbsp;&nbsp; | <a href=\"../expressions.html\"><em>Expression</em></a> <code class=\"hljs\">&gt;&gt;=</code> <a href=\"../expressions.html\"><em>Expression</em></a></p>\n</blockquote>\n<p><em>Compound assignment expressions</em> combine arithmetic and logical binary operators with assignment expressions.</p>\n<p>For example:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> x = <span class=\"hljs-number\">5</span>;\nx += <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-built_in\">assert!</span>(x == <span class=\"hljs-number\">6</span>);\n<span class=\"boring\">}</span></code></pre></pre>\n<p>The syntax of compound assignment is a <a href=\"../expressions.html#mutability\">mutable</a> <a href=\"../expressions.html#place-expressions-and-value-expressions\">place expression</a>, the <em>assigned operand</em>, then one of the operators followed by an <code class=\"hljs\">=</code> as a single token (no whitespace), and then a <a href=\"../expressions.html#place-expressions-and-value-expressions\">value expression</a>, the <em>modifying operand</em>.</p>\n<p>Unlike other place operands, the assigned place operand must be a place expression.\nAttempting to use a value expression is a compiler error rather than promoting it to a temporary.</p>\n<p>Evaluation of compound assignment expressions depends on the types of the operators.</p>\n<p>If both types are primitives, then the modifying operand will be evaluated first followed by the assigned operand.\nIt will then set the value of the assigned operand's place to the value of performing the operation of the operator with the values of the assigned operand and modifying operand.</p>\n<blockquote>\n<p><strong>Note</strong>: This is different than other expressions in that the right operand is evaluated before the left one.</p>\n</blockquote>\n<p>Otherwise, this expression is syntactic sugar for calling the function of the overloading compound assignment trait of the operator (see the table earlier in this chapter).\nA mutable borrow of the assigned operand is automatically taken.</p>\n<p>For example, the following expression statements in <code class=\"hljs\">example</code> are equivalent:</p>\n<pre><pre class=\"playground\"><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-play play-button\" hidden=\"\" title=\"Run this code\" aria-label=\"Run this code\"></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust edition2021 hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-meta\">#![allow(unused)]</span>\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Addable</span></span>;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::ops::AddAssign;\n</span>\n<span class=\"hljs-keyword\">impl</span> AddAssign&lt;Addable&gt; <span class=\"hljs-keyword\">for</span> Addable {\n    <span class=\"hljs-comment\">/* */</span>\n<span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">add_assign</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, other: Addable) {}\n</span>}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">example</span></span>() {\n<span class=\"boring\"><span class=\"hljs-keyword\">let</span> (<span class=\"hljs-keyword\">mut</span> a1, a2) = (Addable, Addable);\n</span>  a1 += a2;\n\n<span class=\"boring\"><span class=\"hljs-keyword\">let</span> (<span class=\"hljs-keyword\">mut</span> a1, a2) = (Addable, Addable);\n</span>  AddAssign::add_assign(&amp;<span class=\"hljs-keyword\">mut</span> a1, a2);\n}\n<span class=\"boring\">}</span></code></pre></pre>\n<p>Like assignment expressions, compound assignment expressions always produce <a href=\"../types/tuple.html\">the unit value</a>.</p>\n<div class=\"warning\">\n<p>Warning: The evaluation order of operands swaps depending on the types of the operands:\nwith primitive types the right-hand side will get evaluated first, while with non-primitive types the left-hand side will get evaluated first.\nTry not to write code that depends on the evaluation order of operands in compound assignment expressions.\nSee <a href=\"https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs\">this test</a> for an example of using this dependency.</p>\n</div>\n<script>\n(function() {\n    var fragments = {\n        \"#slice-dst-pointer-to-pointer-cast\": \"operator-expr.html#pointer-to-pointer-cast\",\n    };\n    var target = fragments[window.location.hash];\n    if (target) {\n        var url = window.location.toString();\n        var base = url.substring(0, url.lastIndexOf('/'));\n        window.location.replace(base + \"/\" + target);\n    }\n})();\n</script>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"../expressions/block-expr.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"../expressions/grouped-expr.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"../expressions/block-expr.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"../expressions/grouped-expr.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"../elasticlunr.min.js\"></script>\n        <script src=\"../mark.min.js\"></script>\n        <script src=\"../searcher.js\"></script>\n\n        <script src=\"../clipboard.min.js\"></script>\n        <script src=\"../highlight.js\"></script>\n        <script src=\"../book.js\"></script>\n\n        <!-- Custom JS scripts -->\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:13:05.381Z"
}