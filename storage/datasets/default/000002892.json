{
	"title": "UnixDatagram in std::os::unix::net - Rust",
	"url": "https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html",
	"markdown": "# UnixDatagram in std::os::unix::net - Rust\n\n```\npub struct UnixDatagram(/* private fields */);\n```\n\nAvailable on **Unix** only.\n\nExpand description\n\nA Unix datagram socket.\n\n## [§](#examples)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let socket = UnixDatagram::bind(\"/path/to/my/socket\")?;\n    socket.send_to(b\"hello world\", \"/path/to/other/socket\")?;\n    let mut buf = [0; 100];\n    let (count, address) = socket.recv_from(&mut buf)?;\n    println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::bind(%22/path/to/my/socket%22)?;%0A++++socket.send_to(b%22hello+world%22,+%22/path/to/other/socket%22)?;%0A++++let+mut+buf+=+%5B0;+100%5D;%0A++++let+(count,+address)+=+socket.recv_from(%26mut+buf)?;%0A++++println!(%22socket+%7B:?%7D+sent+%7B:?%7D%22,+address,+%26buf%5B..count%5D);%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#77-933)[§](#impl-UnixDatagram)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#94-103)\n\nCreates a Unix datagram socket bound to the given path.\n\n##### [§](#examples-1)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nlet sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n    Ok(sock) => sock,\n    Err(e) => {\n        println!(\"Couldn't bind: {e:?}\");\n        return\n    }\n};\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::os::unix::net::UnixDatagram;%0A++++%0A++++let+sock+=+match+UnixDatagram::bind(%22/path/to/the/socket%22)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn%27t+bind:+%7Be:?%7D%22);%0A++++++++++++return%0A++++++++%7D%0A++++%7D;%0A%7D&edition=2021)\n\n1.70.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#127-137)\n\nCreates a Unix datagram socket bound to an address.\n\n##### [§](#examples-2)Examples\n\n```\nuse std::os::unix::net::{UnixDatagram};\n\nfn main() -> std::io::Result<()> {\n    let sock1 = UnixDatagram::bind(\"path/to/socket\")?;\n    let addr = sock1.local_addr()?;\n\n    let sock2 = match UnixDatagram::bind_addr(&addr) {\n        Ok(sock) => sock,\n        Err(err) => {\n            println!(\"Couldn't bind: {err:?}\");\n            return Err(err);\n        }\n    };\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::%7BUnixDatagram%7D;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock1+=+UnixDatagram::bind(%22path/to/socket%22)?;%0A++++let+addr+=+sock1.local_addr()?;%0A%0A++++let+sock2+=+match+UnixDatagram::bind_addr(%26addr)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(err)+=%3E+%7B%0A++++++++++++println!(%22Couldn%27t+bind:+%7Berr:?%7D%22);%0A++++++++++++return+Err(err);%0A++++++++%7D%0A++++%7D;%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#155-158)\n\nCreates a Unix Datagram socket which is not bound to any address.\n\n##### [§](#examples-3)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nlet sock = match UnixDatagram::unbound() {\n    Ok(sock) => sock,\n    Err(e) => {\n        println!(\"Couldn't unbound: {e:?}\");\n        return\n    }\n};\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::os::unix::net::UnixDatagram;%0A++++%0A++++let+sock+=+match+UnixDatagram::unbound()+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn%27t+unbound:+%7Be:?%7D%22);%0A++++++++++++return%0A++++++++%7D%0A++++%7D;%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#178-181)\n\nCreates an unnamed pair of connected sockets.\n\nReturns two `UnixDatagrams`s which are connected to each other.\n\n##### [§](#examples-4)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nlet (sock1, sock2) = match UnixDatagram::pair() {\n    Ok((sock1, sock2)) => (sock1, sock2),\n    Err(e) => {\n        println!(\"Couldn't unbound: {e:?}\");\n        return\n    }\n};\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::os::unix::net::UnixDatagram;%0A++++%0A++++let+(sock1,+sock2)+=+match+UnixDatagram::pair()+%7B%0A++++++++Ok((sock1,+sock2))+=%3E+(sock1,+sock2),%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn%27t+unbound:+%7Be:?%7D%22);%0A++++++++++++return%0A++++++++%7D%0A++++%7D;%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#210-217)\n\nConnects the socket to the specified path address.\n\nThe [`send`](about:blank/struct.UnixDatagram.html#method.send \"method std::os::unix::net::UnixDatagram::send\") method may be used to send data to the specified address. [`recv`](about:blank/struct.UnixDatagram.html#method.recv \"method std::os::unix::net::UnixDatagram::recv\") and [`recv_from`](about:blank/struct.UnixDatagram.html#method.recv_from \"method std::os::unix::net::UnixDatagram::recv_from\") will only receive data from that address.\n\n##### [§](#examples-5)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    match sock.connect(\"/path/to/the/socket\") {\n        Ok(sock) => sock,\n        Err(e) => {\n            println!(\"Couldn't connect: {e:?}\");\n            return Err(e)\n        }\n    };\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++match+sock.connect(%22/path/to/the/socket%22)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn%27t+connect:+%7Be:?%7D%22);%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++%7D;%0A++++Ok(())%0A%7D&edition=2021)\n\n1.70.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#242-251)\n\nConnects the socket to an address.\n\n##### [§](#examples-6)Examples\n\n```\nuse std::os::unix::net::{UnixDatagram};\n\nfn main() -> std::io::Result<()> {\n    let bound = UnixDatagram::bind(\"/path/to/socket\")?;\n    let addr = bound.local_addr()?;\n\n    let sock = UnixDatagram::unbound()?;\n    match sock.connect_addr(&addr) {\n        Ok(sock) => sock,\n        Err(e) => {\n            println!(\"Couldn't connect: {e:?}\");\n            return Err(e)\n        }\n    };\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::%7BUnixDatagram%7D;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+bound+=+UnixDatagram::bind(%22/path/to/socket%22)?;%0A++++let+addr+=+bound.local_addr()?;%0A%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++match+sock.connect_addr(%26addr)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn%27t+connect:+%7Be:?%7D%22);%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++%7D;%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#271-273)\n\nCreates a new independently owned handle to the underlying socket.\n\nThe returned `UnixDatagram` is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.\n\n##### [§](#examples-7)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n    let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::bind(%22/path/to/the/socket%22)?;%0A++++let+sock_copy+=+sock.try_clone().expect(%22try_clone+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#289-291)\n\nReturns the address of this socket.\n\n##### [§](#examples-8)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n    let addr = sock.local_addr().expect(\"Couldn't get local address\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::bind(%22/path/to/the/socket%22)?;%0A++++let+addr+=+sock.local_addr().expect(%22Couldn%27t+get+local+address%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#313-315)\n\nReturns the address of this socket’s peer.\n\nThe [`connect`](about:blank/struct.UnixDatagram.html#method.connect \"method std::os::unix::net::UnixDatagram::connect\") method will connect the socket to a peer.\n\n##### [§](#examples-9)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.connect(\"/path/to/the/socket\")?;\n\n    let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.connect(%22/path/to/the/socket%22)?;%0A%0A++++let+addr+=+sock.peer_addr().expect(%22Couldn%27t+get+peer+address%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#363-365)\n\nReceives data from the socket.\n\nOn success, returns the number of bytes read and the address from whence the data came.\n\n##### [§](#examples-10)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    let mut buf = vec![0; 10];\n    let (size, sender) = sock.recv_from(buf.as_mut_slice())?;\n    println!(\"received {size} bytes from {sender:?}\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+mut+buf+=+vec!%5B0;+10%5D;%0A++++let+(size,+sender)+=+sock.recv_from(buf.as_mut_slice())?;%0A++++println!(%22received+%7Bsize%7D+bytes+from+%7Bsender:?%7D%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#384-386)\n\nReceives data from the socket.\n\nOn success, returns the number of bytes read.\n\n##### [§](#examples-11)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n    let mut buf = vec![0; 10];\n    sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::bind(%22/path/to/the/socket%22)?;%0A++++let+mut+buf+=+vec!%5B0;+10%5D;%0A++++sock.recv(buf.as_mut_slice()).expect(%22recv+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#427-436)\n\n🔬This is a nightly-only experimental API. (`unix_socket_ancillary_data` [#76915](https://github.com/rust-lang/rust/issues/76915))\n\nReceives data and ancillary data from socket.\n\nOn success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.\n\n##### [§](#examples-12)Examples\n\n```\n#![feature(unix_socket_ancillary_data)]\nuse std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\nuse std::io::IoSliceMut;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    let mut buf1 = [1; 8];\n    let mut buf2 = [2; 16];\n    let mut buf3 = [3; 8];\n    let mut bufs = &mut [\n        IoSliceMut::new(&mut buf1),\n        IoSliceMut::new(&mut buf2),\n        IoSliceMut::new(&mut buf3),\n    ][..];\n    let mut fds = [0; 8];\n    let mut ancillary_buffer = [0; 128];\n    let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n    let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;\n    println!(\"received {size}\");\n    for ancillary_result in ancillary.messages() {\n        if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n            for fd in scm_rights {\n                println!(\"receive file descriptor: {fd}\");\n            }\n        }\n    }\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary,+AncillaryData%7D;%0Ause+std::io::IoSliceMut;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+mut+buf1+=+%5B1;+8%5D;%0A++++let+mut+buf2+=+%5B2;+16%5D;%0A++++let+mut+buf3+=+%5B3;+8%5D;%0A++++let+mut+bufs+=+%26mut+%5B%0A++++++++IoSliceMut::new(%26mut+buf1),%0A++++++++IoSliceMut::new(%26mut+buf2),%0A++++++++IoSliceMut::new(%26mut+buf3),%0A++++%5D%5B..%5D;%0A++++let+mut+fds+=+%5B0;+8%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++let+(size,+_truncated,+sender)+=+sock.recv_vectored_with_ancillary_from(bufs,+%26mut+ancillary)?;%0A++++println!(%22received+%7Bsize%7D%22);%0A++++for+ancillary_result+in+ancillary.messages()+%7B%0A++++++++if+let+AncillaryData::ScmRights(scm_rights)+=+ancillary_result.unwrap()+%7B%0A++++++++++++for+fd+in+scm_rights+%7B%0A++++++++++++++++println!(%22receive+file+descriptor:+%7Bfd%7D%22);%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#477-486)\n\n🔬This is a nightly-only experimental API. (`unix_socket_ancillary_data` [#76915](https://github.com/rust-lang/rust/issues/76915))\n\nReceives data and ancillary data from socket.\n\nOn success, returns the number of bytes read and if the data was truncated.\n\n##### [§](#examples-13)Examples\n\n```\n#![feature(unix_socket_ancillary_data)]\nuse std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\nuse std::io::IoSliceMut;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    let mut buf1 = [1; 8];\n    let mut buf2 = [2; 16];\n    let mut buf3 = [3; 8];\n    let mut bufs = &mut [\n        IoSliceMut::new(&mut buf1),\n        IoSliceMut::new(&mut buf2),\n        IoSliceMut::new(&mut buf3),\n    ][..];\n    let mut fds = [0; 8];\n    let mut ancillary_buffer = [0; 128];\n    let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n    let (size, _truncated) = sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n    println!(\"received {size}\");\n    for ancillary_result in ancillary.messages() {\n        if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n            for fd in scm_rights {\n                println!(\"receive file descriptor: {fd}\");\n            }\n        }\n    }\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary,+AncillaryData%7D;%0Ause+std::io::IoSliceMut;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+mut+buf1+=+%5B1;+8%5D;%0A++++let+mut+buf2+=+%5B2;+16%5D;%0A++++let+mut+buf3+=+%5B3;+8%5D;%0A++++let+mut+bufs+=+%26mut+%5B%0A++++++++IoSliceMut::new(%26mut+buf1),%0A++++++++IoSliceMut::new(%26mut+buf2),%0A++++++++IoSliceMut::new(%26mut+buf3),%0A++++%5D%5B..%5D;%0A++++let+mut+fds+=+%5B0;+8%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++let+(size,+_truncated)+=+sock.recv_vectored_with_ancillary(bufs,+%26mut+ancillary)?;%0A++++println!(%22received+%7Bsize%7D%22);%0A++++for+ancillary_result+in+ancillary.messages()+%7B%0A++++++++if+let+AncillaryData::ScmRights(scm_rights)+=+ancillary_result.unwrap()+%7B%0A++++++++++++for+fd+in+scm_rights+%7B%0A++++++++++++++++println!(%22receive+file+descriptor:+%7Bfd%7D%22);%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#504-518)\n\nSends data on the socket to the specified address.\n\nOn success, returns the number of bytes written.\n\n##### [§](#examples-14)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.send_to(b%22omelette+au+fromage%22,+%22/some/sock%22).expect(%22send_to+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.70.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#541-553)\n\nSends data on the socket to the specified [SocketAddr](struct.SocketAddr.html \"struct std::os::unix::net::SocketAddr\").\n\nOn success, returns the number of bytes written.\n\n##### [§](#examples-15)Examples\n\n```\nuse std::os::unix::net::{UnixDatagram};\n\nfn main() -> std::io::Result<()> {\n    let bound = UnixDatagram::bind(\"/path/to/socket\")?;\n    let addr = bound.local_addr()?;\n\n    let sock = UnixDatagram::unbound()?;\n    sock.send_to_addr(b\"bacon egg and cheese\", &addr).expect(\"send_to_addr function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::%7BUnixDatagram%7D;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+bound+=+UnixDatagram::bind(%22/path/to/socket%22)?;%0A++++let+addr+=+bound.local_addr()?;%0A%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.send_to_addr(b%22bacon+egg+and+cheese%22,+%26addr).expect(%22send_to_addr+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#575-577)\n\nSends data on the socket to the socket’s peer.\n\nThe peer address may be set by the `connect` method, and this method will return an error if the socket has not already been connected.\n\nOn success, returns the number of bytes written.\n\n##### [§](#examples-16)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n    sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.connect(%22/some/sock%22).expect(%22Couldn%27t+connect%22);%0A++++sock.send(b%22omelette+au+fromage%22).expect(%22send_to+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#612-619)\n\n🔬This is a nightly-only experimental API. (`unix_socket_ancillary_data` [#76915](https://github.com/rust-lang/rust/issues/76915))\n\nSends data and ancillary data on the socket to the specified address.\n\nOn success, returns the number of bytes written.\n\n##### [§](#examples-17)Examples\n\n```\n#![feature(unix_socket_ancillary_data)]\nuse std::os::unix::net::{UnixDatagram, SocketAncillary};\nuse std::io::IoSlice;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    let buf1 = [1; 8];\n    let buf2 = [2; 16];\n    let buf3 = [3; 8];\n    let bufs = &[\n        IoSlice::new(&buf1),\n        IoSlice::new(&buf2),\n        IoSlice::new(&buf3),\n    ][..];\n    let fds = [0, 1, 2];\n    let mut ancillary_buffer = [0; 128];\n    let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n    ancillary.add_fds(&fds[..]);\n    sock.send_vectored_with_ancillary_to(bufs, &mut ancillary, \"/some/sock\")\n        .expect(\"send_vectored_with_ancillary_to function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary%7D;%0Ause+std::io::IoSlice;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+buf1+=+%5B1;+8%5D;%0A++++let+buf2+=+%5B2;+16%5D;%0A++++let+buf3+=+%5B3;+8%5D;%0A++++let+bufs+=+%26%5B%0A++++++++IoSlice::new(%26buf1),%0A++++++++IoSlice::new(%26buf2),%0A++++++++IoSlice::new(%26buf3),%0A++++%5D%5B..%5D;%0A++++let+fds+=+%5B0,+1,+2%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++ancillary.add_fds(%26fds%5B..%5D);%0A++++sock.send_vectored_with_ancillary_to(bufs,+%26mut+ancillary,+%22/some/sock%22)%0A++++++++.expect(%22send_vectored_with_ancillary_to+function+failed%22);%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#654-660)\n\n🔬This is a nightly-only experimental API. (`unix_socket_ancillary_data` [#76915](https://github.com/rust-lang/rust/issues/76915))\n\nSends data and ancillary data on the socket.\n\nOn success, returns the number of bytes written.\n\n##### [§](#examples-18)Examples\n\n```\n#![feature(unix_socket_ancillary_data)]\nuse std::os::unix::net::{UnixDatagram, SocketAncillary};\nuse std::io::IoSlice;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    let buf1 = [1; 8];\n    let buf2 = [2; 16];\n    let buf3 = [3; 8];\n    let bufs = &[\n        IoSlice::new(&buf1),\n        IoSlice::new(&buf2),\n        IoSlice::new(&buf3),\n    ][..];\n    let fds = [0, 1, 2];\n    let mut ancillary_buffer = [0; 128];\n    let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n    ancillary.add_fds(&fds[..]);\n    sock.send_vectored_with_ancillary(bufs, &mut ancillary)\n        .expect(\"send_vectored_with_ancillary function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary%7D;%0Ause+std::io::IoSlice;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+buf1+=+%5B1;+8%5D;%0A++++let+buf2+=+%5B2;+16%5D;%0A++++let+buf3+=+%5B3;+8%5D;%0A++++let+bufs+=+%26%5B%0A++++++++IoSlice::new(%26buf1),%0A++++++++IoSlice::new(%26buf2),%0A++++++++IoSlice::new(%26buf3),%0A++++%5D%5B..%5D;%0A++++let+fds+=+%5B0,+1,+2%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++ancillary.add_fds(%26fds%5B..%5D);%0A++++sock.send_vectored_with_ancillary(bufs,+%26mut+ancillary)%0A++++++++.expect(%22send_vectored_with_ancillary+function+failed%22);%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#702-704)\n\nSets the read timeout for the socket.\n\nIf the provided value is [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"), then [`recv`](about:blank/struct.UnixDatagram.html#method.recv \"method std::os::unix::net::UnixDatagram::recv\") and [`recv_from`](about:blank/struct.UnixDatagram.html#method.recv_from \"method std::os::unix::net::UnixDatagram::recv_from\") calls will block indefinitely. An [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned if the zero [`Duration`](../../../time/struct.Duration.html \"struct std::time::Duration\") is passed to this method.\n\n##### [§](#examples-19)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\nuse std::time::Duration;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.set_read_timeout(Some(Duration::new(1, 0)))\n        .expect(\"set_read_timeout function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_read_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_read_timeout+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\nAn [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned if the zero [`Duration`](../../../time/struct.Duration.html \"struct std::time::Duration\") is passed to this method:\n\n```\nuse std::io;\nuse std::os::unix::net::UnixDatagram;\nuse std::time::Duration;\n\nfn main() -> std::io::Result<()> {\n    let socket = UnixDatagram::unbound()?;\n    let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n    let err = result.unwrap_err();\n    assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::unbound()?;%0A++++let+result+=+socket.set_read_timeout(Some(Duration::new(0,+0)));%0A++++let+err+=+result.unwrap_err();%0A++++assert_eq!(err.kind(),+io::ErrorKind::InvalidInput);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#746-748)\n\nSets the write timeout for the socket.\n\nIf the provided value is [`None`](about:blank/option/enum.Option.html#variant.None \"variant std::option::Option::None\"), then [`send`](about:blank/struct.UnixDatagram.html#method.send \"method std::os::unix::net::UnixDatagram::send\") and [`send_to`](about:blank/struct.UnixDatagram.html#method.send_to \"method std::os::unix::net::UnixDatagram::send_to\") calls will block indefinitely. An [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned if the zero [`Duration`](../../../time/struct.Duration.html \"struct std::time::Duration\") is passed to this method.\n\n##### [§](#examples-20)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\nuse std::time::Duration;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.set_write_timeout(Some(Duration::new(1, 0)))\n        .expect(\"set_write_timeout function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_write_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_write_timeout+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\nAn [`Err`](about:blank/result/enum.Result.html#variant.Err \"variant std::result::Result::Err\") is returned if the zero [`Duration`](../../../time/struct.Duration.html \"struct std::time::Duration\") is passed to this method:\n\n```\nuse std::io;\nuse std::os::unix::net::UnixDatagram;\nuse std::time::Duration;\n\nfn main() -> std::io::Result<()> {\n    let socket = UnixDatagram::unbound()?;\n    let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n    let err = result.unwrap_err();\n    assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::unbound()?;%0A++++let+result+=+socket.set_write_timeout(Some(Duration::new(0,+0)));%0A++++let+err+=+result.unwrap_err();%0A++++assert_eq!(err.kind(),+io::ErrorKind::InvalidInput);%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#767-769)\n\nReturns the read timeout of this socket.\n\n##### [§](#examples-21)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\nuse std::time::Duration;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.set_read_timeout(Some(Duration::new(1, 0)))\n        .expect(\"set_read_timeout function failed\");\n    assert_eq!(sock.read_timeout()?, Some(Duration::new(1, 0)));\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_read_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_read_timeout+function+failed%22);%0A++++assert_eq!(sock.read_timeout()?,+Some(Duration::new(1,+0)));%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#788-790)\n\nReturns the write timeout of this socket.\n\n##### [§](#examples-22)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\nuse std::time::Duration;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.set_write_timeout(Some(Duration::new(1, 0)))\n        .expect(\"set_write_timeout function failed\");\n    assert_eq!(sock.write_timeout()?, Some(Duration::new(1, 0)));\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_write_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_write_timeout+function+failed%22);%0A++++assert_eq!(sock.write_timeout()?,+Some(Duration::new(1,+0)));%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#806-808)\n\nMoves the socket into or out of nonblocking mode.\n\n##### [§](#examples-23)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_nonblocking(true).expect(%22set_nonblocking+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#831-833)\n\n🔬This is a nightly-only experimental API. (`unix_set_mark` [#96467](https://github.com/rust-lang/rust/issues/96467))\n\nSet the id of the socket for network filtering purpose\n\n```\n#![feature(unix_set_mark)]\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.set_mark(32)?;\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_set_mark)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_mark(32)?;%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#851-853)\n\nReturns the value of the `SO_ERROR` option.\n\n##### [§](#examples-24)Examples\n\n```\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    if let Ok(Some(err)) = sock.take_error() {\n        println!(\"Got error: {err:?}\");\n    }\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++if+let+Ok(Some(err))+=+sock.take_error()+%7B%0A++++++++println!(%22Got+error:+%7Berr:?%7D%22);%0A++++%7D%0A++++Ok(())%0A%7D&edition=2021)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#872-874)\n\nShut down the read, write, or both halves of this connection.\n\nThis function will cause all pending and future I/O calls on the specified portions to immediately return with an appropriate value (see the documentation of [`Shutdown`](../../../net/enum.Shutdown.html \"enum std::net::Shutdown\")).\n\n```\nuse std::os::unix::net::UnixDatagram;\nuse std::net::Shutdown;\n\nfn main() -> std::io::Result<()> {\n    let sock = UnixDatagram::unbound()?;\n    sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::net::Shutdown;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.shutdown(Shutdown::Both).expect(%22shutdown+function+failed%22);%0A++++Ok(())%0A%7D&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#898-900)\n\n🔬This is a nightly-only experimental API. (`unix_socket_peek` [#76923](https://github.com/rust-lang/rust/issues/76923))\n\nReceives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.\n\nSuccessive calls return the same data. This is accomplished by passing `MSG_PEEK` as a flag to the underlying `recv` system call.\n\n##### [§](#examples-25)Examples\n\n```\n#![feature(unix_socket_peek)]\n\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n    let mut buf = [0; 10];\n    let len = socket.peek(&mut buf).expect(\"peek failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_peek)%5D%0A%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::bind(%22/tmp/sock%22)?;%0A++++let+mut+buf+=+%5B0;+10%5D;%0A++++let+len+=+socket.peek(%26mut+buf).expect(%22peek+failed%22);%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#930-932)\n\n🔬This is a nightly-only experimental API. (`unix_socket_peek` [#76923](https://github.com/rust-lang/rust/issues/76923))\n\nReceives a single datagram message on the socket, without removing it from the queue. On success, returns the number of bytes read and the origin.\n\nThe function must be called with valid byte array `buf` of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.\n\nSuccessive calls return the same data. This is accomplished by passing `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n\nDo not use this function to implement busy waiting, instead use `libc::poll` to synchronize IO events on one or more sockets.\n\n##### [§](#examples-26)Examples\n\n```\n#![feature(unix_socket_peek)]\n\nuse std::os::unix::net::UnixDatagram;\n\nfn main() -> std::io::Result<()> {\n    let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n    let mut buf = [0; 10];\n    let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n    Ok(())\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_peek)%5D%0A%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::bind(%22/tmp/sock%22)?;%0A++++let+mut+buf+=+%5B0;+10%5D;%0A++++let+(len,+addr)+=+socket.peek_from(%26mut+buf).expect(%22peek+failed%22);%0A++++Ok(())%0A%7D&version=nightly&edition=2021)\n\n1.63.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#960-965)[§](#impl-AsFd-for-UnixDatagram)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#936-941)[§](#impl-AsRawFd-for-UnixDatagram)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#63-75)[§](#impl-Debug-for-UnixDatagram)\n\n1.63.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#977-982)[§](#impl-From%3COwnedFd%3E-for-UnixDatagram)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#979-981)[§](#method.from-1)\n\nConverts to this type from the input type.\n\n1.63.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#968-974)[§](#impl-From%3CUnixDatagram%3E-for-OwnedFd)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#944-949)[§](#impl-FromRawFd-for-UnixDatagram)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#946-948)[§](#method.from_raw_fd)\n\nConstructs a new instance of `Self` from the given raw file descriptor. [Read more](about:blank/fd/trait.FromRawFd.html#tymethod.from_raw_fd)\n\n1.10.0 · [source](about:blank/src/std/os/unix/net/datagram.rs.html#952-957)[§](#impl-IntoRawFd-for-UnixDatagram)\n\n[source](about:blank/src/std/os/unix/net/datagram.rs.html#954-956)[§](#method.into_raw_fd)\n\nConsumes this object, returning the raw underlying file descriptor. [Read more](about:blank/fd/trait.IntoRawFd.html#tymethod.into_raw_fd)\n\n[source](about:blank/src/std/os/net/linux_ext/socket.rs.html#44-52)[§](#impl-UnixSocketExt-for-UnixDatagram)\n\nAvailable on **Linux or Android** only.\n\n[source](about:blank/src/std/os/net/linux_ext/socket.rs.html#45-47)[§](#method.passcred)\n\n🔬This is a nightly-only experimental API. (`unix_socket_ancillary_data` [#76915](https://github.com/rust-lang/rust/issues/76915))\n\nAvailable on **Linux** only.\n\nQuery the current setting of socket option `SO_PASSCRED`.\n\n[source](about:blank/src/std/os/net/linux_ext/socket.rs.html#49-51)[§](#method.set_passcred)\n\n🔬This is a nightly-only experimental API. (`unix_socket_ancillary_data` [#76915](https://github.com/rust-lang/rust/issues/76915))\n\nAvailable on **Linux** only.\n\nEnable or disable socket option `SO_PASSCRED`. [Read more](about:blank/linux/net/trait.UnixSocketExt.html#tymethod.set_passcred)\n\n[§](#impl-Freeze-for-UnixDatagram)\n\n[§](#impl-RefUnwindSafe-for-UnixDatagram)\n\n[§](#impl-Send-for-UnixDatagram)\n\n[§](#impl-Sync-for-UnixDatagram)\n\n[§](#impl-Unpin-for-UnixDatagram)\n\n[§](#impl-UnwindSafe-for-UnixDatagram)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140)[§](#impl-Any-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208)[§](#impl-Borrow%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216)[§](#impl-BorrowMut%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765)[§](#impl-From%3CT%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768)[§](#method.from-2)\n\nReturns the argument unchanged.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750)[§](#impl-Into%3CU%3E-for-T)\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758)[§](#method.into)\n\nCalls `U::from(self)`.\n\nThat is, this conversion is whatever the implementation of `[From](../../../convert/trait.From.html \"trait std::convert::From\")<T> for U` chooses to do.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807)[§](#impl-TryFrom%3CU%3E-for-T)\n\n[§](#associatedtype.Error-1)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812)[§](#method.try_from)\n\nPerforms the conversion.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792)[§](#impl-TryInto%3CU%3E-for-T)\n\n[§](#associatedtype.Error)\n\nThe type returned in the event of a conversion error.\n\n[source](https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797)[§](#method.try_into)\n\nPerforms the conversion.",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A Unix datagram socket.\"><title>UnixDatagram in std::os::unix::net - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../../../\" data-static-root-path=\"../../../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc struct\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">UnixDatagram</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../../../std/index.html\"><img class=\"rust-logo\" src=\"../../../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">UnixDatagram</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#implementations\">Methods</a></h3><ul class=\"block method\"><li><a href=\"#method.bind\">bind</a></li><li><a href=\"#method.bind_addr\">bind_addr</a></li><li><a href=\"#method.connect\">connect</a></li><li><a href=\"#method.connect_addr\">connect_addr</a></li><li><a href=\"#method.local_addr\">local_addr</a></li><li><a href=\"#method.pair\">pair</a></li><li><a href=\"#method.peek\">peek</a></li><li><a href=\"#method.peek_from\">peek_from</a></li><li><a href=\"#method.peer_addr\">peer_addr</a></li><li><a href=\"#method.read_timeout\">read_timeout</a></li><li><a href=\"#method.recv\">recv</a></li><li><a href=\"#method.recv_from\">recv_from</a></li><li><a href=\"#method.recv_vectored_with_ancillary\">recv_vectored_with_ancillary</a></li><li><a href=\"#method.recv_vectored_with_ancillary_from\">recv_vectored_with_ancillary_from</a></li><li><a href=\"#method.send\">send</a></li><li><a href=\"#method.send_to\">send_to</a></li><li><a href=\"#method.send_to_addr\">send_to_addr</a></li><li><a href=\"#method.send_vectored_with_ancillary\">send_vectored_with_ancillary</a></li><li><a href=\"#method.send_vectored_with_ancillary_to\">send_vectored_with_ancillary_to</a></li><li><a href=\"#method.set_mark\">set_mark</a></li><li><a href=\"#method.set_nonblocking\">set_nonblocking</a></li><li><a href=\"#method.set_read_timeout\">set_read_timeout</a></li><li><a href=\"#method.set_write_timeout\">set_write_timeout</a></li><li><a href=\"#method.shutdown\">shutdown</a></li><li><a href=\"#method.take_error\">take_error</a></li><li><a href=\"#method.try_clone\">try_clone</a></li><li><a href=\"#method.unbound\">unbound</a></li><li><a href=\"#method.write_timeout\">write_timeout</a></li></ul><h3><a href=\"#trait-implementations\">Trait Implementations</a></h3><ul class=\"block trait-implementation\"><li><a href=\"#impl-AsFd-for-UnixDatagram\">AsFd</a></li><li><a href=\"#impl-AsRawFd-for-UnixDatagram\">AsRawFd</a></li><li><a href=\"#impl-Debug-for-UnixDatagram\">Debug</a></li><li><a href=\"#impl-From%3COwnedFd%3E-for-UnixDatagram\">From&lt;OwnedFd&gt;</a></li><li><a href=\"#impl-From%3CUnixDatagram%3E-for-OwnedFd\">From&lt;UnixDatagram&gt;</a></li><li><a href=\"#impl-FromRawFd-for-UnixDatagram\">FromRawFd</a></li><li><a href=\"#impl-IntoRawFd-for-UnixDatagram\">IntoRawFd</a></li><li><a href=\"#impl-UnixSocketExt-for-UnixDatagram\">UnixSocketExt</a></li></ul><h3><a href=\"#synthetic-implementations\">Auto Trait Implementations</a></h3><ul class=\"block synthetic-implementation\"><li><a href=\"#impl-Freeze-for-UnixDatagram\">Freeze</a></li><li><a href=\"#impl-RefUnwindSafe-for-UnixDatagram\">RefUnwindSafe</a></li><li><a href=\"#impl-Send-for-UnixDatagram\">Send</a></li><li><a href=\"#impl-Sync-for-UnixDatagram\">Sync</a></li><li><a href=\"#impl-Unpin-for-UnixDatagram\">Unpin</a></li><li><a href=\"#impl-UnwindSafe-for-UnixDatagram\">UnwindSafe</a></li></ul><h3><a href=\"#blanket-implementations\">Blanket Implementations</a></h3><ul class=\"block blanket-implementation\"><li><a href=\"#impl-Any-for-T\">Any</a></li><li><a href=\"#impl-Borrow%3CT%3E-for-T\">Borrow&lt;T&gt;</a></li><li><a href=\"#impl-BorrowMut%3CT%3E-for-T\">BorrowMut&lt;T&gt;</a></li><li><a href=\"#impl-From%3CT%3E-for-T\">From&lt;T&gt;</a></li><li><a href=\"#impl-Into%3CU%3E-for-T\">Into&lt;U&gt;</a></li><li><a href=\"#impl-TryFrom%3CU%3E-for-T\">TryFrom&lt;U&gt;</a></li><li><a href=\"#impl-TryInto%3CU%3E-for-T\">TryInto&lt;U&gt;</a></li></ul></section><h2><a href=\"index.html\">In std::os::unix::net</a></h2><h3><a href=\"index.html#structs\">Structs</a></h3><ul class=\"block struct\"><li><a href=\"struct.Incoming.html\">Incoming</a></li><li><a href=\"struct.Messages.html\">Messages</a></li><li><a href=\"struct.ScmCredentials.html\">ScmCredentials</a></li><li><a href=\"struct.ScmRights.html\">ScmRights</a></li><li><a href=\"struct.SocketAddr.html\">SocketAddr</a></li><li><a href=\"struct.SocketAncillary.html\">SocketAncillary</a></li><li><a href=\"struct.SocketCred.html\">SocketCred</a></li><li><a href=\"struct.UCred.html\">UCred</a></li><li><a href=\"struct.UnixDatagram.html\">UnixDatagram</a></li><li><a href=\"struct.UnixListener.html\">UnixListener</a></li><li><a href=\"struct.UnixStream.html\">UnixStream</a></li></ul><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.AncillaryData.html\">AncillaryData</a></li><li><a href=\"enum.AncillaryError.html\">AncillaryError</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Struct <a href=\"../../../index.html\">std</a>::<wbr><a href=\"../../index.html\">os</a>::<wbr><a href=\"../index.html\">unix</a>::<wbr><a href=\"index.html\">net</a>::<wbr><a class=\"struct\" href=\"#\">UnixDatagram</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#56\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub struct UnixDatagram(<span class=\"comment\">/* private fields */</span>);</code></pre><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Unix</strong> only.</div></span><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A Unix datagram socket.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>socket = UnixDatagram::bind(<span class=\"string\">\"/path/to/my/socket\"</span>)<span class=\"question-mark\">?</span>;\n    socket.send_to(<span class=\"string\">b\"hello world\"</span>, <span class=\"string\">\"/path/to/other/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = [<span class=\"number\">0</span>; <span class=\"number\">100</span>];\n    <span class=\"kw\">let </span>(count, address) = socket.recv_from(<span class=\"kw-2\">&amp;mut </span>buf)<span class=\"question-mark\">?</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"socket {:?} sent {:?}\"</span>, address, <span class=\"kw-2\">&amp;</span>buf[..count]);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::bind(%22/path/to/my/socket%22)?;%0A++++socket.send_to(b%22hello+world%22,+%22/path/to/other/socket%22)?;%0A++++let+mut+buf+=+%5B0;+100%5D;%0A++++let+(count,+address)+=+socket.recv_from(%26mut+buf)?;%0A++++println!(%22socket+%7B:?%7D+sent+%7B:?%7D%22,+address,+%26buf%5B..count%5D);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><h2 id=\"implementations\" class=\"section-header\">Implementations<a href=\"#implementations\" class=\"anchor\">§</a></h2><div id=\"implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-UnixDatagram\" class=\"impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#77-933\">source</a><a href=\"#impl-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bind\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#94-103\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.bind\" class=\"fn\">bind</a>&lt;P: <a class=\"trait\" href=\"../../../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"../../../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;&gt;(path: P) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a Unix datagram socket bound to the given path.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">let </span>sock = <span class=\"kw\">match </span>UnixDatagram::bind(<span class=\"string\">\"/path/to/the/socket\"</span>) {\n    <span class=\"prelude-val\">Ok</span>(sock) =&gt; sock,\n    <span class=\"prelude-val\">Err</span>(e) =&gt; {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Couldn't bind: {e:?}\"</span>);\n        <span class=\"kw\">return\n    </span>}\n};</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::os::unix::net::UnixDatagram;%0A++++%0A++++let+sock+=+match+UnixDatagram::bind(%22/path/to/the/socket%22)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn't+bind:+%7Be:?%7D%22);%0A++++++++++++return%0A++++++++%7D%0A++++%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.bind_addr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.70.0\">1.70.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#127-137\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.bind_addr\" class=\"fn\">bind_addr</a>(socket_addr: &amp;<a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a Unix datagram socket bound to an address.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram};\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock1 = UnixDatagram::bind(<span class=\"string\">\"path/to/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>addr = sock1.local_addr()<span class=\"question-mark\">?</span>;\n\n    <span class=\"kw\">let </span>sock2 = <span class=\"kw\">match </span>UnixDatagram::bind_addr(<span class=\"kw-2\">&amp;</span>addr) {\n        <span class=\"prelude-val\">Ok</span>(sock) =&gt; sock,\n        <span class=\"prelude-val\">Err</span>(err) =&gt; {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Couldn't bind: {err:?}\"</span>);\n            <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(err);\n        }\n    };\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::%7BUnixDatagram%7D;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock1+=+UnixDatagram::bind(%22path/to/socket%22)?;%0A++++let+addr+=+sock1.local_addr()?;%0A%0A++++let+sock2+=+match+UnixDatagram::bind_addr(%26addr)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(err)+=%3E+%7B%0A++++++++++++println!(%22Couldn't+bind:+%7Berr:?%7D%22);%0A++++++++++++return+Err(err);%0A++++++++%7D%0A++++%7D;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.unbound\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#155-158\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.unbound\" class=\"fn\">unbound</a>() -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a Unix Datagram socket which is not bound to any address.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">let </span>sock = <span class=\"kw\">match </span>UnixDatagram::unbound() {\n    <span class=\"prelude-val\">Ok</span>(sock) =&gt; sock,\n    <span class=\"prelude-val\">Err</span>(e) =&gt; {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Couldn't unbound: {e:?}\"</span>);\n        <span class=\"kw\">return\n    </span>}\n};</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::os::unix::net::UnixDatagram;%0A++++%0A++++let+sock+=+match+UnixDatagram::unbound()+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn't+unbound:+%7Be:?%7D%22);%0A++++++++++++return%0A++++++++%7D%0A++++%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.pair\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#178-181\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.pair\" class=\"fn\">pair</a>() -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;(<a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>, <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an unnamed pair of connected sockets.</p>\n<p>Returns two <code>UnixDatagrams</code>s which are connected to each other.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">let </span>(sock1, sock2) = <span class=\"kw\">match </span>UnixDatagram::pair() {\n    <span class=\"prelude-val\">Ok</span>((sock1, sock2)) =&gt; (sock1, sock2),\n    <span class=\"prelude-val\">Err</span>(e) =&gt; {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Couldn't unbound: {e:?}\"</span>);\n        <span class=\"kw\">return\n    </span>}\n};</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::os::unix::net::UnixDatagram;%0A++++%0A++++let+(sock1,+sock2)+=+match+UnixDatagram::pair()+%7B%0A++++++++Ok((sock1,+sock2))+=%3E+(sock1,+sock2),%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn't+unbound:+%7Be:?%7D%22);%0A++++++++++++return%0A++++++++%7D%0A++++%7D;%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.connect\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#210-217\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.connect\" class=\"fn\">connect</a>&lt;P: <a class=\"trait\" href=\"../../../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"../../../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;&gt;(&amp;self, path: P) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Connects the socket to the specified path address.</p>\n<p>The <a href=\"struct.UnixDatagram.html#method.send\" title=\"method std::os::unix::net::UnixDatagram::send\"><code>send</code></a> method may be used to send data to the specified address.\n<a href=\"struct.UnixDatagram.html#method.recv\" title=\"method std::os::unix::net::UnixDatagram::recv\"><code>recv</code></a> and <a href=\"struct.UnixDatagram.html#method.recv_from\" title=\"method std::os::unix::net::UnixDatagram::recv_from\"><code>recv_from</code></a> will only receive data from that address.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">match </span>sock.connect(<span class=\"string\">\"/path/to/the/socket\"</span>) {\n        <span class=\"prelude-val\">Ok</span>(sock) =&gt; sock,\n        <span class=\"prelude-val\">Err</span>(e) =&gt; {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Couldn't connect: {e:?}\"</span>);\n            <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(e)\n        }\n    };\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++match+sock.connect(%22/path/to/the/socket%22)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn't+connect:+%7Be:?%7D%22);%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++%7D;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.connect_addr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.70.0\">1.70.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#242-251\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.connect_addr\" class=\"fn\">connect_addr</a>(&amp;self, socket_addr: &amp;<a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Connects the socket to an address.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram};\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>bound = UnixDatagram::bind(<span class=\"string\">\"/path/to/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>addr = bound.local_addr()<span class=\"question-mark\">?</span>;\n\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">match </span>sock.connect_addr(<span class=\"kw-2\">&amp;</span>addr) {\n        <span class=\"prelude-val\">Ok</span>(sock) =&gt; sock,\n        <span class=\"prelude-val\">Err</span>(e) =&gt; {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Couldn't connect: {e:?}\"</span>);\n            <span class=\"kw\">return </span><span class=\"prelude-val\">Err</span>(e)\n        }\n    };\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::%7BUnixDatagram%7D;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+bound+=+UnixDatagram::bind(%22/path/to/socket%22)?;%0A++++let+addr+=+bound.local_addr()?;%0A%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++match+sock.connect_addr(%26addr)+%7B%0A++++++++Ok(sock)+=%3E+sock,%0A++++++++Err(e)+=%3E+%7B%0A++++++++++++println!(%22Couldn't+connect:+%7Be:?%7D%22);%0A++++++++++++return+Err(e)%0A++++++++%7D%0A++++%7D;%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_clone\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#271-273\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.try_clone\" class=\"fn\">try_clone</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new independently owned handle to the underlying socket.</p>\n<p>The returned <code>UnixDatagram</code> is a reference to the same socket that this\nobject references. Both handles can be used to accept incoming\nconnections and options set on one side will affect the other.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::bind(<span class=\"string\">\"/path/to/the/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>sock_copy = sock.try_clone().expect(<span class=\"string\">\"try_clone failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::bind(%22/path/to/the/socket%22)?;%0A++++let+sock_copy+=+sock.try_clone().expect(%22try_clone+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.local_addr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#289-291\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.local_addr\" class=\"fn\">local_addr</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the address of this socket.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::bind(<span class=\"string\">\"/path/to/the/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>addr = sock.local_addr().expect(<span class=\"string\">\"Couldn't get local address\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::bind(%22/path/to/the/socket%22)?;%0A++++let+addr+=+sock.local_addr().expect(%22Couldn't+get+local+address%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.peer_addr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#313-315\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.peer_addr\" class=\"fn\">peer_addr</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the address of this socket’s peer.</p>\n<p>The <a href=\"struct.UnixDatagram.html#method.connect\" title=\"method std::os::unix::net::UnixDatagram::connect\"><code>connect</code></a> method will connect the socket to a peer.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.connect(<span class=\"string\">\"/path/to/the/socket\"</span>)<span class=\"question-mark\">?</span>;\n\n    <span class=\"kw\">let </span>addr = sock.peer_addr().expect(<span class=\"string\">\"Couldn't get peer address\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.connect(%22/path/to/the/socket%22)?;%0A%0A++++let+addr+=+sock.peer_addr().expect(%22Couldn't+get+peer+address%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.recv_from\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#363-365\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.recv_from\" class=\"fn\">recv_from</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;(<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>, <a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Receives data from the socket.</p>\n<p>On success, returns the number of bytes read and the address from\nwhence the data came.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>];\n    <span class=\"kw\">let </span>(size, sender) = sock.recv_from(buf.as_mut_slice())<span class=\"question-mark\">?</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"received {size} bytes from {sender:?}\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+mut+buf+=+vec!%5B0;+10%5D;%0A++++let+(size,+sender)+=+sock.recv_from(buf.as_mut_slice())?;%0A++++println!(%22received+%7Bsize%7D+bytes+from+%7Bsender:?%7D%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.recv\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#384-386\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.recv\" class=\"fn\">recv</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Receives data from the socket.</p>\n<p>On success, returns the number of bytes read.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::bind(<span class=\"string\">\"/path/to/the/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>];\n    sock.recv(buf.as_mut_slice()).expect(<span class=\"string\">\"recv function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::bind(%22/path/to/the/socket%22)?;%0A++++let+mut+buf+=+vec!%5B0;+10%5D;%0A++++sock.recv(buf.as_mut_slice()).expect(%22recv+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.recv_vectored_with_ancillary_from\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#427-436\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.recv_vectored_with_ancillary_from\" class=\"fn\">recv_vectored_with_ancillary_from</a>(\n    &amp;self,\n    bufs: &amp;mut [<a class=\"struct\" href=\"../../../io/struct.IoSliceMut.html\" title=\"struct std::io::IoSliceMut\">IoSliceMut</a>&lt;'_&gt;],\n    ancillary: &amp;mut <a class=\"struct\" href=\"struct.SocketAncillary.html\" title=\"struct std::os::unix::net::SocketAncillary\">SocketAncillary</a>&lt;'_&gt;,\n) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;(<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"../../../primitive.bool.html\">bool</a>, <a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>)&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_ancillary_data</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76915\">#76915</a>)</span></div></span></summary><div class=\"docblock\"><p>Receives data and ancillary data from socket.</p>\n<p>On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_socket_ancillary_data)]\n</span><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n<span class=\"kw\">use </span>std::io::IoSliceMut;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf1 = [<span class=\"number\">1</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf2 = [<span class=\"number\">2</span>; <span class=\"number\">16</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf3 = [<span class=\"number\">3</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bufs = <span class=\"kw-2\">&amp;mut </span>[\n        IoSliceMut::new(<span class=\"kw-2\">&amp;mut </span>buf1),\n        IoSliceMut::new(<span class=\"kw-2\">&amp;mut </span>buf2),\n        IoSliceMut::new(<span class=\"kw-2\">&amp;mut </span>buf3),\n    ][..];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>fds = [<span class=\"number\">0</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary_buffer = [<span class=\"number\">0</span>; <span class=\"number\">128</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary = SocketAncillary::new(<span class=\"kw-2\">&amp;mut </span>ancillary_buffer[..]);\n    <span class=\"kw\">let </span>(size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, <span class=\"kw-2\">&amp;mut </span>ancillary)<span class=\"question-mark\">?</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"received {size}\"</span>);\n    <span class=\"kw\">for </span>ancillary_result <span class=\"kw\">in </span>ancillary.messages() {\n        <span class=\"kw\">if let </span>AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n            <span class=\"kw\">for </span>fd <span class=\"kw\">in </span>scm_rights {\n                <span class=\"macro\">println!</span>(<span class=\"string\">\"receive file descriptor: {fd}\"</span>);\n            }\n        }\n    }\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary,+AncillaryData%7D;%0Ause+std::io::IoSliceMut;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+mut+buf1+=+%5B1;+8%5D;%0A++++let+mut+buf2+=+%5B2;+16%5D;%0A++++let+mut+buf3+=+%5B3;+8%5D;%0A++++let+mut+bufs+=+%26mut+%5B%0A++++++++IoSliceMut::new(%26mut+buf1),%0A++++++++IoSliceMut::new(%26mut+buf2),%0A++++++++IoSliceMut::new(%26mut+buf3),%0A++++%5D%5B..%5D;%0A++++let+mut+fds+=+%5B0;+8%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++let+(size,+_truncated,+sender)+=+sock.recv_vectored_with_ancillary_from(bufs,+%26mut+ancillary)?;%0A++++println!(%22received+%7Bsize%7D%22);%0A++++for+ancillary_result+in+ancillary.messages()+%7B%0A++++++++if+let+AncillaryData::ScmRights(scm_rights)+=+ancillary_result.unwrap()+%7B%0A++++++++++++for+fd+in+scm_rights+%7B%0A++++++++++++++++println!(%22receive+file+descriptor:+%7Bfd%7D%22);%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.recv_vectored_with_ancillary\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#477-486\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.recv_vectored_with_ancillary\" class=\"fn\">recv_vectored_with_ancillary</a>(\n    &amp;self,\n    bufs: &amp;mut [<a class=\"struct\" href=\"../../../io/struct.IoSliceMut.html\" title=\"struct std::io::IoSliceMut\">IoSliceMut</a>&lt;'_&gt;],\n    ancillary: &amp;mut <a class=\"struct\" href=\"struct.SocketAncillary.html\" title=\"struct std::os::unix::net::SocketAncillary\">SocketAncillary</a>&lt;'_&gt;,\n) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;(<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"../../../primitive.bool.html\">bool</a>)&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_ancillary_data</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76915\">#76915</a>)</span></div></span></summary><div class=\"docblock\"><p>Receives data and ancillary data from socket.</p>\n<p>On success, returns the number of bytes read and if the data was truncated.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_socket_ancillary_data)]\n</span><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n<span class=\"kw\">use </span>std::io::IoSliceMut;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf1 = [<span class=\"number\">1</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf2 = [<span class=\"number\">2</span>; <span class=\"number\">16</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf3 = [<span class=\"number\">3</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bufs = <span class=\"kw-2\">&amp;mut </span>[\n        IoSliceMut::new(<span class=\"kw-2\">&amp;mut </span>buf1),\n        IoSliceMut::new(<span class=\"kw-2\">&amp;mut </span>buf2),\n        IoSliceMut::new(<span class=\"kw-2\">&amp;mut </span>buf3),\n    ][..];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>fds = [<span class=\"number\">0</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary_buffer = [<span class=\"number\">0</span>; <span class=\"number\">128</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary = SocketAncillary::new(<span class=\"kw-2\">&amp;mut </span>ancillary_buffer[..]);\n    <span class=\"kw\">let </span>(size, _truncated) = sock.recv_vectored_with_ancillary(bufs, <span class=\"kw-2\">&amp;mut </span>ancillary)<span class=\"question-mark\">?</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"received {size}\"</span>);\n    <span class=\"kw\">for </span>ancillary_result <span class=\"kw\">in </span>ancillary.messages() {\n        <span class=\"kw\">if let </span>AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n            <span class=\"kw\">for </span>fd <span class=\"kw\">in </span>scm_rights {\n                <span class=\"macro\">println!</span>(<span class=\"string\">\"receive file descriptor: {fd}\"</span>);\n            }\n        }\n    }\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary,+AncillaryData%7D;%0Ause+std::io::IoSliceMut;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+mut+buf1+=+%5B1;+8%5D;%0A++++let+mut+buf2+=+%5B2;+16%5D;%0A++++let+mut+buf3+=+%5B3;+8%5D;%0A++++let+mut+bufs+=+%26mut+%5B%0A++++++++IoSliceMut::new(%26mut+buf1),%0A++++++++IoSliceMut::new(%26mut+buf2),%0A++++++++IoSliceMut::new(%26mut+buf3),%0A++++%5D%5B..%5D;%0A++++let+mut+fds+=+%5B0;+8%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++let+(size,+_truncated)+=+sock.recv_vectored_with_ancillary(bufs,+%26mut+ancillary)?;%0A++++println!(%22received+%7Bsize%7D%22);%0A++++for+ancillary_result+in+ancillary.messages()+%7B%0A++++++++if+let+AncillaryData::ScmRights(scm_rights)+=+ancillary_result.unwrap()+%7B%0A++++++++++++for+fd+in+scm_rights+%7B%0A++++++++++++++++println!(%22receive+file+descriptor:+%7Bfd%7D%22);%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.send_to\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#504-518\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.send_to\" class=\"fn\">send_to</a>&lt;P: <a class=\"trait\" href=\"../../../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"../../../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;&gt;(&amp;self, buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>], path: P) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Sends data on the socket to the specified address.</p>\n<p>On success, returns the number of bytes written.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.send_to(<span class=\"string\">b\"omelette au fromage\"</span>, <span class=\"string\">\"/some/sock\"</span>).expect(<span class=\"string\">\"send_to function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.send_to(b%22omelette+au+fromage%22,+%22/some/sock%22).expect(%22send_to+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.send_to_addr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.70.0\">1.70.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#541-553\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.send_to_addr\" class=\"fn\">send_to_addr</a>(\n    &amp;self,\n    buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>],\n    socket_addr: &amp;<a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>,\n) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Sends data on the socket to the specified <a href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>.</p>\n<p>On success, returns the number of bytes written.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram};\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>bound = UnixDatagram::bind(<span class=\"string\">\"/path/to/socket\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>addr = bound.local_addr()<span class=\"question-mark\">?</span>;\n\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.send_to_addr(<span class=\"string\">b\"bacon egg and cheese\"</span>, <span class=\"kw-2\">&amp;</span>addr).expect(<span class=\"string\">\"send_to_addr function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::%7BUnixDatagram%7D;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+bound+=+UnixDatagram::bind(%22/path/to/socket%22)?;%0A++++let+addr+=+bound.local_addr()?;%0A%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.send_to_addr(b%22bacon+egg+and+cheese%22,+%26addr).expect(%22send_to_addr+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.send\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#575-577\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.send\" class=\"fn\">send</a>(&amp;self, buf: &amp;[<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Sends data on the socket to the socket’s peer.</p>\n<p>The peer address may be set by the <code>connect</code> method, and this method\nwill return an error if the socket has not already been connected.</p>\n<p>On success, returns the number of bytes written.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.connect(<span class=\"string\">\"/some/sock\"</span>).expect(<span class=\"string\">\"Couldn't connect\"</span>);\n    sock.send(<span class=\"string\">b\"omelette au fromage\"</span>).expect(<span class=\"string\">\"send_to function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.connect(%22/some/sock%22).expect(%22Couldn't+connect%22);%0A++++sock.send(b%22omelette+au+fromage%22).expect(%22send_to+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.send_vectored_with_ancillary_to\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#612-619\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.send_vectored_with_ancillary_to\" class=\"fn\">send_vectored_with_ancillary_to</a>&lt;P: <a class=\"trait\" href=\"../../../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\">AsRef</a>&lt;<a class=\"struct\" href=\"../../../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt;&gt;(\n    &amp;self,\n    bufs: &amp;[<a class=\"struct\" href=\"../../../io/struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a>&lt;'_&gt;],\n    ancillary: &amp;mut <a class=\"struct\" href=\"struct.SocketAncillary.html\" title=\"struct std::os::unix::net::SocketAncillary\">SocketAncillary</a>&lt;'_&gt;,\n    path: P,\n) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_ancillary_data</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76915\">#76915</a>)</span></div></span></summary><div class=\"docblock\"><p>Sends data and ancillary data on the socket to the specified address.</p>\n<p>On success, returns the number of bytes written.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_socket_ancillary_data)]\n</span><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram, SocketAncillary};\n<span class=\"kw\">use </span>std::io::IoSlice;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>buf1 = [<span class=\"number\">1</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span>buf2 = [<span class=\"number\">2</span>; <span class=\"number\">16</span>];\n    <span class=\"kw\">let </span>buf3 = [<span class=\"number\">3</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span>bufs = <span class=\"kw-2\">&amp;</span>[\n        IoSlice::new(<span class=\"kw-2\">&amp;</span>buf1),\n        IoSlice::new(<span class=\"kw-2\">&amp;</span>buf2),\n        IoSlice::new(<span class=\"kw-2\">&amp;</span>buf3),\n    ][..];\n    <span class=\"kw\">let </span>fds = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary_buffer = [<span class=\"number\">0</span>; <span class=\"number\">128</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary = SocketAncillary::new(<span class=\"kw-2\">&amp;mut </span>ancillary_buffer[..]);\n    ancillary.add_fds(<span class=\"kw-2\">&amp;</span>fds[..]);\n    sock.send_vectored_with_ancillary_to(bufs, <span class=\"kw-2\">&amp;mut </span>ancillary, <span class=\"string\">\"/some/sock\"</span>)\n        .expect(<span class=\"string\">\"send_vectored_with_ancillary_to function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary%7D;%0Ause+std::io::IoSlice;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+buf1+=+%5B1;+8%5D;%0A++++let+buf2+=+%5B2;+16%5D;%0A++++let+buf3+=+%5B3;+8%5D;%0A++++let+bufs+=+%26%5B%0A++++++++IoSlice::new(%26buf1),%0A++++++++IoSlice::new(%26buf2),%0A++++++++IoSlice::new(%26buf3),%0A++++%5D%5B..%5D;%0A++++let+fds+=+%5B0,+1,+2%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++ancillary.add_fds(%26fds%5B..%5D);%0A++++sock.send_vectored_with_ancillary_to(bufs,+%26mut+ancillary,+%22/some/sock%22)%0A++++++++.expect(%22send_vectored_with_ancillary_to+function+failed%22);%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.send_vectored_with_ancillary\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#654-660\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.send_vectored_with_ancillary\" class=\"fn\">send_vectored_with_ancillary</a>(\n    &amp;self,\n    bufs: &amp;[<a class=\"struct\" href=\"../../../io/struct.IoSlice.html\" title=\"struct std::io::IoSlice\">IoSlice</a>&lt;'_&gt;],\n    ancillary: &amp;mut <a class=\"struct\" href=\"struct.SocketAncillary.html\" title=\"struct std::os::unix::net::SocketAncillary\">SocketAncillary</a>&lt;'_&gt;,\n) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_ancillary_data</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76915\">#76915</a>)</span></div></span></summary><div class=\"docblock\"><p>Sends data and ancillary data on the socket.</p>\n<p>On success, returns the number of bytes written.</p>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_socket_ancillary_data)]\n</span><span class=\"kw\">use </span>std::os::unix::net::{UnixDatagram, SocketAncillary};\n<span class=\"kw\">use </span>std::io::IoSlice;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>buf1 = [<span class=\"number\">1</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span>buf2 = [<span class=\"number\">2</span>; <span class=\"number\">16</span>];\n    <span class=\"kw\">let </span>buf3 = [<span class=\"number\">3</span>; <span class=\"number\">8</span>];\n    <span class=\"kw\">let </span>bufs = <span class=\"kw-2\">&amp;</span>[\n        IoSlice::new(<span class=\"kw-2\">&amp;</span>buf1),\n        IoSlice::new(<span class=\"kw-2\">&amp;</span>buf2),\n        IoSlice::new(<span class=\"kw-2\">&amp;</span>buf3),\n    ][..];\n    <span class=\"kw\">let </span>fds = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary_buffer = [<span class=\"number\">0</span>; <span class=\"number\">128</span>];\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>ancillary = SocketAncillary::new(<span class=\"kw-2\">&amp;mut </span>ancillary_buffer[..]);\n    ancillary.add_fds(<span class=\"kw-2\">&amp;</span>fds[..]);\n    sock.send_vectored_with_ancillary(bufs, <span class=\"kw-2\">&amp;mut </span>ancillary)\n        .expect(<span class=\"string\">\"send_vectored_with_ancillary function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_ancillary_data)%5D%0Ause+std::os::unix::net::%7BUnixDatagram,+SocketAncillary%7D;%0Ause+std::io::IoSlice;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++let+buf1+=+%5B1;+8%5D;%0A++++let+buf2+=+%5B2;+16%5D;%0A++++let+buf3+=+%5B3;+8%5D;%0A++++let+bufs+=+%26%5B%0A++++++++IoSlice::new(%26buf1),%0A++++++++IoSlice::new(%26buf2),%0A++++++++IoSlice::new(%26buf3),%0A++++%5D%5B..%5D;%0A++++let+fds+=+%5B0,+1,+2%5D;%0A++++let+mut+ancillary_buffer+=+%5B0;+128%5D;%0A++++let+mut+ancillary+=+SocketAncillary::new(%26mut+ancillary_buffer%5B..%5D);%0A++++ancillary.add_fds(%26fds%5B..%5D);%0A++++sock.send_vectored_with_ancillary(bufs,+%26mut+ancillary)%0A++++++++.expect(%22send_vectored_with_ancillary+function+failed%22);%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set_read_timeout\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#702-704\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.set_read_timeout\" class=\"fn\">set_read_timeout</a>(&amp;self, timeout: <a class=\"enum\" href=\"../../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\">Duration</a>&gt;) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Sets the read timeout for the socket.</p>\n<p>If the provided value is <a href=\"../../../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, then <a href=\"struct.UnixDatagram.html#method.recv\" title=\"method std::os::unix::net::UnixDatagram::recv\"><code>recv</code></a> and <a href=\"struct.UnixDatagram.html#method.recv_from\" title=\"method std::os::unix::net::UnixDatagram::recv_from\"><code>recv_from</code></a> calls will\nblock indefinitely. An <a href=\"../../../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned if the zero <a href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\"><code>Duration</code></a>\nis passed to this method.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.set_read_timeout(<span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">1</span>, <span class=\"number\">0</span>)))\n        .expect(<span class=\"string\">\"set_read_timeout function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_read_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_read_timeout+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p>An <a href=\"../../../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned if the zero <a href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\"><code>Duration</code></a> is passed to this\nmethod:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>socket = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>result = socket.set_read_timeout(<span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>)));\n    <span class=\"kw\">let </span>err = result.unwrap_err();\n    <span class=\"macro\">assert_eq!</span>(err.kind(), io::ErrorKind::InvalidInput);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::unbound()?;%0A++++let+result+=+socket.set_read_timeout(Some(Duration::new(0,+0)));%0A++++let+err+=+result.unwrap_err();%0A++++assert_eq!(err.kind(),+io::ErrorKind::InvalidInput);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set_write_timeout\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#746-748\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.set_write_timeout\" class=\"fn\">set_write_timeout</a>(&amp;self, timeout: <a class=\"enum\" href=\"../../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\">Duration</a>&gt;) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Sets the write timeout for the socket.</p>\n<p>If the provided value is <a href=\"../../../option/enum.Option.html#variant.None\" title=\"variant std::option::Option::None\"><code>None</code></a>, then <a href=\"struct.UnixDatagram.html#method.send\" title=\"method std::os::unix::net::UnixDatagram::send\"><code>send</code></a> and <a href=\"struct.UnixDatagram.html#method.send_to\" title=\"method std::os::unix::net::UnixDatagram::send_to\"><code>send_to</code></a> calls will\nblock indefinitely. An <a href=\"../../../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned if the zero <a href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\"><code>Duration</code></a> is passed to this\nmethod.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.set_write_timeout(<span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">1</span>, <span class=\"number\">0</span>)))\n        .expect(<span class=\"string\">\"set_write_timeout function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_write_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_write_timeout+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n<p>An <a href=\"../../../result/enum.Result.html#variant.Err\" title=\"variant std::result::Result::Err\"><code>Err</code></a> is returned if the zero <a href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\"><code>Duration</code></a> is passed to this\nmethod:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::io;\n<span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>socket = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span>result = socket.set_write_timeout(<span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">0</span>, <span class=\"number\">0</span>)));\n    <span class=\"kw\">let </span>err = result.unwrap_err();\n    <span class=\"macro\">assert_eq!</span>(err.kind(), io::ErrorKind::InvalidInput);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::io;%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::unbound()?;%0A++++let+result+=+socket.set_write_timeout(Some(Duration::new(0,+0)));%0A++++let+err+=+result.unwrap_err();%0A++++assert_eq!(err.kind(),+io::ErrorKind::InvalidInput);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.read_timeout\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#767-769\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.read_timeout\" class=\"fn\">read_timeout</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"enum\" href=\"../../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\">Duration</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the read timeout of this socket.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.set_read_timeout(<span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">1</span>, <span class=\"number\">0</span>)))\n        .expect(<span class=\"string\">\"set_read_timeout function failed\"</span>);\n    <span class=\"macro\">assert_eq!</span>(sock.read_timeout()<span class=\"question-mark\">?</span>, <span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">1</span>, <span class=\"number\">0</span>)));\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_read_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_read_timeout+function+failed%22);%0A++++assert_eq!(sock.read_timeout()?,+Some(Duration::new(1,+0)));%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.write_timeout\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#788-790\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.write_timeout\" class=\"fn\">write_timeout</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"enum\" href=\"../../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"../../../time/struct.Duration.html\" title=\"struct std::time::Duration\">Duration</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the write timeout of this socket.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::time::Duration;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.set_write_timeout(<span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">1</span>, <span class=\"number\">0</span>)))\n        .expect(<span class=\"string\">\"set_write_timeout function failed\"</span>);\n    <span class=\"macro\">assert_eq!</span>(sock.write_timeout()<span class=\"question-mark\">?</span>, <span class=\"prelude-val\">Some</span>(Duration::new(<span class=\"number\">1</span>, <span class=\"number\">0</span>)));\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::time::Duration;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_write_timeout(Some(Duration::new(1,+0)))%0A++++++++.expect(%22set_write_timeout+function+failed%22);%0A++++assert_eq!(sock.write_timeout()?,+Some(Duration::new(1,+0)));%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set_nonblocking\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#806-808\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.set_nonblocking\" class=\"fn\">set_nonblocking</a>(&amp;self, nonblocking: <a class=\"primitive\" href=\"../../../primitive.bool.html\">bool</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Moves the socket into or out of nonblocking mode.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.set_nonblocking(<span class=\"bool-val\">true</span>).expect(<span class=\"string\">\"set_nonblocking function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_nonblocking(true).expect(%22set_nonblocking+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set_mark\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#831-833\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.set_mark\" class=\"fn\">set_mark</a>(&amp;self, mark: <a class=\"primitive\" href=\"../../../primitive.u32.html\">u32</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_set_mark</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/96467\">#96467</a>)</span></div></span></summary><div class=\"docblock\"><p>Set the id of the socket for network filtering purpose</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_set_mark)]\n</span><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.set_mark(<span class=\"number\">32</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_set_mark)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.set_mark(32)?;%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.take_error\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#851-853\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.take_error\" class=\"fn\">take_error</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"enum\" href=\"../../../option/enum.Option.html\" title=\"enum std::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"../../../io/struct.Error.html\" title=\"struct std::io::Error\">Error</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the value of the <code>SO_ERROR</code> option.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>(<span class=\"prelude-val\">Some</span>(err)) = sock.take_error() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"Got error: {err:?}\"</span>);\n    }\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++if+let+Ok(Some(err))+=+sock.take_error()+%7B%0A++++++++println!(%22Got+error:+%7Berr:?%7D%22);%0A++++%7D%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.shutdown\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#872-874\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.shutdown\" class=\"fn\">shutdown</a>(&amp;self, how: <a class=\"enum\" href=\"../../../net/enum.Shutdown.html\" title=\"enum std::net::Shutdown\">Shutdown</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Shut down the read, write, or both halves of this connection.</p>\n<p>This function will cause all pending and future I/O calls on the\nspecified portions to immediately return with an appropriate value\n(see the documentation of <a href=\"../../../net/enum.Shutdown.html\" title=\"enum std::net::Shutdown\"><code>Shutdown</code></a>).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n<span class=\"kw\">use </span>std::net::Shutdown;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>sock = UnixDatagram::unbound()<span class=\"question-mark\">?</span>;\n    sock.shutdown(Shutdown::Both).expect(<span class=\"string\">\"shutdown function failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::os::unix::net::UnixDatagram;%0Ause+std::net::Shutdown;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+sock+=+UnixDatagram::unbound()?;%0A++++sock.shutdown(Shutdown::Both).expect(%22shutdown+function+failed%22);%0A++++Ok(())%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.peek\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#898-900\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.peek\" class=\"fn\">peek</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_peek</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76923\">#76923</a>)</span></div></span></summary><div class=\"docblock\"><p>Receives data on the socket from the remote address to which it is\nconnected, without removing that data from the queue. On success,\nreturns the number of bytes peeked.</p>\n<p>Successive calls return the same data. This is accomplished by passing\n<code>MSG_PEEK</code> as a flag to the underlying <code>recv</code> system call.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_socket_peek)]\n\n</span><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>socket = UnixDatagram::bind(<span class=\"string\">\"/tmp/sock\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = [<span class=\"number\">0</span>; <span class=\"number\">10</span>];\n    <span class=\"kw\">let </span>len = socket.peek(<span class=\"kw-2\">&amp;mut </span>buf).expect(<span class=\"string\">\"peek failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_peek)%5D%0A%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::bind(%22/tmp/sock%22)?;%0A++++let+mut+buf+=+%5B0;+10%5D;%0A++++let+len+=+socket.peek(%26mut+buf).expect(%22peek+failed%22);%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.peek_from\" class=\"method\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#930-932\">source</a><h4 class=\"code-header\">pub fn <a href=\"#method.peek_from\" class=\"fn\">peek_from</a>(&amp;self, buf: &amp;mut [<a class=\"primitive\" href=\"../../../primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;(<a class=\"primitive\" href=\"../../../primitive.usize.html\">usize</a>, <a class=\"struct\" href=\"struct.SocketAddr.html\" title=\"struct std::os::unix::net::SocketAddr\">SocketAddr</a>)&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_peek</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76923\">#76923</a>)</span></div></span></summary><div class=\"docblock\"><p>Receives a single datagram message on the socket, without removing it from the\nqueue. On success, returns the number of bytes read and the origin.</p>\n<p>The function must be called with valid byte array <code>buf</code> of sufficient size to\nhold the message bytes. If a message is too long to fit in the supplied buffer,\nexcess bytes may be discarded.</p>\n<p>Successive calls return the same data. This is accomplished by passing\n<code>MSG_PEEK</code> as a flag to the underlying <code>recvfrom</code> system call.</p>\n<p>Do not use this function to implement busy waiting, instead use <code>libc::poll</code> to\nsynchronize IO events on one or more sockets.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(unix_socket_peek)]\n\n</span><span class=\"kw\">use </span>std::os::unix::net::UnixDatagram;\n\n<span class=\"kw\">fn </span>main() -&gt; std::io::Result&lt;()&gt; {\n    <span class=\"kw\">let </span>socket = UnixDatagram::bind(<span class=\"string\">\"/tmp/sock\"</span>)<span class=\"question-mark\">?</span>;\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = [<span class=\"number\">0</span>; <span class=\"number\">10</span>];\n    <span class=\"kw\">let </span>(len, addr) = socket.peek_from(<span class=\"kw-2\">&amp;mut </span>buf).expect(<span class=\"string\">\"peek failed\"</span>);\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(unix_socket_peek)%5D%0A%0Ause+std::os::unix::net::UnixDatagram;%0A%0Afn+main()+-%3E+std::io::Result%3C()%3E+%7B%0A++++let+socket+=+UnixDatagram::bind(%22/tmp/sock%22)?;%0A++++let+mut+buf+=+%5B0;+10%5D;%0A++++let+(len,+addr)+=+socket.peek_from(%26mut+buf).expect(%22peek+failed%22);%0A++++Ok(())%0A%7D&amp;version=nightly&amp;edition=2021\">Run</a></div>\n</div></details></div></details></div><h2 id=\"trait-implementations\" class=\"section-header\">Trait Implementations<a href=\"#trait-implementations\" class=\"anchor\">§</a></h2><div id=\"trait-implementations-list\"><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsFd-for-UnixDatagram\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#960-965\">source</a></span><a href=\"#impl-AsFd-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../fd/trait.AsFd.html\" title=\"trait std::os::fd::AsFd\">AsFd</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#962-964\">source</a><a href=\"#method.as_fd\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../fd/trait.AsFd.html#tymethod.as_fd\" class=\"fn\">as_fd</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../../fd/struct.BorrowedFd.html\" title=\"struct std::os::fd::BorrowedFd\">BorrowedFd</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\">Borrows the file descriptor. <a href=\"../../fd/trait.AsFd.html#tymethod.as_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-AsRawFd-for-UnixDatagram\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#936-941\">source</a></span><a href=\"#impl-AsRawFd-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../fd/trait.AsRawFd.html\" title=\"trait std::os::fd::AsRawFd\">AsRawFd</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.as_raw_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#938-940\">source</a><a href=\"#method.as_raw_fd\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../fd/trait.AsRawFd.html#tymethod.as_raw_fd\" class=\"fn\">as_raw_fd</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../fd/type.RawFd.html\" title=\"type std::os::fd::RawFd\">RawFd</a></h4></section></summary><div class=\"docblock\">Extracts the raw file descriptor. <a href=\"../../fd/trait.AsRawFd.html#tymethod.as_raw_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-Debug-for-UnixDatagram\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#63-75\">source</a></span><a href=\"#impl-Debug-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../fmt/trait.Debug.html\" title=\"trait std::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#64-74\">source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"../../../fmt/struct.Formatter.html\" title=\"struct std::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"../../../fmt/type.Result.html\" title=\"type std::fmt::Result\">Result</a></h4></section></summary><div class=\"docblock\">Formats the value using the given formatter. <a href=\"../../../fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3COwnedFd%3E-for-UnixDatagram\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#977-982\">source</a></span><a href=\"#impl-From%3COwnedFd%3E-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"../../fd/struct.OwnedFd.html\" title=\"struct std::os::fd::OwnedFd\">OwnedFd</a>&gt; for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-1\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#979-981\">source</a><a href=\"#method.from-1\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(owned: <a class=\"struct\" href=\"../../fd/struct.OwnedFd.html\" title=\"struct std::os::fd::OwnedFd\">OwnedFd</a>) -&gt; Self</h4></section></summary><div class=\"docblock\">Converts to this type from the input type.</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-From%3CUnixDatagram%3E-for-OwnedFd\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.63.0\">1.63.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#968-974\">source</a></span><a href=\"#impl-From%3CUnixDatagram%3E-for-OwnedFd\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;<a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>&gt; for <a class=\"struct\" href=\"../../fd/struct.OwnedFd.html\" title=\"struct std::os::fd::OwnedFd\">OwnedFd</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#971-973\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(unix_datagram: <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a>) -&gt; <a class=\"struct\" href=\"../../fd/struct.OwnedFd.html\" title=\"struct std::os::fd::OwnedFd\">OwnedFd</a></h4></section></summary><div class=\"docblock\"><p>Takes ownership of a <a href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\"><code>UnixDatagram</code></a>’s socket file descriptor.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-FromRawFd-for-UnixDatagram\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#944-949\">source</a></span><a href=\"#impl-FromRawFd-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../fd/trait.FromRawFd.html\" title=\"trait std::os::fd::FromRawFd\">FromRawFd</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from_raw_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#946-948\">source</a><a href=\"#method.from_raw_fd\" class=\"anchor\">§</a><h4 class=\"code-header\">unsafe fn <a href=\"../../fd/trait.FromRawFd.html#tymethod.from_raw_fd\" class=\"fn\">from_raw_fd</a>(fd: <a class=\"type\" href=\"../../fd/type.RawFd.html\" title=\"type std::os::fd::RawFd\">RawFd</a>) -&gt; <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h4></section></summary><div class=\"docblock\">Constructs a new instance of <code>Self</code> from the given raw file\ndescriptor. <a href=\"../../fd/trait.FromRawFd.html#tymethod.from_raw_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-IntoRawFd-for-UnixDatagram\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#952-957\">source</a></span><a href=\"#impl-IntoRawFd-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../fd/trait.IntoRawFd.html\" title=\"trait std::os::fd::IntoRawFd\">IntoRawFd</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into_raw_fd\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/unix/net/datagram.rs.html#954-956\">source</a><a href=\"#method.into_raw_fd\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../fd/trait.IntoRawFd.html#tymethod.into_raw_fd\" class=\"fn\">into_raw_fd</a>(self) -&gt; <a class=\"type\" href=\"../../fd/type.RawFd.html\" title=\"type std::os::fd::RawFd\">RawFd</a></h4></section></summary><div class=\"docblock\">Consumes this object, returning the raw underlying file descriptor. <a href=\"../../fd/trait.IntoRawFd.html#tymethod.into_raw_fd\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\" open=\"\"><summary><section id=\"impl-UnixSocketExt-for-UnixDatagram\" class=\"impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/net/linux_ext/socket.rs.html#44-52\">source</a><a href=\"#impl-UnixSocketExt-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../linux/net/trait.UnixSocketExt.html\" title=\"trait std::os::linux::net::UnixSocketExt\">UnixSocketExt</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3><span class=\"item-info\"><div class=\"stab portability\">Available on <strong>Linux or Android</strong> only.</div></span></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.passcred\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/net/linux_ext/socket.rs.html#45-47\">source</a><a href=\"#method.passcred\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../linux/net/trait.UnixSocketExt.html#tymethod.passcred\" class=\"fn\">passcred</a>(&amp;self) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.bool.html\">bool</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_ancillary_data</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76915\">#76915</a>)</span></div><div class=\"stab portability\">Available on <strong>Linux</strong> only.</div></span><div class=\"docblock\">Query the current setting of socket option <code>SO_PASSCRED</code>.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.set_passcred\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"../../../../src/std/os/net/linux_ext/socket.rs.html#49-51\">source</a><a href=\"#method.set_passcred\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../linux/net/trait.UnixSocketExt.html#tymethod.set_passcred\" class=\"fn\">set_passcred</a>(&amp;self, passcred: <a class=\"primitive\" href=\"../../../primitive.bool.html\">bool</a>) -&gt; <a class=\"type\" href=\"../../../io/type.Result.html\" title=\"type std::io::Result\">Result</a>&lt;<a class=\"primitive\" href=\"../../../primitive.unit.html\">()</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>unix_socket_ancillary_data</code>&nbsp;<a href=\"https://github.com/rust-lang/rust/issues/76915\">#76915</a>)</span></div><div class=\"stab portability\">Available on <strong>Linux</strong> only.</div></span><div class=\"docblock\">Enable or disable socket option <code>SO_PASSCRED</code>. <a href=\"../../linux/net/trait.UnixSocketExt.html#tymethod.set_passcred\">Read more</a></div></details></div></details></div><h2 id=\"synthetic-implementations\" class=\"section-header\">Auto Trait Implementations<a href=\"#synthetic-implementations\" class=\"anchor\">§</a></h2><div id=\"synthetic-implementations-list\"><section id=\"impl-Freeze-for-UnixDatagram\" class=\"impl\"><a href=\"#impl-Freeze-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../marker/trait.Freeze.html\" title=\"trait std::marker::Freeze\">Freeze</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section><section id=\"impl-RefUnwindSafe-for-UnixDatagram\" class=\"impl\"><a href=\"#impl-RefUnwindSafe-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../panic/trait.RefUnwindSafe.html\" title=\"trait std::panic::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section><section id=\"impl-Send-for-UnixDatagram\" class=\"impl\"><a href=\"#impl-Send-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../marker/trait.Send.html\" title=\"trait std::marker::Send\">Send</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section><section id=\"impl-Sync-for-UnixDatagram\" class=\"impl\"><a href=\"#impl-Sync-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../marker/trait.Sync.html\" title=\"trait std::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section><section id=\"impl-Unpin-for-UnixDatagram\" class=\"impl\"><a href=\"#impl-Unpin-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../marker/trait.Unpin.html\" title=\"trait std::marker::Unpin\">Unpin</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section><section id=\"impl-UnwindSafe-for-UnixDatagram\" class=\"impl\"><a href=\"#impl-UnwindSafe-for-UnixDatagram\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"../../../panic/trait.UnwindSafe.html\" title=\"trait std::panic::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"struct.UnixDatagram.html\" title=\"struct std::os::unix::net::UnixDatagram\">UnixDatagram</a></h3></section></div><h2 id=\"blanket-implementations\" class=\"section-header\">Blanket Implementations<a href=\"#blanket-implementations\" class=\"anchor\">§</a></h2><div id=\"blanket-implementations-list\"><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Any-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140\">source</a><a href=\"#impl-Any-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../any/trait.Any.html\" title=\"trait std::any::Any\">Any</a> for T<div class=\"where\">where\n    T: 'static + ?<a class=\"trait\" href=\"../../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.type_id\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141\">source</a><a href=\"#method.type_id\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../any/trait.Any.html#tymethod.type_id\" class=\"fn\">type_id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"../../../any/struct.TypeId.html\" title=\"struct std::any::TypeId\">TypeId</a></h4></section></summary><div class=\"docblock\">Gets the <code>TypeId</code> of <code>self</code>. <a href=\"../../../any/trait.Any.html#tymethod.type_id\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../borrow/trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210\">source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../borrow/trait.Borrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../../../primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\">Immutably borrows from an owned value. <a href=\"../../../borrow/trait.Borrow.html#tymethod.borrow\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-BorrowMut%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216\">source</a><a href=\"#impl-BorrowMut%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../borrow/trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\">BorrowMut</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../../../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217\">source</a><a href=\"#method.borrow_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../borrow/trait.BorrowMut.html#tymethod.borrow_mut\" class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"../../../primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\">Mutably borrows from an owned value. <a href=\"../../../borrow/trait.BorrowMut.html#tymethod.borrow_mut\">Read more</a></div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-From%3CT%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765\">source</a><a href=\"#impl-From%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for T</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.from-2\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768\">source</a><a href=\"#method.from-2\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Returns the argument unchanged.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-Into%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750\">source</a><a href=\"#impl-Into%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../../../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758\">source</a><a href=\"#method.into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../convert/trait.Into.html#tymethod.into\" class=\"fn\">into</a>(self) -&gt; U</h4></section></summary><div class=\"docblock\"><p>Calls <code>U::from(self)</code>.</p>\n<p>That is, this conversion is whatever the implementation of\n<code><a href=\"../../../convert/trait.From.html\" title=\"trait std::convert::From\">From</a>&lt;T&gt; for U</code> chooses to do.</p>\n</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryFrom%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807\">source</a><a href=\"#impl-TryFrom%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../../../convert/trait.Into.html\" title=\"trait std::convert::Into\">Into</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error-1\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error-1\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../../../convert/trait.TryFrom.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = <a class=\"enum\" href=\"../../../convert/enum.Infallible.html\" title=\"enum std::convert::Infallible\">Infallible</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812\">source</a><a href=\"#method.try_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../convert/trait.TryFrom.html#tymethod.try_from\" class=\"fn\">try_from</a>(value: U) -&gt; <a class=\"enum\" href=\"../../../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;T, &lt;T as <a class=\"trait\" href=\"../../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;U&gt;&gt;::<a class=\"associatedtype\" href=\"../../../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details><details class=\"toggle implementors-toggle\"><summary><section id=\"impl-TryInto%3CU%3E-for-T\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792\">source</a><a href=\"#impl-TryInto%3CU%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"../../../convert/trait.TryInto.html\" title=\"trait std::convert::TryInto\">TryInto</a>&lt;U&gt; for T<div class=\"where\">where\n    U: <a class=\"trait\" href=\"../../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open=\"\"><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"../../../convert/trait.TryInto.html#associatedtype.Error\" class=\"associatedtype\">Error</a> = &lt;U as <a class=\"trait\" href=\"../../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../../../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a></h4></section></summary><div class=\"docblock\">The type returned in the event of a conversion error.</div></details><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"method.try_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797\">source</a><a href=\"#method.try_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"../../../convert/trait.TryInto.html#tymethod.try_into\" class=\"fn\">try_into</a>(self) -&gt; <a class=\"enum\" href=\"../../../result/enum.Result.html\" title=\"enum std::result::Result\">Result</a>&lt;U, &lt;U as <a class=\"trait\" href=\"../../../convert/trait.TryFrom.html\" title=\"trait std::convert::TryFrom\">TryFrom</a>&lt;T&gt;&gt;::<a class=\"associatedtype\" href=\"../../../convert/trait.TryFrom.html#associatedtype.Error\" title=\"type std::convert::TryFrom::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\">Performs the conversion.</div></details></div></details></div></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:26:20.273Z"
}