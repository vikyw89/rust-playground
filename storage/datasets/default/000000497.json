{
	"title": "Borrow in std::borrow - Rust",
	"url": "https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html",
	"markdown": "# Borrow in std::borrow - Rust\n\n```\npub trait Borrow<Borrowed>where\n    Borrowed: ?Sized,{\n    // Required method\n    fn borrow(&self) -> &Borrowed;\n}\n```\n\nExpand description\n\nA trait for borrowing data.\n\nIn Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as [`Box<T>`](../../std/boxed/struct.Box.html) or [`Rc<T>`](../../std/rc/struct.Rc.html). Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is [`String`](../../std/string/struct.String.html) which adds the ability to extend a string to the basic [`str`](../primitive.str.html \"primitive str\"). This requires keeping additional information unnecessary for a simple, immutable string.\n\nThese types provide access to the underlying data through references to the type of that data. They are said to be ‘borrowed as’ that type. For instance, a [`Box<T>`](../../std/boxed/struct.Box.html) can be borrowed as `T` while a [`String`](../../std/string/struct.String.html) can be borrowed as `str`.\n\nTypes express that they can be borrowed as some type `T` by implementing `Borrow<T>`, providing a reference to a `T` in the trait’s [`borrow`](about:blank/trait.Borrow.html#tymethod.borrow \"method std::borrow::Borrow::borrow\") method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type, allowing the underlying data to be modified, it can additionally implement [`BorrowMut<T>`](trait.BorrowMut.html \"trait std::borrow::BorrowMut\").\n\nFurther, when providing implementations for additional traits, it needs to be considered whether they should behave identically to those of the underlying type as a consequence of acting as a representation of that underlying type. Generic code typically uses `Borrow<T>` when it relies on the identical behavior of these additional trait implementations. These traits will likely appear as additional trait bounds.\n\nIn particular `Eq`, `Ord` and `Hash` must be equivalent for borrowed and owned values: `x.borrow() == y.borrow()` should give the same result as `x == y`.\n\nIf generic code merely needs to work for all types that can provide a reference to related type `T`, it is often better to use [`AsRef<T>`](../convert/trait.AsRef.html \"trait std::convert::AsRef\") as more types can safely implement it.\n\n## [§](#examples)Examples\n\nAs a data collection, [`HashMap<K, V>`](../../std/collections/struct.HashMap.html) owns both keys and values. If the key’s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key’s data. For instance, if the key is a string, then it is likely stored with the hash map as a [`String`](../../std/string/struct.String.html), while it should be possible to search using a [`&str`](../primitive.str.html \"primitive str\"). Thus, `insert` needs to operate on a `String` while `get` needs to be able to use a `&str`.\n\nSlightly simplified, the relevant parts of `HashMap<K, V>` look like this:\n\n```\nuse std::borrow::Borrow;\nuse std::hash::Hash;\n\npub struct HashMap<K, V> {\n    // fields omitted\n}\n\nimpl<K, V> HashMap<K, V> {\n    pub fn insert(&self, key: K, value: V) -> Option<V>\n    where K: Hash + Eq\n    {\n        // ...\n    }\n\n    pub fn get<Q>(&self, k: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized\n    {\n        // ...\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Borrow;%0A++++use+std::hash::Hash;%0A++++%0A++++pub+struct+HashMap%3CK,+V%3E+%7B%0A++++marker:+::std::marker::PhantomData%3C(K,+V)%3E,%0A++++++++//+fields+omitted%0A++++%7D%0A++++%0A++++impl%3CK,+V%3E+HashMap%3CK,+V%3E+%7B%0A++++++++pub+fn+insert(%26self,+key:+K,+value:+V)+-%3E+Option%3CV%3E%0A++++++++where+K:+Hash+%2B+Eq%0A++++++++%7B%0A++++unimplemented!()%0A++++++++++++//+...%0A++++++++%7D%0A++++%0A++++++++pub+fn+get%3CQ%3E(%26self,+k:+%26Q)+-%3E+Option%3C%26V%3E%0A++++++++where%0A++++++++++++K:+Borrow%3CQ%3E,%0A++++++++++++Q:+Hash+%2B+Eq+%2B+?Sized%0A++++++++%7B%0A++++unimplemented!()%0A++++++++++++//+...%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nThe entire hash map is generic over a key type `K`. Because these keys are stored with the hash map, this type has to own the key’s data. When inserting a key-value pair, the map is given such a `K` and needs to find the correct hash bucket and check if the key is already present based on that `K`. It therefore requires `K: Hash + Eq`.\n\nWhen searching for a value in the map, however, having to provide a reference to a `K` as the key to search for would require to always create such an owned value. For string keys, this would mean a `String` value needs to be created just for the search for cases where only a `str` is available.\n\nInstead, the `get` method is generic over the type of the underlying key data, called `Q` in the method signature above. It states that `K` borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q` have implementations of the `Hash` and `Eq` traits that produce identical results.\n\nThe implementation of `get` relies in particular on identical implementations of `Hash` by determining the key’s hash bucket by calling `Hash::hash` on the `Q` value even though it inserted the key based on the hash value calculated from the `K` value.\n\nAs a consequence, the hash map breaks if a `K` wrapping a `Q` value produces a different hash than `Q`. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:\n\n```\npub struct CaseInsensitiveString(String);\n\nimpl PartialEq for CaseInsensitiveString {\n    fn eq(&self, other: &Self) -> bool {\n        self.0.eq_ignore_ascii_case(&other.0)\n    }\n}\n\nimpl Eq for CaseInsensitiveString { }\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++pub+struct+CaseInsensitiveString(String);%0A++++%0A++++impl+PartialEq+for+CaseInsensitiveString+%7B%0A++++++++fn+eq(%26self,+other:+%26Self)+-%3E+bool+%7B%0A++++++++++++self.0.eq_ignore_ascii_case(%26other.0)%0A++++++++%7D%0A++++%7D%0A++++%0A++++impl+Eq+for+CaseInsensitiveString+%7B+%7D%0A%7D&edition=2021)\n\nBecause two equal values need to produce the same hash value, the implementation of `Hash` needs to ignore ASCII case, too:\n\n```\nimpl Hash for CaseInsensitiveString {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        for c in self.0.as_bytes() {\n            c.to_ascii_lowercase().hash(state)\n        }\n    }\n}\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::hash::%7BHash,+Hasher%7D;%0A++++pub+struct+CaseInsensitiveString(String);%0A++++impl+Hash+for+CaseInsensitiveString+%7B%0A++++++++fn+hash%3CH:+Hasher%3E(%26self,+state:+%26mut+H)+%7B%0A++++++++++++for+c+in+self.0.as_bytes()+%7B%0A++++++++++++++++c.to_ascii_lowercase().hash(state)%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D&edition=2021)\n\nCan `CaseInsensitiveString` implement `Borrow<str>`? It certainly can provide a reference to a string slice via its contained owned string. But because its `Hash` implementation differs, it behaves differently from `str` and therefore must not, in fact, implement `Borrow<str>`. If it wants to allow others access to the underlying `str`, it can do that via `AsRef<str>` which doesn’t carry any extra requirements.\n\n1.0.0 · [source](https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#178)\n\nImmutably borrows from an owned value.\n\n##### [§](#examples-1)Examples\n\n```\nuse std::borrow::Borrow;\n\nfn check<T: Borrow<str>>(s: T) {\n    assert_eq!(\"Hello\", s.borrow());\n}\n\nlet s = \"Hello\".to_string();\n\ncheck(s);\n\nlet s = \"Hello\";\n\ncheck(s);\n```\n\n[Run](https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Borrow;%0A++++%0A++++fn+check%3CT:+Borrow%3Cstr%3E%3E(s:+T)+%7B%0A++++++++assert_eq!(%22Hello%22,+s.borrow());%0A++++%7D%0A++++%0A++++let+s+=+%22Hello%22.to_string();%0A++++%0A++++check(s);%0A++++%0A++++let+s+=+%22Hello%22;%0A++++%0A++++check(s);%0A%7D&edition=2021)",
	"html": "<!DOCTYPE html><html lang=\"en\" data-theme=\"light\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"generator\" content=\"rustdoc\"><meta name=\"description\" content=\"A trait for borrowing data.\"><title>Borrow in std::borrow - Rust</title><script>if(window.location.protocol!==\"file:\")document.head.insertAdjacentHTML(\"beforeend\",\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\".split(\",\").map(f=>`<link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"../../static.files/${f}\">`).join(\"\"))</script><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\"><link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin=\"\" href=\"../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\"><link rel=\"stylesheet\" href=\"../../static.files/normalize-76eba96aa4d2e634.css\"><link rel=\"stylesheet\" href=\"../../static.files/rustdoc-dd39b87e5fcfba68.css\"><meta name=\"rustdoc-vars\" data-root-path=\"../../\" data-static-root-path=\"../../static.files/\" data-current-crate=\"std\" data-themes=\"\" data-resource-suffix=\"1.80.0\" data-rustdoc-version=\"1.80.0 (051478957 2024-07-21)\" data-channel=\"1.80.0\" data-search-js=\"search-d52510db62a78183.js\" data-settings-js=\"settings-4313503d2e1961c2.js\"><script src=\"../../static.files/storage-118b08c4c78b968e.js\"></script><script defer=\"\" src=\"sidebar-items1.80.0.js\"></script><script defer=\"\" src=\"../../static.files/main-20a3ad099b048cf2.js\"></script><noscript><link rel=\"stylesheet\" href=\"../../static.files/noscript-df360f571f6edeae.css\"></noscript><link rel=\"alternate icon\" type=\"image/png\" href=\"../../static.files/favicon-32x32-422f7d1d52889060.png\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"../../static.files/favicon-2c020d218678b618.svg\"></head><body class=\"rustdoc trait\"><!--[if lte IE 11]><div class=\"warning\">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class=\"mobile-topbar\"><button class=\"sidebar-menu-toggle\" title=\"show sidebar\"></button><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"\"></a><h2 class=\"location\"><a href=\"#\">Borrow</a></h2></nav><nav class=\"sidebar\"><div class=\"sidebar-crate\"><a class=\"logo-container\" href=\"../../std/index.html\"><img class=\"rust-logo\" src=\"../../static.files/rust-logo-151179464ae7ed46.svg\" alt=\"logo\"></a><h2><a href=\"../../std/index.html\">std</a><span class=\"version\">1.80.0</span></h2></div><div class=\"version\">(051478957\t2024-07-21)</div><h2 class=\"location\"><a href=\"#\">Borrow</a></h2><div class=\"sidebar-elems\"><section><h3><a href=\"#required-methods\">Required Methods</a></h3><ul class=\"block\"><li><a href=\"#tymethod.borrow\">borrow</a></li></ul><h3><a href=\"#implementors\">Implementors</a></h3></section><h2><a href=\"index.html\">In std::borrow</a></h2><h3><a href=\"index.html#enums\">Enums</a></h3><ul class=\"block enum\"><li><a href=\"enum.Cow.html\">Cow</a></li></ul><h3><a href=\"index.html#traits\">Traits</a></h3><ul class=\"block trait\"><li><a href=\"trait.Borrow.html\">Borrow</a></li><li><a href=\"trait.BorrowMut.html\">BorrowMut</a></li><li><a href=\"trait.ToOwned.html\">ToOwned</a></li></ul></div></nav><div class=\"sidebar-resizer\"></div><main><div class=\"width-limiter\"><rustdoc-search><nav class=\"sub\">\n            <form class=\"search-form\">\n                <span></span> <!-- This empty span is a hacky fix for Safari - See #93184 -->\n                <div id=\"sidebar-button\" tabindex=\"-1\">\n                    <a href=\"../../std/all.html\" title=\"show sidebar\"></a>\n                </div>\n                <input class=\"search-input\" name=\"search\" aria-label=\"Run search in the documentation\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"Type ‘S’ or ‘/’ to search, ‘?’ for more options…\" type=\"search\">\n                <div id=\"help-button\" tabindex=\"-1\">\n                    <a href=\"../../help.html\" title=\"help\">?</a>\n                </div>\n                <div id=\"settings-menu\" tabindex=\"-1\">\n                    <a href=\"../../settings.html\" title=\"settings\">\n                        Settings\n                    </a>\n                </div>\n            </form>\n        </nav></rustdoc-search><section id=\"main-content\" class=\"content\"><div class=\"main-heading\"><h1>Trait <a href=\"../index.html\">std</a>::<wbr><a href=\"index.html\">borrow</a>::<wbr><a class=\"trait\" href=\"#\">Borrow</a><button id=\"copy-path\" title=\"Copy item path to clipboard\">Copy item path</button></h1><span class=\"out-of-band\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#157\">source</a> · <button id=\"toggle-all-docs\" title=\"collapse all docs\">[<span>−</span>]</button></span></div><pre class=\"rust item-decl\"><code>pub trait Borrow&lt;Borrowed&gt;<div class=\"where\">where\n    Borrowed: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div>{\n    // Required method\n    fn <a href=\"#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Borrowed</a>;\n}</code></pre><details class=\"toggle top-doc\" open=\"\"><summary class=\"hideme\"><span>Expand description</span></summary><div class=\"docblock\"><p>A trait for borrowing data.</p>\n<p>In Rust, it is common to provide different representations of a type for\ndifferent use cases. For instance, storage location and management for a\nvalue can be specifically chosen as appropriate for a particular use via\npointer types such as <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> or <a href=\"../../std/rc/struct.Rc.html\"><code>Rc&lt;T&gt;</code></a>. Beyond these generic\nwrappers that can be used with any type, some types provide optional\nfacets providing potentially costly functionality. An example for such a\ntype is <a href=\"../../std/string/struct.String.html\"><code>String</code></a> which adds the ability to extend a string to the basic\n<a href=\"../primitive.str.html\" title=\"primitive str\"><code>str</code></a>. This requires keeping additional information unnecessary for a\nsimple, immutable string.</p>\n<p>These types provide access to the underlying data through references\nto the type of that data. They are said to be ‘borrowed as’ that type.\nFor instance, a <a href=\"../../std/boxed/struct.Box.html\"><code>Box&lt;T&gt;</code></a> can be borrowed as <code>T</code> while a <a href=\"../../std/string/struct.String.html\"><code>String</code></a>\ncan be borrowed as <code>str</code>.</p>\n<p>Types express that they can be borrowed as some type <code>T</code> by implementing\n<code>Borrow&lt;T&gt;</code>, providing a reference to a <code>T</code> in the trait’s\n<a href=\"trait.Borrow.html#tymethod.borrow\" title=\"method std::borrow::Borrow::borrow\"><code>borrow</code></a> method. A type is free to borrow as several different types.\nIf it wishes to mutably borrow as the type, allowing the underlying data\nto be modified, it can additionally implement <a href=\"trait.BorrowMut.html\" title=\"trait std::borrow::BorrowMut\"><code>BorrowMut&lt;T&gt;</code></a>.</p>\n<p>Further, when providing implementations for additional traits, it needs\nto be considered whether they should behave identically to those of the\nunderlying type as a consequence of acting as a representation of that\nunderlying type. Generic code typically uses <code>Borrow&lt;T&gt;</code> when it relies\non the identical behavior of these additional trait implementations.\nThese traits will likely appear as additional trait bounds.</p>\n<p>In particular <code>Eq</code>, <code>Ord</code> and <code>Hash</code> must be equivalent for\nborrowed and owned values: <code>x.borrow() == y.borrow()</code> should give the\nsame result as <code>x == y</code>.</p>\n<p>If generic code merely needs to work for all types that can\nprovide a reference to related type <code>T</code>, it is often better to use\n<a href=\"../convert/trait.AsRef.html\" title=\"trait std::convert::AsRef\"><code>AsRef&lt;T&gt;</code></a> as more types can safely implement it.</p>\n<h2 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h2>\n<p>As a data collection, <a href=\"../../std/collections/struct.HashMap.html\"><code>HashMap&lt;K, V&gt;</code></a> owns both keys and values. If\nthe key’s actual data is wrapped in a managing type of some kind, it\nshould, however, still be possible to search for a value using a\nreference to the key’s data. For instance, if the key is a string, then\nit is likely stored with the hash map as a <a href=\"../../std/string/struct.String.html\"><code>String</code></a>, while it should\nbe possible to search using a <a href=\"../primitive.str.html\" title=\"primitive str\"><code>&amp;str</code></a>. Thus, <code>insert</code> needs to\noperate on a <code>String</code> while <code>get</code> needs to be able to use a <code>&amp;str</code>.</p>\n<p>Slightly simplified, the relevant parts of <code>HashMap&lt;K, V&gt;</code> look like\nthis:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::borrow::Borrow;\n<span class=\"kw\">use </span>std::hash::Hash;\n\n<span class=\"kw\">pub struct </span>HashMap&lt;K, V&gt; {\n    <span class=\"comment\">// fields omitted\n</span>}\n\n<span class=\"kw\">impl</span>&lt;K, V&gt; HashMap&lt;K, V&gt; {\n    <span class=\"kw\">pub fn </span>insert(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, key: K, value: V) -&gt; <span class=\"prelude-ty\">Option</span>&lt;V&gt;\n    <span class=\"kw\">where </span>K: Hash + Eq\n    {\n        <span class=\"comment\">// ...\n    </span>}\n\n    <span class=\"kw\">pub fn </span>get&lt;Q&gt;(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, k: <span class=\"kw-2\">&amp;</span>Q) -&gt; <span class=\"prelude-ty\">Option</span>&lt;<span class=\"kw-2\">&amp;</span>V&gt;\n    <span class=\"kw\">where\n        </span>K: Borrow&lt;Q&gt;,\n        Q: Hash + Eq + <span class=\"question-mark\">?</span>Sized\n    {\n        <span class=\"comment\">// ...\n    </span>}\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Borrow;%0A++++use+std::hash::Hash;%0A++++%0A++++pub+struct+HashMap%3CK,+V%3E+%7B%0A++++marker:+::std::marker::PhantomData%3C(K,+V)%3E,%0A++++++++//+fields+omitted%0A++++%7D%0A++++%0A++++impl%3CK,+V%3E+HashMap%3CK,+V%3E+%7B%0A++++++++pub+fn+insert(%26self,+key:+K,+value:+V)+-%3E+Option%3CV%3E%0A++++++++where+K:+Hash+%2B+Eq%0A++++++++%7B%0A++++unimplemented!()%0A++++++++++++//+...%0A++++++++%7D%0A++++%0A++++++++pub+fn+get%3CQ%3E(%26self,+k:+%26Q)+-%3E+Option%3C%26V%3E%0A++++++++where%0A++++++++++++K:+Borrow%3CQ%3E,%0A++++++++++++Q:+Hash+%2B+Eq+%2B+?Sized%0A++++++++%7B%0A++++unimplemented!()%0A++++++++++++//+...%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>The entire hash map is generic over a key type <code>K</code>. Because these keys\nare stored with the hash map, this type has to own the key’s data.\nWhen inserting a key-value pair, the map is given such a <code>K</code> and needs\nto find the correct hash bucket and check if the key is already present\nbased on that <code>K</code>. It therefore requires <code>K: Hash + Eq</code>.</p>\n<p>When searching for a value in the map, however, having to provide a\nreference to a <code>K</code> as the key to search for would require to always\ncreate such an owned value. For string keys, this would mean a <code>String</code>\nvalue needs to be created just for the search for cases where only a\n<code>str</code> is available.</p>\n<p>Instead, the <code>get</code> method is generic over the type of the underlying key\ndata, called <code>Q</code> in the method signature above. It states that <code>K</code>\nborrows as a <code>Q</code> by requiring that <code>K: Borrow&lt;Q&gt;</code>. By additionally\nrequiring <code>Q: Hash + Eq</code>, it signals the requirement that <code>K</code> and <code>Q</code>\nhave implementations of the <code>Hash</code> and <code>Eq</code> traits that produce identical\nresults.</p>\n<p>The implementation of <code>get</code> relies in particular on identical\nimplementations of <code>Hash</code> by determining the key’s hash bucket by calling\n<code>Hash::hash</code> on the <code>Q</code> value even though it inserted the key based on\nthe hash value calculated from the <code>K</code> value.</p>\n<p>As a consequence, the hash map breaks if a <code>K</code> wrapping a <code>Q</code> value\nproduces a different hash than <code>Q</code>. For instance, imagine you have a\ntype that wraps a string but compares ASCII letters ignoring their case:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">pub struct </span>CaseInsensitiveString(String);\n\n<span class=\"kw\">impl </span>PartialEq <span class=\"kw\">for </span>CaseInsensitiveString {\n    <span class=\"kw\">fn </span>eq(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, other: <span class=\"kw-2\">&amp;</span><span class=\"self\">Self</span>) -&gt; bool {\n        <span class=\"self\">self</span>.<span class=\"number\">0</span>.eq_ignore_ascii_case(<span class=\"kw-2\">&amp;</span>other.<span class=\"number\">0</span>)\n    }\n}\n\n<span class=\"kw\">impl </span>Eq <span class=\"kw\">for </span>CaseInsensitiveString { }</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++pub+struct+CaseInsensitiveString(String);%0A++++%0A++++impl+PartialEq+for+CaseInsensitiveString+%7B%0A++++++++fn+eq(%26self,+other:+%26Self)+-%3E+bool+%7B%0A++++++++++++self.0.eq_ignore_ascii_case(%26other.0)%0A++++++++%7D%0A++++%7D%0A++++%0A++++impl+Eq+for+CaseInsensitiveString+%7B+%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Because two equal values need to produce the same hash value, the\nimplementation of <code>Hash</code> needs to ignore ASCII case, too:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">impl </span>Hash <span class=\"kw\">for </span>CaseInsensitiveString {\n    <span class=\"kw\">fn </span>hash&lt;H: Hasher&gt;(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, state: <span class=\"kw-2\">&amp;mut </span>H) {\n        <span class=\"kw\">for </span>c <span class=\"kw\">in </span><span class=\"self\">self</span>.<span class=\"number\">0</span>.as_bytes() {\n            c.to_ascii_lowercase().hash(state)\n        }\n    }\n}</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::hash::%7BHash,+Hasher%7D;%0A++++pub+struct+CaseInsensitiveString(String);%0A++++impl+Hash+for+CaseInsensitiveString+%7B%0A++++++++fn+hash%3CH:+Hasher%3E(%26self,+state:+%26mut+H)+%7B%0A++++++++++++for+c+in+self.0.as_bytes()+%7B%0A++++++++++++++++c.to_ascii_lowercase().hash(state)%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2021\">Run</a></div>\n<p>Can <code>CaseInsensitiveString</code> implement <code>Borrow&lt;str&gt;</code>? It certainly can\nprovide a reference to a string slice via its contained owned string.\nBut because its <code>Hash</code> implementation differs, it behaves differently\nfrom <code>str</code> and therefore must not, in fact, implement <code>Borrow&lt;str&gt;</code>.\nIf it wants to allow others access to the underlying <code>str</code>, it can do\nthat via <code>AsRef&lt;str&gt;</code> which doesn’t carry any extra requirements.</p>\n</div></details><h2 id=\"required-methods\" class=\"section-header\">Required Methods<a href=\"#required-methods\" class=\"anchor\">§</a></h2><div class=\"methods\"><details class=\"toggle method-toggle\" open=\"\"><summary><section id=\"tymethod.borrow\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#178\">source</a></span><h4 class=\"code-header\">fn <a href=\"#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;Borrowed</a></h4></section></summary><div class=\"docblock\"><p>Immutably borrows from an owned value.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::borrow::Borrow;\n\n<span class=\"kw\">fn </span>check&lt;T: Borrow&lt;str&gt;&gt;(s: T) {\n    <span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Hello\"</span>, s.borrow());\n}\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"Hello\"</span>.to_string();\n\ncheck(s);\n\n<span class=\"kw\">let </span>s = <span class=\"string\">\"Hello\"</span>;\n\ncheck(s);</code></pre><a class=\"test-arrow\" target=\"_blank\" href=\"https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Borrow;%0A++++%0A++++fn+check%3CT:+Borrow%3Cstr%3E%3E(s:+T)+%7B%0A++++++++assert_eq!(%22Hello%22,+s.borrow());%0A++++%7D%0A++++%0A++++let+s+=+%22Hello%22.to_string();%0A++++%0A++++check(s);%0A++++%0A++++let+s+=+%22Hello%22;%0A++++%0A++++check(s);%0A%7D&amp;edition=2021\">Run</a></div>\n</div></details></div><h2 id=\"implementors\" class=\"section-header\">Implementors<a href=\"#implementors\" class=\"anchor\">§</a></h2><div id=\"implementors-list\"><section id=\"impl-Borrow%3Cstr%3E-for-String\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/str.rs.html#190\">source</a></span><a href=\"#impl-Borrow%3Cstr%3E-for-String\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"../primitive.str.html\">str</a>&gt; for <a class=\"struct\" href=\"../string/struct.String.html\" title=\"struct std::string::String\">String</a></h3></section><section id=\"impl-Borrow%3CCStr%3E-for-CString\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/ffi/c_str.rs.html#749\">source</a></span><a href=\"#impl-Borrow%3CCStr%3E-for-CString\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"struct\" href=\"../ffi/struct.CStr.html\" title=\"struct std::ffi::CStr\">CStr</a>&gt; for <a class=\"struct\" href=\"../ffi/struct.CString.html\" title=\"struct std::ffi::CString\">CString</a></h3></section><section id=\"impl-Borrow%3COsStr%3E-for-OsString\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/ffi/os_str.rs.html#1539-1544\">source</a></span><a href=\"#impl-Borrow%3COsStr%3E-for-OsString\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"struct\" href=\"../ffi/struct.OsStr.html\" title=\"struct std::ffi::OsStr\">OsStr</a>&gt; for <a class=\"struct\" href=\"../ffi/struct.OsString.html\" title=\"struct std::ffi::OsString\">OsString</a></h3></section><section id=\"impl-Borrow%3CPath%3E-for-PathBuf\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"../../src/std/path.rs.html#1805-1810\">source</a></span><a href=\"#impl-Borrow%3CPath%3E-for-PathBuf\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"struct\" href=\"../path/struct.Path.html\" title=\"struct std::path::Path\">Path</a>&gt; for <a class=\"struct\" href=\"../path/struct.PathBuf.html\" title=\"struct std::path::PathBuf\">PathBuf</a></h3></section><section id=\"impl-Borrow%3CB%3E-for-Cow%3C'a,+B%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#21-23\">source</a></span><a href=\"#impl-Borrow%3CB%3E-for-Cow%3C'a,+B%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, B&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;B&gt; for <a class=\"enum\" href=\"enum.Cow.html\" title=\"enum std::borrow::Cow\">Cow</a>&lt;'a, B&gt;<div class=\"where\">where\n    B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait std::borrow::ToOwned\">ToOwned</a> + ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3CT%3E-for-%26T\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#223\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-%26T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;T</a><div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3CT%3E-for-%26mut+T\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#230\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-%26mut+T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"primitive\" href=\"../primitive.reference.html\">&amp;mut T</a><div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3CT%3E-for-T\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-T\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for T<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3C%5BT%5D%3E-for-Vec%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/slice.rs.html#772\">source</a></span><a href=\"#impl-Borrow%3C%5BT%5D%3E-for-Vec%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"struct\" href=\"../vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></h3></section><section id=\"impl-Borrow%3CT%3E-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.1.0\">1.1.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/boxed.rs.html#2253\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-Box%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"struct\" href=\"../boxed/struct.Box.html\" title=\"struct std::boxed::Box\">Box</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/rc.rs.html#3481\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"struct\" href=\"../rc/struct.Rc.html\" title=\"struct std::rc::Rc\">Rc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/alloc/sync.rs.html#3771\">source</a></span><a href=\"#impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, A&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;T&gt; for <a class=\"struct\" href=\"../sync/struct.Arc.html\" title=\"struct std::sync::Arc\">Arc</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"../alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>,\n    T: ?<a class=\"trait\" href=\"../marker/trait.Sized.html\" title=\"trait std::marker::Sized\">Sized</a>,</div></h3></section><section id=\"impl-Borrow%3C%5BT%5D%3E-for-%5BT;+N%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.4.0\">1.4.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.80.0/src/core/array/mod.rs.html#175\">source</a></span><a href=\"#impl-Borrow%3C%5BT%5D%3E-for-%5BT;+N%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, const N: <a class=\"primitive\" href=\"../primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"trait.Borrow.html\" title=\"trait std::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"../primitive.slice.html\">[T]</a>&gt; for <a class=\"primitive\" href=\"../primitive.array.html\">[T; N]</a></h3></section></div><script src=\"../../trait.impl/core/borrow/trait.Borrow.js\" data-ignore-extern-crates=\"alloc\" async=\"\"></script></section></div></main></body></html>",
	"crawlDate": "2024-07-28T05:11:55.634Z"
}