{
	"title": "Graceful Shutdown and Cleanup - The Rust Programming Language",
	"url": "https://doc.rust-lang.org/stable/book/ch20-03-graceful-shutdown-and-cleanup.html",
	"markdown": "# Graceful Shutdown and Cleanup - The Rust Programming Language\n\nThe code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the `workers`, `id`, and `thread` fields that we’re not using in a direct way that reminds us we’re not cleaning up anything. When we use the less elegant ctrl\\-c method to halt the main thread, all other threads are stopped immediately as well, even if they’re in the middle of serving a request.\n\nNext, then, we’ll implement the `Drop` trait to call `join` on each of the threads in the pool so they can finish the requests they’re working on before closing. Then we’ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we’ll modify our server to accept only two requests before gracefully shutting down its thread pool.\n\n### [Implementing the `Drop` Trait on `ThreadPool`](#implementing-the-drop-trait-on-threadpool)\n\nLet’s start with implementing `Drop` on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-22 shows a first attempt at a `Drop` implementation; this code won’t quite work yet.\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n\n            job();\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\nListing 20-22: Joining each thread when the thread pool goes out of scope\n\nFirst, we loop through each of the thread pool `workers`. We use `&mut` for this because `self` is a mutable reference, and we also need to be able to mutate `worker`. For each worker, we print a message saying that this particular worker is shutting down, and then we call `join` on that worker’s thread. If the call to `join` fails, we use `unwrap` to make Rust panic and go into an ungraceful shutdown.\n\nHere is the error we get when we compile this code:\n\n```console\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0507]: cannot move out of `worker.thread` which is behind a mutable reference\n  --> src/lib.rs:52:13\n   |\n52 |             worker.thread.join().unwrap();\n   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call\n   |             |\n   |             move occurs because `worker.thread` has type `JoinHandle<()>`, which does not implement the `Copy` trait\n   |\nnote: `JoinHandle::<T>::join` takes ownership of the receiver `self`, which moves `worker.thread`\n  --> /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:17\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `hello` (lib) due to 1 previous error\n\n```\n\nThe error tells us we can’t call `join` because we only have a mutable borrow of each `worker` and `join` takes ownership of its argument. To solve this issue, we need to move the thread out of the `Worker` instance that owns `thread` so `join` can consume the thread. We did this in Listing 17-15: if `Worker` holds an `Option<thread::JoinHandle<()>>` instead, we can call the `take` method on the `Option` to move the value out of the `Some` variant and leave a `None` variant in its place. In other words, a `Worker` that is running will have a `Some` variant in `thread`, and when we want to clean up a `Worker`, we’ll replace `Some` with `None` so the `Worker` doesn’t have a thread to run.\n\nSo we know we want to update the definition of `Worker` like this:\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n\n            job();\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\nNow let’s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:\n\n```console\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no method named `join` found for enum `Option` in the current scope\n  --> src/lib.rs:52:27\n   |\n52 |             worker.thread.join().unwrap();\n   |                           ^^^^ method not found in `Option<JoinHandle<()>>`\n   |\nnote: the method `join` exists on the type `JoinHandle<()>`\n  --> /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:5\nhelp: consider using `Option::expect` to unwrap the `JoinHandle<()>` value, panicking if the value is an `Option::None`\n   |\n52 |             worker.thread.expect(\"REASON\").join().unwrap();\n   |                          +++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/lib.rs:72:22\n   |\n72 |         Worker { id, thread }\n   |                      ^^^^^^ expected `Option<JoinHandle<()>>`, found `JoinHandle<_>`\n   |\n   = note: expected enum `Option<JoinHandle<()>>`\n            found struct `JoinHandle<_>`\nhelp: try wrapping the expression in `Some`\n   |\n72 |         Worker { id, thread: Some(thread) }\n   |                      +++++++++++++      +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `hello` (lib) due to 2 previous errors\n\n```\n\nLet’s address the second error, which points to the code at the end of `Worker::new`; we need to wrap the `thread` value in `Some` when we create a new `Worker`. Make the following changes to fix this error:\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        // --snip--\n\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n\n            job();\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\nThe first error is in our `Drop` implementation. We mentioned earlier that we intended to call `take` on the `Option` value to move `thread` out of `worker`. The following changes will do so:\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n\n            job();\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\nAs discussed in Chapter 17, the `take` method on `Option` takes the `Some` variant out and leaves `None` in its place. We’re using `if let` to destructure the `Some` and get the thread; then we call `join` on the thread. If a worker’s thread is already `None`, we know that worker has already had its thread cleaned up, so nothing happens in that case.\n\n### [Signaling to the Threads to Stop Listening for Jobs](#signaling-to-the-threads-to-stop-listening-for-jobs)\n\nWith all the changes we’ve made, our code compiles without any warnings. However, the bad news is this code doesn’t function the way we want it to yet. The key is the logic in the closures run by the threads of the `Worker` instances: at the moment, we call `join`, but that won’t shut down the threads because they `loop` forever looking for jobs. If we try to drop our `ThreadPool` with our current implementation of `drop`, the main thread will block forever waiting for the first thread to finish.\n\nTo fix this problem, we’ll need a change in the `ThreadPool` `drop` implementation and then a change in the `Worker` loop.\n\nFirst, we’ll change the `ThreadPool` `drop` implementation to explicitly drop the `sender` before waiting for the threads to finish. Listing 20-23 shows the changes to `ThreadPool` to explicitly drop `sender`. We use the same `Option` and `take` technique as we did with the thread to be able to move `sender` out of `ThreadPool`:\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n// --snip--\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        // --snip--\n\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n\n            job();\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\nListing 20-23: Explicitly drop `sender` before joining the worker threads\n\nDropping `sender` closes the channel, which indicates no more messages will be sent. When that happens, all the calls to `recv` that the workers do in the infinite loop will return an error. In Listing 20-24, we change the `Worker` loop to gracefully exit the loop in that case, which means the threads will finish when the `ThreadPool` `drop` implementation calls `join` on them.\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) => {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) => {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\nListing 20-24: Explicitly break out of the loop when `recv` returns an error\n\nTo see this code in action, let’s modify `main` to accept only two requests before gracefully shutting down the server, as shown in Listing 20-25.\n\nFilename: src/main.rs\n\n```rust\nuse hello::ThreadPool;\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\nListing 20-25: Shut down the server after serving two requests by exiting the loop\n\nYou wouldn’t want a real-world web server to shut down after serving only two requests. This code just demonstrates that the graceful shutdown and cleanup is in working order.\n\nThe `take` method is defined in the `Iterator` trait and limits the iteration to the first two items at most. The `ThreadPool` will go out of scope at the end of `main`, and the `drop` implementation will run.\n\nStart the server with `cargo run`, and make three requests. The third request should error, and in your terminal you should see output similar to this:\n\n```console\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.0s\n     Running `target/debug/hello`\nWorker 0 got a job; executing.\nShutting down.\nShutting down worker 0\nWorker 3 got a job; executing.\nWorker 1 disconnected; shutting down.\nWorker 2 disconnected; shutting down.\nWorker 3 disconnected; shutting down.\nWorker 0 disconnected; shutting down.\nShutting down worker 1\nShutting down worker 2\nShutting down worker 3\n\n```\n\nYou might see a different ordering of workers and messages printed. We can see how this code works from the messages: workers 0 and 3 got the first two requests. The server stopped accepting connections after the second connection, and the `Drop` implementation on `ThreadPool` starts executing before worker 3 even starts its job. Dropping the `sender` disconnects all the workers and tells them to shut down. The workers each print a message when they disconnect, and then the thread pool calls `join` to wait for each worker thread to finish.\n\nNotice one interesting aspect of this particular execution: the `ThreadPool` dropped the `sender`, and before any worker received an error, we tried to join worker 0. Worker 0 had not yet gotten an error from `recv`, so the main thread blocked waiting for worker 0 to finish. In the meantime, worker 3 received a job and then all threads received an error. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all exited their loops and stopped.\n\nCongrats! We’ve now completed our project; we have a basic web server that uses a thread pool to respond asynchronously. We’re able to perform a graceful shutdown of the server, which cleans up all the threads in the pool.\n\nHere’s the full code for reference:\n\nFilename: src/main.rs\n\n```rust\nuse hello::ThreadPool;\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\nFilename: src/lib.rs\n\n```rust\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) => {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) => {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\nWe could do more here! If you want to continue enhancing this project, here are some ideas:\n\n-   Add more documentation to `ThreadPool` and its public methods.\n-   Add tests of the library’s functionality.\n-   Change calls to `unwrap` to more robust error handling.\n-   Use `ThreadPool` to perform some task other than serving web requests.\n-   Find a thread pool crate on [crates.io](https://crates.io/) and implement a similar web server using the crate instead. Then compare its API and robustness to the thread pool we implemented.\n\n## [Summary](#summary)\n\nWell done! You’ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You’re now ready to implement your own Rust projects and help with other peoples’ projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.",
	"html": "<!DOCTYPE html><html lang=\"en\" class=\"light\" dir=\"ltr\"><head>\n        <!-- Book generated using mdBook -->\n        <meta charset=\"UTF-8\">\n        <title>Graceful Shutdown and Cleanup - The Rust Programming Language</title>\n\n\n        <!-- Custom HTML head -->\n        \n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <meta name=\"theme-color\" content=\"rgb(255, 255, 255)\">\n\n        <link rel=\"icon\" href=\"favicon.svg\">\n        <link rel=\"shortcut icon\" href=\"favicon.png\">\n        <link rel=\"stylesheet\" href=\"css/variables.css\">\n        <link rel=\"stylesheet\" href=\"css/general.css\">\n        <link rel=\"stylesheet\" href=\"css/chrome.css\">\n        <link rel=\"stylesheet\" href=\"css/print.css\" media=\"print\">\n\n        <!-- Fonts -->\n        <link rel=\"stylesheet\" href=\"FontAwesome/css/font-awesome.css\">\n        <link rel=\"stylesheet\" href=\"fonts/fonts.css\">\n\n        <!-- Highlight.js Stylesheets -->\n        <link rel=\"stylesheet\" href=\"highlight.css\">\n        <link rel=\"stylesheet\" href=\"tomorrow-night.css\" disabled=\"\">\n        <link rel=\"stylesheet\" href=\"ayu-highlight.css\" disabled=\"\">\n\n        <!-- Custom theme stylesheets -->\n        <link rel=\"stylesheet\" href=\"ferris.css\">\n        <link rel=\"stylesheet\" href=\"theme/2018-edition.css\">\n        <link rel=\"stylesheet\" href=\"theme/semantic-notes.css\">\n        <link rel=\"stylesheet\" href=\"theme/listing.css\">\n\n    </head>\n    <body class=\"js sidebar-visible\">\n    <div id=\"body-container\">\n        <!-- Provide site root to javascript -->\n        <script>\n            var path_to_root = \"\";\n            var default_theme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"navy\" : \"light\";\n        </script>\n\n        <!-- Work around some values being stored in localStorage wrapped in quotes -->\n        <script>\n            try {\n                var theme = localStorage.getItem('mdbook-theme');\n                var sidebar = localStorage.getItem('mdbook-sidebar');\n\n                if (theme.startsWith('\"') && theme.endsWith('\"')) {\n                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));\n                }\n\n                if (sidebar.startsWith('\"') && sidebar.endsWith('\"')) {\n                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));\n                }\n            } catch (e) { }\n        </script>\n\n        <!-- Set the theme before any content is loaded, prevents flash -->\n        <script>\n            var theme;\n            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }\n            if (theme === null || theme === undefined) { theme = default_theme; }\n            var html = document.querySelector('html');\n            html.classList.remove('light')\n            html.classList.add(theme);\n            var body = document.querySelector('body');\n            body.classList.remove('no-js')\n            body.classList.add('js');\n        </script>\n\n        <input type=\"checkbox\" id=\"sidebar-toggle-anchor\" class=\"hidden\">\n\n        <!-- Hide / unhide sidebar before it is displayed -->\n        <script>\n            var body = document.querySelector('body');\n            var sidebar = null;\n            var sidebar_toggle = document.getElementById(\"sidebar-toggle-anchor\");\n            if (document.body.clientWidth >= 1080) {\n                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }\n                sidebar = sidebar || 'visible';\n            } else {\n                sidebar = 'hidden';\n            }\n            sidebar_toggle.checked = sidebar === 'visible';\n            body.classList.remove('sidebar-visible');\n            body.classList.add(\"sidebar-\" + sidebar);\n        </script>\n\n        <nav id=\"sidebar\" class=\"sidebar\" aria-label=\"Table of contents\" aria-hidden=\"false\">\n            <div class=\"sidebar-scrollbox\">\n                <ol class=\"chapter\"><li class=\"chapter-item expanded affix \"><a href=\"title-page.html\" tabindex=\"0\">The Rust Programming Language</a></li><li class=\"chapter-item expanded affix \"><a href=\"foreword.html\" tabindex=\"0\">Foreword</a></li><li class=\"chapter-item expanded affix \"><a href=\"ch00-00-introduction.html\" tabindex=\"0\">Introduction</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-00-getting-started.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.</strong> Getting Started</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch01-01-installation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.1.</strong> Installation</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-02-hello-world.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.2.</strong> Hello, World!</a></li><li class=\"chapter-item expanded \"><a href=\"ch01-03-hello-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch02-00-guessing-game-tutorial.html\" tabindex=\"0\"><strong aria-hidden=\"true\">2.</strong> Programming a Guessing Game</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-00-common-programming-concepts.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.</strong> Common Programming Concepts</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch03-01-variables-and-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.1.</strong> Variables and Mutability</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-02-data-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.2.</strong> Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-03-how-functions-work.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.3.</strong> Functions</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-04-comments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.4.</strong> Comments</a></li><li class=\"chapter-item expanded \"><a href=\"ch03-05-control-flow.html\" tabindex=\"0\"><strong aria-hidden=\"true\">3.5.</strong> Control Flow</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch04-00-understanding-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.</strong> Understanding Ownership</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch04-01-what-is-ownership.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.1.</strong> What is Ownership?</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-02-references-and-borrowing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.2.</strong> References and Borrowing</a></li><li class=\"chapter-item expanded \"><a href=\"ch04-03-slices.html\" tabindex=\"0\"><strong aria-hidden=\"true\">4.3.</strong> The Slice Type</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch05-00-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch05-01-defining-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.1.</strong> Defining and Instantiating Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-02-example-structs.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.2.</strong> An Example Program Using Structs</a></li><li class=\"chapter-item expanded \"><a href=\"ch05-03-method-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">5.3.</strong> Method Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch06-00-enums.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.</strong> Enums and Pattern Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch06-01-defining-an-enum.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.1.</strong> Defining an Enum</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-02-match.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.2.</strong> The match Control Flow Construct</a></li><li class=\"chapter-item expanded \"><a href=\"ch06-03-if-let.html\" tabindex=\"0\"><strong aria-hidden=\"true\">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch07-01-packages-and-crates.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.1.</strong> Packages and Crates</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-02-defining-modules-to-control-scope-and-privacy.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-04-bringing-paths-into-scope-with-the-use-keyword.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=\"chapter-item expanded \"><a href=\"ch07-05-separating-modules-into-different-files.html\" tabindex=\"0\"><strong aria-hidden=\"true\">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch08-00-common-collections.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.</strong> Common Collections</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch08-01-vectors.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-02-strings.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=\"chapter-item expanded \"><a href=\"ch08-03-hash-maps.html\" tabindex=\"0\"><strong aria-hidden=\"true\">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch09-00-error-handling.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.</strong> Error Handling</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch09-01-unrecoverable-errors-with-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-02-recoverable-errors-with-result.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.2.</strong> Recoverable Errors with Result</a></li><li class=\"chapter-item expanded \"><a href=\"ch09-03-to-panic-or-not-to-panic.html\" tabindex=\"0\"><strong aria-hidden=\"true\">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch10-00-generics.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch10-01-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.1.</strong> Generic Data Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-02-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=\"chapter-item expanded \"><a href=\"ch10-03-lifetime-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch11-00-testing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.</strong> Writing Automated Tests</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch11-01-writing-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.1.</strong> How to Write Tests</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-02-running-tests.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.2.</strong> Controlling How Tests Are Run</a></li><li class=\"chapter-item expanded \"><a href=\"ch11-03-test-organization.html\" tabindex=\"0\"><strong aria-hidden=\"true\">11.3.</strong> Test Organization</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch12-00-an-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch12-01-accepting-command-line-arguments.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.1.</strong> Accepting Command Line Arguments</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-02-reading-a-file.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.2.</strong> Reading a File</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-03-improving-error-handling-and-modularity.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-04-testing-the-librarys-functionality.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-05-working-with-environment-variables.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.5.</strong> Working with Environment Variables</a></li><li class=\"chapter-item expanded \"><a href=\"ch12-06-writing-to-stderr-instead-of-stdout.html\" tabindex=\"0\"><strong aria-hidden=\"true\">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch13-00-functional-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch13-01-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-02-iterators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-03-improving-our-io-project.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.3.</strong> Improving Our I/O Project</a></li><li class=\"chapter-item expanded \"><a href=\"ch13-04-performance.html\" tabindex=\"0\"><strong aria-hidden=\"true\">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch14-00-more-about-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.</strong> More about Cargo and Crates.io</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch14-01-release-profiles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-02-publishing-to-crates-io.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-03-cargo-workspaces.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.3.</strong> Cargo Workspaces</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-04-installing-binaries.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=\"chapter-item expanded \"><a href=\"ch14-05-extending-cargo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch15-00-smart-pointers.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.</strong> Smart Pointers</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch15-01-box.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-02-deref.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-03-drop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-04-rc.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-05-interior-mutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class=\"chapter-item expanded \"><a href=\"ch15-06-reference-cycles.html\" tabindex=\"0\"><strong aria-hidden=\"true\">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch16-00-concurrency.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.</strong> Fearless Concurrency</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch16-01-threads.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-02-message-passing.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-03-shared-state.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.3.</strong> Shared-State Concurrency</a></li><li class=\"chapter-item expanded \"><a href=\"ch16-04-extensible-concurrency-sync-and-send.html\" tabindex=\"0\"><strong aria-hidden=\"true\">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch17-00-oop.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch17-01-what-is-oo.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-02-trait-objects.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch17-03-oo-design-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch18-00-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.</strong> Patterns and Matching</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch18-01-all-the-places-for-patterns.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-02-refutability.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=\"chapter-item expanded \"><a href=\"ch18-03-pattern-syntax.html\" tabindex=\"0\"><strong aria-hidden=\"true\">18.3.</strong> Pattern Syntax</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch19-00-advanced-features.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.</strong> Advanced Features</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch19-01-unsafe-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.1.</strong> Unsafe Rust</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-03-advanced-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.2.</strong> Advanced Traits</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-04-advanced-types.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.3.</strong> Advanced Types</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-05-advanced-functions-and-closures.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.4.</strong> Advanced Functions and Closures</a></li><li class=\"chapter-item expanded \"><a href=\"ch19-06-macros.html\" tabindex=\"0\"><strong aria-hidden=\"true\">19.5.</strong> Macros</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"ch20-00-final-project-a-web-server.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"ch20-01-single-threaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-02-multithreaded.html\" tabindex=\"0\"><strong aria-hidden=\"true\">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=\"chapter-item expanded \"><a href=\"ch20-03-graceful-shutdown-and-cleanup.html\" class=\"active\" tabindex=\"0\"><strong aria-hidden=\"true\">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=\"chapter-item expanded \"><a href=\"appendix-00.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.</strong> Appendix</a></li><li><ol class=\"section\"><li class=\"chapter-item expanded \"><a href=\"appendix-01-keywords.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.1.</strong> A - Keywords</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-02-operators.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.2.</strong> B - Operators and Symbols</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-03-derivable-traits.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.3.</strong> C - Derivable Traits</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-04-useful-development-tools.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.4.</strong> D - Useful Development Tools</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-05-editions.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.5.</strong> E - Editions</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-06-translation.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.6.</strong> F - Translations of the Book</a></li><li class=\"chapter-item expanded \"><a href=\"appendix-07-nightly-rust.html\" tabindex=\"0\"><strong aria-hidden=\"true\">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>\n            </div>\n            <div id=\"sidebar-resize-handle\" class=\"sidebar-resize-handle\">\n                <div class=\"sidebar-resize-indicator\"></div>\n            </div>\n        </nav>\n\n        <!-- Track and set sidebar scroll position -->\n        <script>\n            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');\n            sidebarScrollbox.addEventListener('click', function(e) {\n                if (e.target.tagName === 'A') {\n                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);\n                }\n            }, { passive: true });\n            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');\n            sessionStorage.removeItem('sidebar-scroll');\n            if (sidebarScrollTop) {\n                // preserve sidebar scroll position when navigating via links within sidebar\n                sidebarScrollbox.scrollTop = sidebarScrollTop;\n            } else {\n                // scroll sidebar to current active section when navigating via \"next/previous chapter\" buttons\n                var activeSection = document.querySelector('#sidebar .active');\n                if (activeSection) {\n                    activeSection.scrollIntoView({ block: 'center' });\n                }\n            }\n        </script>\n\n        <div id=\"page-wrapper\" class=\"page-wrapper\">\n\n            <div class=\"page\">\n                                <div id=\"menu-bar-hover-placeholder\"></div>\n                <div id=\"menu-bar\" class=\"menu-bar\" style=\"top: 0px;\">\n                    <div class=\"left-buttons\">\n                        <label id=\"sidebar-toggle\" class=\"icon-button\" for=\"sidebar-toggle-anchor\" title=\"Toggle Table of Contents\" aria-label=\"Toggle Table of Contents\" aria-controls=\"sidebar\" aria-expanded=\"true\">\n                            <i class=\"fa fa-bars\"></i>\n                        </label>\n                        <button id=\"theme-toggle\" class=\"icon-button\" type=\"button\" title=\"Change theme\" aria-label=\"Change theme\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-controls=\"theme-list\">\n                            <i class=\"fa fa-paint-brush\"></i>\n                        </button>\n                        <ul id=\"theme-list\" class=\"theme-popup\" aria-label=\"Themes\" role=\"menu\">\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme theme-selected\" id=\"light\">Light</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"rust\">Rust</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"coal\">Coal</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"navy\">Navy</button></li>\n                            <li role=\"none\"><button role=\"menuitem\" class=\"theme\" id=\"ayu\">Ayu</button></li>\n                        </ul>\n                        <button id=\"search-toggle\" class=\"icon-button\" type=\"button\" title=\"Search. (Shortkey: s)\" aria-label=\"Toggle Searchbar\" aria-expanded=\"false\" aria-keyshortcuts=\"S\" aria-controls=\"searchbar\">\n                            <i class=\"fa fa-search\"></i>\n                        </button>\n                    </div>\n\n                    <h1 class=\"menu-title\">The Rust Programming Language</h1>\n\n                    <div class=\"right-buttons\">\n                        <a href=\"print.html\" title=\"Print this book\" aria-label=\"Print this book\">\n                            <i id=\"print-button\" class=\"fa fa-print\"></i>\n                        </a>\n                        <a href=\"https://github.com/rust-lang/book\" title=\"Git repository\" aria-label=\"Git repository\">\n                            <i id=\"git-repository-button\" class=\"fa fa-github\"></i>\n                        </a>\n\n                    </div>\n                </div>\n\n                <div id=\"search-wrapper\" class=\"hidden\">\n                    <form id=\"searchbar-outer\" class=\"searchbar-outer\">\n                        <input type=\"search\" id=\"searchbar\" name=\"searchbar\" placeholder=\"Search this book ...\" aria-controls=\"searchresults-outer\" aria-describedby=\"searchresults-header\">\n                    </form>\n                    <div id=\"searchresults-outer\" class=\"searchresults-outer hidden\">\n                        <div id=\"searchresults-header\" class=\"searchresults-header\"></div>\n                        <ul id=\"searchresults\">\n                        </ul>\n                    </div>\n                </div>\n\n                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->\n                <script>\n                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');\n                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');\n                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {\n                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);\n                    });\n                </script>\n\n                <div id=\"content\" class=\"content\">\n                    <main>\n                        <h2 id=\"graceful-shutdown-and-cleanup\"><a class=\"header\" href=\"#graceful-shutdown-and-cleanup\">Graceful Shutdown and Cleanup</a></h2>\n<p>The code in Listing 20-20 is responding to requests asynchronously through the\nuse of a thread pool, as we intended. We get some warnings about the <code class=\"hljs\">workers</code>,\n<code class=\"hljs\">id</code>, and <code class=\"hljs\">thread</code> fields that we’re not using in a direct way that reminds us\nwe’re not cleaning up anything. When we use the less elegant\n<kbd>ctrl</kbd>-<kbd>c</kbd> method to halt the main thread, all other threads\nare stopped immediately as well, even if they’re in the middle of serving a\nrequest.</p>\n<p>Next, then, we’ll implement the <code class=\"hljs\">Drop</code> trait to call <code class=\"hljs\">join</code> on each of the\nthreads in the pool so they can finish the requests they’re working on before\nclosing. Then we’ll implement a way to tell the threads they should stop\naccepting new requests and shut down. To see this code in action, we’ll modify\nour server to accept only two requests before gracefully shutting down its\nthread pool.</p>\n<h3 id=\"implementing-the-drop-trait-on-threadpool\"><a class=\"header\" href=\"#implementing-the-drop-trait-on-threadpool\">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></a></h3>\n<p>Let’s start with implementing <code class=\"hljs\">Drop</code> on our thread pool. When the pool is\ndropped, our threads should all join to make sure they finish their work.\nListing 20-22 shows a first attempt at a <code class=\"hljs\">Drop</code> implementation; this code won’t\nquite work yet.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    sync::{mpsc, Arc, Mutex},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n</span><span class=\"boring\">    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n</span><span class=\"boring\">    sender: mpsc::Sender&lt;Job&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// # Panics</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n</span><span class=\"boring\">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        ThreadPool { workers, sender }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">where</span>\n</span><span class=\"boring\">        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n</span><span class=\"boring\">    {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.sender.send(job).unwrap();\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n</span><span class=\"boring\">    id: <span class=\"hljs-built_in\">usize</span>,\n</span><span class=\"boring\">    thread: thread::JoinHandle&lt;()&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Worker {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> job = receiver.lock().unwrap().recv().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            job();\n</span><span class=\"boring\">        });\n</span><span class=\"boring\">\n</span><span class=\"boring\">        Worker { id, thread }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 20-22: Joining each thread when the thread pool\ngoes out of scope</span></p>\n<p>First, we loop through each of the thread pool <code class=\"hljs\">workers</code>. We use <code class=\"hljs\">&amp;mut</code> for\nthis because <code class=\"hljs\">self</code> is a mutable reference, and we also need to be able to\nmutate <code class=\"hljs\">worker</code>. For each worker, we print a message saying that this\nparticular worker is shutting down, and then we call <code class=\"hljs\">join</code> on that worker’s\nthread. If the call to <code class=\"hljs\">join</code> fails, we use <code class=\"hljs\">unwrap</code> to make Rust panic and go\ninto an ungraceful shutdown.</p>\n<p>Here is the error we get when we compile this code:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo check</span>\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0507]: cannot move out of `worker.thread` which is behind a mutable reference\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/lib.rs:52:13</span>\n   |\n52 |             worker.thread.join().unwrap();\n   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call\n   |             |\n   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait\n   |\nnote: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:17</span>\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `hello` (lib) due to 1 previous error\n</code></pre>\n<p>The error tells us we can’t call <code class=\"hljs\">join</code> because we only have a mutable borrow\nof each <code class=\"hljs\">worker</code> and <code class=\"hljs\">join</code> takes ownership of its argument. To solve this\nissue, we need to move the thread out of the <code class=\"hljs\">Worker</code> instance that owns\n<code class=\"hljs\">thread</code> so <code class=\"hljs\">join</code> can consume the thread. We did this in Listing 17-15: if\n<code class=\"hljs\">Worker</code> holds an <code class=\"hljs\">Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> instead, we can call the\n<code class=\"hljs\">take</code> method on the <code class=\"hljs\">Option</code> to move the value out of the <code class=\"hljs\">Some</code> variant and\nleave a <code class=\"hljs\">None</code> variant in its place. In other words, a <code class=\"hljs\">Worker</code> that is running\nwill have a <code class=\"hljs\">Some</code> variant in <code class=\"hljs\">thread</code>, and when we want to clean up a\n<code class=\"hljs\">Worker</code>, we’ll replace <code class=\"hljs\">Some</code> with <code class=\"hljs\">None</code> so the <code class=\"hljs\">Worker</code> doesn’t have a\nthread to run.</p>\n<p>So we know we want to update the definition of <code class=\"hljs\">Worker</code> like this:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    sync::{mpsc, Arc, Mutex},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n</span><span class=\"boring\">    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n</span><span class=\"boring\">    sender: mpsc::Sender&lt;Job&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// # Panics</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n</span><span class=\"boring\">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        ThreadPool { workers, sender }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">where</span>\n</span><span class=\"boring\">        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n</span><span class=\"boring\">    {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.sender.send(job).unwrap();\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            worker.thread.join().unwrap();\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n    id: <span class=\"hljs-built_in\">usize</span>,\n    thread: <span class=\"hljs-built_in\">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Worker {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> job = receiver.lock().unwrap().recv().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            job();\n</span><span class=\"boring\">        });\n</span><span class=\"boring\">\n</span><span class=\"boring\">        Worker { id, thread }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>Now let’s lean on the compiler to find the other places that need to change.\nChecking this code, we get two errors:</p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo check</span>\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no method named `join` found for enum `Option` in the current scope\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/lib.rs:52:27</span>\n   |\n52 |             worker.thread.join().unwrap();\n   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`\n   |\nnote: the method `join` exists on the type `JoinHandle&lt;()&gt;`\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:5</span>\nhelp: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`\n   |\n52 |             worker.thread.expect(\"REASON\").join().unwrap();\n   |                          +++++++++++++++++\n\nerror[E0308]: mismatched types\n<span class=\"hljs-meta\">  --&gt;</span><span class=\"bash\"> src/lib.rs:72:22</span>\n   |\n72 |         Worker { id, thread }\n   |                      ^^^^^^ expected `Option&lt;JoinHandle&lt;()&gt;&gt;`, found `JoinHandle&lt;_&gt;`\n   |\n   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`\n            found struct `JoinHandle&lt;_&gt;`\nhelp: try wrapping the expression in `Some`\n   |\n72 |         Worker { id, thread: Some(thread) }\n   |                      +++++++++++++      +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `hello` (lib) due to 2 previous errors\n</code></pre>\n<p>Let’s address the second error, which points to the code at the end of\n<code class=\"hljs\">Worker::new</code>; we need to wrap the <code class=\"hljs\">thread</code> value in <code class=\"hljs\">Some</code> when we create a\nnew <code class=\"hljs\">Worker</code>. Make the following changes to fix this error:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/does_not_compile.svg\" title=\"This code does not compile!\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore does_not_compile hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    sync::{mpsc, Arc, Mutex},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n</span><span class=\"boring\">    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n</span><span class=\"boring\">    sender: mpsc::Sender&lt;Job&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// # Panics</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n</span><span class=\"boring\">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        ThreadPool { workers, sender }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">where</span>\n</span><span class=\"boring\">        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n</span><span class=\"boring\">    {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.sender.send(job).unwrap();\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            worker.thread.join().unwrap();\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n</span><span class=\"boring\">    id: <span class=\"hljs-built_in\">usize</span>,\n</span><span class=\"boring\">    thread: <span class=\"hljs-built_in\">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Worker {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        <span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\">        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> job = receiver.lock().unwrap().recv().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            job();\n</span><span class=\"boring\">        });\n</span><span class=\"boring\">\n</span>        Worker {\n            id,\n            thread: <span class=\"hljs-literal\">Some</span>(thread),\n        }\n    }\n}</code></pre>\n<p>The first error is in our <code class=\"hljs\">Drop</code> implementation. We mentioned earlier that we\nintended to call <code class=\"hljs\">take</code> on the <code class=\"hljs\">Option</code> value to move <code class=\"hljs\">thread</code> out of <code class=\"hljs\">worker</code>.\nThe following changes will do so:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust ignore not_desired_behavior hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    sync::{mpsc, Arc, Mutex},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n</span><span class=\"boring\">    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n</span><span class=\"boring\">    sender: mpsc::Sender&lt;Job&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// # Panics</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n</span><span class=\"boring\">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        ThreadPool { workers, sender }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">where</span>\n</span><span class=\"boring\">        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n</span><span class=\"boring\">    {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.sender.send(job).unwrap();\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n</span><span class=\"boring\">    id: <span class=\"hljs-built_in\">usize</span>,\n</span><span class=\"boring\">    thread: <span class=\"hljs-built_in\">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Worker {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> job = receiver.lock().unwrap().recv().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            job();\n</span><span class=\"boring\">        });\n</span><span class=\"boring\">\n</span><span class=\"boring\">        Worker {\n</span><span class=\"boring\">            id,\n</span><span class=\"boring\">            thread: <span class=\"hljs-literal\">Some</span>(thread),\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p>As discussed in Chapter 17, the <code class=\"hljs\">take</code> method on <code class=\"hljs\">Option</code> takes the <code class=\"hljs\">Some</code>\nvariant out and leaves <code class=\"hljs\">None</code> in its place. We’re using <code class=\"hljs\">if let</code> to destructure\nthe <code class=\"hljs\">Some</code> and get the thread; then we call <code class=\"hljs\">join</code> on the thread. If a worker’s\nthread is already <code class=\"hljs\">None</code>, we know that worker has already had its thread\ncleaned up, so nothing happens in that case.</p>\n<h3 id=\"signaling-to-the-threads-to-stop-listening-for-jobs\"><a class=\"header\" href=\"#signaling-to-the-threads-to-stop-listening-for-jobs\">Signaling to the Threads to Stop Listening for Jobs</a></h3>\n<p>With all the changes we’ve made, our code compiles without any warnings.\nHowever, the bad news is this code doesn’t function the way we want it to yet.\nThe key is the logic in the closures run by the threads of the <code class=\"hljs\">Worker</code>\ninstances: at the moment, we call <code class=\"hljs\">join</code>, but that won’t shut down the threads\nbecause they <code class=\"hljs\">loop</code> forever looking for jobs. If we try to drop our\n<code class=\"hljs\">ThreadPool</code> with our current implementation of <code class=\"hljs\">drop</code>, the main thread will\nblock forever waiting for the first thread to finish.</p>\n<p>To fix this problem, we’ll need a change in the <code class=\"hljs\">ThreadPool</code> <code class=\"hljs\">drop</code>\nimplementation and then a change in the <code class=\"hljs\">Worker</code> loop.</p>\n<p>First, we’ll change the <code class=\"hljs\">ThreadPool</code> <code class=\"hljs\">drop</code> implementation to explicitly drop\nthe <code class=\"hljs\">sender</code> before waiting for the threads to finish. Listing 20-23 shows the\nchanges to <code class=\"hljs\">ThreadPool</code> to explicitly drop <code class=\"hljs\">sender</code>. We use the same <code class=\"hljs\">Option</code>\nand <code class=\"hljs\">take</code> technique as we did with the thread to be able to move <code class=\"hljs\">sender</code> out\nof <code class=\"hljs\">ThreadPool</code>:</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><div class=\"ferris-container\"><a href=\"ch00-00-introduction.html#ferris\" target=\"_blank\"><img src=\"img/ferris/not_desired_behavior.svg\" title=\"This code does not produce the desired behavior.\" class=\"ferris ferris-large\"></a></div><code class=\"language-rust noplayground not_desired_behavior hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    sync::{mpsc, Arc, Mutex},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n    sender: <span class=\"hljs-built_in\">Option</span>&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n<span class=\"hljs-comment\">// --snip--</span>\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> ThreadPool {\n<span class=\"boring\">    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// # Panics</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n</span>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n        <span class=\"hljs-comment\">// --snip--</span>\n\n<span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n</span><span class=\"boring\">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span>        ThreadPool {\n            workers,\n            sender: <span class=\"hljs-literal\">Some</span>(sender),\n        }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n    <span class=\"hljs-keyword\">where</span>\n        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n    {\n        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n\n        <span class=\"hljs-keyword\">self</span>.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">drop</span>(<span class=\"hljs-keyword\">self</span>.sender.take());\n\n        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n</span><span class=\"boring\">    id: <span class=\"hljs-built_in\">usize</span>,\n</span><span class=\"boring\">    thread: <span class=\"hljs-built_in\">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> Worker {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">let</span> job = receiver.lock().unwrap().recv().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            job();\n</span><span class=\"boring\">        });\n</span><span class=\"boring\">\n</span><span class=\"boring\">        Worker {\n</span><span class=\"boring\">            id,\n</span><span class=\"boring\">            thread: <span class=\"hljs-literal\">Some</span>(thread),\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 20-23: Explicitly drop <code class=\"hljs\">sender</code> before joining\nthe worker threads</span></p>\n<p>Dropping <code class=\"hljs\">sender</code> closes the channel, which indicates no more messages will be\nsent. When that happens, all the calls to <code class=\"hljs\">recv</code> that the workers do in the\ninfinite loop will return an error. In Listing 20-24, we change the <code class=\"hljs\">Worker</code>\nloop to gracefully exit the loop in that case, which means the threads will\nfinish when the <code class=\"hljs\">ThreadPool</code> <code class=\"hljs\">drop</code> implementation calls <code class=\"hljs\">join</code> on them.</p>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust noplayground hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    sync::{mpsc, Arc, Mutex},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n</span><span class=\"boring\">    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n</span><span class=\"boring\">    sender: <span class=\"hljs-built_in\">Option</span>&lt;mpsc::Sender&lt;Job&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// # Panics</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">///</span>\n</span><span class=\"boring\">    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n</span><span class=\"boring\">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">\n</span><span class=\"boring\">        ThreadPool {\n</span><span class=\"boring\">            workers,\n</span><span class=\"boring\">            sender: <span class=\"hljs-literal\">Some</span>(sender),\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">where</span>\n</span><span class=\"boring\">        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n</span><span class=\"boring\">    {\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">self</span>.sender.as_ref().unwrap().send(job).unwrap();\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n</span><span class=\"boring\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">drop</span>(<span class=\"hljs-keyword\">self</span>.sender.take());\n</span><span class=\"boring\">\n</span><span class=\"boring\">        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n</span><span class=\"boring\">            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n</span><span class=\"boring\">\n</span><span class=\"boring\">            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(thread) = worker.thread.take() {\n</span><span class=\"boring\">                thread.join().unwrap();\n</span><span class=\"boring\">            }\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">    }\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n</span><span class=\"boring\">    id: <span class=\"hljs-built_in\">usize</span>,\n</span><span class=\"boring\">    thread: <span class=\"hljs-built_in\">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,\n</span><span class=\"boring\">}\n</span><span class=\"boring\">\n</span><span class=\"hljs-keyword\">impl</span> Worker {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n            <span class=\"hljs-keyword\">let</span> message = receiver.lock().unwrap().recv();\n\n            <span class=\"hljs-keyword\">match</span> message {\n                <span class=\"hljs-literal\">Ok</span>(job) =&gt; {\n                    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n\n                    job();\n                }\n                <span class=\"hljs-literal\">Err</span>(_) =&gt; {\n                    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} disconnected; shutting down.\"</span>);\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: <span class=\"hljs-literal\">Some</span>(thread),\n        }\n    }\n}</code></pre>\n<p><span class=\"caption\">Listing 20-24: Explicitly break out of the loop when\n<code class=\"hljs\">recv</code> returns an error</span></p>\n<p>To see this code in action, let’s modify <code class=\"hljs\">main</code> to accept only two requests\nbefore gracefully shutting down the server, as shown in Listing 20-25.</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button><button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button></div><code class=\"language-rust ignore hljs hide-boring\"><span class=\"boring\"><span class=\"hljs-keyword\">use</span> hello::ThreadPool;\n</span><span class=\"boring\"><span class=\"hljs-keyword\">use</span> std::{\n</span><span class=\"boring\">    fs,\n</span><span class=\"boring\">    io::{prelude::*, BufReader},\n</span><span class=\"boring\">    net::{TcpListener, TcpStream},\n</span><span class=\"boring\">    thread,\n</span><span class=\"boring\">    time::Duration,\n</span><span class=\"boring\">};\n</span><span class=\"boring\">\n</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n    <span class=\"hljs-keyword\">let</span> pool = ThreadPool::new(<span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming().take(<span class=\"hljs-number\">2</span>) {\n        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down.\"</span>);\n}\n<span class=\"boring\">\n</span><span class=\"boring\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> request_line = buf_reader.lines().next().unwrap().unwrap();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> (status_line, filename) = <span class=\"hljs-keyword\">match</span> &amp;request_line[..] {\n</span><span class=\"boring\">        <span class=\"hljs-string\">\"GET / HTTP/1.1\"</span> =&gt; (<span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>, <span class=\"hljs-string\">\"hello.html\"</span>),\n</span><span class=\"boring\">        <span class=\"hljs-string\">\"GET /sleep HTTP/1.1\"</span> =&gt; {\n</span><span class=\"boring\">            thread::sleep(Duration::from_secs(<span class=\"hljs-number\">5</span>));\n</span><span class=\"boring\">            (<span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>, <span class=\"hljs-string\">\"hello.html\"</span>)\n</span><span class=\"boring\">        }\n</span><span class=\"boring\">        _ =&gt; (<span class=\"hljs-string\">\"HTTP/1.1 404 NOT FOUND\"</span>, <span class=\"hljs-string\">\"404.html\"</span>),\n</span><span class=\"boring\">    };\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(filename).unwrap();\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> length = contents.len();\n</span><span class=\"boring\">\n</span><span class=\"boring\">    <span class=\"hljs-keyword\">let</span> response =\n</span><span class=\"boring\">        <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>);\n</span><span class=\"boring\">\n</span><span class=\"boring\">    stream.write_all(response.as_bytes()).unwrap();\n</span><span class=\"boring\">}</span></code></pre>\n<p><span class=\"caption\">Listing 20-25: Shut down the server after serving two\nrequests by exiting the loop</span></p>\n<p>You wouldn’t want a real-world web server to shut down after serving only two\nrequests. This code just demonstrates that the graceful shutdown and cleanup is\nin working order.</p>\n<p>The <code class=\"hljs\">take</code> method is defined in the <code class=\"hljs\">Iterator</code> trait and limits the iteration\nto the first two items at most. The <code class=\"hljs\">ThreadPool</code> will go out of scope at the\nend of <code class=\"hljs\">main</code>, and the <code class=\"hljs\">drop</code> implementation will run.</p>\n<p>Start the server with <code class=\"hljs\">cargo run</code>, and make three requests. The third request\nshould error, and in your terminal you should see output similar to this:</p>\n<!-- manual-regeneration\ncd listings/ch20-web-server/listing-20-25\ncargo run\ncurl http://127.0.0.1:7878\ncurl http://127.0.0.1:7878\ncurl http://127.0.0.1:7878\nthird request will error because server will have shut down\ncopy output below\nCan't automate because the output depends on making requests\n-->\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-console hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> cargo run</span>\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.0s\n     Running `target/debug/hello`\nWorker 0 got a job; executing.\nShutting down.\nShutting down worker 0\nWorker 3 got a job; executing.\nWorker 1 disconnected; shutting down.\nWorker 2 disconnected; shutting down.\nWorker 3 disconnected; shutting down.\nWorker 0 disconnected; shutting down.\nShutting down worker 1\nShutting down worker 2\nShutting down worker 3\n</code></pre>\n<p>You might see a different ordering of workers and messages printed. We can see\nhow this code works from the messages: workers 0 and 3 got the first two\nrequests. The server stopped accepting connections after the second connection,\nand the <code class=\"hljs\">Drop</code> implementation on <code class=\"hljs\">ThreadPool</code> starts executing before worker 3\neven starts its job. Dropping the <code class=\"hljs\">sender</code> disconnects all the workers and\ntells them to shut down. The workers each print a message when they disconnect,\nand then the thread pool calls <code class=\"hljs\">join</code> to wait for each worker thread to finish.</p>\n<p>Notice one interesting aspect of this particular execution: the <code class=\"hljs\">ThreadPool</code>\ndropped the <code class=\"hljs\">sender</code>, and before any worker received an error, we tried to join\nworker 0. Worker 0 had not yet gotten an error from <code class=\"hljs\">recv</code>, so the main thread\nblocked waiting for worker 0 to finish. In the meantime, worker 3 received a\njob and then all threads received an error. When worker 0 finished, the main\nthread waited for the rest of the workers to finish. At that point, they had\nall exited their loops and stopped.</p>\n<p>Congrats! We’ve now completed our project; we have a basic web server that uses\na thread pool to respond asynchronously. We’re able to perform a graceful\nshutdown of the server, which cleans up all the threads in the pool.</p>\n<p>Here’s the full code for reference:</p>\n<p><span class=\"filename\">Filename: src/main.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust ignore hljs\"><span class=\"hljs-keyword\">use</span> hello::ThreadPool;\n<span class=\"hljs-keyword\">use</span> std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(<span class=\"hljs-string\">\"127.0.0.1:7878\"</span>).unwrap();\n    <span class=\"hljs-keyword\">let</span> pool = ThreadPool::new(<span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-keyword\">for</span> stream <span class=\"hljs-keyword\">in</span> listener.incoming().take(<span class=\"hljs-number\">2</span>) {\n        <span class=\"hljs-keyword\">let</span> stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down.\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">handle_connection</span></span>(<span class=\"hljs-keyword\">mut</span> stream: TcpStream) {\n    <span class=\"hljs-keyword\">let</span> buf_reader = BufReader::new(&amp;<span class=\"hljs-keyword\">mut</span> stream);\n    <span class=\"hljs-keyword\">let</span> request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    <span class=\"hljs-keyword\">let</span> (status_line, filename) = <span class=\"hljs-keyword\">match</span> &amp;request_line[..] {\n        <span class=\"hljs-string\">\"GET / HTTP/1.1\"</span> =&gt; (<span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>, <span class=\"hljs-string\">\"hello.html\"</span>),\n        <span class=\"hljs-string\">\"GET /sleep HTTP/1.1\"</span> =&gt; {\n            thread::sleep(Duration::from_secs(<span class=\"hljs-number\">5</span>));\n            (<span class=\"hljs-string\">\"HTTP/1.1 200 OK\"</span>, <span class=\"hljs-string\">\"hello.html\"</span>)\n        }\n        _ =&gt; (<span class=\"hljs-string\">\"HTTP/1.1 404 NOT FOUND\"</span>, <span class=\"hljs-string\">\"404.html\"</span>),\n    };\n\n    <span class=\"hljs-keyword\">let</span> contents = fs::read_to_string(filename).unwrap();\n    <span class=\"hljs-keyword\">let</span> length = contents.len();\n\n    <span class=\"hljs-keyword\">let</span> response =\n        <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"</span>);\n\n    stream.write_all(response.as_bytes()).unwrap();\n}</code></pre>\n<p><span class=\"filename\">Filename: src/lib.rs</span></p>\n<pre><div class=\"buttons\"><button class=\"fa fa-copy clip-button\" title=\"Copy to clipboard\" aria-label=\"Copy to clipboard\"><i class=\"tooltiptext\"></i></button></div><code class=\"language-rust noplayground hljs\"><span class=\"hljs-keyword\">use</span> std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadPool</span></span> {\n    workers: <span class=\"hljs-built_in\">Vec</span>&lt;Worker&gt;,\n    sender: <span class=\"hljs-built_in\">Option</span>&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Job</span></span> = <span class=\"hljs-built_in\">Box</span>&lt;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>&gt;;\n\n<span class=\"hljs-keyword\">impl</span> ThreadPool {\n    <span class=\"hljs-comment\">/// Create a new ThreadPool.</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// The size is the number of threads in the pool.</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// # Panics</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// The `new` function will panic if the size is zero.</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(size: <span class=\"hljs-built_in\">usize</span>) -&gt; ThreadPool {\n        <span class=\"hljs-built_in\">assert!</span>(size &gt; <span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-keyword\">let</span> (sender, receiver) = mpsc::channel();\n\n        <span class=\"hljs-keyword\">let</span> receiver = Arc::new(Mutex::new(receiver));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> workers = <span class=\"hljs-built_in\">Vec</span>::with_capacity(size);\n\n        <span class=\"hljs-keyword\">for</span> id <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..size {\n            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: <span class=\"hljs-literal\">Some</span>(sender),\n        }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">execute</span></span>&lt;F&gt;(&amp;<span class=\"hljs-keyword\">self</span>, f: F)\n    <span class=\"hljs-keyword\">where</span>\n        F: <span class=\"hljs-built_in\">FnOnce</span>() + <span class=\"hljs-built_in\">Send</span> + <span class=\"hljs-symbol\">'static</span>,\n    {\n        <span class=\"hljs-keyword\">let</span> job = <span class=\"hljs-built_in\">Box</span>::new(f);\n\n        <span class=\"hljs-keyword\">self</span>.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> ThreadPool {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">drop</span>(<span class=\"hljs-keyword\">self</span>.sender.take());\n\n        <span class=\"hljs-keyword\">for</span> worker <span class=\"hljs-keyword\">in</span> &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.workers {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Shutting down worker {}\"</span>, worker.id);\n\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Worker</span></span> {\n    id: <span class=\"hljs-built_in\">usize</span>,\n    thread: <span class=\"hljs-built_in\">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> Worker {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(id: <span class=\"hljs-built_in\">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        <span class=\"hljs-keyword\">let</span> thread = thread::spawn(<span class=\"hljs-keyword\">move</span> || <span class=\"hljs-keyword\">loop</span> {\n            <span class=\"hljs-keyword\">let</span> message = receiver.lock().unwrap().recv();\n\n            <span class=\"hljs-keyword\">match</span> message {\n                <span class=\"hljs-literal\">Ok</span>(job) =&gt; {\n                    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} got a job; executing.\"</span>);\n\n                    job();\n                }\n                <span class=\"hljs-literal\">Err</span>(_) =&gt; {\n                    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Worker {id} disconnected; shutting down.\"</span>);\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: <span class=\"hljs-literal\">Some</span>(thread),\n        }\n    }\n}</code></pre>\n<p>We could do more here! If you want to continue enhancing this project, here are\nsome ideas:</p>\n<ul>\n<li>Add more documentation to <code class=\"hljs\">ThreadPool</code> and its public methods.</li>\n<li>Add tests of the library’s functionality.</li>\n<li>Change calls to <code class=\"hljs\">unwrap</code> to more robust error handling.</li>\n<li>Use <code class=\"hljs\">ThreadPool</code> to perform some task other than serving web requests.</li>\n<li>Find a thread pool crate on <a href=\"https://crates.io/\">crates.io</a> and implement a\nsimilar web server using the crate instead. Then compare its API and\nrobustness to the thread pool we implemented.</li>\n</ul>\n<h2 id=\"summary\"><a class=\"header\" href=\"#summary\">Summary</a></h2>\n<p>Well done! You’ve made it to the end of the book! We want to thank you for\njoining us on this tour of Rust. You’re now ready to implement your own Rust\nprojects and help with other peoples’ projects. Keep in mind that there is a\nwelcoming community of other Rustaceans who would love to help you with any\nchallenges you encounter on your Rust journey.</p>\n\n                    </main>\n\n                    <nav class=\"nav-wrapper\" aria-label=\"Page navigation\">\n                        <!-- Mobile navigation buttons -->\n                            <a rel=\"prev\" href=\"ch20-02-multithreaded.html\" class=\"mobile-nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                                <i class=\"fa fa-angle-left\"></i>\n                            </a>\n\n                            <a rel=\"next prefetch\" href=\"appendix-00.html\" class=\"mobile-nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                                <i class=\"fa fa-angle-right\"></i>\n                            </a>\n\n                        <div style=\"clear: both\"></div>\n                    </nav>\n                </div>\n            </div>\n\n            <nav class=\"nav-wide-wrapper\" aria-label=\"Page navigation\">\n                    <a rel=\"prev\" href=\"ch20-02-multithreaded.html\" class=\"nav-chapters previous\" title=\"Previous chapter\" aria-label=\"Previous chapter\" aria-keyshortcuts=\"Left\">\n                        <i class=\"fa fa-angle-left\"></i>\n                    </a>\n\n                    <a rel=\"next prefetch\" href=\"appendix-00.html\" class=\"nav-chapters next\" title=\"Next chapter\" aria-label=\"Next chapter\" aria-keyshortcuts=\"Right\">\n                        <i class=\"fa fa-angle-right\"></i>\n                    </a>\n            </nav>\n\n        </div>\n\n\n\n\n        <script>\n            window.playground_copyable = true;\n        </script>\n\n\n        <script src=\"elasticlunr.min.js\"></script>\n        <script src=\"mark.min.js\"></script>\n        <script src=\"searcher.js\"></script>\n\n        <script src=\"clipboard.min.js\"></script>\n        <script src=\"highlight.js\"></script>\n        <script src=\"book.js\"></script>\n\n        <!-- Custom JS scripts -->\n        <script src=\"ferris.js\"></script>\n\n\n    </div>\n    \n\n</body></html>",
	"crawlDate": "2024-07-28T05:08:35.664Z"
}